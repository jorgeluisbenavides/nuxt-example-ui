// node_modules/devextreme-vue/esm/data-grid.js
import { defineComponent as defineComponent4 } from "vue";

// node_modules/devextreme-vue/esm/core/component.js
import { defineComponent as defineComponent2, h as h2 } from "vue";

// node_modules/devextreme/esm/__internal/core/utils/m_callbacks.js
var Callback = function(options2) {
  this._options = options2 || {};
  this._list = [];
  this._queue = [];
  this._firing = false;
  this._fired = false;
  this._firingIndexes = [];
};
Callback.prototype._fireCore = function(context2, args) {
  const firingIndexes = this._firingIndexes;
  const list = this._list;
  const {
    stopOnFalse
  } = this._options;
  const step = firingIndexes.length;
  for (firingIndexes[step] = 0; firingIndexes[step] < list.length; firingIndexes[step]++) {
    const result2 = list[firingIndexes[step]].apply(context2, args);
    if (false === result2 && stopOnFalse) {
      break;
    }
  }
  firingIndexes.pop();
};
Callback.prototype.add = function(fn) {
  if ("function" === typeof fn && (!this._options.unique || !this.has(fn))) {
    this._list.push(fn);
  }
  return this;
};
Callback.prototype.remove = function(fn) {
  const list = this._list;
  const firingIndexes = this._firingIndexes;
  const index2 = list.indexOf(fn);
  if (index2 > -1) {
    list.splice(index2, 1);
    if (this._firing && firingIndexes.length) {
      for (let step = 0; step < firingIndexes.length; step++) {
        if (index2 <= firingIndexes[step]) {
          firingIndexes[step]--;
        }
      }
    }
  }
  return this;
};
Callback.prototype.has = function(fn) {
  const list = this._list;
  return fn ? list.indexOf(fn) > -1 : !!list.length;
};
Callback.prototype.empty = function(fn) {
  this._list = [];
  return this;
};
Callback.prototype.fireWith = function(context2, args) {
  const queue = this._queue;
  args = args || [];
  args = args.slice ? args.slice() : args;
  if (this._options.syncStrategy) {
    this._firing = true;
    this._fireCore(context2, args);
  } else {
    queue.push([context2, args]);
    if (this._firing) {
      return;
    }
    this._firing = true;
    while (queue.length) {
      const memory = queue.shift();
      this._fireCore(memory[0], memory[1]);
    }
  }
  this._firing = false;
  this._fired = true;
  return this;
};
Callback.prototype.fire = function() {
  this.fireWith(this, arguments);
};
Callback.prototype.fired = function() {
  return this._fired;
};
var Callbacks = function(options2) {
  return new Callback(options2);
};
var m_callbacks_default = Callbacks;

// node_modules/devextreme/esm/core/utils/callbacks.js
var callbacks_default = Callbacks;

// node_modules/devextreme/esm/__internal/core/utils/m_iterator.js
var map = (values, callback) => {
  if (Array.isArray(values)) {
    return values.map(callback);
  }
  const result2 = [];
  for (const key in values) {
    result2.push(callback(values[key], key));
  }
  return result2;
};
var each = (values, callback) => {
  if (!values) {
    return;
  }
  if ("length" in values) {
    for (let i = 0; i < values.length; i++) {
      if (false === callback.call(values[i], i, values[i])) {
        break;
      }
    }
  } else {
    for (const key in values) {
      if (false === callback.call(values[key], key, values[key])) {
        break;
      }
    }
  }
  return values;
};

// node_modules/devextreme/esm/__internal/core/m_memorized_callbacks.js
var MemorizedCallbacks = class {
  constructor() {
    this.memory = [];
    this.callbacks = callbacks_default();
  }
  add(fn) {
    each(this.memory, (_, item) => fn.apply(fn, item));
    this.callbacks.add(fn);
  }
  remove(fn) {
    this.callbacks.remove(fn);
  }
  fire() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    this.memory.push(args);
    this.callbacks.fire.apply(this.callbacks, args);
  }
};

// node_modules/devextreme/esm/core/memorized_callbacks.js
var memorized_callbacks_default = MemorizedCallbacks;

// node_modules/devextreme/esm/common/core/events/core/event_registrator_callbacks.js
var event_registrator_callbacks_default = new memorized_callbacks_default();

// node_modules/devextreme/esm/__internal/events/core/m_hook_touch_props.js
var touchPropsToHook = ["pageX", "pageY", "screenX", "screenY", "clientX", "clientY"];
var touchPropHook = function(name2, event) {
  if (event[name2] && !event.touches || !event.touches) {
    return event[name2];
  }
  const touches = event.touches.length ? event.touches : event.changedTouches;
  if (!touches.length) {
    return;
  }
  return touches[0][name2];
};
function m_hook_touch_props_default(callback) {
  touchPropsToHook.forEach((name2) => {
    callback(name2, (event) => touchPropHook(name2, event));
  }, this);
}

// node_modules/devextreme/esm/__internal/events/utils/m_event_target.js
var getEventTarget = (event) => {
  var _originalEvent$target, _originalEvent$compos;
  const {
    originalEvent
  } = event;
  if (!originalEvent) {
    return event.target;
  }
  const isShadowDOMUsed = Boolean(null === (_originalEvent$target = originalEvent.target) || void 0 === _originalEvent$target ? void 0 : _originalEvent$target.shadowRoot);
  if (!isShadowDOMUsed) {
    return originalEvent.target;
  }
  const path = originalEvent.path ?? (null === (_originalEvent$compos = originalEvent.composedPath) || void 0 === _originalEvent$compos ? void 0 : _originalEvent$compos.call(originalEvent));
  const target = (null === path || void 0 === path ? void 0 : path[0]) ?? event.target;
  return target;
};

// node_modules/@babel/runtime/helpers/esm/extends.js
function _extends() {
  return _extends = Object.assign ? Object.assign.bind() : function(n) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
    }
    return n;
  }, _extends.apply(null, arguments);
}

// node_modules/devextreme/esm/__internal/core/utils/m_type.js
var types = {
  "[object Array]": "array",
  "[object Date]": "date",
  "[object Object]": "object",
  "[object String]": "string"
};
var type = function(object) {
  if (null === object) {
    return "null";
  }
  const typeOfObject = Object.prototype.toString.call(object);
  return "object" === typeof object ? types[typeOfObject] || "object" : typeof object;
};
var isBoolean = function(object) {
  return "boolean" === typeof object;
};
var isExponential = function(value2) {
  return isNumeric(value2) && -1 !== value2.toString().indexOf("e");
};
var isDate = function(object) {
  return "date" === type(object);
};
var isDefined = function(object) {
  return null !== object && void 0 !== object;
};
var isFunction = function(object) {
  return "function" === typeof object;
};
var isString = function(object) {
  return "string" === typeof object;
};
var isNumeric = function(object) {
  return "number" === typeof object && isFinite(object) || !isNaN(object - parseFloat(object));
};
var isObject = function(object) {
  return "object" === type(object);
};
var isEmptyObject = function(object) {
  let property;
  for (property in object) {
    return false;
  }
  return true;
};
var isPlainObject = function(object) {
  if (!object || "object" !== type(object)) {
    return false;
  }
  const proto = Object.getPrototypeOf(object);
  if (!proto) {
    return true;
  }
  const ctor = Object.hasOwnProperty.call(proto, "constructor") && proto.constructor;
  return "function" === typeof ctor && Object.toString.call(ctor) === Object.toString.call(Object);
};
var isPrimitive = function(value2) {
  return !["object", "array", "function"].includes(type(value2));
};
var isWindow = function(object) {
  return null != object && object === object.window;
};
var isRenderer = function(object) {
  return !!object && !!(object.jquery || object.dxRenderer);
};
var isPromise = function(object) {
  return !!object && isFunction(object.then);
};
var isDeferred = function(object) {
  return !!object && isFunction(object.done) && isFunction(object.fail);
};
var isEvent = function(object) {
  return !!(object && object.preventDefault);
};
var m_type_default = {
  isBoolean,
  isDate,
  isDeferred,
  isDefined,
  isEmptyObject,
  isEvent,
  isExponential,
  isFunction,
  isNumeric,
  isObject,
  isPlainObject,
  isPrimitive,
  isPromise,
  isRenderer,
  isString,
  isWindow,
  type
};

// node_modules/devextreme/esm/__internal/core/utils/m_extend.js
var extendFromObject = function(target, source, overrideExistingValues) {
  target = target || {};
  for (const prop in source) {
    if (Object.prototype.hasOwnProperty.call(source, prop)) {
      const value2 = source[prop];
      if (!(prop in target) || overrideExistingValues) {
        target[prop] = value2;
      }
    }
  }
  return target;
};
var extend = function(target) {
  target = target || {};
  let i = 1;
  let deep = false;
  if ("boolean" === typeof target) {
    deep = target;
    target = arguments[1] || {};
    i++;
  }
  for (; i < arguments.length; i++) {
    const source = arguments[i];
    if (null == source) {
      continue;
    }
    for (const key in source) {
      const targetValue = target[key];
      const sourceValue = source[key];
      let sourceValueIsArray = false;
      let clone2;
      if ("__proto__" === key || "constructor" === key || target === sourceValue) {
        continue;
      }
      if (deep && sourceValue && (isPlainObject(sourceValue) || (sourceValueIsArray = Array.isArray(sourceValue)))) {
        if (sourceValueIsArray) {
          clone2 = targetValue && Array.isArray(targetValue) ? targetValue : [];
        } else {
          clone2 = targetValue && isPlainObject(targetValue) ? targetValue : {};
        }
        target[key] = extend(deep, clone2, sourceValue);
      } else if (void 0 !== sourceValue) {
        target[key] = sourceValue;
      }
    }
  }
  return target;
};

// node_modules/devextreme/esm/__internal/core/utils/m_string.js
var encodeHtml = function() {
  const encodeRegExp = [new RegExp("&", "g"), new RegExp('"', "g"), new RegExp("'", "g"), new RegExp("<", "g"), new RegExp(">", "g")];
  return function(str) {
    return String(str).replace(encodeRegExp[0], "&amp;").replace(encodeRegExp[1], "&quot;").replace(encodeRegExp[2], "&#39;").replace(encodeRegExp[3], "&lt;").replace(encodeRegExp[4], "&gt;");
  };
}();
var splitQuad = function(raw) {
  switch (typeof raw) {
    case "string":
      return raw.split(/\s+/, 4);
    case "object":
      return [raw.x || raw.h || raw.left, raw.y || raw.v || raw.top, raw.x || raw.h || raw.right, raw.y || raw.v || raw.bottom];
    case "number":
      return [raw];
    default:
      return raw;
  }
};
var quadToObject = function(raw) {
  const quad = splitQuad(raw);
  let left = parseInt(quad && quad[0], 10);
  let top = parseInt(quad && quad[1], 10);
  let right = parseInt(quad && quad[2], 10);
  let bottom = parseInt(quad && quad[3], 10);
  if (!isFinite(left)) {
    left = 0;
  }
  if (!isFinite(top)) {
    top = left;
  }
  if (!isFinite(right)) {
    right = left;
  }
  if (!isFinite(bottom)) {
    bottom = top;
  }
  return {
    top,
    right,
    bottom,
    left
  };
};
function format(template) {
  for (var _len = arguments.length, values = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    values[_key - 1] = arguments[_key];
  }
  if (isFunction(template)) {
    return template(...values);
  }
  values.forEach((value2, index2) => {
    if (isString(value2)) {
      value2 = value2.replace(/\$/g, "$$$$");
    }
    const placeholderReg = new RegExp(`\\{${index2}\\}`, "gm");
    template = template.replace(placeholderReg, value2);
  });
  return template;
}
var isEmpty = /* @__PURE__ */ function() {
  const SPACE_REGEXP = /\s/g;
  return function(text) {
    return !text || !text.replace(SPACE_REGEXP, "");
  };
}();

// node_modules/devextreme/esm/core/version.js
var version = "25.1.3";
var fullVersion = "25.1.3";

// node_modules/devextreme/esm/__internal/core/utils/m_console.js
var noop = function() {
};
var getConsoleMethod = function(method) {
  if ("undefined" === typeof console || !isFunction(console[method])) {
    return noop;
  }
  return console[method].bind(console);
};
var logger = {
  log: getConsoleMethod("log"),
  info: getConsoleMethod("info"),
  warn: getConsoleMethod("warn"),
  error: getConsoleMethod("error")
};
var debug = /* @__PURE__ */ function() {
  function assert(condition, message) {
    if (!condition) {
      throw new Error(message);
    }
  }
  return {
    assert,
    assertParam: function(parameter, message) {
      assert(null !== parameter && void 0 !== parameter, message);
    }
  };
}();
var m_console_default = {
  logger,
  debug
};

// node_modules/devextreme/esm/__internal/core/utils/m_error.js
var ERROR_URL = `https://js.devexpress.com/error/${version.split(".").slice(0, 2).join("_")}/`;
function error(baseErrors, errors2) {
  const exports = {
    ERROR_MESSAGES: extend(errors2, baseErrors),
    Error: function() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return function(args2) {
        const id = args2[0];
        args2 = args2.slice(1);
        const details = formatDetails(id, args2);
        const url = getErrorUrl(id);
        const message = formatMessage(id, details);
        return extend(new Error(message), {
          __id: id,
          __details: details,
          url
        });
      }(args);
    },
    log() {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      const id = args[0];
      let method = "log";
      if (/^E\d+$/.test(id)) {
        method = "error";
      } else if (/^W\d+$/.test(id)) {
        method = "warn";
      }
      m_console_default.logger[method]("log" === method ? id : function(args2) {
        const id2 = args2[0];
        args2 = args2.slice(1);
        return formatMessage(id2, formatDetails(id2, args2));
      }(args));
    }
  };
  function formatDetails(id, args) {
    args = [exports.ERROR_MESSAGES[id]].concat(args);
    return format.apply(this, args).replace(/\.*\s*?$/, "");
  }
  function formatMessage(id, details) {
    const kind = null !== id && void 0 !== id && id.startsWith("W") ? "warning" : "error";
    return format.apply(this, ["{0} - {1}.\n\nFor additional information on this {2} message, see: {3}", id, details, kind, getErrorUrl(id)]);
  }
  function getErrorUrl(id) {
    return ERROR_URL + id;
  }
  return exports;
}

// node_modules/devextreme/esm/core/utils/error.js
var error_default = error;

// node_modules/devextreme/esm/__internal/core/m_errors.js
var m_errors_default = error_default({
  E0001: "Method is not implemented",
  E0002: "Member name collision: {0}",
  E0003: "A class must be instantiated using the 'new' keyword",
  E0004: "The NAME property of the component is not specified",
  E0005: "Unknown device",
  E0006: "Unknown endpoint key is requested",
  E0007: "'Invalidate' method is called outside the update transaction",
  E0008: "Type of the option name is not appropriate to create an action",
  E0009: "Component '{0}' has not been initialized for an element",
  E0010: "Animation configuration with the '{0}' type requires '{1}' configuration as {2}",
  E0011: "Unknown animation type '{0}'",
  E0012: "jQuery version is too old. Please upgrade jQuery to 1.10.0 or later",
  E0013: "KnockoutJS version is too old. Please upgrade KnockoutJS to 2.3.0 or later",
  E0014: "The 'release' method shouldn't be called for an unlocked Lock object",
  E0015: "Queued task returned an unexpected result",
  E0017: "Event namespace is not defined",
  E0018: "DevExpress.ui.DevExpressPopup widget is required",
  E0020: "Template engine '{0}' is not supported",
  E0021: "Unknown theme is set: {0}",
  E0022: "LINK[rel=DevExpress-theme] tags must go before DevExpress included scripts",
  E0023: "Template name is not specified",
  E0024: "DevExtreme bundle already included",
  E0025: "Unexpected argument type",
  E0100: "Unknown validation type is detected",
  E0101: "Misconfigured range validation rule is detected",
  E0102: "Misconfigured comparison validation rule is detected",
  E0103: "validationCallback of an asynchronous rule should return a jQuery or a native promise",
  E0110: "Unknown validation group is detected",
  E0120: "Adapter for a DevExpressValidator component cannot be configured",
  E0121: "The 'customItem' parameter of the 'onCustomItemCreating' function is empty or contains invalid data. Assign a custom object or a Promise that is resolved after the item is created.",
  E0122: "AIIntegration: The sendRequest method is missing.",
  W0000: "'{0}' is deprecated in {1}. {2}",
  W0001: "{0} - '{1}' option is deprecated in {2}. {3}",
  W0002: "{0} - '{1}' method is deprecated in {2}. {3}",
  W0003: "{0} - '{1}' property is deprecated in {2}. {3}",
  W0004: "Timeout for theme loading is over: {0}",
  W0005: "'{0}' event is deprecated in {1}. {2}",
  W0006: "Invalid recurrence rule: '{0}'",
  W0007: "'{0}' Globalize culture is not defined",
  W0008: "Invalid view name: '{0}'",
  W0009: "Invalid time zone name: '{0}'",
  W0010: "{0} is deprecated in {1}. {2}",
  W0011: "Number parsing is invoked while the parser is not defined",
  W0012: "Date parsing is invoked while the parser is not defined",
  W0013: "'{0}' file is deprecated in {1}. {2}",
  W0014: "{0} - '{1}' type is deprecated in {2}. {3}",
  W0015: "Instead of returning a value from the '{0}' function, write it into the '{1}' field of the function's parameter.",
  W0016: 'The "{0}" option does not accept the "{1}" value since v{2}. {3}.',
  W0017: 'Setting the "{0}" property with a function is deprecated since v21.2',
  W0018: 'Setting the "position" property with a function is deprecated since v21.2',
  W0019: "DevExtreme: Unable to Locate a Valid License Key.\n\nDetailed license/registration related information and instructions: https://js.devexpress.com/Documentation/Licensing/.\n\nIf you are using a 30-day trial version of DevExtreme, you must uninstall all copies of DevExtreme once your 30-day trial period expires. For terms and conditions that govern use of DevExtreme UI components/libraries, please refer to the DevExtreme End User License Agreement: https://js.devexpress.com/EULAs/DevExtremeComplete.\n\nTo use DevExtreme in a commercial project, you must purchase a license. For pricing/licensing options, please visit: https://js.devexpress.com/Buy.\n\nIf you have licensing-related questions or need help with a purchase, please email clientservices@devexpress.com.\n\n",
  W0020: "DevExtreme: License Key Has Expired.\n\nDetailed license/registration related information and instructions: https://js.devexpress.com/Documentation/Licensing/.\n\nA mismatch exists between the license key used and the DevExtreme version referenced in this project.\n\nTo proceed, you can:\n• use a version of DevExtreme linked to your license key: https://www.devexpress.com/ClientCenter/DownloadManager\n• renew your DevExpress Subscription: https://www.devexpress.com/buy/renew (once you renew your subscription, you will be entitled to product updates and support service as defined in the DevExtreme End User License Agreement)\n\nIf you have licensing-related questions or need help with a renewal, please email clientservices@devexpress.com.\n\n",
  W0021: "DevExtreme: License Key Verification Has Failed.\n\nDetailed license/registration related information and instructions: https://js.devexpress.com/Documentation/Licensing/.\n\nTo verify your DevExtreme license, make certain to specify a correct key in the GlobalConfig. If you continue to encounter this error, please visit https://www.devexpress.com/ClientCenter/DownloadManager to obtain a valid license key.\n\nIf you have a valid license and this problem persists, please submit a support ticket via the DevExpress Support Center. We will be happy to follow-up: https://supportcenter.devexpress.com/ticket/create.\n\n",
  W0022: "DevExtreme: Pre-release software. Not suitable for commercial use.\n\nDetailed license/registration related information and instructions: https://js.devexpress.com/Documentation/Licensing/.\n\nPre-release software may contain deficiencies and as such, should not be considered for use or integrated in any mission critical application.\n\n",
  W0023: "DevExtreme: the following 'devextreme' package version does not match versions of other DevExpress products used in this application:\n\n{0}\n\nInteroperability between different versions of the products listed herein cannot be guaranteed.\n\n"
});

// node_modules/devextreme/esm/core/errors.js
var errors_default = m_errors_default;

// node_modules/devextreme/esm/__internal/core/m_config.js
var config = {
  rtlEnabled: false,
  defaultCurrency: "USD",
  defaultUseCurrencyAccountingStyle: true,
  oDataFilterToLower: true,
  serverDecimalSeparator: ".",
  decimalSeparator: ".",
  thousandsSeparator: ",",
  forceIsoDateParsing: true,
  wrapActionsBeforeExecute: true,
  useLegacyStoreResult: false,
  useJQuery: void 0,
  editorStylingMode: void 0,
  useLegacyVisibleIndex: false,
  floatingActionButtonConfig: {
    icon: "add",
    closeIcon: "close",
    label: "",
    position: {
      at: "right bottom",
      my: "right bottom",
      offset: {
        x: -16,
        y: -16
      }
    },
    maxSpeedDialActionCount: 5,
    shading: false,
    direction: "auto"
  },
  optionsParser: (optionsString) => {
    if ("{" !== optionsString.trim().charAt(0)) {
      optionsString = `{${optionsString}}`;
    }
    try {
      return JSON.parse(optionsString);
    } catch (ex) {
      try {
        return JSON.parse(normalizeToJSONString(optionsString));
      } catch (exNormalize) {
        throw errors_default.Error("E3018", ex, optionsString);
      }
    }
  }
};
var normalizeToJSONString = (optionsString) => optionsString.replace(/'/g, '"').replace(/,\s*([\]}])/g, "$1").replace(/([{,])\s*([^":\s]+)\s*:/g, '$1"$2":');
var deprecatedFields = ["decimalSeparator", "thousandsSeparator"];
var configMethod = function() {
  if (!arguments.length) {
    return config;
  }
  const newConfig = arguments.length <= 0 ? void 0 : arguments[0];
  deprecatedFields.forEach((deprecatedField) => {
    if (newConfig[deprecatedField]) {
      const message = `Now, the ${deprecatedField} is selected based on the specified locale.`;
      errors_default.log("W0003", "config", deprecatedField, "19.2", message);
    }
  });
  extend(config, newConfig);
};
if ("undefined" !== typeof DevExpress && DevExpress.config) {
  configMethod(DevExpress.config);
}
var m_config_default = configMethod;

// node_modules/devextreme/esm/common/config.js
var config_default = m_config_default;

// node_modules/devextreme/esm/__internal/core/m_class.js
var wrapOverridden = function(baseProto, methodName, method) {
  return function() {
    const prevCallBase = this.callBase;
    this.callBase = baseProto[methodName];
    try {
      return method.apply(this, arguments);
    } finally {
      this.callBase = prevCallBase;
    }
  };
};
var clonePrototype = function(obj) {
  const func = function() {
  };
  func.prototype = obj.prototype;
  return new func();
};
var redefine = function(members) {
  const that = this;
  let overridden;
  let memberName;
  let member;
  if (!members) {
    return that;
  }
  for (memberName in members) {
    member = members[memberName];
    overridden = "function" === typeof that.prototype[memberName] && "function" === typeof member;
    that.prototype[memberName] = overridden ? wrapOverridden(that.parent.prototype, memberName, member) : member;
  }
  return that;
};
var include = function() {
  const classObj = this;
  let argument;
  let name2;
  let i;
  const hasClassObjOwnProperty = Object.prototype.hasOwnProperty.bind(classObj);
  const isES6Class = !hasClassObjOwnProperty("_includedCtors") && !hasClassObjOwnProperty("_includedPostCtors");
  if (isES6Class) {
    classObj._includedCtors = classObj._includedCtors.slice(0);
    classObj._includedPostCtors = classObj._includedPostCtors.slice(0);
  }
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  for (i = 0; i < args.length; i++) {
    argument = args[i];
    if (argument.ctor) {
      classObj._includedCtors.push(argument.ctor);
    }
    if (argument.postCtor) {
      classObj._includedPostCtors.push(argument.postCtor);
    }
    for (name2 in argument) {
      if ("ctor" === name2 || "postCtor" === name2 || "default" === name2) {
        continue;
      }
      classObj.prototype[name2] = argument[name2];
    }
  }
  return classObj;
};
var subclassOf = function(parentClass) {
  const hasParentProperty = Object.prototype.hasOwnProperty.bind(this)("parent");
  const isES6Class = !hasParentProperty && this.parent;
  if (isES6Class) {
    const baseClass = Object.getPrototypeOf(this);
    return baseClass === parentClass || baseClass.subclassOf(parentClass);
  }
  if (this.parent === parentClass) {
    return true;
  }
  if (!this.parent || !this.parent.subclassOf) {
    return false;
  }
  return this.parent.subclassOf(parentClass);
};
var abstract = function() {
  throw errors_default.Error("E0001");
};
var classImpl = function() {
};
classImpl.inherit = function(members) {
  const inheritor = function() {
    if (!this || isWindow(this) || "function" !== typeof this.constructor) {
      throw errors_default.Error("E0003");
    }
    const instance = this;
    const {
      ctor
    } = instance;
    const includedCtors = instance.constructor._includedCtors;
    const includedPostCtors = instance.constructor._includedPostCtors;
    let i;
    for (i = 0; i < includedCtors.length; i++) {
      includedCtors[i].call(instance);
    }
    if (ctor) {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      ctor.apply(instance, args);
    }
    for (i = 0; i < includedPostCtors.length; i++) {
      includedPostCtors[i].call(instance);
    }
  };
  inheritor.prototype = clonePrototype(this);
  Object.setPrototypeOf(inheritor, this);
  inheritor.inherit = this.inherit;
  inheritor.abstract = abstract;
  inheritor.redefine = redefine;
  inheritor.include = include;
  inheritor.subclassOf = subclassOf;
  inheritor.parent = this;
  inheritor._includedCtors = this._includedCtors ? this._includedCtors.slice(0) : [];
  inheritor._includedPostCtors = this._includedPostCtors ? this._includedPostCtors.slice(0) : [];
  inheritor.prototype.constructor = inheritor;
  inheritor.redefine(members);
  return inheritor;
};
classImpl.abstract = abstract;
var m_class_default = classImpl;

// node_modules/devextreme/esm/core/class.js
var class_default = m_class_default;

// node_modules/devextreme/esm/__internal/core/m_guid.js
var Guid = class_default.inherit({
  ctor: function(value2) {
    if (value2) {
      value2 = String(value2);
    }
    this._value = this._normalize(value2 || this._generate());
  },
  _normalize: function(value2) {
    value2 = value2.replace(/[^a-f0-9]/gi, "").toLowerCase();
    while (value2.length < 32) {
      value2 += "0";
    }
    return [value2.substr(0, 8), value2.substr(8, 4), value2.substr(12, 4), value2.substr(16, 4), value2.substr(20, 12)].join("-");
  },
  _generate: function() {
    let value2 = "";
    for (let i = 0; i < 32; i++) {
      value2 += Math.round(15 * Math.random()).toString(16);
    }
    return value2;
  },
  toString: function() {
    return this._value;
  },
  valueOf: function() {
    return this._value;
  },
  toJSON: function() {
    return this._value;
  }
});

// node_modules/devextreme/esm/common/guid.js
var guid_default = Guid;

// node_modules/devextreme/esm/__internal/core/templates/m_template_engine_registry.js
var templateEngines = {};
var currentTemplateEngine;
function registerTemplateEngine(name2, templateEngine) {
  templateEngines[name2] = templateEngine;
}
function setTemplateEngine(templateEngine) {
  if (isString(templateEngine)) {
    currentTemplateEngine = templateEngines[templateEngine];
    if (!currentTemplateEngine) {
      throw errors_default.Error("E0020", templateEngine);
    }
  } else {
    currentTemplateEngine = templateEngine;
  }
}
function getCurrentTemplateEngine() {
  return currentTemplateEngine;
}

// node_modules/devextreme/esm/core/config.js
var config_default2 = config_default;

// node_modules/devextreme/esm/core/guid.js
var guid_default2 = guid_default;

// node_modules/devextreme/esm/__internal/core/utils/m_dependency_injector.js
function injector(object) {
  const BaseClass = class_default.inherit(object);
  let InjectedClass = BaseClass;
  let instance = new InjectedClass(object);
  const initialFields = {};
  const injectFields = function(injectionObject, initial) {
    each(injectionObject, function(key) {
      if (isFunction(instance[key])) {
        if (initial || !object[key]) {
          object[key] = function() {
            return instance[key].apply(object, arguments);
          };
        }
      } else {
        if (initial) {
          initialFields[key] = object[key];
        }
        object[key] = instance[key];
      }
    });
  };
  injectFields(object, true);
  object.inject = function(injectionObject) {
    InjectedClass = InjectedClass.inherit(injectionObject);
    instance = new InjectedClass();
    injectFields(injectionObject);
  };
  object.resetInjection = function() {
    extend(object, initialFields);
    InjectedClass = BaseClass;
    instance = new BaseClass();
  };
  return object;
}

// node_modules/devextreme/esm/core/utils/dependency_injector.js
var dependency_injector_default = injector;

// node_modules/devextreme/esm/__internal/core/utils/m_variable_wrapper.js
var variableWrapper = dependency_injector_default({
  isWrapped: function() {
    return false;
  },
  isWritableWrapped: function() {
    return false;
  },
  wrap: function(value2) {
    return value2;
  },
  unwrap: function(value2) {
    return value2;
  },
  assign: function() {
    logger.error("Method 'assign' should not be used for not wrapped variables. Use 'isWrapped' method for ensuring.");
  }
});

// node_modules/devextreme/esm/core/utils/variable_wrapper.js
var variable_wrapper_default = variableWrapper;

// node_modules/devextreme/esm/__internal/core/utils/m_object.js
var orderEach = function(map3, func) {
  const keys = [];
  let key;
  let i;
  for (key in map3) {
    if (Object.prototype.hasOwnProperty.call(map3, key)) {
      keys.push(key);
    }
  }
  keys.sort(function(x, y) {
    const isNumberX = isNumeric(x);
    const isNumberY = isNumeric(y);
    if (isNumberX && isNumberY) {
      return x - y;
    }
    if (isNumberX && !isNumberY) {
      return -1;
    }
    if (!isNumberX && isNumberY) {
      return 1;
    }
    if (x < y) {
      return -1;
    }
    if (x > y) {
      return 1;
    }
    return 0;
  });
  for (i = 0; i < keys.length; i++) {
    key = keys[i];
    func(key, map3[key]);
  }
};
var getDeepCopyTarget = (item) => {
  if (isObject(item)) {
    return Array.isArray(item) ? [] : {};
  }
  return item;
};
var legacyAssign = function(target, property, value2, extendComplexObject, assignByReference, shouldCopyUndefined) {
  if (!assignByReference && variable_wrapper_default.isWrapped(target[property])) {
    variable_wrapper_default.assign(target[property], value2);
  } else {
    target[property] = value2;
  }
};
var newAssign = function(target, property, value2, extendComplexObject, assignByReference, shouldCopyUndefined) {
  const goDeeper = extendComplexObject ? isObject(target) : isPlainObject(target);
  if (!assignByReference && variable_wrapper_default.isWrapped(target[property])) {
    variable_wrapper_default.assign(target[property], value2);
  } else if (!assignByReference && Array.isArray(value2)) {
    target[property] = value2.map((item) => deepExtendArraySafe(getDeepCopyTarget(item), item, extendComplexObject, assignByReference, shouldCopyUndefined));
  } else if (!assignByReference && goDeeper) {
    target[property] = deepExtendArraySafe(getDeepCopyTarget(value2), value2, extendComplexObject, assignByReference, shouldCopyUndefined, newAssign);
  } else {
    target[property] = value2;
  }
};
var deepExtendArraySafe = function(target, changes, extendComplexObject, assignByReference, shouldCopyUndefined, useNewAssign) {
  let prevValue;
  let newValue;
  const assignFunc = useNewAssign ? newAssign : legacyAssign;
  for (const name2 in changes) {
    prevValue = target[name2];
    newValue = changes[name2];
    if ("__proto__" === name2 || "constructor" === name2 || target === newValue) {
      continue;
    }
    if (isPlainObject(newValue)) {
      const goDeeper = extendComplexObject ? isObject(prevValue) : isPlainObject(prevValue);
      newValue = deepExtendArraySafe(goDeeper ? prevValue : {}, newValue, extendComplexObject, assignByReference, shouldCopyUndefined);
    }
    const isDeepCopyArray = Array.isArray(newValue) && !assignByReference;
    const hasDifferentNewValue = (shouldCopyUndefined || void 0 !== newValue) && prevValue !== newValue || shouldCopyUndefined && void 0 === prevValue;
    if (isDeepCopyArray || hasDifferentNewValue) {
      assignFunc(target, name2, newValue, extendComplexObject, assignByReference, shouldCopyUndefined);
    }
  }
  return target;
};

// node_modules/devextreme/esm/__internal/core/utils/m_data.js
var unwrapVariable = variable_wrapper_default.unwrap;
var {
  isWrapped
} = variable_wrapper_default;
var {
  assign
} = variable_wrapper_default;
var bracketsToDots = function(expr) {
  return expr.replace(/\[/g, ".").replace(/\]/g, "");
};
var getPathParts = function(name2) {
  return bracketsToDots(name2).split(".");
};
var readPropValue = function(obj, propName, options2) {
  options2 = options2 || {};
  if ("this" === propName) {
    return unwrap(obj, options2);
  }
  return unwrap(obj[propName], options2);
};
var assignPropValue = function(obj, propName, value2, options2) {
  if ("this" === propName) {
    throw new errors_default.Error("E4016");
  }
  const propValue = obj[propName];
  if (options2.unwrapObservables && isWrapped(propValue)) {
    assign(propValue, value2);
  } else {
    obj[propName] = value2;
  }
};
var prepareOptions = function(options2) {
  options2 = options2 || {};
  options2.unwrapObservables = void 0 !== options2.unwrapObservables ? options2.unwrapObservables : true;
  return options2;
};
function unwrap(value2, options2) {
  return options2.unwrapObservables ? unwrapVariable(value2) : value2;
}
var compileGetter = function(expr) {
  if (arguments.length > 1) {
    expr = [].slice.call(arguments);
  }
  if (!expr || "this" === expr) {
    return function(obj) {
      return obj;
    };
  }
  if ("string" === typeof expr) {
    const path = getPathParts(expr);
    return function(obj, options2) {
      options2 = prepareOptions(options2);
      const functionAsIs = options2.functionsAsIs;
      const hasDefaultValue = "defaultValue" in options2;
      let current2 = unwrap(obj, options2);
      for (let i = 0; i < path.length; i++) {
        if (!current2) {
          if (null == current2 && hasDefaultValue) {
            return options2.defaultValue;
          }
          break;
        }
        const pathPart = path[i];
        if (hasDefaultValue && isObject(current2) && !(pathPart in current2)) {
          return options2.defaultValue;
        }
        let next = unwrap(current2[pathPart], options2);
        if (!functionAsIs && isFunction(next)) {
          next = next.call(current2);
        }
        current2 = next;
      }
      return current2;
    };
  }
  if (Array.isArray(expr)) {
    return combineGetters(expr);
  }
  if (isFunction(expr)) {
    return expr;
  }
};
function combineGetters(getters) {
  const compiledGetters = {};
  for (let i = 0, l = getters.length; i < l; i++) {
    const getter = getters[i];
    compiledGetters[getter] = compileGetter(getter);
  }
  return function(obj, options2) {
    let result2;
    each(compiledGetters, function(name2) {
      const value2 = this(obj, options2);
      if (void 0 === value2) {
        return;
      }
      let current2 = result2 || (result2 = {});
      const path = name2.split(".");
      const last = path.length - 1;
      for (let i = 0; i < last; i++) {
        const pathItem = path[i];
        if (!(pathItem in current2)) {
          current2[pathItem] = {};
        }
        current2 = current2[pathItem];
      }
      current2[path[last]] = value2;
    });
    return result2;
  };
}
function toLowerCase(value2, options2) {
  return null !== options2 && void 0 !== options2 && options2.locale ? value2.toLocaleLowerCase(options2.locale) : value2.toLowerCase();
}
function toUpperCase(value2, options2) {
  return null !== options2 && void 0 !== options2 && options2.locale ? value2.toLocaleUpperCase(options2.locale) : value2.toUpperCase();
}
var ensurePropValueDefined = function(obj, propName, value2, options2) {
  if (isDefined(value2)) {
    return value2;
  }
  const newValue = {};
  assignPropValue(obj, propName, newValue, options2);
  return newValue;
};
var compileSetter = function(expr) {
  expr = getPathParts(expr || "this");
  const lastLevelIndex = expr.length - 1;
  return function(obj, value2, options2) {
    options2 = prepareOptions(options2);
    let currentValue = unwrap(obj, options2);
    expr.forEach(function(propertyName, levelIndex) {
      let propertyValue = readPropValue(currentValue, propertyName, options2);
      const isPropertyFunc = !options2.functionsAsIs && isFunction(propertyValue) && !isWrapped(propertyValue);
      if (levelIndex === lastLevelIndex) {
        if (options2.merge && isPlainObject(value2) && (!isDefined(propertyValue) || isPlainObject(propertyValue))) {
          propertyValue = ensurePropValueDefined(currentValue, propertyName, propertyValue, options2);
          deepExtendArraySafe(propertyValue, value2, false, true);
        } else if (isPropertyFunc) {
          currentValue[propertyName](value2);
        } else {
          assignPropValue(currentValue, propertyName, value2, options2);
        }
      } else {
        propertyValue = ensurePropValueDefined(currentValue, propertyName, propertyValue, options2);
        if (isPropertyFunc) {
          propertyValue = propertyValue.call(currentValue);
        }
        currentValue = propertyValue;
      }
    });
  };
};
var toComparable = function(value2, caseSensitive) {
  var _options$collatorOpti;
  let options2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
  if (value2 instanceof Date) {
    return value2.getTime();
  }
  const collatorSensitivity = null === options2 || void 0 === options2 || null === (_options$collatorOpti = options2.collatorOptions) || void 0 === _options$collatorOpti ? void 0 : _options$collatorOpti.sensitivity;
  if (value2 && value2 instanceof class_default && value2.valueOf) {
    value2 = value2.valueOf();
  } else if ("string" === typeof value2 && ("base" === collatorSensitivity || "case" === collatorSensitivity)) {
    const REMOVE_DIACRITICAL_MARKS_REGEXP = /[\u0300-\u036f]/g;
    if ("base" === collatorSensitivity) {
      value2 = toLowerCase(value2, options2);
    }
    value2 = value2.normalize("NFD").replace(REMOVE_DIACRITICAL_MARKS_REGEXP, "");
  }
  const isCaseSensitive = caseSensitive || "case" === collatorSensitivity || "variant" === collatorSensitivity;
  if ("string" === typeof value2 && !isCaseSensitive) {
    var _options$locale;
    const locale = null === options2 || void 0 === options2 || null === (_options$locale = options2.locale) || void 0 === _options$locale ? void 0 : _options$locale.toLowerCase();
    const useUpperCase = locale && !!["hy", "el"].find((code) => locale === code || locale.startsWith(`${code}-`));
    return (useUpperCase ? toUpperCase : toLowerCase)(value2, options2);
  }
  return value2;
};

// node_modules/devextreme/esm/__internal/core/utils/m_deferred.js
var deferredConfig = [{
  method: "resolve",
  handler: "done",
  state: "resolved"
}, {
  method: "reject",
  handler: "fail",
  state: "rejected"
}, {
  method: "notify",
  handler: "progress"
}];
var DeferredObj = function() {
  const that = this;
  this._state = "pending";
  this._promise = {};
  deferredConfig.forEach(function(config3) {
    const methodName = config3.method;
    this[`${methodName}Callbacks`] = callbacks_default();
    this[methodName] = function() {
      return this[`${methodName}With`](this._promise, arguments);
    }.bind(this);
    this._promise[config3.handler] = function(handler) {
      if (!handler) {
        return this;
      }
      const callbacks2 = that[`${methodName}Callbacks`];
      if (callbacks2.fired()) {
        handler.apply(that[`${methodName}Context`], that[`${methodName}Args`]);
      } else {
        callbacks2.add(function(context2, args) {
          handler.apply(context2, args);
        });
      }
      return this;
    };
  }.bind(this));
  this._promise.always = function(handler) {
    return this.done(handler).fail(handler);
  };
  this._promise.catch = function(handler) {
    return this.then(null, handler);
  };
  this._promise.then = function(resolve, reject) {
    const result2 = new DeferredObj();
    ["done", "fail"].forEach(function(method) {
      const callback = "done" === method ? resolve : reject;
      this[method](function() {
        if (!callback) {
          result2["done" === method ? "resolve" : "reject"].apply(this, arguments);
          return;
        }
        const callbackResult = callback && callback.apply(this, arguments);
        if (isDeferred(callbackResult)) {
          callbackResult.done(result2.resolve).fail(result2.reject);
        } else if (isPromise(callbackResult)) {
          callbackResult.then(result2.resolve, result2.reject);
        } else {
          result2.resolve.apply(this, isDefined(callbackResult) ? [callbackResult] : arguments);
        }
      });
    }.bind(this));
    return result2.promise();
  };
  this._promise.state = function() {
    return that._state;
  };
  this._promise.promise = function(args) {
    return args ? extend(args, that._promise) : that._promise;
  };
  this._promise.promise(this);
};
deferredConfig.forEach(function(config3) {
  const methodName = config3.method;
  const {
    state
  } = config3;
  DeferredObj.prototype[`${methodName}With`] = function(context2, args) {
    const callbacks2 = this[`${methodName}Callbacks`];
    if ("pending" === this.state()) {
      this[`${methodName}Args`] = args;
      this[`${methodName}Context`] = context2;
      if (state) {
        this._state = state;
      }
      callbacks2.fire(context2, args);
      if ("pending" !== state) {
        this.resolveCallbacks.empty();
        this.rejectCallbacks.empty();
      }
    }
    return this;
  };
});
function fromPromise(promise, context2) {
  if (isDeferred(promise)) {
    return promise;
  }
  if (isPromise(promise)) {
    const d = new DeferredObj();
    promise.then(function() {
      d.resolveWith.apply(d, [context2].concat([
        [].slice.call(arguments)
      ]));
    }, function() {
      d.rejectWith.apply(d, [context2].concat([
        [].slice.call(arguments)
      ]));
    });
    return d;
  }
  return new DeferredObj().resolveWith(context2, [promise]);
}
var whenFunc = function() {
  if (1 === arguments.length) {
    return fromPromise(arguments[0]);
  }
  const values = [].slice.call(arguments);
  const contexts = [];
  let resolvedCount = 0;
  const deferred = new DeferredObj();
  const updateState = function(i) {
    return function(value2) {
      contexts[i] = this;
      values[i] = arguments.length > 1 ? [].slice.call(arguments) : value2;
      resolvedCount++;
      if (resolvedCount === values.length) {
        deferred.resolveWith(contexts, values);
      }
    };
  };
  for (let i = 0; i < values.length; i++) {
    if (isDeferred(values[i])) {
      values[i].promise().done(updateState(i)).fail(deferred.reject);
    } else {
      resolvedCount++;
    }
  }
  if (resolvedCount === values.length) {
    deferred.resolveWith(contexts, values);
  }
  return deferred.promise();
};
function Deferred() {
  return new DeferredObj();
}
function when() {
  return whenFunc.apply(this, arguments);
}

// node_modules/devextreme/esm/__internal/core/utils/m_common.js
var uiLayerInitialized = new Deferred();
var ensureDefined = function(value2, defaultValue) {
  return isDefined(value2) ? value2 : defaultValue;
};
var executeAsync = function(action, context2) {
  const deferred = new Deferred();
  const normalizedContext = context2 || this;
  const task = {
    promise: deferred.promise(),
    abort() {
      clearTimeout(timerId);
      deferred.rejectWith(normalizedContext);
    }
  };
  const timerId = (arguments[2] || setTimeout)(function() {
    const result2 = action.call(normalizedContext);
    if (result2 && result2.done && isFunction(result2.done)) {
      result2.done(function() {
        deferred.resolveWith(normalizedContext);
      });
    } else {
      deferred.resolveWith(normalizedContext);
    }
  }, "number" === typeof context2 ? context2 : 0);
  return task;
};
var delayedFuncs = [];
var delayedNames = [];
var delayedDeferreds = [];
var executingName;
var deferExecute = function(name2, func, deferred) {
  if (executingName && executingName !== name2) {
    delayedFuncs.push(func);
    delayedNames.push(name2);
    deferred = deferred || new Deferred();
    delayedDeferreds.push(deferred);
    return deferred;
  }
  const oldExecutingName = executingName;
  const currentDelayedCount = delayedDeferreds.length;
  executingName = name2;
  let result2 = func();
  if (!result2) {
    if (delayedDeferreds.length > currentDelayedCount) {
      result2 = when.apply(this, delayedDeferreds.slice(currentDelayedCount));
    } else if (deferred) {
      deferred.resolve();
    }
  }
  executingName = oldExecutingName;
  if (deferred && result2 && result2.done) {
    result2.done(deferred.resolve).fail(deferred.reject);
  }
  if (!executingName && delayedFuncs.length) {
    ("render" === delayedNames.shift() ? deferRender : deferUpdate)(delayedFuncs.shift(), delayedDeferreds.shift());
  }
  return result2 || when();
};
var deferRender = function(func, deferred) {
  return deferExecute("render", func, deferred);
};
var deferUpdate = function(func, deferred) {
  return deferExecute("update", func, deferred);
};
var deferRenderer = function(func) {
  return function() {
    const that = this;
    return deferExecute("render", function() {
      return func.call(that);
    });
  };
};
var deferUpdater = function(func) {
  return function() {
    const that = this;
    return deferExecute("update", function() {
      return func.call(that);
    });
  };
};
var findBestMatches = (targetFilter, items, mapFn) => {
  const bestMatches = [];
  let maxMatchCount = 0;
  each(items, (index2, itemSrc) => {
    let matchCount = 0;
    const item = mapFn ? mapFn(itemSrc) : itemSrc;
    each(targetFilter, (paramName, targetValue) => {
      const value2 = item[paramName];
      if (void 0 === value2) {
        return;
      }
      if (match(value2, targetValue)) {
        matchCount++;
        return;
      }
      matchCount = -1;
      return false;
    });
    if (matchCount < maxMatchCount) {
      return;
    }
    if (matchCount > maxMatchCount) {
      bestMatches.length = 0;
      maxMatchCount = matchCount;
    }
    bestMatches.push(itemSrc);
  });
  return bestMatches;
};
var match = function(value2, targetValue) {
  if (Array.isArray(value2) && Array.isArray(targetValue)) {
    let mismatch = false;
    each(value2, (index2, valueItem) => {
      if (valueItem !== targetValue[index2]) {
        mismatch = true;
        return false;
      }
    });
    if (mismatch) {
      return false;
    }
    return true;
  }
  if (value2 === targetValue) {
    return true;
  }
  return false;
};
var splitPair = function(raw) {
  switch (type(raw)) {
    case "string":
      return raw.split(/\s+/, 2);
    case "object":
      return [raw.x ?? raw.h, raw.y ?? raw.v];
    case "number":
      return [raw];
    case "array":
      return raw;
    default:
      return null;
  }
};
var normalizeKey = function(id) {
  let key = isString(id) ? id : id.toString();
  const arr = key.match(/[^a-zA-Z0-9_]/g);
  arr && each(arr, (_, sign2) => {
    key = key.replace(sign2, `__${sign2.charCodeAt()}__`);
  });
  return key;
};
var denormalizeKey = function(key) {
  const arr = key.match(/__\d+__/g);
  arr && arr.forEach((char) => {
    const charCode = parseInt(char.replace("__", ""));
    key = key.replace(char, String.fromCharCode(charCode));
  });
  return key;
};
var pairToObject = function(raw, preventRound) {
  const pair = splitPair(raw);
  let h3 = preventRound ? parseFloat(pair && pair[0]) : parseInt(pair && pair[0], 10);
  let v = preventRound ? parseFloat(pair && pair[1]) : parseInt(pair && pair[1], 10);
  if (!isFinite(h3)) {
    h3 = 0;
  }
  if (!isFinite(v)) {
    v = h3;
  }
  return {
    h: h3,
    v
  };
};
var getKeyHash = function(key) {
  if (key instanceof guid_default2) {
    return key.toString();
  }
  if (isObject(key) || Array.isArray(key)) {
    try {
      const keyHash = JSON.stringify(key);
      return "{}" === keyHash ? key : keyHash;
    } catch (e) {
      return key;
    }
  }
  return key;
};
var escapeRegExp = function(string) {
  return string.replace(/[[\]{}\-()*+?.\\^$|\s]/g, "\\$&");
};
var applyServerDecimalSeparator = function(value2) {
  const separator = config_default2().serverDecimalSeparator;
  if (isDefined(value2)) {
    value2 = value2.toString().replace(".", separator);
  }
  return value2;
};
var noop2 = function() {
};
var asyncNoop = function() {
  return new Deferred().resolve().promise();
};
var grep = function(elements, checkFunction, invert) {
  const result2 = [];
  let check;
  const expectedCheck = !invert;
  for (let i = 0; i < elements.length; i++) {
    check = !!checkFunction(elements[i], i);
    if (check === expectedCheck) {
      result2.push(elements[i]);
    }
  }
  return result2;
};
var compareArrays = (array1, array2, depth, options2) => {
  if (array1.length !== array2.length) {
    return false;
  }
  return !array1.some((item, idx) => !compareByValue(item, array2[idx], depth + 1, _extends({}, options2, {
    strict: true
  })));
};
var compareObjects = (object1, object2, depth, options2) => {
  const keys1 = Object.keys(object1);
  const keys2 = Object.keys(object2);
  if (keys1.length !== keys2.length) {
    return false;
  }
  const keys2Set = new Set(keys2);
  return !keys1.some((key) => !keys2Set.has(key) || !compareByValue(object1[key], object2[key], depth + 1, options2));
};
var DEFAULT_EQUAL_BY_VALUE_OPTS = {
  maxDepth: 3,
  strict: true
};
var compareByValue = (value1, value2, depth, options2) => {
  const {
    strict,
    maxDepth
  } = options2;
  const comparable1 = toComparable(value1, true);
  const comparable2 = toComparable(value2, true);
  const comparisonResult = strict ? comparable1 === comparable2 : comparable1 == comparable2;
  switch (true) {
    case comparisonResult:
    case depth >= maxDepth:
      return true;
    case (isObject(comparable1) && isObject(comparable2)):
      return compareObjects(comparable1, comparable2, depth, options2);
    case (Array.isArray(comparable1) && Array.isArray(comparable2)):
      return compareArrays(comparable1, comparable2, depth, options2);
    default:
      return false;
  }
};
var equalByValue = function(value1, value2) {
  let options2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : DEFAULT_EQUAL_BY_VALUE_OPTS;
  const compareOptions = _extends({}, DEFAULT_EQUAL_BY_VALUE_OPTS, options2);
  return compareByValue(value1, value2, 0, compareOptions);
};
var m_common_default = {
  ensureDefined,
  executeAsync,
  deferRender,
  deferUpdate,
  deferRenderer,
  deferUpdater,
  findBestMatches,
  splitPair,
  normalizeKey,
  denormalizeKey,
  pairToObject,
  getKeyHash,
  escapeRegExp,
  applyServerDecimalSeparator,
  noop: noop2,
  asyncNoop,
  grep,
  equalByValue
};

// node_modules/devextreme/esm/__internal/core/utils/m_shadow_dom.js
var ownerDocumentStyleSheet = null;
function createConstructedStyleSheet(rootNode) {
  try {
    return new CSSStyleSheet();
  } catch (err) {
    const styleElement = rootNode.ownerDocument.createElement("style");
    rootNode.appendChild(styleElement);
    return styleElement.sheet;
  }
}
function processRules(targetStyleSheet, styleSheets, needApplyAllStyles) {
  for (let i = 0; i < styleSheets.length; i++) {
    const sheet = styleSheets[i];
    try {
      for (let j = 0; j < sheet.cssRules.length; j++) {
        insertRule(targetStyleSheet, sheet.cssRules[j], needApplyAllStyles);
      }
    } catch (err) {
    }
  }
}
function insertRule(targetStyleSheet, rule, needApplyAllStyles) {
  var _rule$selectorText, _rule$cssRules, _rule$name, _rule$style;
  const isDxRule = needApplyAllStyles || (null === (_rule$selectorText = rule.selectorText) || void 0 === _rule$selectorText ? void 0 : _rule$selectorText.includes("dx-")) || (null === (_rule$cssRules = rule.cssRules) || void 0 === _rule$cssRules || null === (_rule$cssRules = _rule$cssRules[0]) || void 0 === _rule$cssRules || null === (_rule$cssRules = _rule$cssRules.selectorText) || void 0 === _rule$cssRules ? void 0 : _rule$cssRules.includes("dx-")) || (null === (_rule$name = rule.name) || void 0 === _rule$name ? void 0 : _rule$name.startsWith("dx-")) || "DXIcons" === (null === (_rule$style = rule.style) || void 0 === _rule$style ? void 0 : _rule$style.fontFamily);
  if (isDxRule) {
    targetStyleSheet.insertRule(rule.cssText, targetStyleSheet.cssRules.length);
  }
}
function addShadowDomStyles($element) {
  var _el$getRootNode;
  const el = $element.get(0);
  const root = null === (_el$getRootNode = el.getRootNode) || void 0 === _el$getRootNode ? void 0 : _el$getRootNode.call(el);
  if (!(null !== root && void 0 !== root && root.host)) {
    return;
  }
  if (!ownerDocumentStyleSheet) {
    ownerDocumentStyleSheet = createConstructedStyleSheet(root);
    processRules(ownerDocumentStyleSheet, el.ownerDocument.styleSheets, false);
  }
  const currentShadowDomStyleSheet = createConstructedStyleSheet(root);
  processRules(currentShadowDomStyleSheet, root.styleSheets, true);
  root.adoptedStyleSheets = [ownerDocumentStyleSheet, currentShadowDomStyleSheet];
}
function isPositionInElementRectangle(element, x, y) {
  var _element$getBoundingC;
  const rect = null === (_element$getBoundingC = element.getBoundingClientRect) || void 0 === _element$getBoundingC ? void 0 : _element$getBoundingC.call(element);
  return rect && x >= rect.left && x < rect.right && y >= rect.top && y < rect.bottom;
}
function createQueue() {
  let shiftIndex = 0;
  const items = [];
  return {
    push(item) {
      items.push(item);
      return this;
    },
    shift() {
      shiftIndex++;
      return items[shiftIndex - 1];
    },
    get length() {
      return items.length - shiftIndex;
    },
    get items() {
      return items;
    }
  };
}
function getShadowElementsFromPoint(x, y, root) {
  const elementQueue = createQueue().push(root);
  while (elementQueue.length) {
    const el = elementQueue.shift();
    for (let i = 0; i < el.childNodes.length; i++) {
      const childNode = el.childNodes[i];
      if (childNode.nodeType === Node.ELEMENT_NODE && isPositionInElementRectangle(childNode, x, y) && "none" !== getComputedStyle(childNode).pointerEvents) {
        elementQueue.push(childNode);
      }
    }
  }
  const result2 = elementQueue.items.reverse();
  result2.pop();
  return result2;
}

// node_modules/devextreme/esm/__internal/core/m_dom_adapter.js
var nativeDOMAdapterStrategy = {
  querySelectorAll: (element, selector) => element.querySelectorAll(selector),
  elementMatches(element, selector) {
    const matches = element.matches || element.matchesSelector || element.mozMatchesSelector || element.msMatchesSelector || element.oMatchesSelector || element.webkitMatchesSelector || ((selector2) => {
      const doc = element.document || element.ownerDocument;
      if (!doc) {
        return false;
      }
      const items = this.querySelectorAll(doc, selector2);
      for (let i = 0; i < items.length; i++) {
        if (items[i] === element) {
          return true;
        }
      }
    });
    return matches.call(element, selector);
  },
  createElement(tagName, context2) {
    context2 = context2 ?? this._document;
    return context2.createElement(tagName);
  },
  createElementNS(ns, tagName, context2) {
    context2 = context2 || this._document;
    return context2.createElementNS(ns, tagName);
  },
  createTextNode(text, context2) {
    context2 = context2 || this._document;
    return context2.createTextNode(text);
  },
  createAttribute(text, context2) {
    context2 = context2 || this._document;
    return context2.createAttribute(text);
  },
  isNode: (element) => !!element && "object" === typeof element && "nodeType" in element && "nodeName" in element,
  isElementNode: (element) => !!element && 1 === element.nodeType,
  isTextNode: (element) => element && 3 === element.nodeType,
  isDocument: (element) => element && 9 === element.nodeType,
  isDocumentFragment: (element) => element && 11 === element.nodeType,
  removeElement(element) {
    const parentNode = element && element.parentNode;
    if (parentNode) {
      parentNode.removeChild(element);
    }
  },
  insertElement(parentElement, newElement, nextSiblingElement) {
    if (parentElement && newElement && parentElement !== newElement) {
      if (nextSiblingElement) {
        parentElement.insertBefore(newElement, nextSiblingElement);
      } else {
        parentElement.appendChild(newElement);
      }
    }
  },
  getAttribute: (element, name2) => element.getAttribute(name2),
  setAttribute(element, name2, value2) {
    if ("style" === name2) {
      element.style.cssText = value2;
    } else {
      element.setAttribute(name2, value2);
    }
  },
  removeAttribute(element, name2) {
    element.removeAttribute(name2);
  },
  setProperty(element, name2, value2) {
    element[name2] = value2;
  },
  setText(element, text) {
    if (element) {
      element.textContent = text;
    }
  },
  setClass(element, className, isAdd) {
    if (1 === element.nodeType && className) {
      isAdd ? element.classList.add(className) : element.classList.remove(className);
    }
  },
  setStyle(element, name2, value2) {
    element.style[name2] = value2 || "";
  },
  _document: "undefined" === typeof document ? void 0 : document,
  getDocument() {
    return this._document;
  },
  getActiveElement(element) {
    const activeElementHolder = this.getRootNode(element);
    return activeElementHolder.activeElement;
  },
  getRootNode(element) {
    var _element$getRootNode;
    return (null === element || void 0 === element || null === (_element$getRootNode = element.getRootNode) || void 0 === _element$getRootNode ? void 0 : _element$getRootNode.call(element)) ?? this._document;
  },
  getBody() {
    return this._document.body;
  },
  createDocumentFragment() {
    return this._document.createDocumentFragment();
  },
  getDocumentElement() {
    return this._document.documentElement;
  },
  getLocation() {
    return this._document.location;
  },
  getSelection() {
    return this._document.selection;
  },
  getReadyState() {
    return this._document.readyState;
  },
  getHead() {
    return this._document.head;
  },
  hasDocumentProperty(property) {
    return property in this._document;
  },
  listen(element, event, callback, options2) {
    if (!element || !("addEventListener" in element)) {
      return noop2;
    }
    element.addEventListener(event, callback, options2);
    return () => {
      element.removeEventListener(event, callback);
    };
  },
  elementsFromPoint(x, y, element) {
    const activeElementHolder = this.getRootNode(element);
    if (activeElementHolder.host) {
      return getShadowElementsFromPoint(x, y, activeElementHolder);
    }
    return activeElementHolder.elementsFromPoint(x, y);
  }
};
var domAdapter = dependency_injector_default(nativeDOMAdapterStrategy);

// node_modules/devextreme/esm/core/dom_adapter.js
var dom_adapter_default = domAdapter;

// node_modules/devextreme/esm/__internal/core/utils/m_call_once.js
var callOnce = function(handler) {
  let result2;
  let wrappedHandler = function() {
    result2 = handler.apply(this, arguments);
    wrappedHandler = function() {
      return result2;
    };
    return result2;
  };
  return function() {
    return wrappedHandler.apply(this, arguments);
  };
};

// node_modules/devextreme/esm/core/utils/call_once.js
var call_once_default = callOnce;

// node_modules/devextreme/esm/__internal/core/utils/m_window.js
var hasWindowValue = "undefined" !== typeof window;
var hasWindow = () => hasWindowValue;
var windowObject = hasWindow() ? window : void 0;
if (!windowObject) {
  windowObject = {};
  windowObject.window = windowObject;
}
var getWindow = () => windowObject;
var setWindow = (newWindowObject, hasWindow2) => {
  if (void 0 === hasWindow2) {
    hasWindowValue = "undefined" !== typeof window && window === newWindowObject;
  } else {
    hasWindowValue = hasWindow2;
  }
  windowObject = newWindowObject;
};
var hasProperty = (prop) => hasWindow() && prop in windowObject;
var defaultScreenFactorFunc = (width) => {
  if (width < 768) {
    return "xs";
  }
  if (width < 992) {
    return "sm";
  }
  if (width < 1200) {
    return "md";
  }
  return "lg";
};
var getCurrentScreenFactor = (screenFactorCallback) => {
  const screenFactorFunc = screenFactorCallback || defaultScreenFactorFunc;
  const windowWidth = dom_adapter_default.getDocumentElement().clientWidth;
  return screenFactorFunc(windowWidth);
};
var getNavigator = () => {
  var _windowObject;
  return hasWindow() ? null === (_windowObject = windowObject) || void 0 === _windowObject ? void 0 : _windowObject.navigator : {
    userAgent: ""
  };
};
var m_window_default = {
  defaultScreenFactorFunc,
  getCurrentScreenFactor,
  getNavigator,
  getWindow,
  hasProperty,
  hasWindow,
  setWindow
};

// node_modules/devextreme/esm/__internal/events/core/m_events_engine.js
var window2 = getWindow();
var EMPTY_EVENT_NAME = "dxEmptyEventType";
var NATIVE_EVENTS_TO_SUBSCRIBE = {
  mouseenter: "mouseover",
  mouseleave: "mouseout",
  pointerenter: "pointerover",
  pointerleave: "pointerout"
};
var NATIVE_EVENTS_TO_TRIGGER = {
  focusin: "focus",
  focusout: "blur"
};
var NO_BUBBLE_EVENTS = ["blur", "focus", "load"];
var forcePassiveFalseEventNames = ["touchmove", "wheel", "mousewheel", "touchstart"];
var EVENT_PROPERTIES = ["target", "relatedTarget", "delegateTarget", "altKey", "bubbles", "cancelable", "changedTouches", "ctrlKey", "detail", "eventPhase", "metaKey", "shiftKey", "view", "char", "code", "charCode", "key", "keyCode", "button", "buttons", "offsetX", "offsetY", "pointerId", "pointerType", "targetTouches", "toElement", "touches"];
function matchesSafe(target, selector) {
  return !isWindow(target) && "#document" !== target.nodeName && dom_adapter_default.elementMatches(target, selector);
}
var elementDataMap = /* @__PURE__ */ new WeakMap();
var guid = 0;
var skipEvent;
var special = function() {
  const specialData = {};
  event_registrator_callbacks_default.add((eventName, eventObject) => {
    specialData[eventName] = eventObject;
  });
  return {
    getField: (eventName, field) => specialData[eventName] && specialData[eventName][field],
    callMethod: (eventName, methodName, context2, args) => specialData[eventName] && specialData[eventName][methodName] && specialData[eventName][methodName].apply(context2, args)
  };
}();
var eventsEngine = dependency_injector_default({
  on: getHandler(normalizeOnArguments(iterate((element, eventName, selector, data17, handler) => {
    const handlersController = getHandlersController(element, eventName);
    handlersController.addHandler(handler, selector, data17);
  }))),
  one: getHandler(normalizeOnArguments((element, eventName, selector, data17, handler) => {
    const oneTimeHandler = function() {
      eventsEngine.off(element, eventName, selector, oneTimeHandler);
      handler.apply(this, arguments);
    };
    eventsEngine.on(element, eventName, selector, data17, oneTimeHandler);
  })),
  off: getHandler(normalizeOffArguments(iterate((element, eventName, selector, handler) => {
    const handlersController = getHandlersController(element, eventName);
    handlersController.removeHandler(handler, selector);
  }))),
  trigger: getHandler(normalizeTriggerArguments((element, event, extraParameters) => {
    const eventName = event.type;
    const handlersController = getHandlersController(element, event.type);
    special.callMethod(eventName, "trigger", element, [event, extraParameters]);
    handlersController.callHandlers(event, extraParameters);
    const noBubble = special.getField(eventName, "noBubble") || event.isPropagationStopped() || NO_BUBBLE_EVENTS.includes(eventName);
    if (!noBubble) {
      const parents = [];
      const getParents = function(element2) {
        const parent = element2.parentNode ?? (isObject(element2.host) ? element2.host : null);
        if (parent) {
          parents.push(parent);
          getParents(parent);
        }
      };
      getParents(element);
      parents.push(window2);
      let i = 0;
      while (parents[i] && !event.isPropagationStopped()) {
        const parentDataByEvent = getHandlersController(parents[i], event.type);
        parentDataByEvent.callHandlers(extend(event, {
          currentTarget: parents[i]
        }), extraParameters);
        i++;
      }
    }
    if (element.nodeType || isWindow(element)) {
      special.callMethod(eventName, "_default", element, [event, extraParameters]);
      callNativeMethod(eventName, element);
    }
  })),
  triggerHandler: getHandler(normalizeTriggerArguments((element, event, extraParameters) => {
    const handlersController = getHandlersController(element, event.type);
    handlersController.callHandlers(event, extraParameters);
  }))
});
function applyForEach(args, method) {
  const element = args[0];
  if (!element) {
    return;
  }
  if (dom_adapter_default.isNode(element) || isWindow(element)) {
    method.apply(eventsEngine, args);
  } else if (!isString(element) && "length" in element) {
    const itemArgs = Array.prototype.slice.call(args, 0);
    Array.prototype.forEach.call(element, (itemElement) => {
      itemArgs[0] = itemElement;
      applyForEach(itemArgs, method);
    });
  } else {
    throw errors_default.Error("E0025");
  }
}
function getHandler(method) {
  return function() {
    applyForEach(arguments, method);
  };
}
function detectPassiveEventHandlersSupport() {
  let isSupported = false;
  try {
    const options2 = Object.defineProperty({}, "passive", {
      get() {
        isSupported = true;
        return true;
      }
    });
    window2.addEventListener("test", null, options2);
  } catch (e) {
  }
  return isSupported;
}
var passiveEventHandlersSupported = call_once_default(detectPassiveEventHandlersSupport);
var contains = (container, element) => {
  if (isWindow(container)) {
    return contains(container.document, element);
  }
  return container.contains ? container.contains(element) : !!(element.compareDocumentPosition(container) & element.DOCUMENT_POSITION_CONTAINS);
};
function getHandlersController(element, eventName) {
  let elementData = elementDataMap.get(element);
  eventName = eventName || "";
  const eventNameParts = eventName.split(".");
  const namespaces2 = eventNameParts.slice(1);
  const eventNameIsDefined = !!eventNameParts[0];
  eventName = eventNameParts[0] || EMPTY_EVENT_NAME;
  if (!elementData) {
    elementData = {};
    elementDataMap.set(element, elementData);
  }
  if (!elementData[eventName]) {
    elementData[eventName] = {
      handleObjects: [],
      nativeHandler: null
    };
  }
  const eventData2 = elementData[eventName];
  return {
    addHandler(handler, selector, data17) {
      const callHandler = function(e, extraParameters) {
        const handlerArgs = [e];
        const target = e.currentTarget;
        const {
          relatedTarget
        } = e;
        let secondaryTargetIsInside;
        let result2;
        if (eventName in NATIVE_EVENTS_TO_SUBSCRIBE) {
          secondaryTargetIsInside = relatedTarget && target && (relatedTarget === target || contains(target, relatedTarget));
        }
        if (void 0 !== extraParameters) {
          handlerArgs.push(extraParameters);
        }
        special.callMethod(eventName, "handle", element, [e, data17]);
        if (!secondaryTargetIsInside) {
          result2 = handler.apply(target, handlerArgs);
        }
        if (false === result2) {
          e.preventDefault();
          e.stopPropagation();
        }
      };
      const handleObject = {
        handler,
        wrappedHandler: function(e, extraParameters) {
          if (skipEvent && e.type === skipEvent) {
            return;
          }
          e.data = data17;
          e.delegateTarget = element;
          if (selector) {
            let currentTarget = e.target;
            while (currentTarget && currentTarget !== element) {
              if (matchesSafe(currentTarget, selector)) {
                e.currentTarget = currentTarget;
                callHandler(e, extraParameters);
              }
              currentTarget = currentTarget.parentNode;
            }
          } else {
            var _e$target;
            e.currentTarget = e.delegateTarget || e.target;
            const isTargetInShadowDOM = Boolean(null === (_e$target = e.target) || void 0 === _e$target ? void 0 : _e$target.shadowRoot);
            if (isTargetInShadowDOM) {
              const target = getEventTarget(e);
              e.target = target;
            }
            callHandler(e, extraParameters);
          }
        },
        selector,
        type: eventName,
        data: data17,
        namespace: namespaces2.join("."),
        namespaces: namespaces2,
        guid: ++guid
      };
      eventData2.handleObjects.push(handleObject);
      const firstHandlerForTheType = 1 === eventData2.handleObjects.length;
      let shouldAddNativeListener = firstHandlerForTheType && eventNameIsDefined;
      let nativeListenerOptions;
      if (shouldAddNativeListener) {
        shouldAddNativeListener = !special.callMethod(eventName, "setup", element, [data17, namespaces2, handler]);
      }
      if (shouldAddNativeListener) {
        eventData2.nativeHandler = getNativeHandler(eventName);
        if (passiveEventHandlersSupported() && forcePassiveFalseEventNames.includes(eventName)) {
          nativeListenerOptions = {
            passive: false
          };
        }
        eventData2.removeListener = dom_adapter_default.listen(element, NATIVE_EVENTS_TO_SUBSCRIBE[eventName] || eventName, eventData2.nativeHandler, nativeListenerOptions);
      }
      special.callMethod(eventName, "add", element, [handleObject]);
    },
    removeHandler(handler, selector) {
      const removeByEventName = function(eventName2) {
        const eventData3 = elementData[eventName2];
        if (!eventData3.handleObjects.length) {
          delete elementData[eventName2];
          return;
        }
        let removedHandler;
        eventData3.handleObjects = eventData3.handleObjects.filter((handleObject) => {
          const skip = namespaces2.length && !isSubset(handleObject.namespaces, namespaces2) || handler && handleObject.handler !== handler || selector && handleObject.selector !== selector;
          if (!skip) {
            removedHandler = handleObject.handler;
            special.callMethod(eventName2, "remove", element, [handleObject]);
          }
          return skip;
        });
        const lastHandlerForTheType = !eventData3.handleObjects.length;
        const shouldRemoveNativeListener = lastHandlerForTheType && eventName2 !== EMPTY_EVENT_NAME;
        if (shouldRemoveNativeListener) {
          special.callMethod(eventName2, "teardown", element, [namespaces2, removedHandler]);
          if (eventData3.nativeHandler) {
            eventData3.removeListener();
          }
          delete elementData[eventName2];
        }
      };
      if (eventNameIsDefined) {
        removeByEventName(eventName);
      } else {
        for (const name2 in elementData) {
          removeByEventName(name2);
        }
      }
      const elementDataIsEmpty = 0 === Object.keys(elementData).length;
      if (elementDataIsEmpty) {
        elementDataMap.delete(element);
      }
    },
    callHandlers(event, extraParameters) {
      let forceStop = false;
      const handleCallback = function(handleObject) {
        if (forceStop) {
          return;
        }
        if (!namespaces2.length || isSubset(handleObject.namespaces, namespaces2)) {
          handleObject.wrappedHandler(event, extraParameters);
          forceStop = event.isImmediatePropagationStopped();
        }
      };
      eventData2.handleObjects.forEach(handleCallback);
      if (namespaces2.length && elementData[EMPTY_EVENT_NAME]) {
        elementData[EMPTY_EVENT_NAME].handleObjects.forEach(handleCallback);
      }
    }
  };
}
function getNativeHandler(subscribeName) {
  return function(event, extraParameters) {
    const handlersController = getHandlersController(this, subscribeName);
    event = eventsEngine.Event(event);
    handlersController.callHandlers(event, extraParameters);
  };
}
function isSubset(original, checked) {
  for (let i = 0; i < checked.length; i++) {
    if (original.indexOf(checked[i]) < 0) {
      return false;
    }
  }
  return true;
}
function normalizeOnArguments(callback) {
  return function(element, eventName, selector, data17, handler) {
    if (!handler) {
      handler = data17;
      data17 = void 0;
    }
    if ("string" !== typeof selector) {
      data17 = selector;
      selector = void 0;
    }
    if (!handler && "string" === typeof eventName) {
      handler = data17 || selector;
      selector = void 0;
      data17 = void 0;
    }
    callback(element, eventName, selector, data17, handler);
  };
}
function normalizeOffArguments(callback) {
  return function(element, eventName, selector, handler) {
    if ("function" === typeof selector) {
      handler = selector;
      selector = void 0;
    }
    callback(element, eventName, selector, handler);
  };
}
function normalizeTriggerArguments(callback) {
  return function(element, src, extraParameters) {
    if ("string" === typeof src) {
      src = {
        type: src
      };
    }
    if (!src.target) {
      src.target = element;
    }
    src.currentTarget = element;
    if (!src.delegateTarget) {
      src.delegateTarget = element;
    }
    if (!src.type && src.originalEvent) {
      src.type = src.originalEvent.type;
    }
    callback(element, src instanceof eventsEngine.Event ? src : eventsEngine.Event(src), extraParameters);
  };
}
function normalizeEventArguments(callback) {
  eventsEngine.Event = function(src, config3) {
    if (!(this instanceof eventsEngine.Event)) {
      return new eventsEngine.Event(src, config3);
    }
    if (!src) {
      src = {};
    }
    if ("string" === typeof src) {
      src = {
        type: src
      };
    }
    if (!config3) {
      config3 = {};
    }
    callback.call(this, src, config3);
  };
  Object.assign(eventsEngine.Event.prototype, {
    _propagationStopped: false,
    _immediatePropagationStopped: false,
    _defaultPrevented: false,
    isPropagationStopped() {
      return !!(this._propagationStopped || this.originalEvent && this.originalEvent.propagationStopped);
    },
    stopPropagation() {
      this._propagationStopped = true;
      this.originalEvent && this.originalEvent.stopPropagation();
    },
    isImmediatePropagationStopped() {
      return this._immediatePropagationStopped;
    },
    stopImmediatePropagation() {
      this.stopPropagation();
      this._immediatePropagationStopped = true;
      this.originalEvent && this.originalEvent.stopImmediatePropagation();
    },
    isDefaultPrevented() {
      return !!(this._defaultPrevented || this.originalEvent && this.originalEvent.defaultPrevented);
    },
    preventDefault() {
      this._defaultPrevented = true;
      this.originalEvent && this.originalEvent.preventDefault();
    }
  });
  return eventsEngine.Event;
}
function iterate(callback) {
  const iterateEventNames = function(element, eventName) {
    if (eventName && eventName.indexOf(" ") > -1) {
      const args = Array.prototype.slice.call(arguments, 0);
      eventName.split(" ").forEach(function(eventName2) {
        args[1] = eventName2;
        callback.apply(this, args);
      });
    } else {
      callback.apply(this, arguments);
    }
  };
  return function(element, eventName) {
    if ("object" === typeof eventName) {
      const args = Array.prototype.slice.call(arguments, 0);
      for (const name2 in eventName) {
        args[1] = name2;
        args[args.length - 1] = eventName[name2];
        iterateEventNames.apply(this, args);
      }
    } else {
      iterateEventNames.apply(this, arguments);
    }
  };
}
function callNativeMethod(eventName, element) {
  const nativeMethodName = NATIVE_EVENTS_TO_TRIGGER[eventName] || eventName;
  if (function(eventName2, element2) {
    return "click" === eventName2 && "a" === element2.localName;
  }(eventName, element)) {
    return;
  }
  if (isFunction(element[nativeMethodName])) {
    skipEvent = eventName;
    element[nativeMethodName]();
    skipEvent = void 0;
  }
}
function calculateWhich(event) {
  if (function(event2) {
    return null == event2.which && 0 === event2.type.indexOf("key");
  }(event)) {
    return null != event.charCode ? event.charCode : event.keyCode;
  }
  if (function(event2) {
    return !event2.which && void 0 !== event2.button && /^(?:mouse|pointer|contextmenu|drag|drop)|click/.test(event2.type);
  }(event)) {
    const whichByButton = {
      1: 1,
      2: 3,
      3: 1,
      4: 2
    };
    return whichByButton[event.button];
  }
  return event.which;
}
function initEvent(EventClass) {
  if (EventClass) {
    eventsEngine.Event = EventClass;
    eventsEngine.Event.prototype = EventClass.prototype;
  }
}
initEvent(normalizeEventArguments(function(src, config3) {
  var _src$view;
  const srcIsEvent = src instanceof eventsEngine.Event || hasWindow() && src instanceof window2.Event || (null === (_src$view = src.view) || void 0 === _src$view ? void 0 : _src$view.Event) && src instanceof src.view.Event;
  if (srcIsEvent) {
    this.originalEvent = src;
    this.type = src.type;
    this.currentTarget = void 0;
    if (Object.prototype.hasOwnProperty.call(src, "isTrusted")) {
      this.isTrusted = src.isTrusted;
    }
    this.timeStamp = src.timeStamp || Date.now();
  } else {
    Object.assign(this, src);
  }
  addProperty("which", calculateWhich, this);
  if (0 === src.type.indexOf("touch")) {
    delete config3.pageX;
    delete config3.pageY;
  }
  Object.assign(this, config3);
  this.guid = ++guid;
}));
function addProperty(propName, hook, eventInstance) {
  Object.defineProperty(eventInstance || eventsEngine.Event.prototype, propName, {
    enumerable: true,
    configurable: true,
    get() {
      return this.originalEvent && hook(this.originalEvent);
    },
    set(value2) {
      Object.defineProperty(this, propName, {
        enumerable: true,
        configurable: true,
        writable: true,
        value: value2
      });
    }
  });
}
EVENT_PROPERTIES.forEach((prop) => addProperty(prop, (event) => event[prop]));
m_hook_touch_props_default(addProperty);
var beforeSetStrategy = callbacks_default();
var afterSetStrategy = callbacks_default();
eventsEngine.set = function(engine) {
  beforeSetStrategy.fire();
  eventsEngine.inject(engine);
  initEvent(engine.Event);
  afterSetStrategy.fire();
};
eventsEngine.subscribeGlobal = function() {
  applyForEach(arguments, normalizeOnArguments(function() {
    const args = arguments;
    eventsEngine.on.apply(this, args);
    beforeSetStrategy.add(function() {
      const offArgs = Array.prototype.slice.call(args, 0);
      offArgs.splice(3, 1);
      eventsEngine.off.apply(this, offArgs);
    });
    afterSetStrategy.add(function() {
      eventsEngine.on.apply(this, args);
    });
  }));
};
eventsEngine.forcePassiveFalseEventNames = forcePassiveFalseEventNames;
eventsEngine.passiveEventHandlersSupported = passiveEventHandlersSupported;
var m_events_engine_default = eventsEngine;

// node_modules/devextreme/esm/common/core/events.js
var on = m_events_engine_default.on;
var one = m_events_engine_default.one;
var off = m_events_engine_default.off;
var trigger = m_events_engine_default.trigger;
var Event = m_events_engine_default.Event;

// node_modules/devextreme/esm/events/events.types.js
var triggerHandler = m_events_engine_default.triggerHandler;

// node_modules/devextreme-vue/esm/core/vue-helper.js
import { Comment, createApp } from "vue";

// node_modules/devextreme-vue/esm/core/helpers.js
function getTemplatePropName(props, templateName) {
  for (const propName in props) {
    if (props[propName] === templateName) {
      return propName;
    }
  }
  return templateName;
}
function uppercaseFirst(value2) {
  return value2[0].toUpperCase() + value2.substr(1);
}
function lowercaseFirst(value2) {
  return value2[0].toLowerCase() + value2.substr(1);
}
function camelize(value2) {
  return lowercaseFirst(value2.split("-").map((v) => uppercaseFirst(v)).join(""));
}
function toComparable2(value2) {
  return value2 instanceof Date ? value2.getTime() : value2;
}
function isEqual(value1, value2) {
  if (toComparable2(value1) === toComparable2(value2)) {
    return true;
  }
  if (Array.isArray(value1) && Array.isArray(value2)) {
    return value1.length === 0 && value2.length === 0;
  }
  return false;
}
function forEachChildNode(el, callback) {
  Array.prototype.slice.call(el.childNodes).forEach(callback);
}
function allKeysAreEqual(obj1, obj2) {
  const obj1Keys = Object.keys(obj1);
  if (obj1Keys.length !== Object.keys(obj2).length) {
    return false;
  }
  for (const key of obj1Keys) {
    if (!obj2.hasOwnProperty(key)) {
      return false;
    }
  }
  return true;
}
function getOptionValue(options2, optionPath) {
  let value2 = options2;
  optionPath.split(".").forEach((p2) => {
    const optionInfo = getOptionInfo(p2);
    if (value2) {
      value2 = optionInfo.isCollection ? value2[optionInfo.name]?.[optionInfo.index] : value2[optionInfo.name];
    }
  });
  return value2;
}
function getOptionInfo(name2) {
  const parts = name2.split("[");
  if (parts.length === 1) {
    return {
      isCollection: false,
      name: name2,
      fullName: name2
    };
  }
  return {
    isCollection: true,
    name: parts[0],
    fullName: name2,
    index: Number(parts[1].slice(0, -1))
  };
}

// node_modules/devextreme-vue/esm/core/children-processing.js
import { PatchFlags } from "@vue/shared";
function pullAllChildren(directChildren, allChildren, config3) {
  if (!directChildren || directChildren.length === 0) {
    return;
  }
  pullConfigComponents(directChildren, allChildren, config3);
}
function isFragment(node) {
  const { patchFlag } = node;
  return patchFlag === PatchFlags.KEYED_FRAGMENT || patchFlag === PatchFlags.UNKEYED_FRAGMENT || patchFlag === PatchFlags.STABLE_FRAGMENT || patchFlag === PatchFlags.BAIL;
}
function pullConfigComponents(children, nodes, ownerConfig) {
  children.forEach((node) => {
    if (isFragment(node) && Array.isArray(node.children)) {
      pullConfigComponents(node.children, nodes, ownerConfig);
    }
    if (!isFragment(node)) {
      nodes.push(node);
    }
    if (!node) {
      return;
    }
    const componentInfo = getComponentInfo(node);
    if (!componentInfo?.$_optionName) {
      return;
    }
    const componentChildren = configurationChildren(node);
    const initialValues = {
      ...componentInfo.$_predefinedProps,
      ...getNormalizedProps(node.props || {})
    };
    const config3 = ownerConfig.createNested(componentInfo.$_optionName, initialValues, componentInfo.$_isCollectionItem, componentInfo.$_expectedChildren);
    node.$_config = config3;
    node.$_innerChanges = {};
    if (componentChildren) {
      pullConfigComponents(componentChildren, nodes, config3);
    }
  });
}

// node_modules/devextreme-vue/esm/core/vue-helper.js
var VMODEL_NAME = "modelValue";
function getChildren(component) {
  if (!hasChildren(component) || !component.$_config) {
    return [];
  }
  const children = component.$.subTree && component.$.subTree.children;
  if (!Array.isArray(children)) {
    return [];
  }
  return children.filter((child) => {
    if (!isFragment(child)) {
      return child;
    }
  });
}
function getComponentInfo(component) {
  return getConfigurationOptions(component);
}
function getNormalizedProps(props) {
  const result2 = {};
  for (const propName in props) {
    if (props.hasOwnProperty(propName)) {
      result2[camelize(propName)] = props[propName];
    }
  }
  return result2;
}
function configurationChildren(component) {
  if (!component.children?.default) {
    return [];
  }
  return findConfigurationComponents(component.children.default());
}
function configurationDefaultTemplate(node) {
  if (!node.children || node.children === "object" || !node.children.default) {
    return;
  }
  return hasInlineTemplate(node.children.default()) ? node.children.default : void 0;
}
function configurationTemplate(node) {
  return configurationDefaultTemplate(node);
}
function declaredTemplates(component) {
  return component.$slots;
}
function defaultSlots(component) {
  const templates = declaredTemplates(component);
  if (!templates.default) {
    return [];
  }
  return templates.default();
}
function mount(options2, parent, el) {
  const template = createApp(options2);
  template.provide("eventBus", parent.eventBus);
  setAppContext(template, parent);
  return template.mount(el);
}
function getComponentProps(component) {
  const props = component.$.vnode.props || {};
  return getNormalizedProps(props);
}
function getNodeOptions(component) {
  if (component.$) {
    return component.$.vnode;
  }
  return component;
}
function getNodeTypeOfComponent(component) {
  return component.$.vnode.type;
}
function getVModelValue(options2) {
  return options2[VMODEL_NAME];
}
function setVModel(config3) {
  const eventName = `update:${VMODEL_NAME}`;
  config3.model.prop = VMODEL_NAME;
  config3.model.event = eventName;
  config3.props.modelValue = {};
  config3.emits = { ...config3.emits, [`${eventName}`]: null };
}
function setCustomPluginsData(appContext, parentAppContext) {
  for (const prop in parentAppContext) {
    if (!appContext.hasOwnProperty(prop) && parentAppContext.hasOwnProperty(prop)) {
      appContext[prop] = parentAppContext[prop];
    }
  }
}
function setAppContext(template, parent) {
  template._context.components = Object.assign(parent.$.appContext.components, template._context.components);
  Object.setPrototypeOf(template._context.provides, Object.getPrototypeOf(parent.$.provides));
  Object.assign(template._context.provides, parent.$.appContext.provides);
  template._context.config = parent.$.appContext.config;
  template._context.directives = parent.$.appContext.directives;
  template._context.mixins = parent.$.appContext.mixins;
  setCustomPluginsData(template._context.app, parent.$.appContext.app);
}
function findConfigurationComponents(children) {
  return children.filter((child) => {
    if (isFragment(child)) {
      return findConfigurationComponents(child.children || []);
    }
    const childType = child.type;
    if (childType && typeof childType === "object" && childType.$_optionName) {
      delete child.$_config;
      delete child.$_innerChanges;
      return child;
    }
  });
}
function hasInlineTemplate(children) {
  let hasTemplate3 = false;
  children.forEach((child) => {
    if (!isConfiguration(child) && !isFragment(child) && !isComment(child)) {
      hasTemplate3 = true;
    }
  });
  return hasTemplate3;
}
function isComment(node) {
  return node.type === Comment || node.type.toString() === "Symbol()" && !node.children;
}
function isConfiguration(child) {
  return child.type && typeof child.type === "object" && child.type.$_optionName;
}
function getConfigurationOptions(node) {
  return node.type;
}
function hasChildren(component) {
  return component.$.vnode && component.$.vnode.children && component.$.vnode.children.default;
}

// node_modules/devextreme-vue/esm/core/configuration.js
import { toRaw } from "vue";

// node_modules/devextreme-vue/esm/core/config.js
var config2 = {
  deepWatch: false
};
function getOption(optionName) {
  return config2[optionName];
}

// node_modules/devextreme-vue/esm/core/configuration.js
var Configuration = class _Configuration {
  constructor(updateFunc, name2, initialValues, expectedChildren, isCollectionItem, collectionItemIndex, ownerConfig) {
    this._updateFunc = updateFunc;
    this._name = name2;
    this._initialValues = initialValues || {};
    this._nestedConfigurations = [];
    this._isCollectionItem = !!isCollectionItem;
    this._collectionItemIndex = collectionItemIndex;
    this._expectedChildren = expectedChildren || {};
    this._ownerConfig = ownerConfig;
    this._componentChanges = [];
    this.updateValue = this.updateValue.bind(this);
  }
  get name() {
    return this._name;
  }
  get fullName() {
    return this._name && this._isCollectionItem ? `${this._name}[${this._collectionItemIndex}]` : this._name;
  }
  get componentsCountChanged() {
    return this._componentChanges;
  }
  cleanComponentsCountChanged() {
    this._componentChanges = [];
  }
  get fullPath() {
    return this._ownerConfig?.fullPath ? `${this._ownerConfig.fullPath}.${this.fullName}` : this.fullName;
  }
  get ownerConfig() {
    return this._ownerConfig;
  }
  get options() {
    return this._options;
  }
  get initialValues() {
    return this._initialValues;
  }
  get expectedChildren() {
    return this._expectedChildren;
  }
  get nested() {
    return this._nestedConfigurations;
  }
  get prevNestedOptions() {
    return this._prevNestedConfigOptions;
  }
  get collectionItemIndex() {
    return this._collectionItemIndex;
  }
  get isCollectionItem() {
    return this._isCollectionItem;
  }
  get updateFunc() {
    return this._updateFunc;
  }
  init(options2) {
    this._options = options2 || [];
  }
  set emitOptionChanged(handler) {
    this._emitOptionChanged = handler;
  }
  setPrevNestedOptions(value2) {
    this._prevNestedConfigOptions = value2;
  }
  onOptionChanged(args) {
    if (isEqual(args.value, args.previousValue)) {
      return;
    }
    this._onOptionChanged(args.fullName.split("."), args);
  }
  cleanNested() {
    this._nestedConfigurations = [];
  }
  createNested(name2, initialValues, isCollectionItem, expectedChildren) {
    const expected = this._expectedChildren[name2];
    let actualName = name2;
    let actualIsCollectionItem = isCollectionItem;
    if (expected) {
      actualIsCollectionItem = expected.isCollectionItem;
      if (expected.optionName) {
        actualName = expected.optionName;
      }
    }
    let collectionItemIndex = -1;
    if (actualIsCollectionItem && actualName) {
      collectionItemIndex = this._nestedConfigurations.filter((c) => c._name && c._name === actualName).length;
    }
    const configuration = new _Configuration(this._updateFunc, actualName, initialValues, expectedChildren, actualIsCollectionItem, collectionItemIndex, this);
    this._nestedConfigurations.push(configuration);
    return configuration;
  }
  updateValue(nestedName, value2) {
    const fullName = [this.fullPath, nestedName].filter((n) => n).join(".");
    this._updateFunc(fullName, value2);
  }
  getNestedOptionValues() {
    const values = {};
    this._nestedConfigurations.forEach((o) => {
      if (!o._name) {
        return;
      }
      const nestedValue = { ...o.initialValues, ...o.getNestedOptionValues() };
      if (!nestedValue) {
        return;
      }
      if (!o._isCollectionItem) {
        values[o._name] = nestedValue;
      } else {
        let arr = values[o._name];
        if (!arr || !Array.isArray(arr)) {
          arr = [];
          values[o._name] = arr;
        }
        arr.push(nestedValue);
      }
    });
    return values;
  }
  getOptionsToWatch() {
    const blackList = {};
    this._nestedConfigurations.forEach((c) => c._name && (blackList[c._name] = true));
    return this._options.filter((o) => !blackList[o]);
  }
  _onOptionChanged(optionRelPath, args) {
    if (optionRelPath.length === 0) {
      return;
    }
    const optionInfo = getOptionInfo(optionRelPath[0]);
    if (optionInfo.isCollection || optionRelPath.length > 1) {
      const nestedConfig = this._getNestedConfig(optionInfo.fullName);
      if (nestedConfig) {
        nestedConfig._onOptionChanged(optionRelPath.slice(1), args);
        return;
      }
      this._tryEmitOptionChanged(optionInfo.name, args.component.option(this.fullPath ? `${this.fullPath}.${optionInfo.name}` : optionInfo.name));
    } else {
      this._tryEmitOptionChanged(optionInfo.name, args.value);
    }
  }
  _getNestedConfig(fullName) {
    for (const nestedConfig of this._nestedConfigurations) {
      if (nestedConfig.fullName === fullName) {
        return nestedConfig;
      }
    }
    return void 0;
  }
  _tryEmitOptionChanged(name2, value2) {
    if (this._emitOptionChanged) {
      this._emitOptionChanged(name2, value2);
    }
  }
};
function bindOptionWatchers(config3, vueInstance, innerChanges) {
  const targets = config3 && config3.getOptionsToWatch();
  if (targets) {
    targets.forEach((optionName) => {
      vueInstance.$watch(optionName, (value2) => {
        const rawValue = toRaw(value2);
        if (!innerChanges.hasOwnProperty(optionName) || innerChanges[optionName] !== rawValue) {
          config3.updateValue(optionName, value2);
        }
        delete innerChanges[optionName];
      }, { deep: getOption("deepWatch") });
    });
  }
}
function hasProp(vueInstance, propName) {
  const { props } = vueInstance.$options;
  return props?.hasOwnProperty(propName);
}
function hasVModelValue(options2, props, vnode) {
  return options2.model && props.hasOwnProperty(VMODEL_NAME) && vnode?.props?.hasOwnProperty(VMODEL_NAME);
}
function setEmitOptionChangedFunc(config3, vueInstance, innerChanges) {
  config3.emitOptionChanged = (name2, value2) => {
    const props = vueInstance.$props;
    const vnode = vueInstance?.$?.vnode;
    const propsName = name2 === "value" && hasVModelValue(vueInstance.$options, props, vnode) ? VMODEL_NAME : name2;
    const eventName = `update:${propsName}`;
    if (hasProp(vueInstance, name2) && !isEqual(value2, props[propsName]) && vueInstance.$emit) {
      innerChanges[propsName] = toRaw(value2);
      vueInstance.$emit(eventName, value2);
    }
  };
}
var configuration_default = Configuration;

// node_modules/devextreme-vue/esm/core/configuration-component.js
import { defineComponent } from "vue";
function getConfig(vueInstance) {
  const componentOptions = getNodeOptions(vueInstance);
  if (!componentOptions) {
    return;
  }
  return componentOptions.$_config || vueInstance.$_config;
}
function getInnerChanges(vueInstance) {
  const componentOptions = getNodeOptions(vueInstance);
  if (!componentOptions) {
    return;
  }
  return componentOptions.$_innerChanges || vueInstance.$_innerChanges;
}
function initOptionChangedFunc(config3, props, vueInstance, innerChanges) {
  if (!config3) {
    return;
  }
  config3.init(Object.keys(props));
  if (vueInstance) {
    setEmitOptionChangedFunc(config3, vueInstance, innerChanges);
  }
}
function getComponentInfo2({ name: name2, isCollectionItem, ownerConfig }, removed) {
  const parentPath = ownerConfig?.fullPath;
  const optionPath = name2 && parentPath ? `${parentPath}.${name2}` : name2 || "";
  return {
    optionPath,
    isCollection: isCollectionItem,
    removed
  };
}
function initDxConfiguration() {
  return defineComponent({
    beforeMount() {
      const thisComponent = this;
      const config3 = getConfig(thisComponent);
      const innerChanges = getInnerChanges(thisComponent);
      initOptionChangedFunc(config3, getNodeTypeOfComponent(thisComponent).props, thisComponent, innerChanges);
      bindOptionWatchers(config3, this, innerChanges);
    },
    mounted() {
      if (this.$parent.$_instance) {
        this.$parent.$_config.componentsCountChanged.push(getComponentInfo2(getConfig(this)));
      }
    },
    beforeUnmount() {
      const config3 = getConfig(this);
      if (config3) {
        this.$parent.$_config.componentsCountChanged.push(getComponentInfo2(config3, true));
      }
    },
    render() {
      return null;
    }
  });
}

// node_modules/devextreme-vue/esm/core/constants.js
var DX_TEMPLATE_WRAPPER_CLASS = "dx-template-wrapper";
var DX_REMOVE_EVENT = "dxremove";

// node_modules/devextreme-vue/esm/core/templates-discovering.js
import { h } from "vue";
var TEMPLATE_PROP = "template";
function asConfigurable(component) {
  const componentOptions = component;
  if (!componentOptions) {
    return;
  }
  if (!componentOptions.$_config?.name) {
    return void 0;
  }
  return componentOptions;
}
function hasTemplate(component) {
  return TEMPLATE_PROP in component.type.props && configurationTemplate(component);
}
function discover(component) {
  const templates = {};
  const namedTeplates = declaredTemplates(component);
  for (const slotName in namedTeplates) {
    if (slotName === "default" && component.$slots.default) {
      continue;
    }
    const slot = namedTeplates[slotName];
    if (!slot) {
      continue;
    }
    templates[slotName] = slot;
  }
  const componentChildren = getChildren(component);
  for (const childComponent of componentChildren) {
    const configurable = asConfigurable(childComponent);
    if (!configurable) {
      continue;
    }
    const defaultSlot = configurationDefaultTemplate(childComponent);
    if (!defaultSlot || !hasTemplate(childComponent)) {
      continue;
    }
    const templateName = `${configurable.$_config.fullPath}.${TEMPLATE_PROP}`;
    templates[templateName] = defaultSlot;
  }
  return templates;
}
function clearConfiguration(content) {
  const newContent = [];
  content.forEach((item) => {
    const configurable = getConfigurationOptions(item);
    if (!configurable?.$_optionName) {
      newContent.push(item);
    }
  });
  return newContent;
}
function mountTemplate(getSlot, parent, data17, name2, placeholder) {
  return mount({
    name: name2,
    inject: ["eventBus"],
    created() {
      this.eventBus.add(this.$_updatedHandler);
    },
    mounted() {
      data17.onRendered();
    },
    unmounted() {
      this.eventBus.remove(this.$_updatedHandler);
    },
    methods: {
      $_updatedHandler() {
        this.$forceUpdate();
      }
    },
    render: () => {
      const content = clearConfiguration(getSlot()(data17));
      if (!content) {
        return h("div");
      }
      return content.length > 1 ? content : content[0];
    }
  }, parent, placeholder);
}

// node_modules/devextreme-vue/esm/core/templates-manager.js
var TemplatesManager = class {
  constructor(component) {
    this._slots = {};
    this._templates = {};
    this._isDirty = false;
    this._component = component;
    this.discover();
  }
  discover() {
    this._slots = {
      ...discover(this._component)
    };
    if (!allKeysAreEqual(this._templates, this._slots)) {
      this._prepareTemplates();
    }
  }
  get templates() {
    return this._templates;
  }
  get isDirty() {
    return this._isDirty;
  }
  resetDirtyFlag() {
    this._isDirty = false;
  }
  _prepareTemplates() {
    this._templates = {};
    for (const name2 of Object.keys(this._slots)) {
      this._templates[name2] = this.createDxTemplate(name2);
    }
    this._isDirty = true;
  }
  createDxTemplate(name2) {
    return {
      render: (data17) => {
        const rendered = /* @__PURE__ */ ((onRendered, counter = 0) => () => {
          if (counter === 1 && onRendered) {
            onRendered();
          }
          counter++;
        })(data17.onRendered);
        const scopeData = { data: data17.model, index: data17.index, onRendered: rendered };
        const placeholder = document.createElement("div");
        const container = data17.container.get ? data17.container.get(0) : data17.container;
        container.appendChild(placeholder);
        const mountedTemplate = mountTemplate(() => this._slots[name2], this._component, scopeData, name2, placeholder);
        const element = mountedTemplate.$el;
        container.removeChild(placeholder);
        while (placeholder.firstChild) {
          container.appendChild(placeholder.firstChild);
        }
        dom_adapter_default.setClass(element, DX_TEMPLATE_WRAPPER_CLASS, true);
        if (element.nodeType === Node.TEXT_NODE) {
          const removalListener = document.createElement(container.nodeName === "TABLE" ? "tbody" : "span");
          removalListener.style.display = "none";
          container.insertBefore(removalListener, container.firstChild);
          one(removalListener, DX_REMOVE_EVENT, () => {
            mountedTemplate.$.appContext.app.unmount.bind(mountedTemplate)();
            removalListener.remove();
          });
        } else {
          one(element, DX_REMOVE_EVENT, mountedTemplate.$.appContext.app.unmount.bind(mountedTemplate));
        }
        rendered();
        return element;
      }
    };
  }
};

// node_modules/devextreme-vue/esm/core/component.js
var includeAttrs = ["id", "class", "style"];
var dxClassesPrefix = "dx-";
config_default2({
  buyNowLink: "https://go.devexpress.com/Licensing_Installer_Watermark_DevExtremeVue.aspx",
  licensingDocLink: "https://go.devexpress.com/Licensing_Documentation_DevExtremeVue.aspx"
});
function parseClassList(classList) {
  return classList.trim().split(/\s+/);
}
function prepareAttrs(attrs, dxClassesSyncedWithClassAttr) {
  const attributes = {};
  includeAttrs.forEach((attr) => {
    const attrValue = attrs[attr];
    if (attrValue !== void 0 && attrValue !== null) {
      if (attr === "class") {
        const nonDXClassesFromAttr = attrValue.split(" ").filter((classFromAttr) => !classFromAttr.startsWith(dxClassesPrefix)).join(" ");
        attributes[attr] = [nonDXClassesFromAttr, dxClassesSyncedWithClassAttr].filter((item) => item !== "").join(" ");
      } else {
        attributes[attr] = attrValue;
      }
    }
  });
  return attributes;
}
function initBaseComponent() {
  return defineComponent2({
    inheritAttrs: false,
    data() {
      return {
        eventBus: callbacks_default(),
        prevClassAttr: ""
      };
    },
    provide() {
      return {
        eventBus: this.eventBus
      };
    },
    render() {
      const thisComponent = this;
      const children = [];
      const dxClasses = pickOutDxClasses(this.$el) || [];
      if (thisComponent.$_config.cleanNested) {
        thisComponent.$_config.cleanNested();
      }
      pullAllChildren(defaultSlots(this), children, thisComponent.$_config);
      this.$_processChildren(children);
      return h2("div", {
        ...prepareAttrs(this.$attrs, dxClasses.join(" "))
      }, children);
    },
    beforeUpdate() {
      const thisComponent = this;
      thisComponent.$_config.setPrevNestedOptions(thisComponent.$_config.getNestedOptionValues());
      this.$_syncElementClassesWithClassAttr();
    },
    updated() {
      const thisComponent = this;
      const nodes = cleanWidgetNode(this.$el);
      getChildren(thisComponent).forEach((child) => {
        initOptionChangedFunc(child.$_config, child.type.props || {}, child?.component?.proxy, child.$_innerChanges);
      });
      thisComponent.$_templatesManager.discover();
      thisComponent.$_instance.beginUpdate();
      this.$_applyConfigurationChanges();
      if (thisComponent.$_templatesManager.isDirty) {
        thisComponent.$_instance.option("integrationOptions.templates", thisComponent.$_templatesManager.templates);
        const { props } = thisComponent.$.vnode;
        for (const name2 of Object.keys(thisComponent.$_templatesManager.templates)) {
          thisComponent.$_instance.option(getTemplatePropName(props, name2), name2);
        }
        thisComponent.$_templatesManager.resetDirtyFlag();
      }
      for (const name2 of Object.keys(thisComponent.$_pendingOptions)) {
        thisComponent.$_instance.option(name2, thisComponent.$_pendingOptions[name2]);
      }
      thisComponent.$_pendingOptions = {};
      thisComponent.$_instance.endUpdate();
      restoreNodes(this.$el, nodes);
      this.eventBus.fire();
    },
    beforeUnmount() {
      const thisComponent = this;
      const instance = thisComponent.$_instance;
      if (instance) {
        triggerHandler(this.$el, DX_REMOVE_EVENT);
        instance.dispose();
      }
    },
    created() {
      const thisComponent = this;
      const props = getComponentProps(this);
      thisComponent.$_config = new configuration_default((n, v) => {
        if (Array.isArray(v)) {
          thisComponent.$_instance.option(n, v);
        } else {
          thisComponent.$_pendingOptions[n === VMODEL_NAME ? "value" : n] = v;
        }
      }, null, props && { ...props }, thisComponent.$_expectedChildren);
      thisComponent.$_innerChanges = {};
      thisComponent.$_config.init(this.$props && Object.keys(this.$props));
    },
    methods: {
      $_syncElementClassesWithClassAttr() {
        const newClassAttr = typeof this.$attrs?.class === "string" ? this.$attrs?.class : "";
        if (this.prevClassAttr === newClassAttr) {
          return;
        }
        if (this.prevClassAttr.length) {
          this.$el.classList.remove(...parseClassList(this.prevClassAttr));
        }
        if (newClassAttr.length) {
          this.$el.classList.add(...parseClassList(newClassAttr));
        }
        this.prevClassAttr = newClassAttr;
      },
      $_applyConfigurationChanges() {
        const thisComponent = this;
        thisComponent.$_config.componentsCountChanged.forEach(({ optionPath, isCollection, removed }) => {
          const options2 = thisComponent.$_config.getNestedOptionValues();
          if (!isCollection && removed) {
            thisComponent.$_instance.resetOption(optionPath);
          } else {
            thisComponent.$_instance.option(optionPath, getOptionValue(options2, optionPath));
          }
        });
        thisComponent.$_config.cleanComponentsCountChanged();
      },
      $_createWidget(element) {
        const thisComponent = this;
        thisComponent.$_pendingOptions = {};
        thisComponent.$_templatesManager = new TemplatesManager(this);
        const widgetConfig = thisComponent.$_config;
        if (widgetConfig.initialValues.hasOwnProperty(VMODEL_NAME)) {
          widgetConfig.initialValues.value = getVModelValue(widgetConfig.initialValues);
        }
        const options2 = {
          templatesRenderAsynchronously: thisComponent.$_hasAsyncTemplate,
          ...getComponentProps(thisComponent),
          ...widgetConfig.initialValues,
          ...widgetConfig.getNestedOptionValues(),
          ...this.$_getIntegrationOptions()
        };
        const instance = new thisComponent.$_WidgetClass(element, options2);
        thisComponent.$_instance = instance;
        instance.on("optionChanged", (args) => widgetConfig.onOptionChanged(args));
        setEmitOptionChangedFunc(widgetConfig, thisComponent, thisComponent.$_innerChanges);
        bindOptionWatchers(widgetConfig, thisComponent, thisComponent.$_innerChanges);
        this.$_createEmitters(instance);
      },
      $_getIntegrationOptions() {
        const thisComponent = this;
        const result2 = {
          integrationOptions: {
            watchMethod: this.$_getWatchMethod()
          },
          ...this.$_getExtraIntegrationOptions()
        };
        if (thisComponent.$_templatesManager.isDirty) {
          const { templates } = thisComponent.$_templatesManager;
          result2.integrationOptions.templates = templates;
          const { props } = thisComponent.$.vnode;
          for (const name2 of Object.keys(templates)) {
            result2[getTemplatePropName(props, name2)] = name2;
          }
          thisComponent.$_templatesManager.resetDirtyFlag();
        }
        return result2;
      },
      $_getWatchMethod() {
        return (valueGetter, valueChangeCallback, options2) => {
          options2 = options2 || {};
          if (!options2.skipImmediate) {
            valueChangeCallback(valueGetter());
          }
          return this.$watch(() => valueGetter(), (newValue, oldValue) => {
            if (toComparable2(oldValue) !== toComparable2(newValue) || options2.deep) {
              valueChangeCallback(newValue);
            }
          }, {
            deep: options2.deep
          });
        };
      },
      $_getExtraIntegrationOptions() {
        return {};
      },
      $_processChildren(_children) {
      },
      $_createEmitters(instance) {
        if (this.$attrs) {
          Object.keys(this.$attrs).forEach((listenerName) => {
            const eventName = camelize(listenerName);
            instance.on(eventName, (e) => {
              this.$emit(listenerName, e);
            });
          });
        }
      }
    }
  });
}
function cleanWidgetNode(node) {
  const removedNodes = [];
  forEachChildNode(node, (childNode) => {
    const parent = childNode.parentNode;
    const isExtension = childNode.hasAttribute && childNode.hasAttribute("isExtension");
    if ((childNode.nodeName === "#comment" || isExtension) && parent) {
      removedNodes.push(childNode);
      parent.removeChild(childNode);
    }
  });
  return removedNodes;
}
function pickOutDxClasses(el) {
  return el && Array.from(el.classList).filter((item) => item.startsWith(dxClassesPrefix));
}
function restoreNodes(el, nodes) {
  nodes.forEach((node) => {
    el.appendChild(node);
  });
}
function initDxComponent() {
  return defineComponent2({
    extends: initBaseComponent(),
    methods: {
      $_getExtraIntegrationOptions() {
        return {
          onInitializing() {
            this.beginUpdate();
          }
        };
      },
      $_processChildren(children) {
        children.forEach((childNode) => {
          if (!childNode || typeof childNode !== "object") {
            return;
          }
          childNode.$_hasOwner = true;
        });
      }
    },
    mounted() {
      const nodes = cleanWidgetNode(this.$el);
      const thisComponent = this;
      this.$_createWidget(this.$el);
      this.$_syncElementClassesWithClassAttr();
      thisComponent.$_instance.endUpdate();
      restoreNodes(this.$el, nodes);
      if (this.$slots?.default) {
        getChildren(thisComponent).forEach((child) => {
          const childExtenton = child;
          if (childExtenton && childExtenton.$_isExtension) {
            childExtenton.$_attachTo(this.$el);
          }
        });
      }
    }
  });
}

// node_modules/devextreme-vue/esm/core/extension-component.js
import { defineComponent as defineComponent3 } from "vue";

// node_modules/devextreme-vue/esm/core/index.js
function prepareComponentConfig(config3) {
  config3.extends = initDxComponent();
  if (config3.model) {
    setVModel(config3);
  }
}
function prepareConfigurationComponentConfig(config3) {
  config3.extends = initDxConfiguration();
}

// node_modules/devextreme/esm/__internal/core/utils/m_inflector.js
var _normalize = function(text) {
  if (void 0 === text || null === text) {
    return "";
  }
  return String(text);
};
var _upperCaseFirst = function(text) {
  return _normalize(text).charAt(0).toUpperCase() + text.substr(1);
};
var _chop = function(text) {
  return _normalize(text).replace(/([a-z\d])([A-Z])/g, "$1 $2").split(/[\s_-]+/);
};
var dasherize = function(text) {
  return map(_chop(text), function(p2) {
    return p2.toLowerCase();
  }).join("-");
};
var underscore = function(text) {
  return dasherize(text).replace(/-/g, "_");
};
var camelize2 = function(text, upperFirst) {
  return map(_chop(text), function(p2, i) {
    p2 = p2.toLowerCase();
    if (upperFirst || i > 0) {
      p2 = _upperCaseFirst(p2);
    }
    return p2;
  }).join("");
};
var humanize = function(text) {
  return _upperCaseFirst(dasherize(text).replace(/-/g, " "));
};
var titleize = function(text) {
  return map(_chop(text), function(p2) {
    return _upperCaseFirst(p2.toLowerCase());
  }).join(" ");
};
var DIGIT_CHARS = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9"];
var captionize = function(name2) {
  const captionList = [];
  let i;
  let char;
  let isPrevCharNewWord = false;
  let isNewWord = false;
  for (i = 0; i < name2.length; i++) {
    char = name2.charAt(i);
    isNewWord = char === char.toUpperCase() && "-" !== char && ")" !== char && "/" !== char || char in DIGIT_CHARS;
    if ("_" === char || "." === char) {
      char = " ";
      isNewWord = true;
    } else if (0 === i) {
      char = char.toUpperCase();
      isNewWord = true;
    } else if (!isPrevCharNewWord && isNewWord) {
      if (captionList.length > 0) {
        captionList.push(" ");
      }
    }
    captionList.push(char);
    isPrevCharNewWord = isNewWord;
  }
  return captionList.join("");
};
var m_inflector_default = {
  dasherize,
  underscore,
  camelize: camelize2,
  humanize,
  titleize,
  captionize
};

// node_modules/devextreme/esm/common/core/localization/cldr-data/parent_locales.js
var parent_locales_default = {
  "en-150": "en-001",
  "en-AG": "en-001",
  "en-AI": "en-001",
  "en-AU": "en-001",
  "en-BB": "en-001",
  "en-BM": "en-001",
  "en-BS": "en-001",
  "en-BW": "en-001",
  "en-BZ": "en-001",
  "en-CC": "en-001",
  "en-CK": "en-001",
  "en-CM": "en-001",
  "en-CX": "en-001",
  "en-CY": "en-001",
  "en-DG": "en-001",
  "en-DM": "en-001",
  "en-ER": "en-001",
  "en-FJ": "en-001",
  "en-FK": "en-001",
  "en-FM": "en-001",
  "en-GB": "en-001",
  "en-GD": "en-001",
  "en-GG": "en-001",
  "en-GH": "en-001",
  "en-GI": "en-001",
  "en-GM": "en-001",
  "en-GY": "en-001",
  "en-HK": "en-001",
  "en-IE": "en-001",
  "en-IL": "en-001",
  "en-IM": "en-001",
  "en-IN": "en-001",
  "en-IO": "en-001",
  "en-JE": "en-001",
  "en-JM": "en-001",
  "en-KE": "en-001",
  "en-KI": "en-001",
  "en-KN": "en-001",
  "en-KY": "en-001",
  "en-LC": "en-001",
  "en-LR": "en-001",
  "en-LS": "en-001",
  "en-MG": "en-001",
  "en-MO": "en-001",
  "en-MS": "en-001",
  "en-MT": "en-001",
  "en-MU": "en-001",
  "en-MV": "en-001",
  "en-MW": "en-001",
  "en-MY": "en-001",
  "en-NA": "en-001",
  "en-NF": "en-001",
  "en-NG": "en-001",
  "en-NR": "en-001",
  "en-NU": "en-001",
  "en-NZ": "en-001",
  "en-PG": "en-001",
  "en-PK": "en-001",
  "en-PN": "en-001",
  "en-PW": "en-001",
  "en-RW": "en-001",
  "en-SB": "en-001",
  "en-SC": "en-001",
  "en-SD": "en-001",
  "en-SG": "en-001",
  "en-SH": "en-001",
  "en-SL": "en-001",
  "en-SS": "en-001",
  "en-SX": "en-001",
  "en-SZ": "en-001",
  "en-TC": "en-001",
  "en-TK": "en-001",
  "en-TO": "en-001",
  "en-TT": "en-001",
  "en-TV": "en-001",
  "en-TZ": "en-001",
  "en-UG": "en-001",
  "en-VC": "en-001",
  "en-VG": "en-001",
  "en-VU": "en-001",
  "en-WS": "en-001",
  "en-ZA": "en-001",
  "en-ZM": "en-001",
  "en-ZW": "en-001",
  "en-AT": "en-150",
  "en-BE": "en-150",
  "en-CH": "en-150",
  "en-DE": "en-150",
  "en-DK": "en-150",
  "en-FI": "en-150",
  "en-NL": "en-150",
  "en-SE": "en-150",
  "en-SI": "en-150",
  "hi-Latn": "en-IN",
  "es-AR": "es-419",
  "es-BO": "es-419",
  "es-BR": "es-419",
  "es-BZ": "es-419",
  "es-CL": "es-419",
  "es-CO": "es-419",
  "es-CR": "es-419",
  "es-CU": "es-419",
  "es-DO": "es-419",
  "es-EC": "es-419",
  "es-GT": "es-419",
  "es-HN": "es-419",
  "es-MX": "es-419",
  "es-NI": "es-419",
  "es-PA": "es-419",
  "es-PE": "es-419",
  "es-PR": "es-419",
  "es-PY": "es-419",
  "es-SV": "es-419",
  "es-US": "es-419",
  "es-UY": "es-419",
  "es-VE": "es-419",
  nb: "no",
  nn: "no",
  "pt-AO": "pt-PT",
  "pt-CH": "pt-PT",
  "pt-CV": "pt-PT",
  "pt-FR": "pt-PT",
  "pt-GQ": "pt-PT",
  "pt-GW": "pt-PT",
  "pt-LU": "pt-PT",
  "pt-MO": "pt-PT",
  "pt-MZ": "pt-PT",
  "pt-ST": "pt-PT",
  "pt-TL": "pt-PT",
  "az-Arab": "und",
  "az-Cyrl": "und",
  "bal-Latn": "und",
  "blt-Latn": "und",
  "bm-Nkoo": "und",
  "bs-Cyrl": "und",
  "byn-Latn": "und",
  "cu-Glag": "und",
  "dje-Arab": "und",
  "dyo-Arab": "und",
  "en-Dsrt": "und",
  "en-Shaw": "und",
  "ff-Adlm": "und",
  "ff-Arab": "und",
  "ha-Arab": "und",
  "iu-Latn": "und",
  "kk-Arab": "und",
  "ks-Deva": "und",
  "ku-Arab": "und",
  "ky-Arab": "und",
  "ky-Latn": "und",
  "ml-Arab": "und",
  "mn-Mong": "und",
  "mni-Mtei": "und",
  "ms-Arab": "und",
  "pa-Arab": "und",
  "sat-Deva": "und",
  "sd-Deva": "und",
  "sd-Khoj": "und",
  "sd-Sind": "und",
  "shi-Latn": "und",
  "so-Arab": "und",
  "sr-Latn": "und",
  "sw-Arab": "und",
  "tg-Arab": "und",
  "ug-Cyrl": "und",
  "uz-Arab": "und",
  "uz-Cyrl": "und",
  "vai-Latn": "und",
  "wo-Arab": "und",
  "yo-Arab": "und",
  "yue-Hans": "und",
  "zh-Hant": "und",
  "zh-Hant-MO": "zh-Hant-HK"
};

// node_modules/devextreme/esm/common/core/localization/parentLocale.js
var parentLocale_default = (parentLocales, locale) => {
  const parentLocale = parentLocales[locale];
  if (parentLocale) {
    return "root" !== parentLocale && parentLocale;
  }
  return locale.substr(0, locale.lastIndexOf("-"));
};

// node_modules/devextreme/esm/common/core/localization/core.js
var core_default = dependency_injector_default({
  locale: /* @__PURE__ */ (() => {
    let currentLocale = "en";
    return (locale) => {
      if (!locale) {
        return currentLocale;
      }
      currentLocale = locale;
    };
  })(),
  getValueByClosestLocale: function(getter) {
    let locale = this.locale();
    let value2 = getter(locale);
    let isRootLocale;
    while (!value2 && !isRootLocale) {
      locale = parentLocale_default(parent_locales_default, locale);
      if (locale) {
        value2 = getter(locale);
      } else {
        isRootLocale = true;
      }
    }
    if (void 0 === value2 && "en" !== locale) {
      return getter("en");
    }
    return value2;
  }
});

// node_modules/devextreme/esm/common/core/localization/default_messages.js
var defaultMessages = {
  en: {
    Yes: "Yes",
    No: "No",
    Cancel: "Cancel",
    CheckState: "Check state",
    Close: "Close",
    Clear: "Clear",
    Done: "Done",
    Loading: "Loading...",
    Select: "Select...",
    Search: "Search",
    Back: "Back",
    OK: "OK",
    Today: "Today",
    Yesterday: "Yesterday",
    "dxCollectionWidget-noDataText": "No data to display",
    "dxDropDownEditor-selectLabel": "Select",
    "validation-required": "Required",
    "validation-required-formatted": "{0} is required",
    "validation-numeric": "Value must be a number",
    "validation-numeric-formatted": "{0} must be a number",
    "validation-range": "Value is out of range",
    "validation-range-formatted": "{0} is out of range",
    "validation-stringLength": "The length of the value is not correct",
    "validation-stringLength-formatted": "The length of {0} is not correct",
    "validation-custom": "Value is invalid",
    "validation-custom-formatted": "{0} is invalid",
    "validation-async": "Value is invalid",
    "validation-async-formatted": "{0} is invalid",
    "validation-compare": "Values do not match",
    "validation-compare-formatted": "{0} does not match",
    "validation-pattern": "Value does not match pattern",
    "validation-pattern-formatted": "{0} does not match pattern",
    "validation-email": "Email is invalid",
    "validation-email-formatted": "{0} is invalid",
    "validation-mask": "Value is invalid",
    "dxLookup-searchPlaceholder": "Minimum character number: {0}",
    "dxList-pullingDownText": "Pull down to refresh...",
    "dxList-pulledDownText": "Release to refresh...",
    "dxList-refreshingText": "Refreshing...",
    "dxList-pageLoadingText": "Loading...",
    "dxList-nextButtonText": "More",
    "dxList-selectAll": "Select All",
    "dxList-listAriaLabel": "Items",
    "dxList-listAriaLabel-deletable": "Deletable items",
    "dxListEditDecorator-delete": "Delete",
    "dxListEditDecorator-more": "More",
    "dxList-selectAll-indeterminate": "Half-checked",
    "dxList-selectAll-checked": "Checked",
    "dxList-selectAll-notChecked": "Not checked",
    "dxList-ariaRoleDescription": "List",
    "dxList-listAriaLabel-itemContent": "List item content",
    "dxScrollView-pullingDownText": "Pull down to refresh...",
    "dxScrollView-pulledDownText": "Release to refresh...",
    "dxScrollView-refreshingText": "Refreshing...",
    "dxScrollView-reachBottomText": "Loading...",
    "dxDateBox-simulatedDataPickerTitleTime": "Select time",
    "dxDateBox-simulatedDataPickerTitleDate": "Select date",
    "dxDateBox-simulatedDataPickerTitleDateTime": "Select date and time",
    "dxDateBox-validation-datetime": "Value must be a date or time",
    "dxDateRangeBox-invalidStartDateMessage": "Start value must be a date",
    "dxDateRangeBox-invalidEndDateMessage": "End value must be a date",
    "dxDateRangeBox-startDateOutOfRangeMessage": "Start date is out of range",
    "dxDateRangeBox-endDateOutOfRangeMessage": "End date is out of range",
    "dxDateRangeBox-startDateLabel": "Start Date",
    "dxDateRangeBox-endDateLabel": "End Date",
    "dxFileUploader-selectFile": "Select a file",
    "dxFileUploader-dropFile": "or Drop a file here",
    "dxFileUploader-bytes": "bytes",
    "dxFileUploader-kb": "KB",
    "dxFileUploader-Mb": "MB",
    "dxFileUploader-Gb": "GB",
    "dxFileUploader-upload": "Upload",
    "dxFileUploader-uploaded": "Uploaded",
    "dxFileUploader-readyToUpload": "Ready to upload",
    "dxFileUploader-uploadAbortedMessage": "Upload cancelled",
    "dxFileUploader-uploadFailedMessage": "Upload failed",
    "dxFileUploader-invalidFileExtension": "File type is not allowed",
    "dxFileUploader-invalidMaxFileSize": "File is too large",
    "dxFileUploader-invalidMinFileSize": "File is too small",
    "dxRangeSlider-ariaFrom": "From",
    "dxRangeSlider-ariaTill": "Till",
    "dxSwitch-switchedOnText": "ON",
    "dxSwitch-switchedOffText": "OFF",
    "dxForm-optionalMark": "optional",
    "dxForm-requiredMessage": "{0} is required",
    "dxNumberBox-invalidValueMessage": "Value must be a number",
    "dxNumberBox-noDataText": "No data",
    "dxDataGrid-emptyHeaderWithColumnChooserText": "Use {0} to display columns",
    "dxDataGrid-emptyHeaderWithGroupPanelText": "Drag a column from the group panel here",
    "dxDataGrid-emptyHeaderWithColumnChooserAndGroupPanelText": "Use {0} or drag a column from the group panel",
    "dxDataGrid-emptyHeaderColumnChooserText": "column chooser",
    "dxDataGrid-columnChooserTitle": "Column Chooser",
    "dxDataGrid-columnChooserEmptyText": "Drag a column here to hide it",
    "dxDataGrid-groupContinuesMessage": "Continues on the next page",
    "dxDataGrid-groupContinuedMessage": "Continued from the previous page",
    "dxDataGrid-groupHeaderText": "Group by This Column",
    "dxDataGrid-ungroupHeaderText": "Ungroup",
    "dxDataGrid-ungroupAllText": "Ungroup All",
    "dxDataGrid-editingEditRow": "Edit",
    "dxDataGrid-editingSaveRowChanges": "Save",
    "dxDataGrid-editingCancelRowChanges": "Cancel",
    "dxDataGrid-editingDeleteRow": "Delete",
    "dxDataGrid-editingUndeleteRow": "Undelete",
    "dxDataGrid-editingConfirmDeleteMessage": "Are you sure you want to delete this record?",
    "dxDataGrid-validationCancelChanges": "Cancel changes",
    "dxDataGrid-groupPanelEmptyText": "Drag a column header here to group by that column",
    "dxDataGrid-noDataText": "No data",
    "dxDataGrid-searchPanelPlaceholder": "Search...",
    "dxDataGrid-filterRowShowAllText": "(All)",
    "dxDataGrid-filterRowResetOperationText": "Reset",
    "dxDataGrid-filterRowOperationEquals": "Equals",
    "dxDataGrid-filterRowOperationNotEquals": "Does not equal",
    "dxDataGrid-filterRowOperationLess": "Less than",
    "dxDataGrid-filterRowOperationLessOrEquals": "Less than or equal to",
    "dxDataGrid-filterRowOperationGreater": "Greater than",
    "dxDataGrid-filterRowOperationGreaterOrEquals": "Greater than or equal to",
    "dxDataGrid-filterRowOperationStartsWith": "Starts with",
    "dxDataGrid-filterRowOperationContains": "Contains",
    "dxDataGrid-filterRowOperationNotContains": "Does not contain",
    "dxDataGrid-filterRowOperationEndsWith": "Ends with",
    "dxDataGrid-filterRowOperationBetween": "Between",
    "dxDataGrid-filterRowOperationBetweenStartText": "Start",
    "dxDataGrid-filterRowOperationBetweenEndText": "End",
    "dxDataGrid-ariaSearchBox": "Search box",
    "dxDataGrid-applyFilterText": "Apply filter",
    "dxDataGrid-trueText": "true",
    "dxDataGrid-falseText": "false",
    "dxDataGrid-sortingAscendingText": "Sort Ascending",
    "dxDataGrid-sortingDescendingText": "Sort Descending",
    "dxDataGrid-sortingClearText": "Clear Sorting",
    "dxDataGrid-ariaNotSortedColumn": "Not sorted column",
    "dxDataGrid-ariaSortedAscendingColumn": "Column sorted in ascending order",
    "dxDataGrid-ariaSortedDescendingColumn": "Column sorted in descending order",
    "dxDataGrid-ariaSortIndex": "Sort index {0}",
    "dxDataGrid-editingSaveAllChanges": "Save changes",
    "dxDataGrid-editingCancelAllChanges": "Discard changes",
    "dxDataGrid-editingAddRow": "Add a row",
    "dxDataGrid-summaryMin": "Min: {0}",
    "dxDataGrid-summaryMinOtherColumn": "Min of {1} is {0}",
    "dxDataGrid-summaryMax": "Max: {0}",
    "dxDataGrid-summaryMaxOtherColumn": "Max of {1} is {0}",
    "dxDataGrid-summaryAvg": "Avg: {0}",
    "dxDataGrid-summaryAvgOtherColumn": "Avg of {1} is {0}",
    "dxDataGrid-summarySum": "Sum: {0}",
    "dxDataGrid-summarySumOtherColumn": "Sum of {1} is {0}",
    "dxDataGrid-summaryCount": "Count: {0}",
    "dxDataGrid-columnFixingFix": "Set Fixed Position",
    "dxDataGrid-columnFixingUnfix": "Unfix",
    "dxDataGrid-columnFixingLeftPosition": "Left",
    "dxDataGrid-columnFixingRightPosition": "Right",
    "dxDataGrid-columnFixingStickyPosition": "Sticky",
    "dxDataGrid-exportTo": "Export",
    "dxDataGrid-exportToExcel": "Export to Excel file",
    "dxDataGrid-exporting": "Exporting...",
    "dxDataGrid-excelFormat": "Excel file",
    "dxDataGrid-selectedRows": "Selected rows",
    "dxDataGrid-exportSelectedRows": "Export selected rows to {0}",
    "dxDataGrid-exportAll": "Export all data to {0}",
    "dxDataGrid-headerFilterLabel": "Filter options",
    "dxDataGrid-headerFilterIndicatorLabel": "Show filter options for column '{0}'",
    "dxDataGrid-headerFilterEmptyValue": "(Blanks)",
    "dxDataGrid-headerFilterOK": "OK",
    "dxDataGrid-headerFilterCancel": "Cancel",
    "dxDataGrid-ariaAdaptiveCollapse": "Hide additional data",
    "dxDataGrid-ariaAdaptiveExpand": "Display additional data",
    "dxDataGrid-ariaColumn": "Column",
    "dxDataGrid-ariaColumnHeader": "Column header",
    "dxDataGrid-ariaValue": "Value",
    "dxDataGrid-ariaError": "Error",
    "dxDataGrid-ariaRevertButton": "Press Escape to discard the changes",
    "dxDataGrid-ariaFilterCell": "Filter cell",
    "dxDataGrid-ariaCollapse": "Collapse",
    "dxDataGrid-ariaModifiedCell": "Modified",
    "dxDataGrid-ariaDeletedCell": "Deleted",
    "dxDataGrid-ariaEditableCell": "Editable",
    "dxDataGrid-ariaExpand": "Expand",
    "dxDataGrid-ariaCollapsedRow": "Collapsed row",
    "dxDataGrid-ariaExpandedRow": "Expanded row",
    "dxDataGrid-ariaDataGrid": "Data grid with {0} rows and {1} columns",
    "dxDataGrid-ariaSearchInGrid": "Search in the data grid",
    "dxDataGrid-ariaSelectAll": "Select all",
    "dxDataGrid-ariaSelectRow": "Select row",
    "dxDataGrid-ariaToolbar": "Data grid toolbar",
    "dxDataGrid-ariaEditForm": "Edit form",
    "dxDataGrid-filterBuilderPopupTitle": "Filter Builder",
    "dxDataGrid-filterPanelCreateFilter": "Create Filter",
    "dxDataGrid-filterPanelClearFilter": "Clear",
    "dxDataGrid-filterPanelFilterEnabledHint": "Enable the filter",
    "dxDataGrid-masterDetail": "Cell with details",
    "dxDataGrid-moveColumnToTheRight": "Move to the right",
    "dxDataGrid-moveColumnToTheLeft": "Move to the left",
    "dxTreeList-ariaTreeList": "Tree list with {0} rows and {1} columns",
    "dxTreeList-ariaExpandableInstruction": "Press Ctrl + right arrow to expand the focused node and Ctrl + left arrow to collapse it",
    "dxTreeList-ariaSearchInGrid": "Search in the tree list",
    "dxTreeList-ariaToolbar": "Tree list toolbar",
    "dxTreeList-editingAddRowToNode": "Add",
    "dxPager-infoText": "Page {0} of {1} ({2} items)",
    "dxPager-pagesCountText": "of",
    "dxPager-pageSize": "Items per page: {0}",
    "dxPager-pageSizesAllText": "All",
    "dxPager-page": "Page {0}",
    "dxPager-prevPage": "Previous page",
    "dxPager-nextPage": "Next page",
    "dxPager-ariaLabel": "Page navigation",
    "dxPager-ariaPageSize": "Page size",
    "dxPager-ariaPageNumber": "Page number",
    "dxPagination-infoText": "Page {0} of {1} ({2} items)",
    "dxPagination-pagesCountText": "of",
    "dxPagination-pageSize": "Items per page: {0}",
    "dxPagination-pageSizesAllText": "All",
    "dxPagination-page": "Page {0}",
    "dxPagination-prevPage": "Previous page",
    "dxPagination-nextPage": "Next page",
    "dxPagination-ariaLabel": "Page navigation",
    "dxPagination-ariaPageSize": "Page size",
    "dxPagination-ariaPageNumber": "Page number",
    "dxPivotGrid-grandTotal": "Grand Total",
    "dxPivotGrid-total": "{0} Total",
    "dxPivotGrid-fieldChooserTitle": "Field Chooser",
    "dxPivotGrid-showFieldChooser": "Show Field Chooser",
    "dxPivotGrid-expandAll": "Expand All",
    "dxPivotGrid-collapseAll": "Collapse All",
    "dxPivotGrid-sortColumnBySummary": 'Sort "{0}" by This Column',
    "dxPivotGrid-sortRowBySummary": 'Sort "{0}" by This Row',
    "dxPivotGrid-removeAllSorting": "Remove All Sorting",
    "dxPivotGrid-dataNotAvailable": "N/A",
    "dxPivotGrid-rowFields": "Row Fields",
    "dxPivotGrid-columnFields": "Column Fields",
    "dxPivotGrid-dataFields": "Data Fields",
    "dxPivotGrid-filterFields": "Filter Fields",
    "dxPivotGrid-allFields": "All Fields",
    "dxPivotGrid-columnFieldArea": "Drop Column Fields Here",
    "dxPivotGrid-dataFieldArea": "Drop Data Fields Here",
    "dxPivotGrid-rowFieldArea": "Drop Row Fields Here",
    "dxPivotGrid-filterFieldArea": "Drop Filter Fields Here",
    "dxScheduler-dateRange": "from {0} to {1}",
    "dxScheduler-ariaLabel": "Scheduler. {0} view: {1} with {2} appointments",
    "dxScheduler-ariaLabel-currentIndicator-present": "The current time indicator is visible in the view",
    "dxScheduler-ariaLabel-currentIndicator-not-present": "The current time indicator is not visible on the screen",
    "dxScheduler-appointmentAriaLabel-group": "Group: {0}",
    "dxScheduler-appointmentAriaLabel-recurring": "Recurring appointment",
    "dxScheduler-appointmentListAriaLabel": "Appointment list",
    "dxScheduler-editorLabelTitle": "Subject",
    "dxScheduler-editorLabelStartDate": "Start Date",
    "dxScheduler-editorLabelEndDate": "End Date",
    "dxScheduler-editorLabelDescription": "Description",
    "dxScheduler-editorLabelRecurrence": "Repeat",
    "dxScheduler-navigationToday": "Today",
    "dxScheduler-navigationPrevious": "Previous page",
    "dxScheduler-navigationNext": "Next page",
    "dxScheduler-openAppointment": "Open appointment",
    "dxScheduler-recurrenceNever": "Never",
    "dxScheduler-recurrenceMinutely": "Every minute",
    "dxScheduler-recurrenceHourly": "Hourly",
    "dxScheduler-recurrenceDaily": "Daily",
    "dxScheduler-recurrenceWeekly": "Weekly",
    "dxScheduler-recurrenceMonthly": "Monthly",
    "dxScheduler-recurrenceYearly": "Yearly",
    "dxScheduler-recurrenceRepeatEvery": "Repeat Every",
    "dxScheduler-recurrenceRepeatOn": "Repeat On",
    "dxScheduler-recurrenceEnd": "End repeat",
    "dxScheduler-recurrenceAfter": "After",
    "dxScheduler-recurrenceOn": "On",
    "dxScheduler-recurrenceUntilDateLabel": "Date when repeat ends",
    "dxScheduler-recurrenceOccurrenceLabel": "Number of occurrences",
    "dxScheduler-recurrenceRepeatMinutely": "minute(s)",
    "dxScheduler-recurrenceRepeatHourly": "hour(s)",
    "dxScheduler-recurrenceRepeatDaily": "day(s)",
    "dxScheduler-recurrenceRepeatWeekly": "week(s)",
    "dxScheduler-recurrenceRepeatMonthly": "month(s)",
    "dxScheduler-recurrenceRepeatYearly": "year(s)",
    "dxScheduler-switcherDay": "Day",
    "dxScheduler-switcherWeek": "Week",
    "dxScheduler-switcherWorkWeek": "Work Week",
    "dxScheduler-switcherMonth": "Month",
    "dxScheduler-switcherAgenda": "Agenda",
    "dxScheduler-switcherTimelineDay": "Timeline Day",
    "dxScheduler-switcherTimelineWeek": "Timeline Week",
    "dxScheduler-switcherTimelineWorkWeek": "Timeline Work Week",
    "dxScheduler-switcherTimelineMonth": "Timeline Month",
    "dxScheduler-recurrenceRepeatOnDate": "on date",
    "dxScheduler-recurrenceRepeatCount": "occurrence(s)",
    "dxScheduler-allDay": "All day",
    "dxScheduler-ariaEditForm": "Edit form",
    "dxScheduler-confirmRecurrenceEditTitle": "Edit Recurring Appointment",
    "dxScheduler-confirmRecurrenceDeleteTitle": "Delete Recurring Appointment",
    "dxScheduler-confirmRecurrenceEditMessage": "Do you want to edit only this appointment or the whole series?",
    "dxScheduler-confirmRecurrenceDeleteMessage": "Do you want to delete only this appointment or the whole series?",
    "dxScheduler-confirmRecurrenceEditSeries": "Edit series",
    "dxScheduler-confirmRecurrenceDeleteSeries": "Delete series",
    "dxScheduler-confirmRecurrenceEditOccurrence": "Edit appointment",
    "dxScheduler-confirmRecurrenceDeleteOccurrence": "Delete appointment",
    "dxScheduler-noTimezoneTitle": "No timezone",
    "dxScheduler-moreAppointments": "{0} more",
    "dxCalendar-currentDay": "Today",
    "dxCalendar-currentMonth": "Current month",
    "dxCalendar-currentYear": "Current year",
    "dxCalendar-currentYearRange": "Current year range",
    "dxCalendar-todayButtonText": "Today",
    "dxCalendar-ariaWidgetName": "Calendar",
    "dxCalendar-previousMonthButtonLabel": "Previous month",
    "dxCalendar-previousYearButtonLabel": "Previous year",
    "dxCalendar-previousDecadeButtonLabel": "Previous decade",
    "dxCalendar-previousCenturyButtonLabel": "Previous century",
    "dxCalendar-nextMonthButtonLabel": "Next month",
    "dxCalendar-nextYearButtonLabel": "Next year",
    "dxCalendar-nextDecadeButtonLabel": "Next decade",
    "dxCalendar-nextCenturyButtonLabel": "Next century",
    "dxCalendar-captionMonthLabel": "Month selection",
    "dxCalendar-captionYearLabel": "Year selection",
    "dxCalendar-captionDecadeLabel": "Decade selection",
    "dxCalendar-captionCenturyLabel": "Century selection",
    "dxCalendar-selectedDate": "The selected date is {0}",
    "dxCalendar-selectedDates": "The selected dates",
    "dxCalendar-selectedDateRange": "The selected date range is from {0} to {1}",
    "dxCalendar-selectedMultipleDateRange": "from {0} to {1}",
    "dxCalendar-selectedDateRangeCount": "There are {0} selected date ranges",
    "dxCalendar-readOnlyLabel": "Read-only calendar",
    "dxCardView-ariaSearchInGrid": "Search in the card view",
    "dxCardView-ariaHeaderItemLabel": "Field name {0}",
    "dxCardView-ariaHeaderItemSortingAscendingLabel": "Sorted in ascending order",
    "dxCardView-ariaHeaderItemSortingDescendingLabel": "Sorted in descending order",
    "dxCardView-ariaHeaderItemSortingIndexLabel": "Sort index {0}",
    "dxCardView-ariaHeaderHasHeaderFilterLabel": "Header filter applied",
    "dxCardView-ariaSelectCard": "Select card",
    "dxCardView-ariaCardView": "Card view with {0} cards. Each card has {1} fields",
    "dxCardView-ariaCard": "Card",
    "dxCardView-ariaEditableCard": "Editable card",
    "dxCardView-ariaCardPosition": "Row {0}, column {1}",
    "dxCardView-ariaSelectedCardState": "Selected",
    "dxCardView-ariaNotSelectedCardState": "Not selected",
    "dxCardView-selectAll": "Select all",
    "dxCardView-clearSelection": "Clear selection",
    "dxCardView-cardNoImageAriaLabel": "No image",
    "dxCardView-headerItemDropZoneText": "Drop the header item here",
    "dxCardView-emptyHeaderPanelText": "Use {0} to display columns",
    "dxCardView-emptyHeaderPanelColumnChooserText": "column chooser",
    "dxAvatar-defaultImageAlt": "Avatar",
    "dxChat-elementAriaLabel": "Chat",
    "dxChat-textareaPlaceholder": "Type a message",
    "dxChat-sendButtonAriaLabel": "Send",
    "dxChat-cancelEditingButtonAriaLabel": "Cancel",
    "dxChat-editingMessageCaption": "Edit Message",
    "dxChat-defaultUserName": "Unknown User",
    "dxChat-messageListAriaLabel": "Message list",
    "dxChat-alertListAriaLabel": "Error list",
    "dxChat-emptyListMessage": "There are no messages in this chat",
    "dxChat-emptyListPrompt": "Write your first message",
    "dxChat-typingMessageSingleUser": "{0} is typing...",
    "dxChat-typingMessageTwoUsers": "{0} and {1} are typing...",
    "dxChat-typingMessageThreeUsers": "{0}, {1} and {2} are typing...",
    "dxChat-typingMessageMultipleUsers": "{0} and others are typing...",
    "dxChat-editedMessageText": "Edited",
    "dxChat-editingEditMessage": "Edit",
    "dxChat-editingDeleteMessage": "Delete",
    "dxChat-editingDeleteConfirmText": "Are you sure you want to delete this message?",
    "dxChat-deletedMessageText": "This message was deleted",
    "dxChat-defaultImageAlt": "Image shared in chat",
    "dxColorView-ariaRed": "Red",
    "dxColorView-ariaGreen": "Green",
    "dxColorView-ariaBlue": "Blue",
    "dxColorView-ariaAlpha": "Transparency",
    "dxColorView-ariaHex": "Color code",
    "dxTagBox-selected": "{0} selected",
    "dxTagBox-allSelected": "All selected ({0})",
    "dxTagBox-moreSelected": "{0} more",
    "dxTagBox-tagRoleDescription": "Tag. Press the delete button to remove this tag",
    "dxTagBox-ariaRoleDescription": "Tag box",
    "vizExport-printingButtonText": "Print",
    "vizExport-titleMenuText": "Exporting/Printing",
    "vizExport-exportButtonText": "{0} file",
    "dxFilterBuilder-and": "And",
    "dxFilterBuilder-or": "Or",
    "dxFilterBuilder-notAnd": "Not And",
    "dxFilterBuilder-notOr": "Not Or",
    "dxFilterBuilder-addCondition": "Add Condition",
    "dxFilterBuilder-addGroup": "Add Group",
    "dxFilterBuilder-enterValueText": "<enter a value>",
    "dxFilterBuilder-filterOperationEquals": "Equals",
    "dxFilterBuilder-filterOperationNotEquals": "Does not equal",
    "dxFilterBuilder-filterOperationLess": "Is less than",
    "dxFilterBuilder-filterOperationLessOrEquals": "Is less than or equal to",
    "dxFilterBuilder-filterOperationGreater": "Is greater than",
    "dxFilterBuilder-filterOperationGreaterOrEquals": "Is greater than or equal to",
    "dxFilterBuilder-filterOperationStartsWith": "Starts with",
    "dxFilterBuilder-filterOperationContains": "Contains",
    "dxFilterBuilder-filterOperationNotContains": "Does not contain",
    "dxFilterBuilder-filterOperationEndsWith": "Ends with",
    "dxFilterBuilder-filterOperationIsBlank": "Is blank",
    "dxFilterBuilder-filterOperationIsNotBlank": "Is not blank",
    "dxFilterBuilder-filterOperationBetween": "Is between",
    "dxFilterBuilder-filterOperationAnyOf": "Is any of",
    "dxFilterBuilder-filterOperationNoneOf": "Is none of",
    "dxFilterBuilder-filterAriaRootElement": "Filter builder",
    "dxFilterBuilder-filterAriaGroupLevel": "Level {0}",
    "dxFilterBuilder-filterAriaGroupItem": "Group item",
    "dxFilterBuilder-filterAriaOperationButton": "Operation",
    "dxFilterBuilder-filterAriaAddButton": "Add",
    "dxFilterBuilder-filterAriaRemoveButton": "Remove {0}",
    "dxFilterBuilder-filterAriaItemField": "Item field",
    "dxFilterBuilder-filterAriaItemOperation": "Item operation",
    "dxFilterBuilder-filterAriaItemValue": "Item value",
    "dxHtmlEditor-dialogColorCaption": "Change Font Color",
    "dxHtmlEditor-dialogBackgroundCaption": "Change Background Color",
    "dxHtmlEditor-dialogLinkCaption": "Add Link",
    "dxHtmlEditor-dialogLinkUrlField": "URL",
    "dxHtmlEditor-dialogLinkTextField": "Text",
    "dxHtmlEditor-dialogLinkTargetField": "Open link in new window",
    "dxHtmlEditor-dialogImageCaption": "Add Image",
    "dxHtmlEditor-dialogImageUrlField": "URL",
    "dxHtmlEditor-dialogImageAltField": "Alternate text",
    "dxHtmlEditor-dialogImageWidthField": "Width (px)",
    "dxHtmlEditor-dialogImageHeightField": "Height (px)",
    "dxHtmlEditor-dialogInsertTableRowsField": "Rows",
    "dxHtmlEditor-dialogInsertTableColumnsField": "Columns",
    "dxHtmlEditor-dialogInsertTableCaption": "Insert Table",
    "dxHtmlEditor-dialogUpdateImageCaption": "Update Image",
    "dxHtmlEditor-dialogImageUpdateButton": "Update",
    "dxHtmlEditor-dialogImageAddButton": "Add",
    "dxHtmlEditor-dialogImageSpecifyUrl": "From the Web",
    "dxHtmlEditor-dialogImageSelectFile": "From This Device",
    "dxHtmlEditor-dialogImageKeepAspectRatio": "Keep Aspect Ratio",
    "dxHtmlEditor-dialogImageEncodeToBase64": "Encode to Base64",
    "dxHtmlEditor-heading": "Heading",
    "dxHtmlEditor-normalText": "Normal text",
    "dxHtmlEditor-background": "Background Color",
    "dxHtmlEditor-bold": "Bold",
    "dxHtmlEditor-color": "Font Color",
    "dxHtmlEditor-font": "Font",
    "dxHtmlEditor-italic": "Italic",
    "dxHtmlEditor-link": "Add Link",
    "dxHtmlEditor-image": "Add Image",
    "dxHtmlEditor-size": "Size",
    "dxHtmlEditor-strike": "Strikethrough",
    "dxHtmlEditor-subscript": "Subscript",
    "dxHtmlEditor-superscript": "Superscript",
    "dxHtmlEditor-underline": "Underline",
    "dxHtmlEditor-blockquote": "Blockquote",
    "dxHtmlEditor-header": "Header",
    "dxHtmlEditor-increaseIndent": "Increase Indent",
    "dxHtmlEditor-decreaseIndent": "Decrease Indent",
    "dxHtmlEditor-orderedList": "Ordered List",
    "dxHtmlEditor-bulletList": "Bullet List",
    "dxHtmlEditor-alignLeft": "Align Left",
    "dxHtmlEditor-alignCenter": "Align Center",
    "dxHtmlEditor-alignRight": "Align Right",
    "dxHtmlEditor-alignJustify": "Align Justify",
    "dxHtmlEditor-codeBlock": "Code Block",
    "dxHtmlEditor-variable": "Add Variable",
    "dxHtmlEditor-undo": "Undo",
    "dxHtmlEditor-redo": "Redo",
    "dxHtmlEditor-clear": "Clear Formatting",
    "dxHtmlEditor-insertTable": "Insert Table",
    "dxHtmlEditor-insertHeaderRow": "Insert Header Row",
    "dxHtmlEditor-insertRowAbove": "Insert Row Above",
    "dxHtmlEditor-insertRowBelow": "Insert Row Below",
    "dxHtmlEditor-insertColumnLeft": "Insert Column Left",
    "dxHtmlEditor-insertColumnRight": "Insert Column Right",
    "dxHtmlEditor-deleteColumn": "Delete Column",
    "dxHtmlEditor-deleteRow": "Delete Row",
    "dxHtmlEditor-deleteTable": "Delete Table",
    "dxHtmlEditor-cellProperties": "Cell Properties",
    "dxHtmlEditor-tableProperties": "Table Properties",
    "dxHtmlEditor-insert": "Insert",
    "dxHtmlEditor-delete": "Delete",
    "dxHtmlEditor-border": "Border",
    "dxHtmlEditor-style": "Style",
    "dxHtmlEditor-width": "Width",
    "dxHtmlEditor-height": "Height",
    "dxHtmlEditor-borderColor": "Color",
    "dxHtmlEditor-borderWidth": "Border Width",
    "dxHtmlEditor-tableBackground": "Background",
    "dxHtmlEditor-dimensions": "Dimensions",
    "dxHtmlEditor-alignment": "Alignment",
    "dxHtmlEditor-horizontal": "Horizontal",
    "dxHtmlEditor-vertical": "Vertical",
    "dxHtmlEditor-paddingVertical": "Vertical Padding",
    "dxHtmlEditor-paddingHorizontal": "Horizontal Padding",
    "dxHtmlEditor-pixels": "Pixels",
    "dxHtmlEditor-list": "List",
    "dxHtmlEditor-ordered": "Ordered",
    "dxHtmlEditor-bullet": "Bullet",
    "dxHtmlEditor-align": "Align",
    "dxHtmlEditor-center": "Center",
    "dxHtmlEditor-left": "Left",
    "dxHtmlEditor-right": "Right",
    "dxHtmlEditor-indent": "Indent",
    "dxHtmlEditor-justify": "Justify",
    "dxHtmlEditor-borderStyleNone": "none",
    "dxHtmlEditor-borderStyleHidden": "hidden",
    "dxHtmlEditor-borderStyleDotted": "dotted",
    "dxHtmlEditor-borderStyleDashed": "dashed",
    "dxHtmlEditor-borderStyleSolid": "solid",
    "dxHtmlEditor-borderStyleDouble": "double",
    "dxHtmlEditor-borderStyleGroove": "groove",
    "dxHtmlEditor-borderStyleRidge": "ridge",
    "dxHtmlEditor-borderStyleInset": "inset",
    "dxHtmlEditor-borderStyleOutset": "outset",
    "dxHtmlEditor-aiDialogTitle": "AI Assistant",
    "dxHtmlEditor-aiDialogError": "Something went wrong. Please try again.",
    "dxHtmlEditor-aiDialogCanceled": "Generation canceled",
    "dxHtmlEditor-aiReplace": "Replace",
    "dxHtmlEditor-aiInsertAbove": "Insert above",
    "dxHtmlEditor-aiInsertBelow": "Insert below",
    "dxHtmlEditor-aiCopy": "Copy",
    "dxHtmlEditor-aiRegenerate": "Regenerate",
    "dxHtmlEditor-aiGenerate": "Generate",
    "dxHtmlEditor-aiCancel": "Cancel",
    "dxHtmlEditor-aiToolbarItemAriaLabel": "AI Assistant toolbar item",
    "dxHtmlEditor-aiResultTextAreaAriaLabel": "AI Assistant result",
    "dxHtmlEditor-aiAskPlaceholder": "Ask AI to modify text",
    "dxFileManager-newDirectoryName": "Untitled directory",
    "dxFileManager-rootDirectoryName": "Files",
    "dxFileManager-errorNoAccess": "Access Denied. Operation could not be completed.",
    "dxFileManager-errorDirectoryExistsFormat": "Directory '{0}' already exists.",
    "dxFileManager-errorFileExistsFormat": "File '{0}' already exists.",
    "dxFileManager-errorFileNotFoundFormat": "File '{0}' not found.",
    "dxFileManager-errorDirectoryNotFoundFormat": "Directory '{0}' not found.",
    "dxFileManager-errorWrongFileExtension": "File extension is not allowed.",
    "dxFileManager-errorMaxFileSizeExceeded": "File size exceeds the maximum allowed size.",
    "dxFileManager-errorInvalidSymbols": "This name contains invalid characters.",
    "dxFileManager-errorDefault": "Unspecified error.",
    "dxFileManager-errorDirectoryOpenFailed": "The directory cannot be opened",
    "dxFileManager-commandCreate": "New directory",
    "dxFileManager-commandRename": "Rename",
    "dxFileManager-commandMove": "Move to",
    "dxFileManager-commandCopy": "Copy to",
    "dxFileManager-commandDelete": "Delete",
    "dxFileManager-commandDownload": "Download",
    "dxFileManager-commandUpload": "Upload files",
    "dxFileManager-commandRefresh": "Refresh",
    "dxFileManager-commandThumbnails": "Thumbnails View",
    "dxFileManager-commandDetails": "Details View",
    "dxFileManager-commandClearSelection": "Clear selection",
    "dxFileManager-commandShowNavPane": "Toggle navigation pane",
    "dxFileManager-dialogDirectoryChooserMoveTitle": "Move to",
    "dxFileManager-dialogDirectoryChooserMoveButtonText": "Move",
    "dxFileManager-dialogDirectoryChooserCopyTitle": "Copy to",
    "dxFileManager-dialogDirectoryChooserCopyButtonText": "Copy",
    "dxFileManager-dialogRenameItemTitle": "Rename",
    "dxFileManager-dialogRenameItemButtonText": "Save",
    "dxFileManager-dialogCreateDirectoryTitle": "New directory",
    "dxFileManager-dialogCreateDirectoryButtonText": "Create",
    "dxFileManager-dialogDeleteItemTitle": "Delete",
    "dxFileManager-dialogDeleteItemButtonText": "Delete",
    "dxFileManager-dialogDeleteItemSingleItemConfirmation": "Are you sure you want to delete {0}?",
    "dxFileManager-dialogDeleteItemMultipleItemsConfirmation": "Are you sure you want to delete {0} items?",
    "dxFileManager-dialogButtonCancel": "Cancel",
    "dxFileManager-editingCreateSingleItemProcessingMessage": "Creating a directory inside {0}",
    "dxFileManager-editingCreateSingleItemSuccessMessage": "Created a directory inside {0}",
    "dxFileManager-editingCreateSingleItemErrorMessage": "Directory was not created",
    "dxFileManager-editingCreateCommonErrorMessage": "Directory was not created",
    "dxFileManager-editingRenameSingleItemProcessingMessage": "Renaming an item inside {0}",
    "dxFileManager-editingRenameSingleItemSuccessMessage": "Renamed an item inside {0}",
    "dxFileManager-editingRenameSingleItemErrorMessage": "Item was not renamed",
    "dxFileManager-editingRenameCommonErrorMessage": "Item was not renamed",
    "dxFileManager-editingDeleteSingleItemProcessingMessage": "Deleting an item from {0}",
    "dxFileManager-editingDeleteMultipleItemsProcessingMessage": "Deleting {0} items from {1}",
    "dxFileManager-editingDeleteSingleItemSuccessMessage": "Deleted an item from {0}",
    "dxFileManager-editingDeleteMultipleItemsSuccessMessage": "Deleted {0} items from {1}",
    "dxFileManager-editingDeleteSingleItemErrorMessage": "Item was not deleted",
    "dxFileManager-editingDeleteMultipleItemsErrorMessage": "{0} items were not deleted",
    "dxFileManager-editingDeleteCommonErrorMessage": "Some items were not deleted",
    "dxFileManager-editingMoveSingleItemProcessingMessage": "Moving an item to {0}",
    "dxFileManager-editingMoveMultipleItemsProcessingMessage": "Moving {0} items to {1}",
    "dxFileManager-editingMoveSingleItemSuccessMessage": "Moved an item to {0}",
    "dxFileManager-editingMoveMultipleItemsSuccessMessage": "Moved {0} items to {1}",
    "dxFileManager-editingMoveSingleItemErrorMessage": "Item was not moved",
    "dxFileManager-editingMoveMultipleItemsErrorMessage": "{0} items were not moved",
    "dxFileManager-editingMoveCommonErrorMessage": "Some items were not moved",
    "dxFileManager-editingCopySingleItemProcessingMessage": "Copying an item to {0}",
    "dxFileManager-editingCopyMultipleItemsProcessingMessage": "Copying {0} items to {1}",
    "dxFileManager-editingCopySingleItemSuccessMessage": "Copied an item to {0}",
    "dxFileManager-editingCopyMultipleItemsSuccessMessage": "Copied {0} items to {1}",
    "dxFileManager-editingCopySingleItemErrorMessage": "Item was not copied",
    "dxFileManager-editingCopyMultipleItemsErrorMessage": "{0} items were not copied",
    "dxFileManager-editingCopyCommonErrorMessage": "Some items were not copied",
    "dxFileManager-editingUploadSingleItemProcessingMessage": "Uploading an item to {0}",
    "dxFileManager-editingUploadMultipleItemsProcessingMessage": "Uploading {0} items to {1}",
    "dxFileManager-editingUploadSingleItemSuccessMessage": "Uploaded an item to {0}",
    "dxFileManager-editingUploadMultipleItemsSuccessMessage": "Uploaded {0} items to {1}",
    "dxFileManager-editingUploadSingleItemErrorMessage": "Item was not uploaded",
    "dxFileManager-editingUploadMultipleItemsErrorMessage": "{0} items were not uploaded",
    "dxFileManager-editingUploadCanceledMessage": "Canceled",
    "dxFileManager-editingDownloadSingleItemErrorMessage": "Item was not downloaded",
    "dxFileManager-editingDownloadMultipleItemsErrorMessage": "{0} items were not downloaded",
    "dxFileManager-listDetailsColumnCaptionName": "Name",
    "dxFileManager-listDetailsColumnCaptionDateModified": "Date Modified",
    "dxFileManager-listDetailsColumnCaptionFileSize": "File Size",
    "dxFileManager-listThumbnailsTooltipTextSize": "Size",
    "dxFileManager-listThumbnailsTooltipTextDateModified": "Date Modified",
    "dxFileManager-notificationProgressPanelTitle": "Progress",
    "dxFileManager-notificationProgressPanelEmptyListText": "No operations",
    "dxFileManager-notificationProgressPanelOperationCanceled": "Canceled",
    "dxDiagram-categoryGeneral": "General",
    "dxDiagram-categoryFlowchart": "Flowchart",
    "dxDiagram-categoryOrgChart": "Org Chart",
    "dxDiagram-categoryContainers": "Containers",
    "dxDiagram-categoryCustom": "Custom",
    "dxDiagram-commandExportToSvg": "Export to SVG",
    "dxDiagram-commandExportToPng": "Export to PNG",
    "dxDiagram-commandExportToJpg": "Export to JPEG",
    "dxDiagram-commandUndo": "Undo",
    "dxDiagram-commandRedo": "Redo",
    "dxDiagram-commandFontName": "Font Name",
    "dxDiagram-commandFontSize": "Font Size",
    "dxDiagram-commandBold": "Bold",
    "dxDiagram-commandItalic": "Italic",
    "dxDiagram-commandUnderline": "Underline",
    "dxDiagram-commandTextColor": "Font Color",
    "dxDiagram-commandLineColor": "Line Color",
    "dxDiagram-commandLineWidth": "Line Width",
    "dxDiagram-commandLineStyle": "Line Style",
    "dxDiagram-commandLineStyleSolid": "Solid",
    "dxDiagram-commandLineStyleDotted": "Dotted",
    "dxDiagram-commandLineStyleDashed": "Dashed",
    "dxDiagram-commandFillColor": "Fill Color",
    "dxDiagram-commandAlignLeft": "Align Left",
    "dxDiagram-commandAlignCenter": "Align Center",
    "dxDiagram-commandAlignRight": "Align Right",
    "dxDiagram-commandConnectorLineType": "Connector Line Type",
    "dxDiagram-commandConnectorLineStraight": "Straight",
    "dxDiagram-commandConnectorLineOrthogonal": "Orthogonal",
    "dxDiagram-commandConnectorLineStart": "Connector Line Start",
    "dxDiagram-commandConnectorLineEnd": "Connector Line End",
    "dxDiagram-commandConnectorLineNone": "None",
    "dxDiagram-commandConnectorLineArrow": "Arrow",
    "dxDiagram-commandFullscreen": "Full Screen",
    "dxDiagram-commandUnits": "Units",
    "dxDiagram-commandPageSize": "Page Size",
    "dxDiagram-commandPageOrientation": "Page Orientation",
    "dxDiagram-commandPageOrientationLandscape": "Landscape",
    "dxDiagram-commandPageOrientationPortrait": "Portrait",
    "dxDiagram-commandPageColor": "Page Color",
    "dxDiagram-commandShowGrid": "Show Grid",
    "dxDiagram-commandSnapToGrid": "Snap to Grid",
    "dxDiagram-commandGridSize": "Grid Size",
    "dxDiagram-commandZoomLevel": "Zoom Level",
    "dxDiagram-commandAutoZoom": "Auto Zoom",
    "dxDiagram-commandFitToContent": "Fit to Content",
    "dxDiagram-commandFitToWidth": "Fit to Width",
    "dxDiagram-commandAutoZoomByContent": "Auto Zoom by Content",
    "dxDiagram-commandAutoZoomByWidth": "Auto Zoom by Width",
    "dxDiagram-commandSimpleView": "Simple View",
    "dxDiagram-commandCut": "Cut",
    "dxDiagram-commandCopy": "Copy",
    "dxDiagram-commandPaste": "Paste",
    "dxDiagram-commandSelectAll": "Select All",
    "dxDiagram-commandDelete": "Delete",
    "dxDiagram-commandBringToFront": "Bring to Front",
    "dxDiagram-commandSendToBack": "Send to Back",
    "dxDiagram-commandLock": "Lock",
    "dxDiagram-commandUnlock": "Unlock",
    "dxDiagram-commandInsertShapeImage": "Insert Image...",
    "dxDiagram-commandEditShapeImage": "Change Image...",
    "dxDiagram-commandDeleteShapeImage": "Delete Image",
    "dxDiagram-commandLayoutLeftToRight": "Left-to-right",
    "dxDiagram-commandLayoutRightToLeft": "Right-to-left",
    "dxDiagram-commandLayoutTopToBottom": "Top-to-bottom",
    "dxDiagram-commandLayoutBottomToTop": "Bottom-to-top",
    "dxDiagram-unitIn": "in",
    "dxDiagram-unitCm": "cm",
    "dxDiagram-unitPx": "px",
    "dxDiagram-dialogButtonOK": "OK",
    "dxDiagram-dialogButtonCancel": "Cancel",
    "dxDiagram-dialogInsertShapeImageTitle": "Insert Image",
    "dxDiagram-dialogEditShapeImageTitle": "Change Image",
    "dxDiagram-dialogEditShapeImageSelectButton": "Select image",
    "dxDiagram-dialogEditShapeImageLabelText": "or drop a file here",
    "dxDiagram-uiExport": "Export",
    "dxDiagram-uiProperties": "Properties",
    "dxDiagram-uiSettings": "Settings",
    "dxDiagram-uiShowToolbox": "Show Toolbox",
    "dxDiagram-uiSearch": "Search",
    "dxDiagram-uiStyle": "Style",
    "dxDiagram-uiLayout": "Layout",
    "dxDiagram-uiLayoutTree": "Tree",
    "dxDiagram-uiLayoutLayered": "Layered",
    "dxDiagram-uiDiagram": "Diagram",
    "dxDiagram-uiText": "Text",
    "dxDiagram-uiObject": "Object",
    "dxDiagram-uiConnector": "Connector",
    "dxDiagram-uiPage": "Page",
    "dxDiagram-shapeText": "Text",
    "dxDiagram-shapeRectangle": "Rectangle",
    "dxDiagram-shapeEllipse": "Ellipse",
    "dxDiagram-shapeCross": "Cross",
    "dxDiagram-shapeTriangle": "Triangle",
    "dxDiagram-shapeDiamond": "Diamond",
    "dxDiagram-shapeHeart": "Heart",
    "dxDiagram-shapePentagon": "Pentagon",
    "dxDiagram-shapeHexagon": "Hexagon",
    "dxDiagram-shapeOctagon": "Octagon",
    "dxDiagram-shapeStar": "Star",
    "dxDiagram-shapeArrowLeft": "Left Arrow",
    "dxDiagram-shapeArrowUp": "Up Arrow",
    "dxDiagram-shapeArrowRight": "Right Arrow",
    "dxDiagram-shapeArrowDown": "Down Arrow",
    "dxDiagram-shapeArrowUpDown": "Up Down Arrow",
    "dxDiagram-shapeArrowLeftRight": "Left Right Arrow",
    "dxDiagram-shapeProcess": "Process",
    "dxDiagram-shapeDecision": "Decision",
    "dxDiagram-shapeTerminator": "Terminator",
    "dxDiagram-shapePredefinedProcess": "Predefined Process",
    "dxDiagram-shapeDocument": "Document",
    "dxDiagram-shapeMultipleDocuments": "Multiple Documents",
    "dxDiagram-shapeManualInput": "Manual Input",
    "dxDiagram-shapePreparation": "Preparation",
    "dxDiagram-shapeData": "Data",
    "dxDiagram-shapeDatabase": "Database",
    "dxDiagram-shapeHardDisk": "Hard Disk",
    "dxDiagram-shapeInternalStorage": "Internal Storage",
    "dxDiagram-shapePaperTape": "Paper Tape",
    "dxDiagram-shapeManualOperation": "Manual Operation",
    "dxDiagram-shapeDelay": "Delay",
    "dxDiagram-shapeStoredData": "Stored Data",
    "dxDiagram-shapeDisplay": "Display",
    "dxDiagram-shapeMerge": "Merge",
    "dxDiagram-shapeConnector": "Connector",
    "dxDiagram-shapeOr": "Or",
    "dxDiagram-shapeSummingJunction": "Summing Junction",
    "dxDiagram-shapeContainerDefaultText": "Container",
    "dxDiagram-shapeVerticalContainer": "Vertical Container",
    "dxDiagram-shapeHorizontalContainer": "Horizontal Container",
    "dxDiagram-shapeCardDefaultText": "Person's Name",
    "dxDiagram-shapeCardWithImageOnLeft": "Card with Image on the Left",
    "dxDiagram-shapeCardWithImageOnTop": "Card with Image on the Top",
    "dxDiagram-shapeCardWithImageOnRight": "Card with Image on the Right",
    "dxGantt-dialogTitle": "Title",
    "dxGantt-dialogStartTitle": "Start",
    "dxGantt-dialogEndTitle": "End",
    "dxGantt-dialogProgressTitle": "Progress",
    "dxGantt-dialogResourcesTitle": "Resources",
    "dxGantt-dialogResourceManagerTitle": "Resource Manager",
    "dxGantt-dialogTaskDetailsTitle": "Task Details",
    "dxGantt-dialogEditResourceListHint": "Edit Resource List",
    "dxGantt-dialogEditNoResources": "No resources",
    "dxGantt-dialogButtonAdd": "Add",
    "dxGantt-contextMenuNewTask": "New Task",
    "dxGantt-contextMenuNewSubtask": "New Subtask",
    "dxGantt-contextMenuDeleteTask": "Delete Task",
    "dxGantt-contextMenuDeleteDependency": "Delete Dependency",
    "dxGantt-dialogTaskDeleteConfirmation": "Deleting a task also deletes all its dependencies and subtasks. Are you sure you want to delete this task?",
    "dxGantt-dialogDependencyDeleteConfirmation": "Are you sure you want to delete the dependency from the task?",
    "dxGantt-dialogResourcesDeleteConfirmation": "Deleting a resource also deletes it from tasks to which this resource is assigned. Are you sure you want to delete these resources? Resources: {0}",
    "dxGantt-dialogConstraintCriticalViolationMessage": "The task you are attempting to move is linked to a second task by a dependency relation. This change would conflict with dependency rules. How would you like to proceed?",
    "dxGantt-dialogConstraintViolationMessage": "The task you are attempting to move is linked to a second task by a dependency relation. How would you like to proceed?",
    "dxGantt-dialogCancelOperationMessage": "Cancel the operation",
    "dxGantt-dialogDeleteDependencyMessage": "Delete the dependency",
    "dxGantt-dialogMoveTaskAndKeepDependencyMessage": "Move the task and keep the dependency",
    "dxGantt-dialogConstraintCriticalViolationSeveralTasksMessage": "The task you are attempting to move is linked to another tasks by dependency relations. This change would conflict with dependency rules. How would you like to proceed?",
    "dxGantt-dialogConstraintViolationSeveralTasksMessage": "The task you are attempting to move is linked to another tasks by dependency relations. How would you like to proceed?",
    "dxGantt-dialogDeleteDependenciesMessage": "Delete the dependency relations",
    "dxGantt-dialogMoveTaskAndKeepDependenciesMessage": "Move the task and keep the dependencies",
    "dxGantt-undo": "Undo",
    "dxGantt-redo": "Redo",
    "dxGantt-expandAll": "Expand All",
    "dxGantt-collapseAll": "Collapse All",
    "dxGantt-addNewTask": "Add New Task",
    "dxGantt-deleteSelectedTask": "Delete Selected Task",
    "dxGantt-zoomIn": "Zoom In",
    "dxGantt-zoomOut": "Zoom Out",
    "dxGantt-fullScreen": "Full Screen",
    "dxGantt-quarter": "Q{0}",
    "dxGantt-sortingAscendingText": "Sort Ascending",
    "dxGantt-sortingDescendingText": "Sort Descending",
    "dxGantt-sortingClearText": "Clear Sorting",
    "dxGantt-showResources": "Show Resources",
    "dxGantt-showDependencies": "Show Dependencies",
    "dxGantt-dialogStartDateValidation": "Start date must be after {0}",
    "dxGantt-dialogEndDateValidation": "End date must be after {0}",
    "dxGallery-itemName": "Gallery item",
    "dxMultiView-elementAriaRoleDescription": "MultiView",
    "dxMultiView-elementAriaLabel": "Use the arrow keys or swipe to navigate between views",
    "dxMultiView-itemAriaRoleDescription": "View",
    "dxMultiView-itemAriaLabel": "{0} of {1}",
    "dxSplitter-resizeHandleAriaLabel": "Split bar",
    "dxSplitter-resizeHandleAriaRoleDescription": "Separator",
    "dxStepper-optionalMark": "(Optional)"
  }
};

// node_modules/devextreme/esm/common/core/localization/message.js
var baseDictionary = extend(true, {}, defaultMessages);
var getDataByLocale = (localeData, locale) => {
  var _Object$entries$find;
  return localeData[locale] || (null === locale || void 0 === locale ? void 0 : locale.toLowerCase) && (null === (_Object$entries$find = Object.entries(localeData).find((_ref) => {
    let [key] = _ref;
    return key.toLowerCase() === locale.toLowerCase();
  })) || void 0 === _Object$entries$find ? void 0 : _Object$entries$find[1]) || {};
};
var newMessages = {};
var messageLocalization = dependency_injector_default({
  engine: function() {
    return "base";
  },
  _dictionary: baseDictionary,
  load: function(messages) {
    extend(true, this._dictionary, messages);
  },
  _localizablePrefix: "@",
  setup: function(localizablePrefix) {
    this._localizablePrefix = localizablePrefix;
  },
  localizeString: function(text) {
    const that = this;
    const regex = new RegExp("(^|[^a-zA-Z_0-9" + that._localizablePrefix + "-]+)(" + that._localizablePrefix + "{1,2})([a-zA-Z_0-9-]+)", "g");
    const escapeString = that._localizablePrefix + that._localizablePrefix;
    return text.replace(regex, (str, prefix, escape, localizationKey) => {
      const defaultResult = that._localizablePrefix + localizationKey;
      let result2;
      if (escape !== escapeString) {
        result2 = that.format(localizationKey);
      }
      if (!result2) {
        newMessages[localizationKey] = humanize(localizationKey);
      }
      return prefix + (result2 || defaultResult);
    });
  },
  getMessagesByLocales: function() {
    return this._dictionary;
  },
  getDictionary: function(onlyNew) {
    if (onlyNew) {
      return newMessages;
    }
    return extend({}, newMessages, this.getMessagesByLocales()[core_default.locale()]);
  },
  getFormatter: function(key) {
    return this._getFormatterBase(key) || this._getFormatterBase(key, "en");
  },
  _getFormatterBase: function(key, locale) {
    const message = core_default.getValueByClosestLocale((locale2) => getDataByLocale(this._dictionary, locale2)[key]);
    if (message) {
      return function() {
        const args = 1 === arguments.length && Array.isArray(arguments[0]) ? arguments[0].slice(0) : Array.prototype.slice.call(arguments, 0);
        args.unshift(message);
        return format.apply(this, args);
      };
    }
  },
  format: function(key) {
    const formatter = this.getFormatter(key);
    const values = Array.prototype.slice.call(arguments, 1);
    return formatter && formatter.apply(this, values) || "";
  }
});
var message_default = messageLocalization;

// node_modules/devextreme/esm/__internal/core/m_element_data.js
var dataMap = /* @__PURE__ */ new WeakMap();
var strategy;
var strategyChanging = new memorized_callbacks_default();
var beforeCleanDataFunc = function() {
};
var afterCleanDataFunc = function() {
};
var setDataStrategy = function(value2) {
  strategyChanging.fire(value2);
  strategy = value2;
  const {
    cleanData: cleanData2
  } = strategy;
  strategy.cleanData = function(nodes) {
    beforeCleanDataFunc(nodes);
    const result2 = cleanData2.call(this, nodes);
    afterCleanDataFunc(nodes);
    return result2;
  };
};
setDataStrategy({
  data: function() {
    const element = arguments.length <= 0 ? void 0 : arguments[0];
    const key = arguments.length <= 1 ? void 0 : arguments[1];
    const value2 = arguments.length <= 2 ? void 0 : arguments[2];
    if (!element) {
      return;
    }
    let elementData = dataMap.get(element);
    if (!elementData) {
      elementData = {};
      dataMap.set(element, elementData);
    }
    if (void 0 === key) {
      return elementData;
    }
    if (2 === arguments.length) {
      return elementData[key];
    }
    elementData[key] = value2;
    return value2;
  },
  removeData: function(element, key) {
    if (!element) {
      return;
    }
    if (void 0 === key) {
      dataMap.delete(element);
    } else {
      const elementData = dataMap.get(element);
      if (elementData) {
        delete elementData[key];
      }
    }
  },
  cleanData: function(elements) {
    for (let i = 0; i < elements.length; i++) {
      m_events_engine_default.off(elements[i]);
      dataMap.delete(elements[i]);
    }
  }
});
function data() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return strategy.data.apply(this, args);
}
function beforeCleanData(callback) {
  beforeCleanDataFunc = callback;
}
function removeData(element, key) {
  return strategy.removeData.call(this, element, key);
}
function cleanDataRecursive(element, cleanSelf) {
  if (!dom_adapter_default.isElementNode(element)) {
    return;
  }
  const childElements = element.getElementsByTagName("*");
  strategy.cleanData(childElements);
  if (cleanSelf) {
    strategy.cleanData([element]);
  }
}

// node_modules/devextreme/esm/__internal/core/utils/m_html_parser.js
var isTagName = /<([a-z][^/\0>\x20\t\r\n\f]+)/i;
var tagWrappers = {
  default: {
    tagsCount: 0,
    startTags: "",
    endTags: ""
  },
  thead: {
    tagsCount: 1,
    startTags: "<table>",
    endTags: "</table>"
  },
  td: {
    tagsCount: 3,
    startTags: "<table><tbody><tr>",
    endTags: "</tr></tbody></table>"
  },
  col: {
    tagsCount: 2,
    startTags: "<table><colgroup>",
    endTags: "</colgroup></table>"
  },
  tr: {
    tagsCount: 2,
    startTags: "<table><tbody>",
    endTags: "</tbody></table>"
  }
};
tagWrappers.tbody = tagWrappers.colgroup = tagWrappers.caption = tagWrappers.tfoot = tagWrappers.thead;
tagWrappers.th = tagWrappers.td;
var parseHTML = function(html) {
  if ("string" !== typeof html) {
    return null;
  }
  const fragment = dom_adapter_default.createDocumentFragment();
  let container = fragment.appendChild(dom_adapter_default.createElement("div"));
  const tags = isTagName.exec(html);
  const firstRootTag = null === tags || void 0 === tags ? void 0 : tags[1].toLowerCase();
  const tagWrapper = tagWrappers[firstRootTag] || tagWrappers.default;
  container.innerHTML = tagWrapper.startTags + html + tagWrapper.endTags;
  for (let i = 0; i < tagWrapper.tagsCount; i++) {
    container = container.lastChild;
  }
  return [...container.childNodes];
};
var isTablePart = function(html) {
  const tags = isTagName.exec(html);
  return tags && tags[1] in tagWrappers;
};

// node_modules/devextreme/esm/__internal/core/utils/m_size.js
var window3 = getWindow();
var SPECIAL_HEIGHT_VALUES = ["auto", "none", "inherit", "initial"];
var getSizeByStyles = function(elementStyles, styles) {
  let result2 = 0;
  styles.forEach(function(style) {
    result2 += parseFloat(elementStyles[style]) || 0;
  });
  return result2;
};
var getElementBoxParams = function(name2, elementStyles) {
  const beforeName = "width" === name2 ? "Left" : "Top";
  const afterName = "width" === name2 ? "Right" : "Bottom";
  return {
    padding: getSizeByStyles(elementStyles, [`padding${beforeName}`, `padding${afterName}`]),
    border: getSizeByStyles(elementStyles, [`border${beforeName}Width`, `border${afterName}Width`]),
    margin: getSizeByStyles(elementStyles, [`margin${beforeName}`, `margin${afterName}`])
  };
};
var getElementComputedStyle = function(element) {
  var _element$ownerDocumen;
  const view = (null === element || void 0 === element || null === (_element$ownerDocumen = element.ownerDocument) || void 0 === _element$ownerDocumen ? void 0 : _element$ownerDocumen.defaultView) || window3;
  return view.getComputedStyle && view.getComputedStyle(element);
};
var getCSSProperty = function(element, styles, name2, defaultValue) {
  var _element$style;
  return (null === styles || void 0 === styles ? void 0 : styles[name2]) || (null === (_element$style = element.style) || void 0 === _element$style ? void 0 : _element$style[name2]) || defaultValue;
};
var boxIndices = {
  content: 0,
  padding: 1,
  border: 2,
  margin: 3,
  "content-box": 0,
  "border-box": 2
};
var dimensionComponents = {
  width: ["left", "right"],
  height: ["top", "bottom"]
};
function getComponentThickness(elem, dimension, component, styles) {
  const get = (elem2, styles2, field) => parseFloat(getCSSProperty(elem2, styles2, field, "0")) || 0;
  const suffix = "border" === component ? "-width" : "";
  return get(elem, styles, `${component}-${dimensionComponents[dimension][0]}${suffix}`) + get(elem, styles, `${component}-${dimensionComponents[dimension][1]}${suffix}`);
}
var getSize = function(element, dimension, box) {
  const offsetFieldName = "width" === dimension ? "offsetWidth" : "offsetHeight";
  const styles = getElementComputedStyle(element);
  let result2 = getCSSProperty(element, styles, dimension);
  if ("" === result2 || "auto" === result2) {
    result2 = element[offsetFieldName];
  }
  result2 = parseFloat(result2) || 0;
  const currentBox = getCSSProperty(element, styles, "boxSizing", "content-box");
  const targetBox = box || currentBox;
  let targetBoxIndex = boxIndices[targetBox];
  let currentBoxIndex = boxIndices[currentBox];
  if (void 0 === targetBoxIndex || void 0 === currentBoxIndex) {
    throw new Error();
  }
  if (currentBoxIndex === targetBoxIndex) {
    return result2;
  }
  const coeff = Math.sign(targetBoxIndex - currentBoxIndex);
  let padding = false;
  let border = false;
  let margin = false;
  let scrollThickness = false;
  if (1 === coeff) {
    targetBoxIndex += 1;
    currentBoxIndex += 1;
  }
  for (let boxPart = currentBoxIndex; boxPart !== targetBoxIndex; boxPart += coeff) {
    switch (boxPart) {
      case boxIndices.content:
        break;
      case boxIndices.padding:
        padding = coeff * getComponentThickness(element, dimension, "padding", styles);
        break;
      case boxIndices.border:
        border = coeff * getComponentThickness(element, dimension, "border", styles);
        break;
      case boxIndices.margin:
        margin = coeff * getComponentThickness(element, dimension, "margin", styles);
    }
  }
  if (padding || border) {
    const paddingAndBorder = (false === padding ? coeff * getComponentThickness(element, dimension, "padding", styles) : padding) + (false === border ? coeff * getComponentThickness(element, dimension, "border", styles) : border);
    scrollThickness = coeff * Math.max(0, Math.floor(element[offsetFieldName] - result2 - coeff * paddingAndBorder)) || 0;
  }
  return result2 + margin + padding + border + scrollThickness;
};
var getContainerHeight = function(container) {
  return isWindow(container) ? container.innerHeight : container.offsetHeight;
};
var parseHeight = function(value2, container, element) {
  if (value2.indexOf("px") > 0) {
    value2 = parseInt(value2.replace("px", ""));
  } else if (value2.indexOf("%") > 0) {
    value2 = parseInt(value2.replace("%", "")) * getContainerHeight(container) / 100;
  } else if (!isNaN(value2)) {
    value2 = parseInt(value2);
  } else if (value2.indexOf("vh") > 0) {
    value2 = window3.innerHeight / 100 * parseInt(value2.replace("vh", ""));
  } else if (element && value2.indexOf("em") > 0) {
    value2 = parseFloat(value2.replace("em", "")) * parseFloat(window3.getComputedStyle(element).fontSize);
  }
  return value2;
};
var getHeightWithOffset = function(value2, offset2, container) {
  if (!value2) {
    return null;
  }
  if (SPECIAL_HEIGHT_VALUES.includes(value2)) {
    return offset2 ? null : value2;
  }
  if (isString(value2)) {
    value2 = parseHeight(value2, container);
  }
  if (isNumeric(value2)) {
    return Math.max(0, value2 + offset2);
  }
  const operationString = offset2 < 0 ? " - " : " ";
  return `calc(${value2}${operationString}${Math.abs(offset2)}px)`;
};
var addOffsetToMaxHeight = function(value2, offset2, container) {
  const maxHeight = getHeightWithOffset(value2, offset2, container);
  return null !== maxHeight ? maxHeight : "none";
};
var addOffsetToMinHeight = function(value2, offset2, container) {
  const minHeight = getHeightWithOffset(value2, offset2, container);
  return null !== minHeight ? minHeight : 0;
};
var getVerticalOffsets = function(element, withMargins) {
  if (!element) {
    return 0;
  }
  const boxParams = getElementBoxParams("height", window3.getComputedStyle(element));
  return boxParams.padding + boxParams.border + (withMargins ? boxParams.margin : 0);
};
var getVisibleHeight = function(element) {
  if (element) {
    var _element$getBoundingC;
    const boundingClientRect = null === (_element$getBoundingC = element.getBoundingClientRect) || void 0 === _element$getBoundingC ? void 0 : _element$getBoundingC.call(element);
    if (null !== boundingClientRect && void 0 !== boundingClientRect && boundingClientRect.height) {
      return boundingClientRect.height;
    }
  }
  return 0;
};
var implementationsMap = {
  getWidth: function() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return elementSizeHelper("width", ...args);
  },
  setWidth: function() {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    return elementSizeHelper("width", ...args);
  },
  getHeight: function() {
    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      args[_key3] = arguments[_key3];
    }
    return elementSizeHelper("height", ...args);
  },
  setHeight: function() {
    for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
      args[_key4] = arguments[_key4];
    }
    return elementSizeHelper("height", ...args);
  },
  getOuterWidth: function() {
    for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
      args[_key5] = arguments[_key5];
    }
    return elementSizeHelper("outerWidth", ...args);
  },
  setOuterWidth: function() {
    for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
      args[_key6] = arguments[_key6];
    }
    return elementSizeHelper("outerWidth", ...args);
  },
  getOuterHeight: function() {
    for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
      args[_key7] = arguments[_key7];
    }
    return elementSizeHelper("outerHeight", ...args);
  },
  setOuterHeight: function() {
    for (var _len8 = arguments.length, args = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {
      args[_key8] = arguments[_key8];
    }
    return elementSizeHelper("outerHeight", ...args);
  },
  getInnerWidth: function() {
    for (var _len9 = arguments.length, args = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {
      args[_key9] = arguments[_key9];
    }
    return elementSizeHelper("innerWidth", ...args);
  },
  setInnerWidth: function() {
    for (var _len10 = arguments.length, args = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {
      args[_key10] = arguments[_key10];
    }
    return elementSizeHelper("innerWidth", ...args);
  },
  getInnerHeight: function() {
    for (var _len11 = arguments.length, args = new Array(_len11), _key11 = 0; _key11 < _len11; _key11++) {
      args[_key11] = arguments[_key11];
    }
    return elementSizeHelper("innerHeight", ...args);
  },
  setInnerHeight: function() {
    for (var _len12 = arguments.length, args = new Array(_len12), _key12 = 0; _key12 < _len12; _key12++) {
      args[_key12] = arguments[_key12];
    }
    return elementSizeHelper("innerHeight", ...args);
  }
};
function elementSizeHelper(sizeProperty, el, value2) {
  return 2 === arguments.length ? elementSize(el, sizeProperty) : elementSize(el, sizeProperty, value2);
}
var getWidth = (el) => implementationsMap.getWidth(el);
var setWidth = (el, value2) => implementationsMap.setWidth(el, value2);
var getHeight = (el) => implementationsMap.getHeight(el);
var setHeight = (el, value2) => implementationsMap.setHeight(el, value2);
var getOuterWidth = (el, includeMargin) => implementationsMap.getOuterWidth(el, includeMargin || false);
var setOuterWidth = (el, value2) => implementationsMap.setOuterWidth(el, value2);
var getOuterHeight = (el, includeMargin) => implementationsMap.getOuterHeight(el, includeMargin || false);
var setOuterHeight = (el, value2) => implementationsMap.setOuterHeight(el, value2);
var getInnerWidth = (el) => implementationsMap.getInnerWidth(el);
var getInnerHeight = (el) => implementationsMap.getInnerHeight(el);
var elementSize = function(el, sizeProperty, value2) {
  const partialName = sizeProperty.toLowerCase().indexOf("width") >= 0 ? "Width" : "Height";
  const propName = partialName.toLowerCase();
  const isOuter = 0 === sizeProperty.indexOf("outer");
  const isInner = 0 === sizeProperty.indexOf("inner");
  const isGetter = 2 === arguments.length || "boolean" === typeof value2;
  if (isRenderer(el)) {
    if (el.length > 1 && !isGetter) {
      for (let i = 0; i < el.length; i++) {
        elementSize(el[i], sizeProperty, value2);
      }
      return;
    }
    el = el[0];
  }
  if (!el) {
    return;
  }
  if (isWindow(el)) {
    return isOuter ? el[`inner${partialName}`] : dom_adapter_default.getDocumentElement()[`client${partialName}`];
  }
  if (dom_adapter_default.isDocument(el)) {
    const documentElement = dom_adapter_default.getDocumentElement();
    const body = dom_adapter_default.getBody();
    return Math.max(body[`scroll${partialName}`], body[`offset${partialName}`], documentElement[`scroll${partialName}`], documentElement[`offset${partialName}`], documentElement[`client${partialName}`]);
  }
  if (isGetter) {
    let box = "content";
    if (isOuter) {
      box = value2 ? "margin" : "border";
    }
    if (isInner) {
      box = "padding";
    }
    return getSize(el, propName, box);
  }
  if (isNumeric(value2)) {
    const elementStyles = getElementComputedStyle(el);
    const sizeAdjustment = getElementBoxParams(propName, elementStyles);
    const isBorderBox = "border-box" === elementStyles.boxSizing;
    value2 = Number(value2);
    if (isOuter) {
      value2 -= isBorderBox ? 0 : sizeAdjustment.border + sizeAdjustment.padding;
    } else if (isInner) {
      value2 += isBorderBox ? sizeAdjustment.border : -sizeAdjustment.padding;
    } else if (isBorderBox) {
      value2 += sizeAdjustment.border + sizeAdjustment.padding;
    }
  }
  value2 += isNumeric(value2) ? "px" : "";
  dom_adapter_default.setStyle(el, propName, value2);
  return null;
};
var getWindowByElement = (el) => isWindow(el) ? el : el.defaultView;
var getOffset = (el) => {
  if (!el.getClientRects().length) {
    return {
      top: 0,
      left: 0
    };
  }
  const rect = el.getBoundingClientRect();
  const win = getWindowByElement(el.ownerDocument);
  const docElem = el.ownerDocument.documentElement;
  return {
    top: rect.top + win.pageYOffset - docElem.clientTop,
    left: rect.left + win.pageXOffset - docElem.clientLeft
  };
};

// node_modules/devextreme/esm/__internal/core/utils/m_style.js
var jsPrefixes = ["", "Webkit", "Moz", "O", "Ms"];
var cssPrefixes = {
  "": "",
  Webkit: "-webkit-",
  Moz: "-moz-",
  O: "-o-",
  ms: "-ms-"
};
var getStyles = call_once_default(function() {
  return dom_adapter_default.createElement("dx").style;
});
var forEachPrefixes = function(prop, callBack) {
  prop = camelize2(prop, true);
  let result2;
  for (let i = 0, cssPrefixesCount = jsPrefixes.length; i < cssPrefixesCount; i++) {
    const jsPrefix = jsPrefixes[i];
    const prefixedProp = jsPrefix + prop;
    const lowerPrefixedProp = camelize2(prefixedProp);
    result2 = callBack(lowerPrefixedProp, jsPrefix);
    if (void 0 === result2) {
      result2 = callBack(prefixedProp, jsPrefix);
    }
    if (void 0 !== result2) {
      break;
    }
  }
  return result2 || "";
};
var styleProp = function(name2) {
  if (name2 in getStyles()) {
    return name2;
  }
  const originalName = name2;
  name2 = name2.charAt(0).toUpperCase() + name2.substr(1);
  for (let i = 1; i < jsPrefixes.length; i++) {
    const prefixedProp = jsPrefixes[i].toLowerCase() + name2;
    if (prefixedProp in getStyles()) {
      return prefixedProp;
    }
  }
  return originalName;
};
var stylePropPrefix = function(prop) {
  return forEachPrefixes(prop, function(specific, jsPrefix) {
    if (specific in getStyles()) {
      return cssPrefixes[jsPrefix];
    }
  });
};
var pxExceptions = ["fillOpacity", "columnCount", "flexGrow", "flexShrink", "fontWeight", "lineHeight", "opacity", "zIndex", "zoom"];
var normalizeStyleProp = function(prop, value2) {
  if (isNumeric(value2) && !pxExceptions.includes(prop)) {
    value2 += "px";
  }
  return value2;
};
var setDimensionProperty = function(elements, propertyName, value2) {
  if (elements) {
    value2 = isNumeric(value2) ? value2 += "px" : value2;
    for (let i = 0; i < elements.length; ++i) {
      elements[i].style[propertyName] = value2;
    }
  }
};
var setWidth2 = function(elements, value2) {
  setDimensionProperty(elements, "width", value2);
};
var setHeight2 = function(elements, value2) {
  setDimensionProperty(elements, "height", value2);
};
var setStyle = function(element, styleString) {
  let resetStyle = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : true;
  if (resetStyle) {
    const styleList = [].slice.call(element.style);
    styleList.forEach((propertyName) => {
      element.style.removeProperty(propertyName);
    });
  }
  styleString.split(";").forEach((style) => {
    const parts = style.split(":").map((stylePart) => stylePart.trim());
    if (2 === parts.length) {
      const [property, value2] = parts;
      element.style[property] = value2;
    }
  });
};

// node_modules/devextreme/esm/__internal/core/m_renderer_base.js
var window4 = getWindow();
var renderer;
var initRender = function(selector, context2) {
  if (!selector) {
    this.length = 0;
    return this;
  }
  if ("string" === typeof selector) {
    if ("body" === selector) {
      this[0] = context2 ? context2.body : dom_adapter_default.getBody();
      this.length = 1;
      return this;
    }
    context2 = context2 || dom_adapter_default.getDocument();
    if (selector.startsWith("<")) {
      this[0] = dom_adapter_default.createElement(selector.slice(1, -1), context2);
      this.length = 1;
      return this;
    }
    [].push.apply(this, dom_adapter_default.querySelectorAll(context2, selector));
    return this;
  }
  if (dom_adapter_default.isNode(selector) || isWindow(selector)) {
    this[0] = selector;
    this.length = 1;
    return this;
  }
  if (Array.isArray(selector)) {
    [].push.apply(this, selector);
    return this;
  }
  return renderer(selector.toArray ? selector.toArray() : [selector]);
};
renderer = function(selector, context2) {
  return new initRender(selector, context2);
};
renderer.fn = {
  dxRenderer: true
};
initRender.prototype = renderer.fn;
var repeatMethod = function(methodName, args) {
  for (let i = 0; i < this.length; i++) {
    const item = renderer(this[i]);
    item[methodName].apply(item, args);
  }
  return this;
};
var setAttributeValue = function(element, attrName, value2) {
  if (void 0 !== value2 && null !== value2 && false !== value2) {
    dom_adapter_default.setAttribute(element, attrName, value2);
  } else {
    dom_adapter_default.removeAttribute(element, attrName);
  }
};
initRender.prototype.show = function() {
  return this.toggle(true);
};
initRender.prototype.hide = function() {
  return this.toggle(false);
};
initRender.prototype.toggle = function(value2) {
  if (this[0]) {
    this.toggleClass("dx-state-invisible", !value2);
  }
  return this;
};
initRender.prototype.attr = function(attrName, value2) {
  if (this.length > 1 && arguments.length > 1) {
    return repeatMethod.call(this, "attr", arguments);
  }
  if (!this[0]) {
    if (isObject(attrName) || void 0 !== value2) {
      return this;
    }
    return;
  }
  if (!this[0].getAttribute) {
    return this.prop(attrName, value2);
  }
  if ("string" === typeof attrName && 1 === arguments.length) {
    const result2 = this[0].getAttribute(attrName);
    return null == result2 ? void 0 : result2;
  }
  if (isPlainObject(attrName)) {
    for (const key in attrName) {
      this.attr(key, attrName[key]);
    }
  } else {
    setAttributeValue(this[0], attrName, value2);
  }
  return this;
};
initRender.prototype.removeAttr = function(attrName) {
  this.each(function(_, element) {
    dom_adapter_default.removeAttribute(element, attrName);
  });
  return this;
};
initRender.prototype.prop = function(propName, value2) {
  if (!this[0]) {
    return this;
  }
  if ("string" === typeof propName && 1 === arguments.length) {
    return this[0][propName];
  }
  if (isPlainObject(propName)) {
    for (const key in propName) {
      this.prop(key, propName[key]);
    }
  } else {
    dom_adapter_default.setProperty(this[0], propName, value2);
  }
  return this;
};
initRender.prototype.addClass = function(className) {
  return this.toggleClass(className, true);
};
initRender.prototype.removeClass = function(className) {
  return this.toggleClass(className, false);
};
initRender.prototype.hasClass = function(className) {
  if (!this[0] || void 0 === this[0].className) {
    return false;
  }
  const classNames2 = className.split(" ");
  for (let i = 0; i < classNames2.length; i++) {
    if (this[0].classList) {
      if (this[0].classList.contains(classNames2[i])) {
        return true;
      }
    } else {
      const className2 = isString(this[0].className) ? this[0].className : dom_adapter_default.getAttribute(this[0], "class");
      if ((className2 || "").split(" ").indexOf(classNames2[i]) >= 0) {
        return true;
      }
    }
  }
  return false;
};
initRender.prototype.toggleClass = function(className, value2) {
  if (this.length > 1) {
    return repeatMethod.call(this, "toggleClass", arguments);
  }
  if (!this[0] || !className) {
    return this;
  }
  value2 = void 0 === value2 ? !this.hasClass(className) : value2;
  const classNames2 = className.split(" ");
  for (let i = 0; i < classNames2.length; i++) {
    dom_adapter_default.setClass(this[0], classNames2[i], value2);
  }
  return this;
};
initRender.prototype.html = function(value2) {
  if (!arguments.length) {
    return this[0].innerHTML;
  }
  this.empty();
  if ("string" === typeof value2 && !isTablePart(value2) || "number" === typeof value2) {
    this[0].innerHTML = value2;
    return this;
  }
  return this.append(parseHTML(value2));
};
var appendElements = function(element, nextSibling) {
  if (!this[0] || !element) {
    return;
  }
  if ("string" === typeof element) {
    element = parseHTML(element);
  } else if (element.nodeType) {
    element = [element];
  } else if (isNumeric(element)) {
    element = [dom_adapter_default.createTextNode(element)];
  }
  for (let i = 0; i < element.length; i++) {
    const item = element[i];
    let container = this[0];
    const wrapTR = "TABLE" === container.tagName && "TR" === item.tagName;
    if (wrapTR && container.tBodies && container.tBodies.length) {
      container = container.tBodies[0];
    }
    dom_adapter_default.insertElement(container, item.nodeType ? item : item[0], nextSibling);
  }
};
var setCss = function(name2, value2) {
  if (!this[0] || !this[0].style) {
    return;
  }
  if (null === value2 || "number" === typeof value2 && isNaN(value2)) {
    return;
  }
  name2 = styleProp(name2);
  for (let i = 0; i < this.length; i++) {
    this[i].style[name2] = normalizeStyleProp(name2, value2);
  }
};
initRender.prototype.css = function(name2, value2) {
  if (isString(name2)) {
    if (2 === arguments.length) {
      setCss.call(this, name2, value2);
    } else {
      if (!this[0]) {
        return;
      }
      name2 = styleProp(name2);
      const result2 = window4.getComputedStyle(this[0])[name2] || this[0].style[name2];
      return isNumeric(result2) ? result2.toString() : result2;
    }
  } else if (isPlainObject(name2)) {
    for (const key in name2) {
      setCss.call(this, key, name2[key]);
    }
  }
  return this;
};
initRender.prototype.prepend = function(element) {
  if (arguments.length > 1) {
    for (let i = 0; i < arguments.length; i++) {
      this.prepend(arguments[i]);
    }
    return this;
  }
  appendElements.apply(this, [element, this[0].firstChild]);
  return this;
};
initRender.prototype.append = function(element) {
  if (arguments.length > 1) {
    for (let i = 0; i < arguments.length; i++) {
      this.append(arguments[i]);
    }
    return this;
  }
  appendElements.apply(this, [element]);
  return this;
};
initRender.prototype.prependTo = function(element) {
  if (this.length > 1) {
    for (let i = this.length - 1; i >= 0; i--) {
      renderer(this[i]).prependTo(element);
    }
    return this;
  }
  element = renderer(element);
  if (element[0]) {
    dom_adapter_default.insertElement(element[0], this[0], element[0].firstChild);
  }
  return this;
};
initRender.prototype.appendTo = function(element) {
  if (this.length > 1) {
    return repeatMethod.call(this, "appendTo", arguments);
  }
  dom_adapter_default.insertElement(renderer(element)[0], this[0]);
  return this;
};
initRender.prototype.insertBefore = function(element) {
  if (element && element[0]) {
    dom_adapter_default.insertElement(element[0].parentNode, this[0], element[0]);
  }
  return this;
};
initRender.prototype.insertAfter = function(element) {
  if (element && element[0]) {
    dom_adapter_default.insertElement(element[0].parentNode, this[0], element[0].nextSibling);
  }
  return this;
};
initRender.prototype.before = function(element) {
  if (this[0]) {
    dom_adapter_default.insertElement(this[0].parentNode, element[0], this[0]);
  }
  return this;
};
initRender.prototype.after = function(element) {
  if (this[0]) {
    dom_adapter_default.insertElement(this[0].parentNode, element[0], this[0].nextSibling);
  }
  return this;
};
initRender.prototype.wrap = function(wrapper) {
  if (this[0]) {
    const wrap = renderer(wrapper);
    wrap.insertBefore(this);
    wrap.append(this);
  }
  return this;
};
initRender.prototype.wrapInner = function(wrapper) {
  const contents = this.contents();
  if (contents.length) {
    contents.wrap(wrapper);
  } else {
    this.append(wrapper);
  }
  return this;
};
initRender.prototype.replaceWith = function(element) {
  if (!(element && element[0])) {
    return;
  }
  if (element.is(this)) {
    return this;
  }
  element.insertBefore(this);
  this.remove();
  return element;
};
initRender.prototype.remove = function() {
  if (this.length > 1) {
    return repeatMethod.call(this, "remove", arguments);
  }
  cleanDataRecursive(this[0], true);
  dom_adapter_default.removeElement(this[0]);
  return this;
};
initRender.prototype.detach = function() {
  if (this.length > 1) {
    return repeatMethod.call(this, "detach", arguments);
  }
  dom_adapter_default.removeElement(this[0]);
  return this;
};
initRender.prototype.empty = function() {
  if (this.length > 1) {
    return repeatMethod.call(this, "empty", arguments);
  }
  cleanDataRecursive(this[0]);
  dom_adapter_default.setText(this[0], "");
  return this;
};
initRender.prototype.clone = function() {
  const result2 = [];
  for (let i = 0; i < this.length; i++) {
    result2.push(this[i].cloneNode(true));
  }
  return renderer(result2);
};
initRender.prototype.text = function(value2) {
  if (!arguments.length) {
    let result2 = "";
    for (let i = 0; i < this.length; i++) {
      result2 += this[i] && this[i].textContent || "";
    }
    return result2;
  }
  const text = isFunction(value2) ? value2() : value2;
  cleanDataRecursive(this[0], false);
  dom_adapter_default.setText(this[0], isDefined(text) ? text : "");
  return this;
};
initRender.prototype.val = function(value2) {
  if (1 === arguments.length) {
    return this.prop("value", isDefined(value2) ? value2 : "");
  }
  return this.prop("value");
};
initRender.prototype.contents = function() {
  if (!this[0]) {
    return renderer();
  }
  const result2 = [];
  result2.push.apply(result2, this[0].childNodes);
  return renderer(result2);
};
initRender.prototype.find = function(selector) {
  const result2 = renderer();
  if (!selector) {
    return result2;
  }
  const nodes = [];
  let i;
  if ("string" === typeof selector) {
    selector = selector.trim();
    for (i = 0; i < this.length; i++) {
      const element = this[i];
      if (dom_adapter_default.isElementNode(element)) {
        const elementId = element.getAttribute("id");
        let queryId = elementId || "dx-query-children";
        if (!elementId) {
          setAttributeValue(element, "id", queryId);
        }
        queryId = `[id='${queryId}'] `;
        const querySelector = queryId + selector.replace(/([^\\])(,)/g, `$1, ${queryId}`);
        nodes.push.apply(nodes, dom_adapter_default.querySelectorAll(element, querySelector));
        setAttributeValue(element, "id", elementId);
      } else if (dom_adapter_default.isDocument(element) || dom_adapter_default.isDocumentFragment(element)) {
        nodes.push.apply(nodes, dom_adapter_default.querySelectorAll(element, selector));
      }
    }
  } else {
    for (i = 0; i < this.length; i++) {
      selector = dom_adapter_default.isNode(selector) ? selector : selector[0];
      if (this[i] !== selector && this[i].contains(selector)) {
        nodes.push(selector);
      }
    }
  }
  return result2.add(nodes);
};
var isVisible = function(_, element) {
  var _element$getClientRec, _element;
  element = element.host ?? element;
  if (!element.nodeType) {
    return true;
  }
  return !!(element.offsetWidth || element.offsetHeight || null !== (_element$getClientRec = (_element = element).getClientRects) && void 0 !== _element$getClientRec && _element$getClientRec.call(_element).length);
};
initRender.prototype.filter = function(selector) {
  if (!selector) {
    return renderer();
  }
  if (":visible" === selector) {
    return this.filter(isVisible);
  }
  if (":hidden" === selector) {
    return this.filter(function(_, element) {
      return !isVisible(0, element);
    });
  }
  const result2 = [];
  for (let i = 0; i < this.length; i++) {
    const item = this[i];
    if (dom_adapter_default.isElementNode(item) && "string" === type(selector)) {
      dom_adapter_default.elementMatches(item, selector) && result2.push(item);
    } else if (dom_adapter_default.isNode(selector) || isWindow(selector)) {
      selector === item && result2.push(item);
    } else if (isFunction(selector)) {
      selector.call(item, i, item) && result2.push(item);
    } else {
      for (let j = 0; j < selector.length; j++) {
        selector[j] === item && result2.push(item);
      }
    }
  }
  return renderer(result2);
};
initRender.prototype.not = function(selector) {
  const result2 = [];
  const nodes = this.filter(selector).toArray();
  for (let i = 0; i < this.length; i++) {
    if (-1 === nodes.indexOf(this[i])) {
      result2.push(this[i]);
    }
  }
  return renderer(result2);
};
initRender.prototype.is = function(selector) {
  return !!this.filter(selector).length;
};
initRender.prototype.children = function(selector) {
  let result2 = [];
  for (let i = 0; i < this.length; i++) {
    const nodes = this[i] ? this[i].childNodes : [];
    for (let j = 0; j < nodes.length; j++) {
      if (dom_adapter_default.isElementNode(nodes[j])) {
        result2.push(nodes[j]);
      }
    }
  }
  result2 = renderer(result2);
  return selector ? result2.filter(selector) : result2;
};
initRender.prototype.siblings = function() {
  const element = this[0];
  if (!element || !element.parentNode) {
    return renderer();
  }
  const result2 = [];
  const parentChildNodes = element.parentNode.childNodes || [];
  for (let i = 0; i < parentChildNodes.length; i++) {
    const node = parentChildNodes[i];
    if (dom_adapter_default.isElementNode(node) && node !== element) {
      result2.push(node);
    }
  }
  return renderer(result2);
};
initRender.prototype.each = function(callback) {
  for (let i = 0; i < this.length; i++) {
    if (false === callback.call(this[i], i, this[i])) {
      break;
    }
  }
};
initRender.prototype.index = function(element) {
  if (!element) {
    return this.parent().children().index(this);
  }
  element = renderer(element);
  return this.toArray().indexOf(element[0]);
};
initRender.prototype.get = function(index2) {
  return this[index2 < 0 ? this.length + index2 : index2];
};
initRender.prototype.eq = function(index2) {
  index2 = index2 < 0 ? this.length + index2 : index2;
  return renderer(this[index2]);
};
initRender.prototype.first = function() {
  return this.eq(0);
};
initRender.prototype.last = function() {
  return this.eq(-1);
};
initRender.prototype.select = function() {
  for (let i = 0; i < this.length; i += 1) {
    this[i].select && this[i].select();
  }
  return this;
};
initRender.prototype.parent = function(selector) {
  if (!this[0]) {
    return renderer();
  }
  const result2 = renderer(this[0].parentNode);
  return !selector || result2.is(selector) ? result2 : renderer();
};
initRender.prototype.parents = function(selector) {
  const result2 = [];
  let parent = this.parent();
  while (parent && parent[0] && !dom_adapter_default.isDocument(parent[0])) {
    if (dom_adapter_default.isElementNode(parent[0])) {
      if (!selector || parent.is(selector)) {
        result2.push(parent.get(0));
      }
    }
    parent = parent.parent();
  }
  return renderer(result2);
};
initRender.prototype.closest = function(selector) {
  if (this.is(selector)) {
    return this;
  }
  let parent = this.parent();
  while (parent && parent.length) {
    if (parent.is(selector)) {
      return parent;
    }
    parent = parent.parent();
  }
  return renderer();
};
initRender.prototype.next = function(selector) {
  if (!this[0]) {
    return renderer();
  }
  let next = renderer(this[0].nextSibling);
  if (!arguments.length) {
    return next;
  }
  while (next && next.length) {
    if (next.is(selector)) {
      return next;
    }
    next = next.next();
  }
  return renderer();
};
initRender.prototype.prev = function() {
  if (!this[0]) {
    return renderer();
  }
  return renderer(this[0].previousSibling);
};
initRender.prototype.add = function(selector) {
  const targets = renderer(selector);
  const result2 = this.toArray();
  for (let i = 0; i < targets.length; i++) {
    const target = targets[i];
    if (-1 === result2.indexOf(target)) {
      result2.push(target);
    }
  }
  return renderer(result2);
};
var emptyArray = [];
initRender.prototype.splice = function() {
  return renderer(emptyArray.splice.apply(this, arguments));
};
initRender.prototype.slice = function() {
  return renderer(emptyArray.slice.apply(this, arguments));
};
initRender.prototype.toArray = function() {
  return emptyArray.slice.call(this);
};
initRender.prototype.offset = function() {
  if (!this[0]) {
    return;
  }
  return getOffset(this[0]);
};
initRender.prototype.offsetParent = function() {
  if (!this[0]) {
    return renderer();
  }
  let offsetParent = renderer(this[0].offsetParent);
  while (offsetParent[0] && "static" === offsetParent.css("position")) {
    offsetParent = renderer(offsetParent[0].offsetParent);
  }
  offsetParent = offsetParent[0] ? offsetParent : renderer(dom_adapter_default.getDocumentElement());
  return offsetParent;
};
initRender.prototype.position = function() {
  if (!this[0]) {
    return;
  }
  let offset2;
  const marginTop = parseFloat(this.css("marginTop"));
  const marginLeft = parseFloat(this.css("marginLeft"));
  if ("fixed" === this.css("position")) {
    offset2 = this[0].getBoundingClientRect();
    return {
      top: offset2.top - marginTop,
      left: offset2.left - marginLeft
    };
  }
  offset2 = this.offset();
  const offsetParent = this.offsetParent();
  let parentOffset = {
    top: 0,
    left: 0
  };
  if ("HTML" !== offsetParent[0].nodeName) {
    parentOffset = offsetParent.offset();
  }
  parentOffset = {
    top: parentOffset.top + parseFloat(offsetParent.css("borderTopWidth")),
    left: parentOffset.left + parseFloat(offsetParent.css("borderLeftWidth"))
  };
  return {
    top: offset2.top - parentOffset.top - marginTop,
    left: offset2.left - parentOffset.left - marginLeft
  };
};
[{
  name: "scrollLeft",
  offsetProp: "pageXOffset",
  scrollWindow: function(win, value2) {
    win.scrollTo(value2, win.pageYOffset);
  }
}, {
  name: "scrollTop",
  offsetProp: "pageYOffset",
  scrollWindow: function(win, value2) {
    win.scrollTo(win.pageXOffset, value2);
  }
}].forEach(function(directionStrategy) {
  const propName = directionStrategy.name;
  initRender.prototype[propName] = function(value2) {
    if (!this[0]) {
      return;
    }
    const window31 = getWindowByElement(this[0]);
    if (void 0 === value2) {
      return window31 ? window31[directionStrategy.offsetProp] : this[0][propName];
    }
    if (window31) {
      directionStrategy.scrollWindow(window31, value2);
    } else {
      this[0][propName] = value2;
    }
    return this;
  };
});
initRender.prototype.data = function(key, value2) {
  if (!this[0]) {
    return;
  }
  if (arguments.length < 2) {
    return data.call(renderer, this[0], key);
  }
  data.call(renderer, this[0], key, value2);
  return this;
};
initRender.prototype.removeData = function(key) {
  this[0] && removeData(this[0], key);
  return this;
};
var rendererWrapper = function() {
  return renderer.apply(this, arguments);
};
Object.defineProperty(rendererWrapper, "fn", {
  enumerable: true,
  configurable: true,
  get: function() {
    return renderer.fn;
  },
  set: function(value2) {
    renderer.fn = value2;
  }
});
var m_renderer_base_default = {
  set: function(strategy3) {
    renderer = strategy3;
  },
  get: function() {
    return rendererWrapper;
  }
};

// node_modules/devextreme/esm/__internal/core/m_renderer.js
var renderer2 = m_renderer_base_default.get();

// node_modules/devextreme/esm/core/renderer.js
var renderer_default = renderer2;

// node_modules/devextreme/esm/__internal/grids/grid_core/keyboard_navigation/const.js
var ATTRIBUTES = {
  ariaColIndex: "aria-colindex",
  dragCell: "dx-drag-cell"
};
var ROWS_VIEW_CLASS = "rowsview";
var TABLE_CLASS = "table";
var EDIT_FORM_CLASS = "edit-form";
var DATA_ROW_CLASS = "dx-data-row";
var GROUP_ROW_CLASS = "dx-group-row";
var HEADER_ROW_CLASS = "dx-header-row";
var EDIT_FORM_ITEM_CLASS = "edit-form-item";
var MASTER_DETAIL_ROW_CLASS = "dx-master-detail-row";
var FREESPACE_ROW_CLASS = "dx-freespace-row";
var VIRTUAL_ROW_CLASS = "dx-virtual-row";
var MASTER_DETAIL_CELL_CLASS = "dx-master-detail-cell";
var DROPDOWN_EDITOR_OVERLAY_CLASS = "dx-dropdowneditor-overlay";
var COMMAND_EXPAND_CLASS = "dx-command-expand";
var ADAPTIVE_COLUMN_NAME_CLASS = "dx-command-adaptive";
var ADAPTIVE_ITEM_TEXT_CLASS = "dx-adaptive-item-text";
var COMMAND_SELECT_CLASS = "dx-command-select";
var COMMAND_EDIT_CLASS = "dx-command-edit";
var COMMAND_CELL_SELECTOR = "[class^=dx-command]";
var CELL_FOCUS_DISABLED_CLASS = "dx-cell-focus-disabled";
var DATEBOX_WIDGET_NAME = "dxDateBox";
var FOCUS_STATE_CLASS = "dx-state-focused";
var WIDGET_CLASS = "dx-widget";
var REVERT_BUTTON_CLASS = "dx-revert-button";
var FOCUSED_CLASS = "dx-focused";
var FAST_EDITING_DELETE_KEY = "delete";
var INTERACTIVE_ELEMENTS_SELECTOR = '\n  input:not([type="hidden"]):not([disabled]),\n  textarea:not([disabled]),\n  a:not([disabled]),\n  select:not([disabled]),\n  button:not([disabled]),\n  [tabindex]:not([disabled]),\n  .dx-checkbox:not([disabled],.dx-state-readonly)\n';
var NON_FOCUSABLE_ELEMENTS_SELECTOR = `${INTERACTIVE_ELEMENTS_SELECTOR}, .dx-dropdowneditor-icon`;
var FOCUS_TYPE_ROW = "row";
var FOCUS_TYPE_CELL = "cell";
var COLUMN_HEADERS_VIEW = "columnHeadersView";
var ROWS_VIEW = "rowsView";
var FUNCTIONAL_KEYS = ["shift", "control", "alt"];
var DRAG_COLUMN_NAME = "drag";
var Direction;
!function(Direction2) {
  Direction2.Next = "next";
  Direction2.Previous = "previous";
}(Direction || (Direction = {}));
var ViewName;
!function(ViewName2) {
  ViewName2.Group = "group";
  ViewName2.Headers = "headers";
}(ViewName || (ViewName = {}));
var KEY_CODES = {
  G: 71
};

// node_modules/devextreme/esm/__internal/grids/grid_core/context_menu/const.js
var CONTEXT_MENU_MOVE_PREVIOUS_ICON_NAME = "arrowleft";
var CONTEXT_MENU_MOVE_NEXT_ICON_NAME = "arrowright";

// node_modules/devextreme/esm/__internal/grids/grid_core/context_menu/m_column_context_menu_mixin.js
var ColumnContextMenuMixin = (Base) => class extends Base {
  constructor() {
    super(...arguments);
    this.isNeedToFocusColumn = false;
  }
  getMoveColumnContextMenuItems(options2) {
    var _this$isColumnReorder, _this$getKeyboardNavi;
    const {
      column,
      rowIndex
    } = options2;
    const allowColumnReordering = null === (_this$isColumnReorder = this.isColumnReorderingEnabled) || void 0 === _this$isColumnReorder ? void 0 : _this$isColumnReorder.call(this, null === options2 || void 0 === options2 ? void 0 : options2.column);
    const keyboardNavigationController = null === (_this$getKeyboardNavi = this.getKeyboardNavigationController) || void 0 === _this$getKeyboardNavi ? void 0 : _this$getKeyboardNavi.call(this);
    if (!allowColumnReordering || !keyboardNavigationController) {
      return [];
    }
    const rtlEnabled = this.option("rtlEnabled");
    const onItemClick = (e) => {
      var _e$itemData;
      this.isNeedToFocusColumn = true;
      keyboardNavigationController.moveColumn(column, null === (_e$itemData = e.itemData) || void 0 === _e$itemData ? void 0 : _e$itemData.value, rowIndex);
    };
    return [{
      text: rtlEnabled ? message_default.format("dxDataGrid-moveColumnToTheRight") : message_default.format("dxDataGrid-moveColumnToTheLeft"),
      value: Direction.Previous,
      beginGroup: true,
      disabled: !keyboardNavigationController.canReorderColumn(column, Direction.Previous, rowIndex),
      icon: rtlEnabled ? CONTEXT_MENU_MOVE_NEXT_ICON_NAME : CONTEXT_MENU_MOVE_PREVIOUS_ICON_NAME,
      onItemClick
    }, {
      text: rtlEnabled ? message_default.format("dxDataGrid-moveColumnToTheLeft") : message_default.format("dxDataGrid-moveColumnToTheRight"),
      value: Direction.Next,
      disabled: !keyboardNavigationController.canReorderColumn(column, Direction.Next, rowIndex),
      icon: rtlEnabled ? CONTEXT_MENU_MOVE_PREVIOUS_ICON_NAME : CONTEXT_MENU_MOVE_NEXT_ICON_NAME,
      onItemClick
    }];
  }
};

// node_modules/devextreme/esm/__internal/grids/grid_core/columns_resizing_reordering/const.js
var CLASSES = {
  draggableColumn: "draggable-column"
};

// node_modules/devextreme/esm/ui/widget/selectors.js
var focusableFn = function(element, tabIndex) {
  if (!visible(element)) {
    return false;
  }
  const nodeName = element.nodeName.toLowerCase();
  const isTabIndexNotNaN = !isNaN(tabIndex);
  const isDisabled = element.disabled;
  const isDefaultFocus = /^(input|select|textarea|button|object|iframe)$/.test(nodeName);
  const isHyperlink = "a" === nodeName;
  let isFocusable;
  const isContentEditable = element.isContentEditable;
  if (isDefaultFocus || isContentEditable) {
    isFocusable = !isDisabled;
  } else if (isHyperlink) {
    isFocusable = element.href || isTabIndexNotNaN;
  } else {
    isFocusable = isTabIndexNotNaN;
  }
  return isFocusable;
};
function visible(element) {
  const $element = renderer_default(element);
  return $element.is(":visible") && "hidden" !== $element.css("visibility") && "hidden" !== $element.parents().css("visibility");
}
var focusable = function(index2, element) {
  return focusableFn(element, renderer_default(element).attr("tabIndex"));
};
var tabbable = function(index2, element) {
  const tabIndex = renderer_default(element).attr("tabIndex");
  return (isNaN(tabIndex) || tabIndex >= 0) && focusableFn(element, tabIndex);
};
var focused = function($element) {
  const element = renderer_default($element).get(0);
  return dom_adapter_default.getActiveElement(element) === element;
};

// node_modules/devextreme/esm/__internal/events/utils/m_add_namespace.js
var addNamespace = (eventNames, namespace) => {
  if (!namespace) {
    throw errors_default.Error("E0017");
  }
  if (Array.isArray(eventNames)) {
    return eventNames.map((eventName) => addNamespace(eventName, namespace)).join(" ");
  }
  if (-1 !== eventNames.indexOf(" ")) {
    return addNamespace(eventNames.split(/\s+/g), namespace);
  }
  return `${eventNames}.${namespace}`;
};
var m_add_namespace_default = addNamespace;

// node_modules/devextreme/esm/__internal/events/utils/index.js
var KEY_MAP = {
  backspace: "backspace",
  tab: "tab",
  enter: "enter",
  escape: "escape",
  pageup: "pageUp",
  pagedown: "pageDown",
  end: "end",
  home: "home",
  arrowleft: "leftArrow",
  arrowup: "upArrow",
  arrowright: "rightArrow",
  arrowdown: "downArrow",
  delete: "del",
  " ": "space",
  f: "F",
  a: "A",
  "*": "asterisk",
  "-": "minus",
  alt: "alt",
  control: "control",
  shift: "shift"
};
var LEGACY_KEY_CODES = {
  8: "backspace",
  9: "tab",
  13: "enter",
  27: "escape",
  33: "pageUp",
  34: "pageDown",
  35: "end",
  36: "home",
  37: "leftArrow",
  38: "upArrow",
  39: "rightArrow",
  40: "downArrow",
  46: "del",
  32: "space",
  70: "F",
  65: "A",
  106: "asterisk",
  109: "minus",
  189: "minus",
  173: "minus",
  16: "shift",
  17: "control",
  18: "alt"
};
var EVENT_SOURCES_REGEX = {
  dx: /^dx/i,
  mouse: /(mouse|wheel)/i,
  touch: /^touch/i,
  keyboard: /^key/i,
  pointer: /^(ms)?pointer/i
};
var eventSource = (_ref) => {
  let {
    type: type2
  } = _ref;
  let result2 = "other";
  each(EVENT_SOURCES_REGEX, function(key) {
    if (this.test(type2)) {
      result2 = key;
      return false;
    }
  });
  return result2;
};
var fixMethod = (e) => e;
var getEvent = (originalEvent) => m_events_engine_default.Event(originalEvent, originalEvent);
var copyEvent = (originalEvent) => fixMethod(getEvent(originalEvent), originalEvent);
var isDxEvent = (e) => "dx" === eventSource(e);
var isNativeMouseEvent = (e) => "mouse" === eventSource(e);
var isNativeTouchEvent = (e) => "touch" === eventSource(e);
var isPointerEvent = (e) => "pointer" === eventSource(e);
var isMouseEvent = (e) => isNativeMouseEvent(e) || (isPointerEvent(e) || isDxEvent(e)) && "mouse" === e.pointerType;
var isDxMouseWheelEvent = (e) => e && "dxmousewheel" === e.type;
var isTouchEvent = (e) => isNativeTouchEvent(e) || (isPointerEvent(e) || isDxEvent(e)) && "touch" === e.pointerType;
var eventData = (_ref3) => {
  let {
    pageX,
    pageY,
    timeStamp
  } = _ref3;
  return {
    x: pageX,
    y: pageY,
    time: timeStamp
  };
};
var eventDelta = (from, to) => ({
  x: to.x - from.x,
  y: to.y - from.y,
  time: to.time - from.time || 1
});
var hasTouches = (e) => {
  const {
    originalEvent,
    pointers
  } = e;
  if (isNativeTouchEvent(e)) {
    return (originalEvent.touches || []).length;
  }
  if (isDxEvent(e)) {
    return (pointers || []).length;
  }
  return 0;
};
var skipEvents = false;
var needSkipEvent = (e) => {
  if (skipEvents) {
    return true;
  }
  const {
    target
  } = e;
  const $target = renderer_default(target);
  const isContentEditable = (null === target || void 0 === target ? void 0 : target.isContentEditable) || (null === target || void 0 === target ? void 0 : target.hasAttribute("contenteditable"));
  const touchInEditable = $target.is("input, textarea, select") || isContentEditable;
  if (isDxMouseWheelEvent(e)) {
    const isTextArea = $target.is("textarea") && $target.hasClass("dx-texteditor-input");
    if (isTextArea || isContentEditable) {
      return false;
    }
    const isInputFocused = $target.is("input[type='number'], textarea, select") && $target.is(":focus");
    return isInputFocused;
  }
  if (isMouseEvent(e)) {
    return touchInEditable || e.which > 1;
  }
  if (isTouchEvent(e)) {
    return touchInEditable && focused($target);
  }
};
var createEvent = (originalEvent, args) => {
  const event = copyEvent(originalEvent);
  if (args) {
    extend(event, args);
  }
  return event;
};
var fireEvent = (props) => {
  const {
    originalEvent,
    delegateTarget
  } = props;
  const event = createEvent(originalEvent, props);
  m_events_engine_default.trigger(delegateTarget || event.target, event);
  return event;
};
var normalizeKeyName = (_ref4) => {
  let {
    key,
    which
  } = _ref4;
  const normalizedKey = KEY_MAP[null === key || void 0 === key ? void 0 : key.toLowerCase()] || key;
  const normalizedKeyFromWhich = LEGACY_KEY_CODES[which];
  if (normalizedKeyFromWhich && normalizedKey === key) {
    return normalizedKeyFromWhich;
  }
  if (!normalizedKey && which) {
    return String.fromCharCode(which);
  }
  return normalizedKey;
};
var getChar = (_ref5) => {
  let {
    key,
    which
  } = _ref5;
  return key || String.fromCharCode(which);
};
var addNamespace2 = m_add_namespace_default;
var isCommandKeyPressed = (_ref6) => {
  let {
    ctrlKey,
    metaKey
  } = _ref6;
  return ctrlKey || metaKey;
};

// node_modules/devextreme/esm/ui/shared/accessibility.js
var FOCUS_STATE_CLASS2 = "dx-state-focused";
var FOCUS_DISABLED_CLASS = "dx-cell-focus-disabled";
var GRID_ROW_SELECTOR = ".dx-datagrid-rowsview .dx-row";
var GRID_CELL_SELECTOR = `${GRID_ROW_SELECTOR} > td`;
var TREELIST_ROW_SELECTOR = ".dx-treelist-rowsview .dx-row";
var TREELIST_CELL_SELECTOR = `${TREELIST_ROW_SELECTOR} > td`;
var viewItemSelectorMap = {
  groupPanel: [".dx-datagrid-group-panel .dx-group-panel-item[tabindex]"],
  columnHeaders: [".dx-datagrid-headers .dx-header-row > td.dx-datagrid-action", ".dx-treelist-headers .dx-header-row > td.dx-treelist-action"],
  filterRow: [".dx-datagrid-headers .dx-datagrid-filter-row .dx-editor-cell .dx-texteditor-input", ".dx-treelist-headers .dx-treelist-filter-row .dx-editor-cell .dx-texteditor-input"],
  rowsView: [".dx-row-focused", `${GRID_ROW_SELECTOR}[tabindex]`, `${GRID_CELL_SELECTOR}[tabindex]`, `${GRID_CELL_SELECTOR}`, `${TREELIST_ROW_SELECTOR}[tabindex]`, `${TREELIST_CELL_SELECTOR}[tabindex]`, `${TREELIST_CELL_SELECTOR}`],
  footer: [".dx-datagrid-total-footer .dx-datagrid-summary-item", ".dx-treelist-total-footer .dx-treelist-summary-item"],
  filterPanel: [".dx-datagrid-filter-panel .dx-icon-filter", ".dx-treelist-filter-panel .dx-icon-filter"],
  pager: [".dx-datagrid-pager [tabindex]", ".dx-treelist-pager [tabindex]"]
};
var isMouseDown = false;
var isHiddenFocusing = false;
var focusedElementInfo = null;
var needToSkipFocusin = false;
function processKeyDown(viewName2, instance, event, action, $mainElement, executeKeyDown) {
  const isHandled = fireKeyDownEvent(instance, event.originalEvent, executeKeyDown);
  if (isHandled) {
    return;
  }
  const keyName = normalizeKeyName(event);
  if ("enter" === keyName || "space" === keyName) {
    saveFocusedElementInfo(event.target, instance);
    action && action({
      event
    });
  } else if ("tab" === keyName) {
    $mainElement.addClass(FOCUS_STATE_CLASS2);
  } else {
    selectView(viewName2, instance, event);
  }
}
function saveFocusedElementInfo(target, instance) {
  const $target = renderer_default(target);
  const ariaLabel = $target.attr("aria-label");
  const $activeElements = getActiveAccessibleElements(ariaLabel, instance.element());
  const targetIndex = $activeElements.index($target);
  focusedElementInfo = extend({}, {
    ariaLabel,
    index: targetIndex
  }, {
    viewInstance: instance
  });
}
function getActiveAccessibleElements(ariaLabel, viewElement) {
  const $viewElement = renderer_default(viewElement);
  let $activeElements;
  if (ariaLabel) {
    const escapedAriaLabel = null === ariaLabel || void 0 === ariaLabel ? void 0 : ariaLabel.replace(/\\/g, "\\\\").replace(/"/g, '\\"');
    $activeElements = $viewElement.find(`[aria-label="${escapedAriaLabel}"][tabindex]`);
  } else {
    $activeElements = $viewElement.find("[tabindex]");
  }
  return $activeElements;
}
function findFocusedViewElement(instanceRootDomNode, viewSelectors, element) {
  const root = instanceRootDomNode ?? (null === element || void 0 === element ? void 0 : element.getRootNode()) ?? dom_adapter_default.getDocument();
  if (!root) {
    return;
  }
  const $root = renderer_default(root);
  for (const index2 in viewSelectors) {
    const selector = viewSelectors[index2];
    const $focusViewElement = $root.find(selector).first();
    if ($focusViewElement.length) {
      return $focusViewElement;
    }
  }
}
function fireKeyDownEvent(instance, event, executeAction2) {
  const args = {
    event,
    handled: false
  };
  if (executeAction2) {
    executeAction2(args);
  } else {
    instance._createActionByOption("onKeyDown")(args);
  }
  return args.handled;
}
function onDocumentVisibilityChange() {
  const focusedElement = dom_adapter_default.getActiveElement();
  needToSkipFocusin = focusedElement && !focusedElement.closest(`.${FOCUS_STATE_CLASS2}`);
}
function subscribeVisibilityChange() {
  m_events_engine_default.on(dom_adapter_default.getDocument(), "visibilitychange", onDocumentVisibilityChange);
}
function unsubscribeVisibilityChange() {
  m_events_engine_default.off(dom_adapter_default.getDocument(), "visibilitychange", onDocumentVisibilityChange);
}
function hiddenFocus(element, preventScroll) {
  isHiddenFocusing = true;
  element.focus({
    preventScroll
  });
  isHiddenFocusing = false;
}
function registerKeyboardAction(viewName2, instance, $element, selector, action, executeKeyDown) {
  if (instance.option("useLegacyKeyboardNavigation")) {
    return noop2;
  }
  const getMainElement = () => renderer_default(instance.element());
  const keyDownHandler = (e) => processKeyDown(viewName2, instance, e, action, getMainElement(), executeKeyDown);
  const mouseDownHandler = () => {
    isMouseDown = true;
    getMainElement().removeClass(FOCUS_STATE_CLASS2);
  };
  const focusinHandler = () => {
    if (needToSkipFocusin) {
      needToSkipFocusin = false;
      return;
    }
    const needShowOverlay = !isMouseDown && !isHiddenFocusing;
    if (needShowOverlay) {
      getMainElement().addClass(FOCUS_STATE_CLASS2);
    }
    isMouseDown = false;
  };
  const mouseUpHandler = () => {
    isMouseDown = false;
  };
  m_events_engine_default.on($element, "keydown", selector, keyDownHandler);
  m_events_engine_default.on($element, "mousedown", selector, mouseDownHandler);
  m_events_engine_default.on($element, "focusin", selector, focusinHandler);
  m_events_engine_default.on($element, "mouseup contextmenu", selector, mouseUpHandler);
  return () => {
    m_events_engine_default.off($element, "keydown", selector, keyDownHandler);
    m_events_engine_default.off($element, "mousedown", selector, mouseDownHandler);
    m_events_engine_default.off($element, "focusin", selector, focusinHandler);
    m_events_engine_default.off($element, "mouseup contextmenu", selector, mouseUpHandler);
  };
}
function restoreFocus(instance) {
  if (!instance.option("useLegacyKeyboardNavigation") && focusedElementInfo) {
    const viewInstance = focusedElementInfo.viewInstance;
    if (viewInstance) {
      const $activeElements = getActiveAccessibleElements(focusedElementInfo.ariaLabel, viewInstance.element());
      const $targetElement = $activeElements.eq(focusedElementInfo.index);
      focusedElementInfo = null;
      m_events_engine_default.trigger($targetElement, "focus");
    }
  }
}
function selectView(viewName2, instance, event) {
  const keyName = normalizeKeyName(event);
  if (event.ctrlKey && ("upArrow" === keyName || "downArrow" === keyName)) {
    var _instance$component, _instance$component$e;
    const viewNames = Object.keys(viewItemSelectorMap);
    let viewItemIndex = viewNames.indexOf(viewName2);
    const instanceRootDomNode = null === instance || void 0 === instance || null === (_instance$component = instance.component) || void 0 === _instance$component || null === (_instance$component$e = _instance$component.element) || void 0 === _instance$component$e ? void 0 : _instance$component$e.call(_instance$component);
    while (viewItemIndex >= 0 && viewItemIndex < viewNames.length) {
      viewItemIndex = "upArrow" === keyName ? --viewItemIndex : ++viewItemIndex;
      const viewName3 = viewNames[viewItemIndex];
      const viewSelectors = viewItemSelectorMap[viewName3];
      const $focusViewElement = findFocusedViewElement(instanceRootDomNode, viewSelectors, event.target);
      if ($focusViewElement && $focusViewElement.length) {
        $focusViewElement.attr("tabindex", instance.option("tabindex") || 0);
        m_events_engine_default.trigger($focusViewElement, "focus");
        $focusViewElement.removeClass(FOCUS_DISABLED_CLASS);
        break;
      }
    }
  }
}
function setTabIndex(instance, $element) {
  if (!instance.option("useLegacyKeyboardnavigation")) {
    $element.attr("tabindex", instance.option("tabindex") || 0);
  }
}

// node_modules/devextreme/esm/__internal/grids/grid_core/m_accessibility.js
var registerKeyboardAction2 = function(viewName2, instance, $element, selector, action) {
  let executeKeyDown = (args) => {
  };
  const keyboardController = instance.getController("keyboardNavigation");
  if (instance.option("useLegacyKeyboardNavigation") || keyboardController && !keyboardController.isKeyboardEnabled()) {
    return;
  }
  if ("filterPanel" === viewName2) {
    executeKeyDown = (args) => {
      instance.executeAction("onKeyDown", args);
    };
    instance.createAction("onKeyDown");
  }
  registerKeyboardAction(viewName2, instance, $element, selector, action, executeKeyDown);
};

// node_modules/devextreme/esm/common/core/animation/frame.js
var window5 = hasWindow() ? getWindow() : {};
var FRAME_ANIMATION_STEP_TIME = 1e3 / 60;
var request = function(callback) {
  return setTimeout(callback, 16.666666666666668);
};
var cancel = function(requestID) {
  clearTimeout(requestID);
};
var setAnimationFrameMethods = call_once_default(function() {
  const nativeRequest = window5.requestAnimationFrame || window5.webkitRequestAnimationFrame || window5.mozRequestAnimationFrame || window5.oRequestAnimationFrame || window5.msRequestAnimationFrame;
  const nativeCancel = window5.cancelAnimationFrame || window5.webkitCancelAnimationFrame || window5.mozCancelAnimationFrame || window5.oCancelAnimationFrame || window5.msCancelAnimationFrame;
  if (nativeRequest && nativeCancel) {
    request = nativeRequest;
    cancel = nativeCancel;
  }
});
function requestAnimationFrame() {
  setAnimationFrameMethods();
  return request.apply(window5, arguments);
}
function cancelAnimationFrame() {
  setAnimationFrameMethods();
  cancel.apply(window5, arguments);
}

// node_modules/devextreme/esm/__internal/core/m_element.js
function getPublicElementNonJquery(element) {
  if (element && element.get) {
    return element.get(0);
  }
  return element;
}
var strategy2 = getPublicElementNonJquery;
function getPublicElement(element) {
  return strategy2(element);
}

// node_modules/devextreme/esm/common/core/animation/translator.js
var TRANSFORM_MATRIX_REGEX = /matrix(3d)?\((.+?)\)/;
var TRANSLATE_REGEX = /translate(?:3d)?\((.+?)\)/;
var locate = function($element) {
  $element = renderer_default($element);
  const translate = getTranslate($element);
  return {
    left: translate.x,
    top: translate.y
  };
};
function isPercentValue(value2) {
  return "string" === type(value2) && "%" === value2[value2.length - 1];
}
function cacheTranslate($element, translate) {
  if ($element.length) {
    data($element.get(0), "dxTranslator", translate);
  }
}
var clearCache = function($element) {
  if ($element.length) {
    removeData($element.get(0), "dxTranslator");
  }
};
var getTranslateCss = function(translate) {
  translate.x = translate.x || 0;
  translate.y = translate.y || 0;
  const xValueString = isPercentValue(translate.x) ? translate.x : translate.x + "px";
  const yValueString = isPercentValue(translate.y) ? translate.y : translate.y + "px";
  return "translate(" + xValueString + ", " + yValueString + ")";
};
var getTranslate = function($element) {
  let result2 = $element.length ? data($element.get(0), "dxTranslator") : null;
  if (!result2) {
    const transformValue = $element.css("transform") || getTranslateCss({
      x: 0,
      y: 0
    });
    let matrix = transformValue.match(TRANSFORM_MATRIX_REGEX);
    const is3D = matrix && matrix[1];
    if (matrix) {
      matrix = matrix[2].split(",");
      if ("3d" === is3D) {
        matrix = matrix.slice(12, 15);
      } else {
        matrix.push(0);
        matrix = matrix.slice(4, 7);
      }
    } else {
      matrix = [0, 0, 0];
    }
    result2 = {
      x: parseFloat(matrix[0]),
      y: parseFloat(matrix[1]),
      z: parseFloat(matrix[2])
    };
    cacheTranslate($element, result2);
  }
  return result2;
};
var move = function($element, position3) {
  $element = renderer_default($element);
  const left = position3.left;
  const top = position3.top;
  let translate;
  if (void 0 === left) {
    translate = getTranslate($element);
    translate.y = top || 0;
  } else if (void 0 === top) {
    translate = getTranslate($element);
    translate.x = left || 0;
  } else {
    translate = {
      x: left || 0,
      y: top || 0,
      z: 0
    };
    cacheTranslate($element, translate);
  }
  $element.css({
    transform: getTranslateCss(translate)
  });
  if (isPercentValue(left) || isPercentValue(top)) {
    clearCache($element);
  }
};
var resetPosition = function($element, finishTransition) {
  $element = renderer_default($element);
  let originalTransition;
  const stylesConfig = {
    left: 0,
    top: 0,
    transform: "none"
  };
  if (finishTransition) {
    originalTransition = $element.css("transition");
    stylesConfig.transition = "none";
  }
  $element.css(stylesConfig);
  clearCache($element);
  if (finishTransition) {
    $element.get(0).offsetHeight;
    $element.css("transition", originalTransition);
  }
};
var parseTranslate = function(translateString) {
  let result2 = translateString.match(TRANSLATE_REGEX);
  if (!result2 || !result2[1]) {
    return;
  }
  result2 = result2[1].split(",");
  result2 = {
    x: parseFloat(result2[0]),
    y: parseFloat(result2[1]),
    z: parseFloat(result2[2])
  };
  return result2;
};

// node_modules/devextreme/esm/common/core/animation/easing.js
var CSS_TRANSITION_EASING_REGEX = /cubic-bezier\((\d+(?:\.\d+)?)\s*,\s*(\d+(?:\.\d+)?)\s*,\s*(\d+(?:\.\d+)?)\s*,\s*(\d+(?:\.\d+)?)\)/;
var TransitionTimingFuncMap = {
  linear: "cubic-bezier(0, 0, 1, 1)",
  swing: "cubic-bezier(0.445, 0.05, 0.55, 0.95)",
  ease: "cubic-bezier(0.25, 0.1, 0.25, 1)",
  "ease-in": "cubic-bezier(0.42, 0, 1, 1)",
  "ease-out": "cubic-bezier(0, 0, 0.58, 1)",
  "ease-in-out": "cubic-bezier(0.42, 0, 0.58, 1)"
};
var polynomBezier = function(x1, y1, x2, y2) {
  const Cx = 3 * x1;
  const Bx = 3 * (x2 - x1) - Cx;
  const Ax = 1 - Cx - Bx;
  const Cy = 3 * y1;
  const By = 3 * (y2 - y1) - Cy;
  const Ay = 1 - Cy - By;
  const bezierX = function(t) {
    return t * (Cx + t * (Bx + t * Ax));
  };
  const derivativeX = function(t) {
    return Cx + t * (2 * Bx + 3 * t * Ax);
  };
  return function(t) {
    return function(t2) {
      return t2 * (Cy + t2 * (By + t2 * Ay));
    }(function(t2) {
      let x = t2;
      let i = 0;
      let z;
      while (i < 14) {
        z = bezierX(x) - t2;
        if (Math.abs(z) < 1e-3) {
          break;
        }
        x -= z / derivativeX(x);
        i++;
      }
      return x;
    }(t));
  };
};
var easing = {};
var convertTransitionTimingFuncToEasing = function(cssTransitionEasing) {
  cssTransitionEasing = TransitionTimingFuncMap[cssTransitionEasing] || cssTransitionEasing;
  let coeffs = cssTransitionEasing.match(CSS_TRANSITION_EASING_REGEX);
  let forceName;
  if (!coeffs) {
    forceName = "linear";
    coeffs = TransitionTimingFuncMap[forceName].match(CSS_TRANSITION_EASING_REGEX);
  }
  coeffs = coeffs.slice(1, 5);
  for (let i = 0; i < coeffs.length; i++) {
    coeffs[i] = parseFloat(coeffs[i]);
  }
  const easingName = forceName || "cubicbezier_" + coeffs.join("_").replace(/\./g, "p");
  if (!isFunction(easing[easingName])) {
    easing[easingName] = function(x, t, b, c, d) {
      return c * polynomBezier(coeffs[0], coeffs[1], coeffs[2], coeffs[3])(t / d) + b;
    };
  }
  return easingName;
};
function getEasing(name2) {
  return easing[name2];
}

// node_modules/devextreme/esm/__internal/core/m_events_strategy.js
var EventsStrategy = class _EventsStrategy {
  constructor(owner) {
    let options2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    this._events = {};
    this._owner = owner;
    this._options = options2;
  }
  static create(owner, strategy3) {
    if (strategy3) {
      return isFunction(strategy3) ? strategy3(owner) : strategy3;
    }
    return new _EventsStrategy(owner);
  }
  hasEvent(eventName) {
    const callbacks2 = this._events[eventName];
    return callbacks2 ? callbacks2.has() : false;
  }
  fireEvent(eventName, eventArgs) {
    const callbacks2 = this._events[eventName];
    if (callbacks2) {
      callbacks2.fireWith(this._owner, eventArgs);
    }
    return this._owner;
  }
  on(eventName, eventHandler) {
    if (isPlainObject(eventName)) {
      each(eventName, (e, h3) => {
        this.on(e, h3);
      });
    } else {
      let callbacks2 = this._events[eventName];
      if (!callbacks2) {
        callbacks2 = callbacks_default({
          syncStrategy: this._options.syncStrategy
        });
        this._events[eventName] = callbacks2;
      }
      const addFn = callbacks2.originalAdd || callbacks2.add;
      addFn.call(callbacks2, eventHandler);
    }
  }
  off(eventName, eventHandler) {
    const callbacks2 = this._events[eventName];
    if (callbacks2) {
      if (isFunction(eventHandler)) {
        callbacks2.remove(eventHandler);
      } else {
        callbacks2.empty();
      }
    }
  }
  dispose() {
    each(this._events, (eventName, event) => {
      event.empty();
    });
  }
};

// node_modules/devextreme/esm/__internal/core/utils/m_ready_callbacks.js
var callbacks = [];
var subscribeReady = call_once_default(() => {
  const removeListener = dom_adapter_default.listen(dom_adapter_default.getDocument(), "DOMContentLoaded", () => {
    readyCallbacks.fire();
    removeListener();
  });
});
var readyCallbacks = {
  add: (callback) => {
    const windowExists = hasWindow();
    if (windowExists && "loading" !== dom_adapter_default.getReadyState()) {
      callback();
    } else {
      callbacks.push(callback);
      windowExists && subscribeReady();
    }
  },
  fire: () => {
    callbacks.forEach((callback) => callback());
    callbacks = [];
  }
};
var readyCallbacksModule = dependency_injector_default(readyCallbacks);
var m_ready_callbacks_default = readyCallbacksModule;

// node_modules/devextreme/esm/core/utils/ready_callbacks.js
var ready_callbacks_default = readyCallbacksModule;

// node_modules/devextreme/esm/__internal/core/utils/m_resize_callbacks.js
var resizeCallbacks = function() {
  let prevSize;
  const callbacks2 = m_callbacks_default();
  const originalCallbacksAdd = callbacks2.add;
  const originalCallbacksRemove = callbacks2.remove;
  if (!m_window_default.hasWindow()) {
    return callbacks2;
  }
  const formatSize = function() {
    const window31 = m_window_default.getWindow();
    return {
      width: window31.innerWidth,
      height: window31.innerHeight
    };
  };
  const handleResize = function() {
    const now = formatSize();
    if (now.width === prevSize.width && now.height === prevSize.height) {
      return;
    }
    let changedDimension;
    if (now.width === prevSize.width) {
      changedDimension = "height";
    }
    if (now.height === prevSize.height) {
      changedDimension = "width";
    }
    prevSize = now;
    callbacks2.fire(changedDimension);
  };
  const setPrevSize = call_once_default(function() {
    prevSize = formatSize();
  });
  let removeListener;
  callbacks2.add = function() {
    const result2 = originalCallbacksAdd.apply(callbacks2, arguments);
    setPrevSize();
    m_ready_callbacks_default.add(function() {
      if (!removeListener && callbacks2.has()) {
        removeListener = dom_adapter_default.listen(m_window_default.getWindow(), "resize", handleResize);
      }
    });
    return result2;
  };
  callbacks2.remove = function() {
    const result2 = originalCallbacksRemove.apply(callbacks2, arguments);
    if (!callbacks2.has() && removeListener) {
      removeListener();
      removeListener = void 0;
    }
    return result2;
  };
  return callbacks2;
}();

// node_modules/devextreme/esm/core/utils/resize_callbacks.js
var resize_callbacks_default = resizeCallbacks;

// node_modules/devextreme/esm/__internal/core/utils/m_storage.js
var window6 = getWindow();
var getSessionStorage = function() {
  let sessionStorage;
  try {
    sessionStorage = window6.sessionStorage;
  } catch (e) {
  }
  return sessionStorage;
};

// node_modules/devextreme/esm/__internal/core/utils/m_view_port.js
var ready = ready_callbacks_default.add;
var changeCallback = callbacks_default();
var $originalViewPort = renderer_default();
var value = /* @__PURE__ */ function() {
  let $current;
  return function(element) {
    if (!arguments.length) {
      return $current;
    }
    const $element = renderer_default(element);
    $originalViewPort = $element;
    const isNewViewportFound = !!$element.length;
    const prevViewPort = value();
    $current = isNewViewportFound ? $element : renderer_default("body");
    changeCallback.fire(isNewViewportFound ? value() : renderer_default(), prevViewPort);
  };
}();
ready(function() {
  value(".dx-viewport");
});
function originalViewPort() {
  return $originalViewPort;
}

// node_modules/devextreme/esm/__internal/core/m_devices.js
var window7 = getWindow();
var KNOWN_UA_TABLE = {
  iPhone: "iPhone",
  iPhone5: "iPhone",
  iPhone6: "iPhone",
  iPhone6plus: "iPhone",
  iPad: "iPad",
  iPadMini: "iPad Mini",
  androidPhone: "Android Mobile",
  androidTablet: "Android",
  msSurface: "Windows ARM Tablet PC",
  desktop: "desktop"
};
var DEFAULT_DEVICE = {
  deviceType: "desktop",
  platform: "generic",
  version: [],
  phone: false,
  tablet: false,
  android: false,
  ios: false,
  generic: true,
  grade: "A",
  mac: false
};
var UA_PARSERS = {
  generic(userAgent) {
    const isPhone = /windows phone/i.test(userAgent) || userAgent.match(/WPDesktop/);
    const isTablet = !isPhone && /Windows(.*)arm(.*)Tablet PC/i.test(userAgent);
    const isDesktop = !isPhone && !isTablet && /msapphost/i.test(userAgent);
    const isMac = /((intel|ppc) mac os x)/.test(userAgent.toLowerCase());
    if (!(isPhone || isTablet || isDesktop || isMac)) {
      return null;
    }
    return {
      deviceType: isPhone ? "phone" : isTablet ? "tablet" : "desktop",
      platform: "generic",
      version: [],
      grade: "A",
      mac: isMac
    };
  },
  appleTouchDevice(userAgent) {
    const navigator2 = getNavigator();
    const isIpadOs = /Macintosh/i.test(userAgent) && (null === navigator2 || void 0 === navigator2 ? void 0 : navigator2.maxTouchPoints) > 2;
    const isAppleDevice = /ip(hone|od|ad)/i.test(userAgent);
    if (!isAppleDevice && !isIpadOs) {
      return null;
    }
    const isPhone = /ip(hone|od)/i.test(userAgent);
    const matches = userAgent.match(/os\s{0,}X? (\d+)_(\d+)_?(\d+)?/i);
    const version2 = matches ? [parseInt(matches[1], 10), parseInt(matches[2], 10), parseInt(matches[3] || 0, 10)] : [];
    const isIPhone4 = 480 === window7.screen.height;
    const grade = isIPhone4 ? "B" : "A";
    return {
      deviceType: isPhone ? "phone" : "tablet",
      platform: "ios",
      version: version2,
      grade
    };
  },
  android(userAgent) {
    const isAndroid = /android|htc_|silk/i.test(userAgent);
    const isWinPhone = /windows phone/i.test(userAgent);
    if (!isAndroid || isWinPhone) {
      return null;
    }
    const isPhone = /mobile/i.test(userAgent);
    const matches = userAgent.match(/android (\d+)\.?(\d+)?\.?(\d+)?/i);
    const version2 = matches ? [parseInt(matches[1], 10), parseInt(matches[2] || 0, 10), parseInt(matches[3] || 0, 10)] : [];
    const worseThan4_4 = version2.length > 1 && (version2[0] < 4 || 4 === version2[0] && version2[1] < 4);
    const grade = worseThan4_4 ? "B" : "A";
    return {
      deviceType: isPhone ? "phone" : "tablet",
      platform: "android",
      version: version2,
      grade
    };
  }
};
var UA_PARSERS_ARRAY = [UA_PARSERS.appleTouchDevice, UA_PARSERS.android, UA_PARSERS.generic];
var Devices = class {
  constructor(options2) {
    this._window = (null === options2 || void 0 === options2 ? void 0 : options2.window) ?? window7;
    this._realDevice = this._getDevice();
    this._currentDevice = void 0;
    this._currentOrientation = void 0;
    this._eventsStrategy = new EventsStrategy(this);
    this.changed = callbacks_default();
    if (hasWindow()) {
      ready_callbacks_default.add(this._recalculateOrientation.bind(this));
      resize_callbacks_default.add(this._recalculateOrientation.bind(this));
    }
  }
  current(deviceOrName) {
    if (deviceOrName) {
      this._currentDevice = this._getDevice(deviceOrName);
      this._forced = true;
      this.changed.fire();
      return;
    }
    if (!this._currentDevice) {
      deviceOrName = void 0;
      try {
        deviceOrName = this._getDeviceOrNameFromWindowScope();
      } catch (e) {
        deviceOrName = this._getDeviceNameFromSessionStorage();
      } finally {
        if (!deviceOrName) {
          deviceOrName = this._getDeviceNameFromSessionStorage();
        }
        if (deviceOrName) {
          this._forced = true;
        }
      }
      this._currentDevice = this._getDevice(deviceOrName);
    }
    return this._currentDevice;
  }
  real(forceDevice) {
    return extend({}, this._realDevice);
  }
  orientation() {
    return this._currentOrientation;
  }
  isForced() {
    return this._forced;
  }
  isRippleEmulator() {
    return !!this._window.tinyHippos;
  }
  _getCssClasses(device) {
    const result2 = [];
    const realDevice2 = this._realDevice;
    device = device || this.current();
    if (device.deviceType) {
      result2.push(`dx-device-${device.deviceType}`);
      if ("desktop" !== device.deviceType) {
        result2.push("dx-device-mobile");
      }
    }
    result2.push(`dx-device-${realDevice2.platform}`);
    if (realDevice2.version && realDevice2.version.length) {
      result2.push(`dx-device-${realDevice2.platform}-${realDevice2.version[0]}`);
    }
    if (this.isSimulator()) {
      result2.push("dx-simulator");
    }
    if (config_default2().rtlEnabled) {
      result2.push("dx-rtl");
    }
    return result2;
  }
  attachCssClasses(element, device) {
    this._deviceClasses = this._getCssClasses(device).join(" ");
    renderer_default(element).addClass(this._deviceClasses);
  }
  detachCssClasses(element) {
    renderer_default(element).removeClass(this._deviceClasses);
  }
  isSimulator() {
    try {
      var _this$_window$top;
      return this._isSimulator || hasWindow() && this._window.top !== this._window.self && (null === (_this$_window$top = this._window.top) || void 0 === _this$_window$top ? void 0 : _this$_window$top["dx-force-device"]) || this.isRippleEmulator();
    } catch (e) {
      return false;
    }
  }
  forceSimulator() {
    this._isSimulator = true;
  }
  _getDevice(deviceName) {
    if ("genericPhone" === deviceName) {
      deviceName = {
        deviceType: "phone",
        platform: "generic",
        generic: true
      };
    }
    if (isPlainObject(deviceName)) {
      return this._fromConfig(deviceName);
    }
    let ua;
    if (deviceName) {
      ua = KNOWN_UA_TABLE[deviceName];
      if (!ua) {
        throw errors_default.Error("E0005");
      }
    } else {
      const navigator2 = getNavigator();
      ua = navigator2.userAgent;
    }
    return this._fromUA(ua);
  }
  _getDeviceOrNameFromWindowScope() {
    var _this$_window$top2, _this$_window$top3;
    let result2;
    if (hasWindow() && (null !== (_this$_window$top2 = this._window.top) && void 0 !== _this$_window$top2 && _this$_window$top2["dx-force-device-object"] || null !== (_this$_window$top3 = this._window.top) && void 0 !== _this$_window$top3 && _this$_window$top3["dx-force-device"])) {
      var _this$_window$top4, _this$_window$top5;
      result2 = (null === (_this$_window$top4 = this._window.top) || void 0 === _this$_window$top4 ? void 0 : _this$_window$top4["dx-force-device-object"]) || (null === (_this$_window$top5 = this._window.top) || void 0 === _this$_window$top5 ? void 0 : _this$_window$top5["dx-force-device"]);
    }
    return result2;
  }
  _getDeviceNameFromSessionStorage() {
    const sessionStorage = getSessionStorage();
    if (!sessionStorage) {
      return;
    }
    const deviceOrName = sessionStorage.getItem("dx-force-device");
    try {
      return JSON.parse(deviceOrName);
    } catch (ex) {
      return deviceOrName;
    }
  }
  _fromConfig(config3) {
    const result2 = extend({}, DEFAULT_DEVICE, this._currentDevice, config3);
    const shortcuts = {
      phone: "phone" === result2.deviceType,
      tablet: "tablet" === result2.deviceType,
      android: "android" === result2.platform,
      ios: "ios" === result2.platform,
      generic: "generic" === result2.platform
    };
    return extend(result2, shortcuts);
  }
  _fromUA(ua) {
    for (let idx = 0; idx < UA_PARSERS_ARRAY.length; idx += 1) {
      const parser = UA_PARSERS_ARRAY[idx];
      const config3 = parser(ua);
      if (config3) {
        return this._fromConfig(config3);
      }
    }
    return DEFAULT_DEVICE;
  }
  _changeOrientation() {
    const $window = renderer_default(this._window);
    const orientation = getHeight($window) > getWidth($window) ? "portrait" : "landscape";
    if (this._currentOrientation === orientation) {
      return;
    }
    this._currentOrientation = orientation;
    this._eventsStrategy.fireEvent("orientationChanged", [{
      orientation
    }]);
  }
  _recalculateOrientation() {
    const windowWidth = getWidth(this._window);
    if (this._currentWidth === windowWidth) {
      return;
    }
    this._currentWidth = windowWidth;
    this._changeOrientation();
  }
  on(eventName, eventHandler) {
    this._eventsStrategy.on(eventName, eventHandler);
    return this;
  }
  off(eventName, eventHandler) {
    this._eventsStrategy.off(eventName, eventHandler);
    return this;
  }
};
var devices = new Devices();
when(uiLayerInitialized).done(() => {
  const viewPortElement = value();
  if (viewPortElement) {
    devices.attachCssClasses(viewPortElement);
  }
  changeCallback.add((viewPort2, prevViewport) => {
    devices.detachCssClasses(prevViewport);
    devices.attachCssClasses(viewPort2);
  });
});
var m_devices_default = devices;

// node_modules/devextreme/esm/__internal/core/utils/m_support.js
var {
  maxTouchPoints
} = getNavigator();
var transitionEndEventNames = {
  webkitTransition: "webkitTransitionEnd",
  MozTransition: "transitionend",
  OTransition: "oTransitionEnd",
  transition: "transitionend"
};
var supportProp = function(prop) {
  return !!styleProp(prop);
};
var isNativeScrollingSupported = function() {
  const {
    platform,
    mac: isMac
  } = m_devices_default.real();
  const isNativeScrollDevice = "ios" === platform || "android" === platform || isMac;
  return isNativeScrollDevice;
};
var inputType = function(type2) {
  if ("text" === type2) {
    return true;
  }
  const input = dom_adapter_default.createElement("input");
  try {
    input.setAttribute("type", type2);
    input.value = "wrongValue";
    return !input.value;
  } catch (e) {
    return false;
  }
};
var detectTouchEvents = function(hasWindowProperty, maxTouchPoints2) {
  return (hasWindowProperty("ontouchstart") || !!maxTouchPoints2) && !hasWindowProperty("callPhantom");
};
var detectPointerEvent = function(hasWindowProperty) {
  return hasWindowProperty("PointerEvent");
};
var touchEvents = detectTouchEvents(hasProperty, maxTouchPoints);
var pointerEvents = detectPointerEvent(hasProperty);
var touchPointersPresent = !!maxTouchPoints;
var touch = touchEvents || pointerEvents && touchPointersPresent;
var transition = call_once_default(function() {
  return supportProp("transition");
});
var transitionEndEventName = call_once_default(function() {
  return transitionEndEventNames[styleProp("transition")];
});
var animation = call_once_default(function() {
  return supportProp("animation");
});
var nativeScrolling = isNativeScrollingSupported();
var m_support_default = {
  animation,
  inputType,
  nativeScrolling,
  pointerEvents,
  styleProp,
  stylePropPrefix,
  supportProp,
  touch,
  touchEvents,
  transition,
  transitionEndEventName
};

// node_modules/devextreme/esm/__internal/core/utils/m_position.js
var getDefaultAlignment = (isRtlEnabled) => {
  const rtlEnabled = isRtlEnabled ?? config_default2().rtlEnabled;
  return rtlEnabled ? "right" : "left";
};
var getBoundingRect = (element) => {
  var _element$getBoundingC;
  if (isWindow(element)) {
    return {
      width: element.outerWidth,
      height: element.outerHeight
    };
  }
  return null === (_element$getBoundingC = element.getBoundingClientRect) || void 0 === _element$getBoundingC ? void 0 : _element$getBoundingC.call(element);
};

// node_modules/devextreme/esm/__internal/core/utils/m_browser.js
var navigator = getNavigator();
var webkitRegExp = /(webkit)[ /]([\w.]+)/;
var mozillaRegExp = /(mozilla)(?:.*? rv:([\w.]+))/;
var browserFromUA = (ua) => {
  ua = ua.toLowerCase();
  const result2 = {};
  const matches = webkitRegExp.exec(ua) || ua.indexOf("compatible") < 0 && mozillaRegExp.exec(ua) || [];
  let browserName = matches[1];
  let browserVersion = matches[2];
  if ("webkit" === browserName) {
    result2.webkit = true;
    if (ua.indexOf("chrome") >= 0 || ua.indexOf("crios") >= 0) {
      browserName = "chrome";
      browserVersion = /(?:chrome|crios)\/(\d+\.\d+)/.exec(ua);
      browserVersion = browserVersion && browserVersion[1];
    } else if (ua.indexOf("fxios") >= 0) {
      browserName = "mozilla";
      browserVersion = /fxios\/(\d+\.\d+)/.exec(ua);
      browserVersion = browserVersion && browserVersion[1];
    } else if (ua.indexOf("safari") >= 0 && /version|phantomjs/.test(ua)) {
      browserName = "safari";
      browserVersion = /(?:version|phantomjs)\/([0-9.]+)/.exec(ua);
      browserVersion = browserVersion && browserVersion[1];
    } else {
      browserName = "unknown";
      browserVersion = /applewebkit\/([0-9.]+)/.exec(ua);
      browserVersion = browserVersion && browserVersion[1];
    }
  }
  if (browserName) {
    result2[browserName] = true;
    result2.version = browserVersion;
  }
  return result2;
};
var browser = extend({
  _fromUA: browserFromUA
}, browserFromUA(navigator.userAgent));

// node_modules/devextreme/esm/core/utils/browser.js
var browser_default = browser;

// node_modules/devextreme/esm/common/core/environment/hide_callback.js
var hideCallback = /* @__PURE__ */ function() {
  let callbacks2 = [];
  return {
    add: function(callback) {
      if (!callbacks2.includes(callback)) {
        callbacks2.push(callback);
      }
    },
    remove: function(callback) {
      const indexOfCallback = callbacks2.indexOf(callback);
      if (-1 !== indexOfCallback) {
        callbacks2.splice(indexOfCallback, 1);
      }
    },
    fire: function() {
      const callback = callbacks2.pop();
      const result2 = !!callback;
      if (result2) {
        callback();
      }
      return result2;
    },
    hasCallback: function() {
      return callbacks2.length > 0;
    }
  };
}();

// node_modules/devextreme/esm/common/core/environment/init_mobile_viewport/init_mobile_viewport.js
var window8 = getWindow();

// node_modules/devextreme/esm/__internal/core/utils/date.js
var addOffsets = (date, offsets) => {
  const newDateMs = offsets.reduce((result2, offset2) => result2 + offset2, date.getTime());
  return new Date(newDateMs);
};
var isValidDate = (date) => Boolean(date && !isNaN(new Date(date).valueOf()));
var dateUtilsTs = {
  addOffsets,
  isValidDate
};

// node_modules/devextreme/esm/__internal/scheduler/utils/macro_task_array/dispatcher.js
var macroTaskIdSet = /* @__PURE__ */ new Set();
var schedule = async (callback, macroTaskTimeoutMs) => new Promise((resolve) => {
  const taskId = setTimeout(() => {
    callback();
    macroTaskIdSet.delete(taskId);
    resolve();
  }, macroTaskTimeoutMs);
  macroTaskIdSet.add(taskId);
});
var dispose = () => {
  Array.from(macroTaskIdSet).forEach((id) => {
    clearTimeout(id);
    macroTaskIdSet.delete(id);
  });
};
var dispatcher_default = {
  schedule,
  dispose
};

// node_modules/devextreme/esm/__internal/scheduler/utils/macro_task_array/methods.js
var macroTaskArrayForEach = async function(array, callback) {
  let step = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 100;
  let macroTaskTimeoutMs = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0;
  const promises = [];
  const batchesCount = Math.ceil(array.length / step);
  for (let batchIdx = 0; batchIdx < batchesCount; batchIdx += 1) {
    const scheduledTask = dispatcher_default.schedule(() => {
      const startIdx = batchIdx * step;
      const maxIdx = startIdx + step;
      for (let idx = startIdx; idx < maxIdx && void 0 !== array[idx]; idx += 1) {
        callback(array[idx]);
      }
    }, macroTaskTimeoutMs);
    promises.push(scheduledTask);
  }
  await Promise.all(promises);
};
var macroTaskArrayMap = async function(array, callback) {
  let step = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 100;
  let macroTaskTimeoutMs = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0;
  const result2 = [];
  await macroTaskArrayForEach(array, (item) => {
    result2.push(callback(item));
  }, step, macroTaskTimeoutMs);
  return result2;
};

// node_modules/devextreme/esm/__internal/scheduler/utils/macro_task_array/index.js
var macro_task_array_default = {
  forEach: macroTaskArrayForEach,
  map: macroTaskArrayMap,
  dispose: dispatcher_default.dispose
};

// node_modules/devextreme/esm/common/core/localization/default_date_names.js
var MONTHS = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
var DAYS = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
var PERIODS = ["AM", "PM"];
var QUARTERS = ["Q1", "Q2", "Q3", "Q4"];
var cutCaptions = (captions, format2) => {
  const lengthByFormat = {
    abbreviated: 3,
    short: 2,
    narrow: 1
  };
  return map(captions, (caption) => caption.substr(0, lengthByFormat[format2]));
};
var default_date_names_default = {
  getMonthNames: function(format2) {
    return cutCaptions(MONTHS, format2);
  },
  getDayNames: function(format2) {
    return cutCaptions(DAYS, format2);
  },
  getQuarterNames: function(format2) {
    return QUARTERS;
  },
  getPeriodNames: function(format2) {
    return PERIODS;
  }
};

// node_modules/devextreme/esm/common/core/localization/ldml/date.formatter.js
function leftPad(text, length) {
  while (text.length < length) {
    text = "0" + text;
  }
  return text;
}
var FORMAT_TYPES = {
  3: "abbreviated",
  4: "wide",
  5: "narrow"
};
var LDML_FORMATTERS = {
  y: function(date, count, useUtc) {
    let year = date[useUtc ? "getUTCFullYear" : "getFullYear"]();
    if (2 === count) {
      year %= 100;
    }
    return leftPad(year.toString(), count);
  },
  M: function(date, count, useUtc, dateParts) {
    const month = date[useUtc ? "getUTCMonth" : "getMonth"]();
    const formatType = FORMAT_TYPES[count];
    if (formatType) {
      return dateParts.getMonthNames(formatType, "format")[month];
    }
    return leftPad((month + 1).toString(), Math.min(count, 2));
  },
  L: function(date, count, useUtc, dateParts) {
    const month = date[useUtc ? "getUTCMonth" : "getMonth"]();
    const formatType = FORMAT_TYPES[count];
    if (formatType) {
      return dateParts.getMonthNames(formatType, "standalone")[month];
    }
    return leftPad((month + 1).toString(), Math.min(count, 2));
  },
  Q: function(date, count, useUtc, dateParts) {
    const month = date[useUtc ? "getUTCMonth" : "getMonth"]();
    const quarter = Math.floor(month / 3);
    const formatType = FORMAT_TYPES[count];
    if (formatType) {
      return dateParts.getQuarterNames(formatType)[quarter];
    }
    return leftPad((quarter + 1).toString(), Math.min(count, 2));
  },
  E: function(date, count, useUtc, dateParts) {
    const day = date[useUtc ? "getUTCDay" : "getDay"]();
    const formatType = FORMAT_TYPES[count < 3 ? 3 : count];
    return dateParts.getDayNames(formatType)[day];
  },
  a: function(date, count, useUtc, dateParts) {
    const hours = date[useUtc ? "getUTCHours" : "getHours"]();
    const period = hours < 12 ? 0 : 1;
    const formatType = FORMAT_TYPES[count];
    return dateParts.getPeriodNames(formatType)[period];
  },
  d: function(date, count, useUtc) {
    return leftPad(date[useUtc ? "getUTCDate" : "getDate"]().toString(), Math.min(count, 2));
  },
  H: function(date, count, useUtc) {
    return leftPad(date[useUtc ? "getUTCHours" : "getHours"]().toString(), Math.min(count, 2));
  },
  h: function(date, count, useUtc) {
    const hours = date[useUtc ? "getUTCHours" : "getHours"]();
    return leftPad((hours % 12 || 12).toString(), Math.min(count, 2));
  },
  m: function(date, count, useUtc) {
    return leftPad(date[useUtc ? "getUTCMinutes" : "getMinutes"]().toString(), Math.min(count, 2));
  },
  s: function(date, count, useUtc) {
    return leftPad(date[useUtc ? "getUTCSeconds" : "getSeconds"]().toString(), Math.min(count, 2));
  },
  S: function(date, count, useUtc) {
    return leftPad(date[useUtc ? "getUTCMilliseconds" : "getMilliseconds"]().toString(), 3).substr(0, count);
  },
  x: function(date, count, useUtc) {
    const timezoneOffset = useUtc ? 0 : date.getTimezoneOffset();
    const signPart = timezoneOffset > 0 ? "-" : "+";
    const timezoneOffsetAbs = Math.abs(timezoneOffset);
    const hours = Math.floor(timezoneOffsetAbs / 60);
    const minutes = timezoneOffsetAbs % 60;
    const hoursPart = leftPad(hours.toString(), 2);
    const minutesPart = leftPad(minutes.toString(), 2);
    return signPart + hoursPart + (count >= 3 ? ":" : "") + (count > 1 || minutes ? minutesPart : "");
  },
  X: function(date, count, useUtc) {
    if (useUtc || !date.getTimezoneOffset()) {
      return "Z";
    }
    return LDML_FORMATTERS.x(date, count, useUtc);
  },
  Z: function(date, count, useUtc) {
    return LDML_FORMATTERS.X(date, count >= 5 ? 3 : 2, useUtc);
  }
};
var getFormatter = function(format2, dateParts) {
  return function(date) {
    let charIndex;
    let formatter;
    let char;
    let charCount = 0;
    let isEscaping = false;
    let isCurrentCharEqualsNext;
    let result2 = "";
    if (!date) {
      return null;
    }
    if (!format2) {
      return date;
    }
    const useUtc = "Z" === format2[format2.length - 1] || "'Z'" === format2.slice(-3);
    for (charIndex = 0; charIndex < format2.length; charIndex++) {
      char = format2[charIndex];
      formatter = LDML_FORMATTERS[char];
      isCurrentCharEqualsNext = char === format2[charIndex + 1];
      charCount++;
      if (!isCurrentCharEqualsNext) {
        if (formatter && !isEscaping) {
          result2 += formatter(date, charCount, useUtc, dateParts);
        }
        charCount = 0;
      }
      if ("'" === char && !isCurrentCharEqualsNext) {
        isEscaping = !isEscaping;
      } else if (isEscaping || !formatter) {
        result2 += char;
      }
      if ("'" === char && isCurrentCharEqualsNext) {
        charIndex++;
      }
    }
    return result2;
  };
};

// node_modules/devextreme/esm/__internal/core/utils/m_date_serialization.js
var ISO8601_PATTERN = /^(\d{4,})(-)?(\d{2})(-)?(\d{2})(?:T(\d{2})(:)?(\d{2})?(:)?(\d{2}(?:\.(\d{1,3})\d*)?)?)?(Z|([+-])(\d{2})(:)?(\d{2})?)?$/;
var ISO8601_TIME_PATTERN = /^(\d{2}):(\d{2})(:(\d{2}))?$/;
var ISO8601_PATTERN_PARTS = ["", "yyyy", "", "MM", "", "dd", "THH", "", "mm", "", "ss", ".SSS"];
var DATE_SERIALIZATION_PATTERN = /^(\d{4})\/(\d{2})\/(\d{2})$/;
var dateParser = function(text, skipISO8601Parsing) {
  let result2;
  if (isString(text) && !skipISO8601Parsing) {
    result2 = parseISO8601String(text);
  }
  return result2 || parseDate(text);
};
function getTimePart(part) {
  return +part || 0;
}
function parseDate(text) {
  const isDefaultSerializationFormat = "yyyy/MM/dd" === getDateSerializationFormat(text);
  const parsedValue = !isDate(text) && Date.parse(text);
  if (!parsedValue && isDefaultSerializationFormat) {
    const parts = text.match(DATE_SERIALIZATION_PATTERN);
    if (parts) {
      const newDate = new Date(getTimePart(parts[1]), getTimePart(parts[2]), getTimePart(parts[3]));
      newDate.setFullYear(getTimePart(parts[1]));
      newDate.setMonth(getTimePart(parts[2]) - 1);
      newDate.setDate(getTimePart(parts[3]));
      return newDate;
    }
  }
  return isNumeric(parsedValue) ? new Date(parsedValue) : text;
}
function parseISO8601String(text) {
  let parts = text.match(ISO8601_PATTERN);
  if (!parts) {
    parts = text.match(ISO8601_TIME_PATTERN);
    if (parts) {
      return new Date(0, 0, 0, getTimePart(parts[1]), getTimePart(parts[2]), getTimePart(parts[4]));
    }
    return;
  }
  const year = getTimePart(parts[1]);
  const month = --parts[3];
  const day = parts[5];
  let timeZoneHour = 0;
  let timeZoneMinute = 0;
  const correctYear = (d) => {
    year < 100 && d.setFullYear(year);
    return d;
  };
  timeZoneHour = getTimePart(parts[14]);
  timeZoneMinute = getTimePart(parts[16]);
  if ("-" === parts[13]) {
    timeZoneHour = -timeZoneHour;
    timeZoneMinute = -timeZoneMinute;
  }
  const hour = getTimePart(parts[6]) - timeZoneHour;
  const minute = getTimePart(parts[8]) - timeZoneMinute;
  const second = getTimePart(parts[10]);
  const millisecond = function(part) {
    part = part || "";
    return getTimePart(part) * 10 ** (3 - part.length);
  }(parts[11]);
  if (parts[12]) {
    return correctYear(new Date(Date.UTC(year, month, day, hour, minute, second, millisecond)));
  }
  return correctYear(new Date(year, month, day, hour, minute, second, millisecond));
}
var getIso8601Format = function(text, useUtc) {
  let parts = text.match(ISO8601_PATTERN);
  let result2 = "";
  if (!parts) {
    parts = text.match(ISO8601_TIME_PATTERN);
    if (parts) {
      return parts[3] ? "HH:mm:ss" : "HH:mm";
    }
    return;
  }
  for (let i = 1; i < ISO8601_PATTERN_PARTS.length; i++) {
    if (parts[i]) {
      result2 += ISO8601_PATTERN_PARTS[i] || parts[i];
    }
  }
  if ("Z" === parts[12]) {
    result2 += "'Z'";
  }
  if (parts[14]) {
    if (parts[15]) {
      result2 += "xxx";
    } else if (parts[16]) {
      result2 += "xx";
    } else {
      result2 += "x";
    }
  }
  return result2;
};
var deserializeDate = function(value2) {
  if ("number" === typeof value2) {
    return new Date(value2);
  }
  return dateParser(value2, !config_default2().forceIsoDateParsing);
};
var serializeDate = function(value2, serializationFormat) {
  if (!serializationFormat) {
    return value2;
  }
  if (!isDate(value2)) {
    return null;
  }
  if ("number" === serializationFormat) {
    return value2 && value2.valueOf ? value2.valueOf() : null;
  }
  return getFormatter(serializationFormat, default_date_names_default)(value2);
};
var getDateSerializationFormat = function(value2) {
  if ("number" === typeof value2) {
    return "number";
  }
  if (isString(value2)) {
    let format2;
    if (config_default2().forceIsoDateParsing) {
      format2 = getIso8601Format(value2);
    }
    if (format2) {
      return format2;
    }
    if (value2.includes(":")) {
      return "yyyy/MM/dd HH:mm:ss";
    }
    return "yyyy/MM/dd";
  }
  if (value2) {
    return null;
  }
};
var dateSerialization = {
  dateParser,
  deserializeDate,
  serializeDate,
  getDateSerializationFormat
};

// node_modules/devextreme/esm/core/utils/date_serialization.js
var date_serialization_default = dateSerialization;

// node_modules/devextreme/esm/__internal/core/utils/m_math.js
var sign = function(value2) {
  if (0 === value2) {
    return 0;
  }
  return value2 / Math.abs(value2);
};
var fitIntoRange = function(value2, minValue, maxValue) {
  const isMinValueUndefined = !minValue && 0 !== minValue;
  const isMaxValueUndefined = !maxValue && 0 !== maxValue;
  isMinValueUndefined && (minValue = !isMaxValueUndefined ? Math.min(value2, maxValue) : value2);
  isMaxValueUndefined && (maxValue = !isMinValueUndefined ? Math.max(value2, minValue) : value2);
  return Math.min(Math.max(value2, minValue), maxValue);
};
var inRange = function(value2, minValue, maxValue) {
  return value2 >= minValue && value2 <= maxValue;
};
function getExponent(value2) {
  return Math.abs(parseInt(value2.toExponential().split("e")[1], 10));
}
function getExponentialNotation(value2) {
  const parts = value2.toExponential().split("e");
  const mantissa = parseFloat(parts[0]);
  const exponent = parseInt(parts[1], 10);
  return {
    exponent,
    mantissa
  };
}
function multiplyInExponentialForm(value2, exponentShift) {
  const exponentialNotation = getExponentialNotation(value2);
  return parseFloat(`${exponentialNotation.mantissa}e${exponentialNotation.exponent + exponentShift}`);
}
function isEdgeBug() {
  return "0.000300" !== 3e-4.toPrecision(3);
}
function adjust(value2, interval) {
  let precision = getPrecision(interval || 0) + 2;
  const separatedValue = value2.toString().split(".");
  const sourceValue = value2;
  const absValue = Math.abs(value2);
  let separatedAdjustedValue;
  const isExponentValue = isExponential(value2);
  const integerPart = absValue > 1 ? 10 : 0;
  if (1 === separatedValue.length) {
    return value2;
  }
  if (!isExponentValue) {
    if (isExponential(interval)) {
      precision = separatedValue[0].length + getExponent(interval);
    }
    value2 = absValue;
    value2 = value2 - Math.floor(value2) + integerPart;
  }
  precision = isEdgeBug() && getExponent(value2) > 6 || precision > 7 ? 15 : 7;
  if (!isExponentValue) {
    separatedAdjustedValue = parseFloat(value2.toPrecision(precision)).toString().split(".");
    if (separatedAdjustedValue[0] === integerPart.toString()) {
      return parseFloat(`${separatedValue[0]}.${separatedAdjustedValue[1]}`);
    }
  }
  return parseFloat(sourceValue.toPrecision(precision));
}
function getPrecision(value2) {
  const str = value2.toString();
  if (str.indexOf(".") < 0) {
    return 0;
  }
  const mantissa = str.split(".");
  const positionOfDelimiter = mantissa[1].indexOf("e");
  return positionOfDelimiter >= 0 ? positionOfDelimiter : mantissa[1].length;
}

// node_modules/devextreme/esm/__internal/utils/toMilliseconds.js
var timeIntervals = {
  millisecond: 1,
  second: 1e3,
  minute: 6e4,
  hour: 36e5,
  day: 864e5,
  week: 6048e5,
  month: 2592e6,
  quarter: 7776e6,
  year: 31536e6
};
function toMilliseconds(value2) {
  return timeIntervals[value2];
}

// node_modules/devextreme/esm/__internal/core/utils/m_date.js
var dateUnitIntervals = ["millisecond", "second", "minute", "hour", "day", "week", "month", "quarter", "year"];
var getDatesInterval = function(startDate, endDate, intervalUnit) {
  const delta = endDate.getTime() - startDate.getTime();
  const millisecondCount = toMilliseconds(intervalUnit) || 1;
  return Math.floor(delta / millisecondCount);
};
var getNextDateUnit = function(unit, withWeeks) {
  const interval = getDateUnitInterval(unit);
  switch (interval) {
    case "millisecond":
      return "second";
    case "second":
      return "minute";
    case "minute":
      return "hour";
    case "hour":
      return "day";
    case "day":
      return withWeeks ? "week" : "month";
    case "week":
      return "month";
    case "month":
      return "quarter";
    case "quarter":
    case "year":
      return "year";
    default:
      return 0;
  }
};
var convertMillisecondsToDateUnits = function(value2) {
  let i;
  let dateUnitCount;
  let dateUnitInterval;
  const dateUnitIntervals2 = ["millisecond", "second", "minute", "hour", "day", "month", "year"];
  const result2 = {};
  for (i = dateUnitIntervals2.length - 1; i >= 0; i--) {
    dateUnitInterval = dateUnitIntervals2[i];
    dateUnitCount = Math.floor(value2 / toMilliseconds(dateUnitInterval));
    if (dateUnitCount > 0) {
      result2[`${dateUnitInterval}s`] = dateUnitCount;
      value2 -= convertDateUnitToMilliseconds(dateUnitInterval, dateUnitCount);
    }
  }
  return result2;
};
var dateToMilliseconds = function(tickInterval) {
  let milliseconds = 0;
  if (isObject(tickInterval)) {
    each(tickInterval, function(key, value2) {
      milliseconds += convertDateUnitToMilliseconds(key.substr(0, key.length - 1), value2);
    });
  }
  if (isString(tickInterval)) {
    milliseconds = convertDateUnitToMilliseconds(tickInterval, 1);
  }
  return milliseconds;
};
function convertDateUnitToMilliseconds(dateUnit, count) {
  return toMilliseconds(dateUnit) * count;
}
function getDateUnitInterval(tickInterval) {
  let maxInterval = -1;
  let i;
  if (isString(tickInterval)) {
    return tickInterval;
  }
  if (isObject(tickInterval)) {
    each(tickInterval, function(key, value2) {
      for (i = 0; i < dateUnitIntervals.length; i++) {
        if (value2 && (key === `${dateUnitIntervals[i]}s` || key === dateUnitIntervals[i]) && maxInterval < i) {
          maxInterval = i;
        }
      }
    });
    return dateUnitIntervals[maxInterval];
  }
  return "";
}
var tickIntervalToFormatMap = {
  millisecond: "millisecond",
  second: "longtime",
  minute: "shorttime",
  hour: "shorttime",
  day: "day",
  week: "day",
  month: "month",
  quarter: "quarter",
  year: "year"
};
function getDateFormatByTickInterval(tickInterval) {
  return tickIntervalToFormatMap[getDateUnitInterval(tickInterval)] || "";
}
var getQuarter = function(month) {
  return Math.floor(month / 3);
};
var getFirstQuarterMonth = function(month) {
  return 3 * getQuarter(month);
};
function correctDateWithUnitBeginning(date, dateInterval, withCorrection, firstDayOfWeek) {
  date = new Date(date.getTime());
  const oldDate = new Date(date.getTime());
  let firstQuarterMonth;
  let month;
  const dateUnitInterval = getDateUnitInterval(dateInterval);
  switch (dateUnitInterval) {
    case "second":
      date = new Date(1e3 * Math.floor(oldDate.getTime() / 1e3));
      break;
    case "minute":
      date = new Date(6e4 * Math.floor(oldDate.getTime() / 6e4));
      break;
    case "hour":
      date = new Date(36e5 * Math.floor(oldDate.getTime() / 36e5));
      break;
    case "year":
      date.setMonth(0);
    case "month":
      date.setDate(1);
    case "day":
      date.setHours(0, 0, 0, 0);
      break;
    case "week":
      date = getFirstWeekDate(date, firstDayOfWeek || 0);
      date.setHours(0, 0, 0, 0);
      break;
    case "quarter":
      firstQuarterMonth = getFirstQuarterMonth(date.getMonth());
      month = date.getMonth();
      date.setDate(1);
      date.setHours(0, 0, 0, 0);
      if (month !== firstQuarterMonth) {
        date.setMonth(firstQuarterMonth);
      }
  }
  if (withCorrection && "hour" !== dateUnitInterval && "minute" !== dateUnitInterval && "second" !== dateUnitInterval) {
    fixTimezoneGap(oldDate, date);
  }
  return date;
}
function trimTime(date) {
  return correctDateWithUnitBeginning(date, "day");
}
var setToDayEnd = function(date) {
  const result2 = trimTime(date);
  result2.setDate(result2.getDate() + 1);
  return new Date(result2.getTime() - 1);
};
var getDatesDifferences = function(date1, date2) {
  let counter = 0;
  const differences = {
    year: date1.getFullYear() !== date2.getFullYear(),
    month: date1.getMonth() !== date2.getMonth(),
    day: date1.getDate() !== date2.getDate(),
    hour: date1.getHours() !== date2.getHours(),
    minute: date1.getMinutes() !== date2.getMinutes(),
    second: date1.getSeconds() !== date2.getSeconds(),
    millisecond: date1.getMilliseconds() !== date2.getMilliseconds()
  };
  each(differences, function(key, value2) {
    if (value2) {
      counter++;
    }
  });
  if (0 === counter && 0 !== getTimezonesDifference(date1, date2)) {
    differences.hour = true;
    counter++;
  }
  differences.count = counter;
  return differences;
};
function addDateInterval(value2, interval, dir) {
  const result2 = new Date(value2.getTime());
  const intervalObject = isString(interval) ? getDateIntervalByString(interval.toLowerCase()) : isNumeric(interval) ? convertMillisecondsToDateUnits(interval) : interval;
  if (intervalObject.years) {
    result2.setFullYear(result2.getFullYear() + intervalObject.years * dir);
  }
  if (intervalObject.quarters) {
    result2.setMonth(result2.getMonth() + 3 * intervalObject.quarters * dir);
  }
  if (intervalObject.months) {
    result2.setMonth(result2.getMonth() + intervalObject.months * dir);
  }
  if (intervalObject.weeks) {
    result2.setDate(result2.getDate() + 7 * intervalObject.weeks * dir);
  }
  if (intervalObject.days) {
    result2.setDate(result2.getDate() + intervalObject.days * dir);
  }
  if (intervalObject.hours) {
    result2.setTime(result2.getTime() + 36e5 * intervalObject.hours * dir);
  }
  if (intervalObject.minutes) {
    result2.setTime(result2.getTime() + 6e4 * intervalObject.minutes * dir);
  }
  if (intervalObject.seconds) {
    result2.setTime(result2.getTime() + 1e3 * intervalObject.seconds * dir);
  }
  if (intervalObject.milliseconds) {
    result2.setTime(result2.getTime() + intervalObject.milliseconds * dir);
  }
  return result2;
}
var addInterval = function(value2, interval, isNegative) {
  const dir = isNegative ? -1 : 1;
  return isDate(value2) ? addDateInterval(value2, interval, dir) : adjust(value2 + interval * dir, interval);
};
var getSequenceByInterval = function(min, max, interval) {
  const intervals = [];
  let cur;
  intervals.push(isDate(min) ? new Date(min.getTime()) : min);
  cur = min;
  while (cur < max) {
    cur = addInterval(cur, interval);
    intervals.push(cur);
  }
  return intervals;
};
var getViewFirstCellDate = function(viewType, date) {
  if ("month" === viewType) {
    return createDateWithFullYear(date.getFullYear(), date.getMonth(), 1);
  }
  if ("year" === viewType) {
    return createDateWithFullYear(date.getFullYear(), 0, date.getDate());
  }
  if ("decade" === viewType) {
    return createDateWithFullYear(getFirstYearInDecade(date), date.getMonth(), date.getDate());
  }
  if ("century" === viewType) {
    return createDateWithFullYear(getFirstDecadeInCentury(date), date.getMonth(), date.getDate());
  }
};
var getViewLastCellDate = function(viewType, date) {
  if ("month" === viewType) {
    return createDateWithFullYear(date.getFullYear(), date.getMonth(), getLastMonthDay(date));
  }
  if ("year" === viewType) {
    return createDateWithFullYear(date.getFullYear(), 11, date.getDate());
  }
  if ("decade" === viewType) {
    return createDateWithFullYear(getFirstYearInDecade(date) + 9, date.getMonth(), date.getDate());
  }
  if ("century" === viewType) {
    return createDateWithFullYear(getFirstDecadeInCentury(date) + 90, date.getMonth(), date.getDate());
  }
};
var getViewMinBoundaryDate = function(viewType, date) {
  const resultDate = createDateWithFullYear(date.getFullYear(), date.getMonth(), 1);
  if ("month" === viewType) {
    return resultDate;
  }
  resultDate.setMonth(0);
  if ("year" === viewType) {
    return resultDate;
  }
  if ("decade" === viewType) {
    resultDate.setFullYear(getFirstYearInDecade(date));
  }
  if ("century" === viewType) {
    resultDate.setFullYear(getFirstDecadeInCentury(date));
  }
  return resultDate;
};
var getViewMaxBoundaryDate = function(viewType, date) {
  const resultDate = new Date(date);
  resultDate.setDate(getLastMonthDay(date));
  if ("month" === viewType) {
    return resultDate;
  }
  resultDate.setMonth(11);
  resultDate.setDate(getLastMonthDay(resultDate));
  if ("year" === viewType) {
    return resultDate;
  }
  if ("decade" === viewType) {
    resultDate.setFullYear(getFirstYearInDecade(date) + 9);
  }
  if ("century" === viewType) {
    resultDate.setFullYear(getFirstDecadeInCentury(date) + 99);
  }
  return resultDate;
};
function getLastMonthDay(date) {
  const resultDate = createDateWithFullYear(date.getFullYear(), date.getMonth() + 1, 0);
  return resultDate.getDate();
}
var getViewUp = function(typeView) {
  switch (typeView) {
    case "month":
      return "year";
    case "year":
      return "decade";
    case "decade":
      return "century";
  }
};
var getViewDown = function(typeView) {
  switch (typeView) {
    case "century":
      return "decade";
    case "decade":
      return "year";
    case "year":
      return "month";
  }
};
var getDifferenceInMonth = function(typeView) {
  let difference = 1;
  if ("year" === typeView) {
    difference = 12;
  }
  if ("decade" === typeView) {
    difference = 120;
  }
  if ("century" === typeView) {
    difference = 1200;
  }
  return difference;
};
var getDifferenceInMonthForCells = function(typeView) {
  let difference = 1;
  if ("decade" === typeView) {
    difference = 12;
  }
  if ("century" === typeView) {
    difference = 120;
  }
  return difference;
};
function getDateIntervalByString(intervalString) {
  const result2 = {};
  switch (intervalString) {
    case "year":
      result2.years = 1;
      break;
    case "month":
      result2.months = 1;
      break;
    case "quarter":
      result2.months = 3;
      break;
    case "week":
      result2.weeks = 1;
      break;
    case "day":
      result2.days = 1;
      break;
    case "hour":
      result2.hours = 1;
      break;
    case "minute":
      result2.minutes = 1;
      break;
    case "second":
      result2.seconds = 1;
      break;
    case "millisecond":
      result2.milliseconds = 1;
  }
  return result2;
}
function sameDate(date1, date2) {
  return sameMonthAndYear(date1, date2) && date1.getDate() === date2.getDate();
}
function sameMonthAndYear(date1, date2) {
  return sameYear(date1, date2) && date1.getMonth() === date2.getMonth();
}
function sameYear(date1, date2) {
  return date1 && date2 && date1.getFullYear() === date2.getFullYear();
}
function sameHoursAndMinutes(date1, date2) {
  return date1 && date2 && date1.getHours() === date2.getHours() && date1.getMinutes() === date2.getMinutes();
}
var sameDecade = function(date1, date2) {
  if (!isDefined(date1) || !isDefined(date2)) {
    return;
  }
  const startDecadeDate1 = date1.getFullYear() - date1.getFullYear() % 10;
  const startDecadeDate2 = date2.getFullYear() - date2.getFullYear() % 10;
  return date1 && date2 && startDecadeDate1 === startDecadeDate2;
};
var sameCentury = function(date1, date2) {
  if (!isDefined(date1) || !isDefined(date2)) {
    return;
  }
  const startCenturyDate1 = date1.getFullYear() - date1.getFullYear() % 100;
  const startCenturyDate2 = date2.getFullYear() - date2.getFullYear() % 100;
  return date1 && date2 && startCenturyDate1 === startCenturyDate2;
};
var sameDatesArrays = (arr1, arr2) => {
  if (!Array.isArray(arr1) || !Array.isArray(arr2) || arr1.length !== arr2.length) {
    return false;
  }
  return arr1.every((date1, index2) => {
    const date2 = arr2[index2];
    if ([date1, date2].some((date) => null !== date && !(date instanceof Date))) {
      return false;
    }
    if (date1 instanceof Date && date2 instanceof Date) {
      return sameDate(date1, date2);
    }
    return date1 === date2;
  });
};
function getFirstDecadeInCentury(date) {
  return date && date.getFullYear() - date.getFullYear() % 100;
}
function getFirstYearInDecade(date) {
  return date && date.getFullYear() - date.getFullYear() % 10;
}
var getShortDateFormat = function() {
  return "yyyy/MM/dd";
};
var getFirstMonthDate = function(date) {
  let offset2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
  if (!isDefined(date)) {
    return;
  }
  const currentDate = new Date(date.getTime());
  const month = currentDate.getMonth() + offset2;
  currentDate.setMonth(month);
  return createDateWithFullYear(currentDate.getFullYear(), month, 1);
};
var getLastMonthDate = function(date) {
  let offset2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
  if (!isDefined(date)) {
    return;
  }
  const currentDate = new Date(date.getTime());
  const month = currentDate.getMonth() + offset2;
  currentDate.setMonth(month);
  return createDateWithFullYear(currentDate.getFullYear(), month + 1, 0);
};
function getFirstWeekDate(date, firstDayOfWeek) {
  const delta = (date.getDay() - firstDayOfWeek + 7) % 7;
  const result2 = new Date(date);
  result2.setDate(date.getDate() - delta);
  return result2;
}
function getUTCTime(date) {
  return Date.UTC(date.getFullYear(), date.getMonth(), date.getDate());
}
function getDayNumber(date) {
  const ms = getUTCTime(date) - getUTCTime(getFirstDateInYear(date.getFullYear()));
  return 1 + Math.floor(ms / toMilliseconds("day"));
}
function getFirstDateInYear(year) {
  return new Date(year, 0, 1);
}
function getLastDateInYear(year) {
  return new Date(year, 11, 31);
}
function getDayWeekNumber(date, firstDayOfWeek) {
  let day = date.getDay() - firstDayOfWeek + 1;
  if (day <= 0) {
    day += 7;
  }
  return day;
}
function getWeekNumber(date, firstDayOfWeek, rule) {
  const firstWeekDayInYear = getDayWeekNumber(getFirstDateInYear(date.getFullYear()), firstDayOfWeek);
  const lastWeekDayInYear = getDayWeekNumber(getLastDateInYear(date.getFullYear()), firstDayOfWeek);
  const daysInFirstWeek = 7 - firstWeekDayInYear + 1;
  let weekNumber = Math.ceil((getDayNumber(date) - daysInFirstWeek) / 7);
  switch (rule) {
    case "fullWeek":
      if (7 === daysInFirstWeek) {
        weekNumber++;
      }
      if (0 === weekNumber) {
        const lastDateInPreviousYear = getLastDateInYear(date.getFullYear() - 1);
        return getWeekNumber(lastDateInPreviousYear, firstDayOfWeek, rule);
      }
      return weekNumber;
    case "firstDay": {
      if (daysInFirstWeek > 0) {
        weekNumber++;
      }
      const isSunday = 7 === firstWeekDayInYear || 7 === lastWeekDayInYear;
      if (weekNumber > 52 && !isSunday || 54 === weekNumber) {
        weekNumber = 1;
      }
      return weekNumber;
    }
    case "firstFourDays": {
      if (daysInFirstWeek > 3) {
        weekNumber++;
      }
      const isThursday = 4 === firstWeekDayInYear || 4 === lastWeekDayInYear;
      if (weekNumber > 52 && !isThursday) {
        weekNumber = 1;
      }
      if (0 === weekNumber) {
        const lastDateInPreviousYear = getLastDateInYear(date.getFullYear() - 1);
        return getWeekNumber(lastDateInPreviousYear, firstDayOfWeek, rule);
      }
      return weekNumber;
    }
  }
}
var normalizeDateByWeek = function(date, currentDate) {
  const differenceInDays = dateUtils.getDatesInterval(date, currentDate, "day");
  let resultDate = new Date(date);
  if (differenceInDays >= 6) {
    resultDate = new Date(resultDate.setDate(resultDate.getDate() + 7));
  }
  return resultDate;
};
var dateInRange = function(date, min, max, format2) {
  if ("date" === format2) {
    min = min && dateUtils.correctDateWithUnitBeginning(min, "day");
    max = max && dateUtils.correctDateWithUnitBeginning(max, "day");
    date = date && dateUtils.correctDateWithUnitBeginning(date, "day");
  }
  return normalizeDate(date, min, max) === date;
};
var intervalsOverlap = function(options2) {
  const {
    firstMin,
    firstMax,
    secondMin,
    secondMax
  } = options2;
  return firstMin <= secondMin && secondMin <= firstMax || firstMin > secondMin && firstMin < secondMax || firstMin < secondMax && firstMax > secondMax;
};
var dateTimeFromDecimal = function(number) {
  const hours = Math.floor(number);
  const minutes = number % 1 * 60;
  return {
    hours,
    minutes
  };
};
var roundDateByStartDayHour = function(date, startDayHour) {
  const startTime = this.dateTimeFromDecimal(startDayHour);
  const result2 = new Date(date);
  if (date.getHours() === startTime.hours && date.getMinutes() < startTime.minutes || date.getHours() < startTime.hours) {
    result2.setHours(startTime.hours, startTime.minutes, 0, 0);
  }
  return result2;
};
function normalizeDate(date, min, max) {
  let normalizedDate = date;
  if (!isDefined(date)) {
    return date;
  }
  if (isDefined(min) && date < min) {
    normalizedDate = min;
  }
  if (isDefined(max) && date > max) {
    normalizedDate = max;
  }
  return normalizedDate;
}
function fixTimezoneGap(oldDate, newDate) {
  if (!isDefined(oldDate)) {
    return;
  }
  const diff = newDate.getHours() - oldDate.getHours();
  if (0 === diff) {
    return;
  }
  const sign2 = 1 === diff || -23 === diff ? -1 : 1;
  const trial = new Date(newDate.getTime() + 36e5 * sign2);
  if (sign2 > 0 || trial.getDate() === newDate.getDate()) {
    newDate.setTime(trial.getTime());
  }
}
var roundToHour = function(date) {
  const result2 = new Date(date.getTime());
  result2.setHours(result2.getHours() + 1);
  result2.setMinutes(0);
  return result2;
};
function getTimezonesDifference(min, max) {
  return 60 * (max.getTimezoneOffset() - min.getTimezoneOffset()) * 1e3;
}
var makeDate = function(date) {
  return new Date(date);
};
var getDatesOfInterval = function(startDate, endDate, step) {
  const result2 = [];
  let currentDate = new Date(startDate.getTime());
  while (currentDate < endDate) {
    result2.push(new Date(currentDate.getTime()));
    currentDate = this.addInterval(currentDate, step);
  }
  return result2;
};
var createDateWithFullYear = function(year) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }
  const result2 = new Date(year, ...args);
  result2.setFullYear(year);
  return result2;
};
var getMachineTimezoneName = () => {
  const hasIntl3 = "undefined" !== typeof Intl;
  return hasIntl3 ? Intl.DateTimeFormat().resolvedOptions().timeZone : null;
};
var getRangesByDates = (dates) => {
  const datesInMilliseconds = dates.map((value2) => correctDateWithUnitBeginning(value2, "day").getTime());
  const sortedDates = datesInMilliseconds.sort((a, b) => a - b);
  const msInDay = toMilliseconds("day");
  const ranges = [];
  let startDate = sortedDates[0];
  for (let i = 1; i <= sortedDates.length; ++i) {
    const nextDate = sortedDates[i];
    const currentDate = sortedDates[i - 1];
    const isNewRange = nextDate - currentDate > msInDay;
    if (isNewRange || i === sortedDates.length) {
      const range = startDate === sortedDates[i - 1] ? [startDate] : [startDate, sortedDates[i - 1]];
      const serializedRange = range.map((value2) => date_serialization_default.deserializeDate(value2));
      ranges.push(serializedRange);
      startDate = nextDate;
    }
  }
  return ranges;
};
var sameView = function(view, date1, date2) {
  return dateUtils[camelize2(`same ${view}`)](date1, date2);
};
var dateUtils = {
  dateUnitIntervals,
  convertMillisecondsToDateUnits,
  dateToMilliseconds,
  getNextDateUnit,
  convertDateUnitToMilliseconds,
  getDateUnitInterval,
  getDateFormatByTickInterval,
  getDatesDifferences,
  correctDateWithUnitBeginning,
  trimTime,
  setToDayEnd,
  roundDateByStartDayHour,
  dateTimeFromDecimal,
  addDateInterval,
  addInterval,
  getSequenceByInterval,
  getDateIntervalByString,
  sameHoursAndMinutes,
  sameDate,
  sameMonthAndYear,
  sameMonth: sameMonthAndYear,
  sameYear,
  sameDecade,
  sameCentury,
  sameView,
  sameDatesArrays,
  getDifferenceInMonth,
  getDifferenceInMonthForCells,
  getFirstYearInDecade,
  getFirstDecadeInCentury,
  getShortDateFormat,
  getViewFirstCellDate,
  getViewLastCellDate,
  getViewDown,
  getViewUp,
  getLastMonthDay,
  getLastMonthDate,
  getFirstMonthDate,
  getFirstWeekDate,
  getWeekNumber,
  normalizeDateByWeek,
  getQuarter,
  getFirstQuarterMonth,
  dateInRange,
  intervalsOverlap,
  roundToHour,
  normalizeDate,
  getViewMinBoundaryDate,
  getViewMaxBoundaryDate,
  fixTimezoneGap,
  getTimezonesDifference,
  makeDate,
  getDatesInterval,
  getDatesOfInterval,
  createDateWithFullYear,
  getMachineTimezoneName,
  getRangesByDates
};

// node_modules/devextreme/esm/core/utils/date.js
var date_default = dateUtils;

// node_modules/devextreme/esm/__internal/scheduler/m_date_adapter.js
var toMs = date_default.dateToMilliseconds;
var DateAdapterCore = class {
  constructor(source) {
    this._source = new Date(source.getTime ? source.getTime() : source);
  }
  get source() {
    return this._source;
  }
  result() {
    return this._source;
  }
  getTimezoneOffset() {
    let format2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : void 0;
    const value2 = this._source.getTimezoneOffset();
    if ("minute" === format2) {
      return value2 * toMs("minute");
    }
    return value2;
  }
  getTime() {
    return this._source.getTime();
  }
  setTime(value2) {
    this._source.setTime(value2);
    return this;
  }
  addTime(value2) {
    this._source.setTime(this._source.getTime() + value2);
    return this;
  }
  setMinutes(value2) {
    this._source.setMinutes(value2);
    return this;
  }
  addMinutes(value2) {
    this._source.setMinutes(this._source.getMinutes() + value2);
    return this;
  }
  subtractMinutes(value2) {
    this._source.setMinutes(this._source.getMinutes() - value2);
    return this;
  }
};
var DateAdapter = (date) => new DateAdapterCore(date);
var m_date_adapter_default = DateAdapter;

// node_modules/devextreme/esm/__internal/scheduler/timezones/m_utils_timezones_data.js
var getConvertedUntils = (value2) => value2.split("|").map((until) => {
  if ("Infinity" === until) {
    return null;
  }
  return 1e3 * parseInt(until, 36);
});
var parseTimezone = (timeZoneConfig) => {
  const {
    offsets
  } = timeZoneConfig;
  const {
    offsetIndices
  } = timeZoneConfig;
  const {
    untils
  } = timeZoneConfig;
  const offsetList = offsets.split("|").map((value2) => parseInt(value2));
  const offsetIndexList = offsetIndices.split("").map((value2) => parseInt(value2));
  const dateList = getConvertedUntils(untils).map((accumulator = 0, (value2) => accumulator += value2));
  var accumulator;
  return {
    offsetList,
    offsetIndexList,
    dateList
  };
};
var TimeZoneCache = class {
  constructor() {
    this.map = /* @__PURE__ */ new Map();
  }
  tryGet(id) {
    if (!this.map.get(id)) {
      const config3 = timeZoneDataUtils.getTimezoneById(id);
      if (!config3) {
        return false;
      }
      const timeZoneInfo = parseTimezone(config3);
      this.map.set(id, timeZoneInfo);
    }
    return this.map.get(id);
  }
};
var tzCache = new TimeZoneCache();
var timeZoneDataUtils = {
  _tzCache: tzCache,
  getTimeZonesOld: () => config_default2().timezones ?? [],
  formatOffset(offset2) {
    const hours = Math.floor(offset2);
    const minutesInDecimal = offset2 - hours;
    const signString = sign(offset2) >= 0 ? "+" : "-";
    const hoursString = `0${Math.abs(hours)}`.slice(-2);
    const minutesString = minutesInDecimal > 0 ? ":" + 60 * minutesInDecimal : ":00";
    return signString + hoursString + minutesString;
  },
  formatId: (id) => id.split("/").join(" - ").split("_").join(" "),
  getTimezoneById(id) {
    if (!id) {
      return;
    }
    const tzList = this.getTimeZonesOld();
    for (let i = 0; i < tzList.length; i++) {
      const currentId = tzList[i].id;
      if (currentId === id) {
        return tzList[i];
      }
    }
    return;
  },
  getTimeZoneOffsetById(id, timestamp) {
    const timeZoneInfo = tzCache.tryGet(id);
    return timeZoneInfo ? this.getUtcOffset(timeZoneInfo, timestamp) : void 0;
  },
  getTimeZoneDeclarationTuple(id, year) {
    const timeZoneInfo = tzCache.tryGet(id);
    return timeZoneInfo ? this.getTimeZoneDeclarationTupleCore(timeZoneInfo, year) : [];
  },
  getTimeZoneDeclarationTupleCore(timeZoneInfo, year) {
    const {
      offsetList
    } = timeZoneInfo;
    const {
      offsetIndexList
    } = timeZoneInfo;
    const {
      dateList
    } = timeZoneInfo;
    const tupleResult = [];
    for (let i = 0; i < dateList.length; i++) {
      const currentDate = dateList[i];
      const currentYear = new Date(currentDate).getFullYear();
      if (currentYear === year) {
        const offset2 = offsetList[offsetIndexList[i + 1]];
        tupleResult.push({
          date: currentDate,
          offset: -offset2 / 60
        });
      }
      if (currentYear > year) {
        break;
      }
    }
    return tupleResult;
  },
  getUtcOffset(timeZoneInfo, dateTimeStamp) {
    const {
      offsetList
    } = timeZoneInfo;
    const {
      offsetIndexList
    } = timeZoneInfo;
    const {
      dateList
    } = timeZoneInfo;
    const lastIntervalStartIndex = dateList.length - 1 - 1;
    let index2 = lastIntervalStartIndex;
    while (index2 >= 0 && dateTimeStamp < dateList[index2]) {
      index2--;
    }
    const offset2 = offsetList[offsetIndexList[index2 + 1]];
    return -offset2 / 60 || offset2;
  }
};
var m_utils_timezones_data_default = timeZoneDataUtils;

// node_modules/devextreme/esm/__internal/scheduler/timezones/timezone_list.js
var timezone_list_default = {
  value: ["Etc/GMT+12", "Etc/GMT+11", "Pacific/Midway", "Pacific/Niue", "Pacific/Pago_Pago", "Pacific/Samoa", "US/Samoa", "Etc/GMT+10", "HST", "Pacific/Honolulu", "Pacific/Johnston", "Pacific/Rarotonga", "Pacific/Tahiti", "US/Hawaii", "Pacific/Marquesas", "America/Adak", "America/Atka", "Etc/GMT+9", "Pacific/Gambier", "US/Aleutian", "America/Anchorage", "America/Juneau", "America/Metlakatla", "America/Nome", "America/Sitka", "America/Yakutat", "Etc/GMT+8", "Pacific/Pitcairn", "US/Alaska", "America/Creston", "America/Dawson_Creek", "America/Dawson", "America/Ensenada", "America/Fort_Nelson", "America/Hermosillo", "America/Los_Angeles", "America/Phoenix", "America/Santa_Isabel", "America/Tijuana", "America/Vancouver", "America/Whitehorse", "Canada/Pacific", "Canada/Yukon", "Etc/GMT+7", "Mexico/BajaNorte", "MST", "PST8PDT", "US/Arizona", "US/Pacific", "America/Belize", "America/Boise", "America/Cambridge_Bay", "America/Chihuahua", "America/Costa_Rica", "America/Denver", "America/Edmonton", "America/El_Salvador", "America/Guatemala", "America/Inuvik", "America/Managua", "America/Mazatlan", "America/Monterrey", "America/Ojinaga", "America/Regina", "America/Shiprock", "America/Swift_Current", "America/Tegucigalpa", "America/Yellowknife", "Canada/Mountain", "Canada/Saskatchewan", "Chile/EasterIsland", "Etc/GMT+6", "Mexico/BajaSur", "MST7MDT", "Navajo", "Pacific/Easter", "Pacific/Galapagos", "US/Mountain", "America/Atikokan", "America/Bahia_Banderas", "America/Bogota", "America/Cancun", "America/Cayman", "America/Chicago", "America/Coral_Harbour", "America/Eirunepe", "America/Guayaquil", "America/Indiana/Knox", "America/Indiana/Tell_City", "America/Jamaica", "America/Knox_IN", "America/Lima", "America/Matamoros", "America/Menominee", "America/Merida", "America/Mexico_City", "America/North_Dakota/Beulah", "America/North_Dakota/Center", "America/North_Dakota/New_Salem", "America/Panama", "America/Porto_Acre", "America/Rainy_River", "America/Rankin_Inlet", "America/Resolute", "America/Rio_Branco", "America/Winnipeg", "Brazil/Acre", "Canada/Central", "CST6CDT", "EST", "Etc/GMT+5", "Jamaica", "Mexico/General", "US/Central", "US/Indiana-Starke", "America/Anguilla", "America/Antigua", "America/Aruba", "America/Asuncion", "America/Barbados", "America/Blanc-Sablon", "America/Boa_Vista", "America/Campo_Grande", "America/Caracas", "America/Cuiaba", "America/Curacao", "America/Detroit", "America/Dominica", "America/Fort_Wayne", "America/Grand_Turk", "America/Grenada", "America/Guadeloupe", "America/Guyana", "America/Havana", "America/Indiana/Indianapolis", "America/Indiana/Marengo", "America/Indiana/Petersburg", "America/Indiana/Vevay", "America/Indiana/Vincennes", "America/Indiana/Winamac", "America/Indianapolis", "America/Iqaluit", "America/Kentucky/Louisville", "America/Kentucky/Monticello", "America/Kralendijk", "America/La_Paz", "America/Louisville", "America/Lower_Princes", "America/Manaus", "America/Marigot", "America/Martinique", "America/Montreal", "America/Montserrat", "America/Nassau", "America/New_York", "America/Nipigon", "America/Pangnirtung", "America/Port_of_Spain", "America/Port-au-Prince", "America/Porto_Velho", "America/Puerto_Rico", "America/Santiago", "America/Santo_Domingo", "America/St_Barthelemy", "America/St_Kitts", "America/St_Lucia", "America/St_Thomas", "America/St_Vincent", "America/Thunder_Bay", "America/Toronto", "America/Tortola", "America/Virgin", "Brazil/West", "Canada/Eastern", "Chile/Continental", "Cuba", "EST5EDT", "Etc/GMT+4", "US/East-Indiana", "US/Eastern", "US/Michigan", "America/Araguaina", "America/Argentina/Buenos_Aires", "America/Argentina/Catamarca", "America/Argentina/ComodRivadavia", "America/Argentina/Cordoba", "America/Argentina/Jujuy", "America/Argentina/La_Rioja", "America/Argentina/Mendoza", "America/Argentina/Rio_Gallegos", "America/Argentina/Salta", "America/Argentina/San_Juan", "America/Argentina/San_Luis", "America/Argentina/Tucuman", "America/Argentina/Ushuaia", "America/Bahia", "America/Belem", "America/Buenos_Aires", "America/Catamarca", "America/Cayenne", "America/Cordoba", "America/Fortaleza", "America/Glace_Bay", "America/Goose_Bay", "America/Halifax", "America/Jujuy", "America/Maceio", "America/Mendoza", "America/Moncton", "America/Montevideo", "America/Paramaribo", "America/Punta_Arenas", "America/Recife", "America/Rosario", "America/Santarem", "America/Sao_Paulo", "America/Thule", "Antarctica/Palmer", "Antarctica/Rothera", "Atlantic/Bermuda", "Atlantic/Stanley", "Brazil/East", "Canada/Atlantic", "Etc/GMT+3", "America/St_Johns", "Canada/Newfoundland", "America/Godthab", "America/Miquelon", "America/Noronha", "America/Nuuk", "Atlantic/South_Georgia", "Brazil/DeNoronha", "Etc/GMT+2", "Atlantic/Cape_Verde", "Etc/GMT+1", "Africa/Abidjan", "Africa/Accra", "Africa/Bamako", "Africa/Banjul", "Africa/Bissau", "Africa/Conakry", "Africa/Dakar", "Africa/Freetown", "Africa/Lome", "Africa/Monrovia", "Africa/Nouakchott", "Africa/Ouagadougou", "Africa/Sao_Tome", "Africa/Timbuktu", "America/Danmarkshavn", "America/Scoresbysund", "Atlantic/Azores", "Atlantic/Reykjavik", "Atlantic/St_Helena", "Etc/GMT-0", "Etc/GMT", "Etc/GMT+0", "Etc/GMT0", "Etc/Greenwich", "Etc/UCT", "Etc/Universal", "Etc/UTC", "Etc/Zulu", "GMT-0", "GMT", "GMT+0", "GMT0", "Greenwich", "Iceland", "UCT", "Universal", "UTC", "Zulu", "Africa/Algiers", "Africa/Bangui", "Africa/Brazzaville", "Africa/Casablanca", "Africa/Douala", "Africa/El_Aaiun", "Africa/Kinshasa", "Africa/Lagos", "Africa/Libreville", "Africa/Luanda", "Africa/Malabo", "Africa/Ndjamena", "Africa/Niamey", "Africa/Porto-Novo", "Africa/Tunis", "Atlantic/Canary", "Atlantic/Faeroe", "Atlantic/Faroe", "Atlantic/Madeira", "Eire", "Etc/GMT-1", "Europe/Belfast", "Europe/Dublin", "Europe/Guernsey", "Europe/Isle_of_Man", "Europe/Jersey", "Europe/Lisbon", "Europe/London", "GB-Eire", "GB", "Portugal", "WET", "Africa/Blantyre", "Africa/Bujumbura", "Africa/Cairo", "Africa/Ceuta", "Africa/Gaborone", "Africa/Harare", "Africa/Johannesburg", "Africa/Khartoum", "Africa/Kigali", "Africa/Lubumbashi", "Africa/Lusaka", "Africa/Maputo", "Africa/Maseru", "Africa/Mbabane", "Africa/Tripoli", "Africa/Windhoek", "Antarctica/Troll", "Arctic/Longyearbyen", "Atlantic/Jan_Mayen", "CET", "Egypt", "Etc/GMT-2", "Europe/Amsterdam", "Europe/Andorra", "Europe/Belgrade", "Europe/Berlin", "Europe/Bratislava", "Europe/Brussels", "Europe/Budapest", "Europe/Busingen", "Europe/Copenhagen", "Europe/Gibraltar", "Europe/Kaliningrad", "Europe/Ljubljana", "Europe/Luxembourg", "Europe/Madrid", "Europe/Malta", "Europe/Monaco", "Europe/Oslo", "Europe/Paris", "Europe/Podgorica", "Europe/Prague", "Europe/Rome", "Europe/San_Marino", "Europe/Sarajevo", "Europe/Skopje", "Europe/Stockholm", "Europe/Tirane", "Europe/Vaduz", "Europe/Vatican", "Europe/Vienna", "Europe/Warsaw", "Europe/Zagreb", "Europe/Zurich", "Libya", "MET", "Poland", "Africa/Addis_Ababa", "Africa/Asmara", "Africa/Asmera", "Africa/Dar_es_Salaam", "Africa/Djibouti", "Africa/Juba", "Africa/Kampala", "Africa/Mogadishu", "Africa/Nairobi", "Antarctica/Syowa", "Asia/Aden", "Asia/Amman", "Asia/Baghdad", "Asia/Bahrain", "Asia/Beirut", "Asia/Damascus", "Asia/Famagusta", "Asia/Gaza", "Asia/Hebron", "Asia/Istanbul", "Asia/Jerusalem", "Asia/Kuwait", "Asia/Nicosia", "Asia/Qatar", "Asia/Riyadh", "Asia/Tel_Aviv", "EET", "Etc/GMT-3", "Europe/Athens", "Europe/Bucharest", "Europe/Chisinau", "Europe/Helsinki", "Europe/Istanbul", "Europe/Kiev", "Europe/Kirov", "Europe/Mariehamn", "Europe/Minsk", "Europe/Moscow", "Europe/Nicosia", "Europe/Riga", "Europe/Simferopol", "Europe/Sofia", "Europe/Tallinn", "Europe/Tiraspol", "Europe/Uzhgorod", "Europe/Vilnius", "Europe/Zaporozhye", "Indian/Antananarivo", "Indian/Comoro", "Indian/Mayotte", "Israel", "Turkey", "W-SU", "Asia/Baku", "Asia/Dubai", "Asia/Muscat", "Asia/Tbilisi", "Asia/Yerevan", "Etc/GMT-4", "Europe/Astrakhan", "Europe/Samara", "Europe/Saratov", "Europe/Ulyanovsk", "Europe/Volgograd", "Indian/Mahe", "Indian/Mauritius", "Indian/Reunion", "Asia/Kabul", "Asia/Tehran", "Iran", "Antarctica/Mawson", "Asia/Aqtau", "Asia/Aqtobe", "Asia/Ashgabat", "Asia/Ashkhabad", "Asia/Atyrau", "Asia/Dushanbe", "Asia/Karachi", "Asia/Oral", "Asia/Qyzylorda", "Asia/Samarkand", "Asia/Tashkent", "Asia/Yekaterinburg", "Etc/GMT-5", "Indian/Kerguelen", "Indian/Maldives", "Asia/Calcutta", "Asia/Colombo", "Asia/Kolkata", "Asia/Kathmandu", "Asia/Katmandu", "Antarctica/Vostok", "Asia/Almaty", "Asia/Bishkek", "Asia/Dacca", "Asia/Dhaka", "Asia/Kashgar", "Asia/Omsk", "Asia/Qostanay", "Asia/Thimbu", "Asia/Thimphu", "Asia/Urumqi", "Etc/GMT-6", "Indian/Chagos", "Asia/Rangoon", "Asia/Yangon", "Indian/Cocos", "Antarctica/Davis", "Asia/Bangkok", "Asia/Barnaul", "Asia/Ho_Chi_Minh", "Asia/Hovd", "Asia/Jakarta", "Asia/Krasnoyarsk", "Asia/Novokuznetsk", "Asia/Novosibirsk", "Asia/Phnom_Penh", "Asia/Pontianak", "Asia/Saigon", "Asia/Tomsk", "Asia/Vientiane", "Etc/GMT-7", "Indian/Christmas", "Antarctica/Casey", "Asia/Brunei", "Asia/Choibalsan", "Asia/Chongqing", "Asia/Chungking", "Asia/Harbin", "Asia/Hong_Kong", "Asia/Irkutsk", "Asia/Kuala_Lumpur", "Asia/Kuching", "Asia/Macao", "Asia/Macau", "Asia/Makassar", "Asia/Manila", "Asia/Shanghai", "Asia/Singapore", "Asia/Taipei", "Asia/Ujung_Pandang", "Asia/Ulaanbaatar", "Asia/Ulan_Bator", "Australia/Perth", "Australia/West", "Etc/GMT-8", "Hongkong", "PRC", "ROC", "Singapore", "Australia/Eucla", "Asia/Chita", "Asia/Dili", "Asia/Jayapura", "Asia/Khandyga", "Asia/Pyongyang", "Asia/Seoul", "Asia/Tokyo", "Asia/Yakutsk", "Etc/GMT-9", "Japan", "Pacific/Palau", "ROK", "Australia/Adelaide", "Australia/Broken_Hill", "Australia/Darwin", "Australia/North", "Australia/South", "Australia/Yancowinna", "Antarctica/DumontDUrville", "Asia/Ust-Nera", "Asia/Vladivostok", "Australia/ACT", "Australia/Brisbane", "Australia/Canberra", "Australia/Currie", "Australia/Hobart", "Australia/Lindeman", "Australia/Melbourne", "Australia/NSW", "Australia/Queensland", "Australia/Sydney", "Australia/Tasmania", "Australia/Victoria", "Etc/GMT-10", "Pacific/Chuuk", "Pacific/Guam", "Pacific/Port_Moresby", "Pacific/Saipan", "Pacific/Truk", "Pacific/Yap", "Australia/LHI", "Australia/Lord_Howe", "Antarctica/Macquarie", "Asia/Magadan", "Asia/Sakhalin", "Asia/Srednekolymsk", "Etc/GMT-11", "Pacific/Bougainville", "Pacific/Efate", "Pacific/Guadalcanal", "Pacific/Kosrae", "Pacific/Norfolk", "Pacific/Noumea", "Pacific/Pohnpei", "Pacific/Ponape", "Antarctica/McMurdo", "Antarctica/South_Pole", "Asia/Anadyr", "Asia/Kamchatka", "Etc/GMT-12", "Kwajalein", "NZ", "Pacific/Auckland", "Pacific/Fiji", "Pacific/Funafuti", "Pacific/Kwajalein", "Pacific/Majuro", "Pacific/Nauru", "Pacific/Tarawa", "Pacific/Wake", "Pacific/Wallis", "NZ-CHAT", "Pacific/Chatham", "Etc/GMT-13", "Pacific/Apia", "Pacific/Enderbury", "Pacific/Fakaofo", "Pacific/Tongatapu", "Etc/GMT-14", "Pacific/Kiritimati"]
};

// node_modules/devextreme/esm/__internal/scheduler/m_utils_time_zone.js
var toMs2 = date_default.dateToMilliseconds;
var GMT = "GMT";
var offsetFormatRegexp = /^GMT(?:[+-]\d{2}:\d{2})?$/;
var createUTCDateWithLocalOffset = (date) => {
  if (!date) {
    return null;
  }
  return new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds()));
};
var createDateFromUTCWithLocalOffset = (date) => {
  const result2 = m_date_adapter_default(date);
  const timezoneOffsetBeforeInMin = result2.getTimezoneOffset();
  result2.addTime(result2.getTimezoneOffset("minute"));
  result2.subtractMinutes(timezoneOffsetBeforeInMin - result2.getTimezoneOffset());
  return result2.source;
};
var createUTCDate = (date) => new Date(Date.UTC(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate(), date.getUTCHours(), date.getUTCMinutes()));
var getTimezoneOffsetChangeInMinutes = (startDate, endDate, updatedStartDate, updatedEndDate) => getDaylightOffset(updatedStartDate, updatedEndDate) - getDaylightOffset(startDate, endDate);
var getTimezoneOffsetChangeInMs = (startDate, endDate, updatedStartDate, updatedEndDate) => getTimezoneOffsetChangeInMinutes(startDate, endDate, updatedStartDate, updatedEndDate) * toMs2("minute");
var getDaylightOffset = (startDate, endDate) => new Date(startDate).getTimezoneOffset() - new Date(endDate).getTimezoneOffset();
var getDaylightOffsetInMs = (startDate, endDate) => getDaylightOffset(startDate, endDate) * toMs2("minute");
var calculateTimezoneByValueOld = function(timezone) {
  let date = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : /* @__PURE__ */ new Date();
  const customTimezones = m_utils_timezones_data_default.getTimeZonesOld();
  if (0 === customTimezones.length) {
    return;
  }
  const dateUtc = createUTCDate(date);
  return m_utils_timezones_data_default.getTimeZoneOffsetById(timezone, dateUtc.getTime());
};
var calculateTimezoneByValueCore = function(timeZone) {
  let date = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : /* @__PURE__ */ new Date();
  const offset2 = getStringOffset(timeZone, date);
  if (void 0 === offset2) {
    return;
  }
  if (offset2 === GMT) {
    return 0;
  }
  const isMinus = "-" === offset2.substring(3, 4);
  const hours = offset2.substring(4, 6);
  const minutes = offset2.substring(7, 9);
  const result2 = parseInt(hours, 10) + parseInt(minutes, 10) / 60;
  return isMinus ? -result2 : result2;
};
var calculateTimezoneByValue = function(timeZone) {
  let date = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : /* @__PURE__ */ new Date();
  if (!timeZone) {
    return;
  }
  const isValidTimezone = timezone_list_default.value.includes(timeZone);
  if (!isValidTimezone) {
    errors_default.log("W0009", timeZone);
    return;
  }
  if (!dateUtilsTs.isValidDate(date)) {
    return;
  }
  let result2 = calculateTimezoneByValueOld(timeZone, date);
  if (void 0 === result2) {
    result2 = calculateTimezoneByValueCore(timeZone, date);
  }
  return result2;
};
var getStringOffset = function(timeZone) {
  let date = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : /* @__PURE__ */ new Date();
  let result2 = "";
  try {
    var _dateTimeFormat$forma;
    const dateTimeFormat = new Intl.DateTimeFormat("en-US", {
      timeZone,
      timeZoneName: "longOffset"
    });
    result2 = (null === (_dateTimeFormat$forma = dateTimeFormat.formatToParts(date).find((_ref) => {
      let {
        type: type2
      } = _ref;
      return "timeZoneName" === type2;
    })) || void 0 === _dateTimeFormat$forma ? void 0 : _dateTimeFormat$forma.value) ?? "";
  } catch (e) {
    errors_default.log("W0009", timeZone);
    return;
  }
  const isSupportedFormat = offsetFormatRegexp.test(result2);
  if (!isSupportedFormat) {
    errors_default.log("W0009", timeZone);
    return;
  }
  return result2;
};
var getOffsetNamePart = (offset2) => {
  if (offset2 === GMT) {
    return `${offset2} +00:00`;
  }
  return offset2.replace(GMT, `${GMT} `);
};
var getTimezoneTitle = function(timeZone) {
  let date = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : /* @__PURE__ */ new Date();
  if (!dateUtilsTs.isValidDate(date)) {
    return "";
  }
  const tzNamePart = timeZone.replace(/\//g, " - ").replace(/_/g, " ");
  const offset2 = getStringOffset(timeZone, date);
  if (void 0 === offset2) {
    return;
  }
  const offsetNamePart = getOffsetNamePart(offset2);
  return `(${offsetNamePart}) ${tzNamePart}`;
};
var _getDaylightOffsetByTimezone = (startDate, endDate, timeZone) => {
  const startDayOffset = calculateTimezoneByValue(timeZone, startDate);
  const endDayOffset = calculateTimezoneByValue(timeZone, endDate);
  if (void 0 === startDayOffset || void 0 === endDayOffset) {
    return 0;
  }
  return startDayOffset - endDayOffset;
};
var getCorrectedDateByDaylightOffsets = (convertedOriginalStartDate, convertedDate, date, timeZone, startDateTimezone) => {
  const daylightOffsetByCommonTimezone = _getDaylightOffsetByTimezone(convertedOriginalStartDate, convertedDate, timeZone);
  const daylightOffsetByAppointmentTimezone = _getDaylightOffsetByTimezone(convertedOriginalStartDate, convertedDate, startDateTimezone);
  const diff = daylightOffsetByCommonTimezone - daylightOffsetByAppointmentTimezone;
  return new Date(date.getTime() - diff * toMs2("hour"));
};
var correctRecurrenceExceptionByTimezone = function(exception, exceptionByStartDate, timeZone, startDateTimeZone) {
  let isBackConversion = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : false;
  let timezoneOffset = (exception.getTimezoneOffset() - exceptionByStartDate.getTimezoneOffset()) / 60;
  if (startDateTimeZone) {
    timezoneOffset = _getDaylightOffsetByTimezone(exceptionByStartDate, exception, startDateTimeZone);
  } else if (timeZone) {
    timezoneOffset = _getDaylightOffsetByTimezone(exceptionByStartDate, exception, timeZone);
  }
  return new Date(exception.getTime() + (isBackConversion ? -1 : 1) * timezoneOffset * toMs2("hour"));
};
var isTimezoneChangeInDate = (date) => {
  const startDayDate = new Date(new Date(date).setHours(0, 0, 0, 0));
  const endDayDate = new Date(new Date(date).setHours(23, 59, 59, 0));
  return startDayDate.getTimezoneOffset() - endDayDate.getTimezoneOffset() !== 0;
};
var getDateWithoutTimezoneChange = (date) => {
  const clonedDate = new Date(date);
  if (isTimezoneChangeInDate(clonedDate)) {
    const result2 = new Date(clonedDate);
    return new Date(result2.setDate(result2.getDate() + 1));
  }
  return clonedDate;
};
var isSameAppointmentDates = (startDate, endDate) => {
  endDate = new Date(endDate.getTime() - 1);
  return date_default.sameDate(startDate, endDate);
};
var getClientTimezoneOffset = function() {
  let date = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : /* @__PURE__ */ new Date();
  return 6e4 * date.getTimezoneOffset();
};
var getDiffBetweenClientTimezoneOffsets = function() {
  let firstDate = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : /* @__PURE__ */ new Date();
  let secondDate = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : /* @__PURE__ */ new Date();
  return getClientTimezoneOffset(firstDate) - getClientTimezoneOffset(secondDate);
};
var isEqualLocalTimeZone = function(timeZoneName) {
  let date = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : /* @__PURE__ */ new Date();
  if (Intl) {
    const localTimeZoneName = Intl.DateTimeFormat().resolvedOptions().timeZone;
    if (localTimeZoneName === timeZoneName) {
      return true;
    }
  }
  return isEqualLocalTimeZoneByDeclaration(timeZoneName, date);
};
var hasDSTInLocalTimeZone = () => {
  const [startDate, endDate] = getExtremeDates();
  return startDate.getTimezoneOffset() !== endDate.getTimezoneOffset();
};
var getOffset2 = (date) => -date.getTimezoneOffset() / 60;
var getDateAndMoveHourBack = (dateStamp) => new Date(dateStamp - toMs2("hour"));
var isEqualLocalTimeZoneByDeclarationOld = (timeZoneName, date) => {
  const year = date.getFullYear();
  const configTuple = m_utils_timezones_data_default.getTimeZoneDeclarationTuple(timeZoneName, year);
  const [summerTime, winterTime] = configTuple;
  const noDSTInTargetTimeZone = configTuple.length < 2;
  if (noDSTInTargetTimeZone) {
    const targetTimeZoneOffset = m_utils_timezones_data_default.getTimeZoneOffsetById(timeZoneName, date);
    const localTimeZoneOffset = getOffset2(date);
    if (targetTimeZoneOffset !== localTimeZoneOffset) {
      return false;
    }
    return !hasDSTInLocalTimeZone();
  }
  const localSummerOffset = getOffset2(new Date(summerTime.date));
  const localWinterOffset = getOffset2(new Date(winterTime.date));
  if (localSummerOffset !== summerTime.offset) {
    return false;
  }
  if (localSummerOffset === getOffset2(getDateAndMoveHourBack(summerTime.date))) {
    return false;
  }
  if (localWinterOffset !== winterTime.offset) {
    return false;
  }
  if (localWinterOffset === getOffset2(getDateAndMoveHourBack(winterTime.date))) {
    return false;
  }
  return true;
};
var isEqualLocalTimeZoneByDeclaration = (timeZoneName, date) => {
  const customTimezones = m_utils_timezones_data_default.getTimeZonesOld();
  const targetTimezoneData = customTimezones.filter((tz) => tz.id === timeZoneName);
  if (1 === targetTimezoneData.length) {
    return isEqualLocalTimeZoneByDeclarationOld(timeZoneName, date);
  }
  return false;
};
var getExtremeDates = () => {
  const nowDate = new Date(Date.now());
  const startDate = /* @__PURE__ */ new Date();
  const endDate = /* @__PURE__ */ new Date();
  startDate.setFullYear(nowDate.getFullYear(), 0, 1);
  endDate.setFullYear(nowDate.getFullYear(), 6, 1);
  return [startDate, endDate];
};
var setOffsetsToDate = (targetDate, offsetsArray) => {
  const newDateMs = offsetsArray.reduce((result2, offset2) => result2 + offset2, targetDate.getTime());
  return new Date(newDateMs);
};
var addOffsetsWithoutDST = function(date) {
  for (var _len = arguments.length, offsets = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    offsets[_key - 1] = arguments[_key];
  }
  const newDate = dateUtilsTs.addOffsets(date, offsets);
  const daylightShift = getDaylightOffsetInMs(date, newDate);
  if (!daylightShift) {
    return newDate;
  }
  const correctLocalDate = dateUtilsTs.addOffsets(newDate, [-daylightShift]);
  const daylightSecondShift = getDaylightOffsetInMs(newDate, correctLocalDate);
  return !daylightSecondShift ? correctLocalDate : newDate;
};
var getTimeZones = function() {
  let date = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : /* @__PURE__ */ new Date();
  let timeZones = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : timezone_list_default.value;
  return timeZones.map((timezoneId) => ({
    id: timezoneId,
    title: getTimezoneTitle(timezoneId, date),
    offset: calculateTimezoneByValue(timezoneId, date)
  }));
};
var timeZoneDataCache = [];
var timeZoneDataCachePromise;
var cacheTimeZones = async function() {
  let date = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : /* @__PURE__ */ new Date();
  if (timeZoneDataCachePromise) {
    return timeZoneDataCachePromise;
  }
  timeZoneDataCachePromise = macro_task_array_default.map(timezone_list_default.value, (timezoneId) => ({
    id: timezoneId,
    title: getTimezoneTitle(timezoneId, date)
  }), 10);
  timeZoneDataCache = await timeZoneDataCachePromise;
  return timeZoneDataCache;
};
var getTimeZonesCache = () => timeZoneDataCache;
var utils = {
  getDaylightOffset,
  getDaylightOffsetInMs,
  getTimezoneOffsetChangeInMinutes,
  getTimezoneOffsetChangeInMs,
  calculateTimezoneByValue,
  getCorrectedDateByDaylightOffsets,
  isSameAppointmentDates,
  correctRecurrenceExceptionByTimezone,
  getClientTimezoneOffset,
  getDiffBetweenClientTimezoneOffsets,
  createUTCDateWithLocalOffset,
  createDateFromUTCWithLocalOffset,
  createUTCDate,
  isTimezoneChangeInDate,
  getDateWithoutTimezoneChange,
  hasDSTInLocalTimeZone,
  isEqualLocalTimeZone,
  isEqualLocalTimeZoneByDeclaration,
  setOffsetsToDate,
  addOffsetsWithoutDST,
  getTimeZones,
  getTimeZonesCache,
  cacheTimeZones
};
var m_utils_time_zone_default = utils;

// node_modules/devextreme/esm/common/core/environment/time_zone_utils.js
var getTimeZones2 = m_utils_time_zone_default.getTimeZones;

// node_modules/devextreme/esm/core/devices.js
var devices_default = m_devices_default;

// node_modules/devextreme/esm/common/core/animation/position.js
var window9 = getWindow();
var horzRe = /left|right/;
var vertRe = /top|bottom/;
var collisionRe = /fit|flip|none/;
var scaleRe = /scale\(.+?\)/;
var IS_SAFARI = browser_default.safari;
var normalizeAlign = function(raw) {
  const result2 = {
    h: "center",
    v: "center"
  };
  const pair = splitPair(raw);
  if (pair) {
    each(pair, function() {
      const w = String(this).toLowerCase();
      if (horzRe.test(w)) {
        result2.h = w;
      } else if (vertRe.test(w)) {
        result2.v = w;
      }
    });
  }
  return result2;
};
var normalizeOffset = function(raw, preventRound) {
  return pairToObject(raw, preventRound);
};
var normalizeCollision = function(raw) {
  const pair = splitPair(raw);
  let h3 = String(pair && pair[0]).toLowerCase();
  let v = String(pair && pair[1]).toLowerCase();
  if (!collisionRe.test(h3)) {
    h3 = "none";
  }
  if (!collisionRe.test(v)) {
    v = h3;
  }
  return {
    h: h3,
    v
  };
};
var getAlignFactor = function(align) {
  switch (align) {
    case "center":
      return 0.5;
    case "right":
    case "bottom":
      return 1;
    default:
      return 0;
  }
};
var inverseAlign = function(align) {
  switch (align) {
    case "left":
      return "right";
    case "right":
      return "left";
    case "top":
      return "bottom";
    case "bottom":
      return "top";
    default:
      return align;
  }
};
var calculateOversize = function(data17, bounds) {
  let oversize = 0;
  if (data17.myLocation < bounds.min) {
    oversize += bounds.min - data17.myLocation;
  }
  if (data17.myLocation > bounds.max) {
    oversize += data17.myLocation - bounds.max;
  }
  return oversize;
};
var collisionSide = function(direction, data17, bounds) {
  if (data17.myLocation < bounds.min) {
    return "h" === direction ? "left" : "top";
  }
  if (data17.myLocation > bounds.max) {
    return "h" === direction ? "right" : "bottom";
  }
  return "none";
};
var initMyLocation = function(data17) {
  data17.myLocation = data17.atLocation + getAlignFactor(data17.atAlign) * data17.atSize - getAlignFactor(data17.myAlign) * data17.mySize + data17.offset;
};
var collisionResolvers = {
  fit: function(data17, bounds) {
    let result2 = false;
    if (data17.myLocation > bounds.max) {
      data17.myLocation = bounds.max;
      result2 = true;
    }
    if (data17.myLocation < bounds.min) {
      data17.myLocation = bounds.min;
      result2 = true;
    }
    data17.fit = result2;
  },
  flip: function(data17, bounds) {
    data17.flip = false;
    if ("center" === data17.myAlign && "center" === data17.atAlign) {
      return;
    }
    if (data17.myLocation < bounds.min || data17.myLocation > bounds.max) {
      const inverseData = extend({}, data17, {
        myAlign: inverseAlign(data17.myAlign),
        atAlign: inverseAlign(data17.atAlign),
        offset: -data17.offset
      });
      initMyLocation(inverseData);
      inverseData.oversize = calculateOversize(inverseData, bounds);
      if (inverseData.myLocation >= bounds.min && inverseData.myLocation <= bounds.max || data17.oversize > inverseData.oversize) {
        data17.myLocation = inverseData.myLocation;
        data17.oversize = inverseData.oversize;
        data17.flip = true;
      }
    }
  },
  flipfit: function(data17, bounds) {
    this.flip(data17, bounds);
    this.fit(data17, bounds);
  },
  none: function(data17) {
    data17.oversize = 0;
  }
};
var scrollbarWidth;
var calculateScrollbarWidth = function() {
  const $scrollDiv = renderer_default("<div>").css({
    width: 100,
    height: 100,
    overflow: "scroll",
    position: "absolute",
    top: -9999
  }).appendTo(renderer_default("body"));
  const result2 = $scrollDiv.get(0).offsetWidth - $scrollDiv.get(0).clientWidth;
  $scrollDiv.remove();
  scrollbarWidth = result2;
};
var defaultPositionResult = {
  h: {
    location: 0,
    flip: false,
    fit: false,
    oversize: 0
  },
  v: {
    location: 0,
    flip: false,
    fit: false,
    oversize: 0
  }
};
var calculatePosition = function(what, options2) {
  const $what = renderer_default(what);
  const currentOffset = $what.offset();
  const result2 = extend(true, {}, defaultPositionResult, {
    h: {
      location: currentOffset.left
    },
    v: {
      location: currentOffset.top
    }
  });
  if (!options2) {
    return result2;
  }
  const my = normalizeAlign(options2.my);
  const at = normalizeAlign(options2.at);
  let of = renderer_default(options2.of).length && options2.of || window9;
  const offset2 = normalizeOffset(options2.offset, options2.precise);
  const collision = normalizeCollision(options2.collision);
  const boundary = options2.boundary;
  const boundaryOffset = normalizeOffset(options2.boundaryOffset, options2.precise);
  const h3 = {
    mySize: getOuterWidth($what),
    myAlign: my.h,
    atAlign: at.h,
    offset: offset2.h,
    collision: collision.h,
    boundaryOffset: boundaryOffset.h
  };
  const v = {
    mySize: getOuterHeight($what),
    myAlign: my.v,
    atAlign: at.v,
    offset: offset2.v,
    collision: collision.v,
    boundaryOffset: boundaryOffset.v
  };
  if (of.preventDefault) {
    h3.atLocation = of.pageX;
    v.atLocation = of.pageY;
    h3.atSize = 0;
    v.atSize = 0;
  } else {
    of = renderer_default(of);
    if (isWindow(of[0])) {
      h3.atLocation = of.scrollLeft();
      v.atLocation = of.scrollTop();
      if ("phone" === devices_default.real().deviceType && of[0].visualViewport) {
        h3.atLocation = Math.max(h3.atLocation, of[0].visualViewport.offsetLeft);
        v.atLocation = Math.max(v.atLocation, of[0].visualViewport.offsetTop);
        h3.atSize = of[0].visualViewport.width;
        v.atSize = of[0].visualViewport.height;
      } else {
        h3.atSize = of[0].innerWidth > of[0].outerWidth ? of[0].innerWidth : getWidth(of);
        v.atSize = of[0].innerHeight > of[0].outerHeight || IS_SAFARI ? of[0].innerHeight : getHeight(of);
      }
    } else if (9 === of[0].nodeType) {
      h3.atLocation = 0;
      v.atLocation = 0;
      h3.atSize = getWidth(of);
      v.atSize = getHeight(of);
    } else {
      const ofRect = getBoundingRect(of.get(0));
      const o = getOffsetWithoutScale(of);
      h3.atLocation = o.left;
      v.atLocation = o.top;
      h3.atSize = Math.max(ofRect.width, getOuterWidth(of));
      v.atSize = Math.max(ofRect.height, getOuterHeight(of));
    }
  }
  initMyLocation(h3);
  initMyLocation(v);
  const bounds = function() {
    const win = renderer_default(window9);
    const windowWidth = getWidth(win);
    const windowHeight = getHeight(win);
    let left = win.scrollLeft();
    let top = win.scrollTop();
    const documentElement = dom_adapter_default.getDocumentElement();
    const hZoomLevel = touch ? documentElement.clientWidth / windowWidth : 1;
    const vZoomLevel = touch ? documentElement.clientHeight / windowHeight : 1;
    if (void 0 === scrollbarWidth) {
      calculateScrollbarWidth();
    }
    let boundaryWidth = windowWidth;
    let boundaryHeight = windowHeight;
    if (boundary && !isWindow(boundary)) {
      const $boundary = renderer_default(boundary);
      const boundaryPosition = $boundary.offset();
      left = boundaryPosition.left;
      top = boundaryPosition.top;
      boundaryWidth = getWidth($boundary);
      boundaryHeight = getHeight($boundary);
    }
    return {
      h: {
        min: left + h3.boundaryOffset,
        max: left + boundaryWidth / hZoomLevel - h3.mySize - h3.boundaryOffset
      },
      v: {
        min: top + v.boundaryOffset,
        max: top + boundaryHeight / vZoomLevel - v.mySize - v.boundaryOffset
      }
    };
  }();
  h3.oversize = calculateOversize(h3, bounds.h);
  v.oversize = calculateOversize(v, bounds.v);
  h3.collisionSide = collisionSide("h", h3, bounds.h);
  v.collisionSide = collisionSide("v", v, bounds.v);
  if (collisionResolvers[h3.collision]) {
    collisionResolvers[h3.collision](h3, bounds.h);
  }
  if (collisionResolvers[v.collision]) {
    collisionResolvers[v.collision](v, bounds.v);
  }
  const preciser = function(number) {
    return options2.precise ? number : Math.round(number);
  };
  extend(true, result2, {
    h: {
      location: preciser(h3.myLocation),
      oversize: preciser(h3.oversize),
      fit: h3.fit,
      flip: h3.flip,
      collisionSide: h3.collisionSide
    },
    v: {
      location: preciser(v.myLocation),
      oversize: preciser(v.oversize),
      fit: v.fit,
      flip: v.flip,
      collisionSide: v.collisionSide
    },
    precise: options2.precise
  });
  return result2;
};
var setScaleProperty = function(element, scale, styleAttr, isEmpty3) {
  const stylePropIsValid = isDefined(element.style) && !dom_adapter_default.isNode(element.style);
  const newStyleValue = isEmpty3 ? styleAttr.replace(scale, "") : styleAttr;
  if (stylePropIsValid) {
    setStyle(element, newStyleValue, false);
  } else {
    const styleAttributeNode = dom_adapter_default.createAttribute("style");
    styleAttributeNode.value = newStyleValue;
    element.setAttributeNode(styleAttributeNode);
  }
};
var getOffsetWithoutScale = function($startElement) {
  var _currentElement$getAt, _style$match;
  let $currentElement = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : $startElement;
  const currentElement = $currentElement.get(0);
  if (!currentElement) {
    return $startElement.offset();
  }
  const style = (null === (_currentElement$getAt = currentElement.getAttribute) || void 0 === _currentElement$getAt ? void 0 : _currentElement$getAt.call(currentElement, "style")) || "";
  const scale = null === (_style$match = style.match(scaleRe)) || void 0 === _style$match ? void 0 : _style$match[0];
  let offset2;
  if (scale) {
    setScaleProperty(currentElement, scale, style, true);
    offset2 = getOffsetWithoutScale($startElement, $currentElement.parent());
    setScaleProperty(currentElement, scale, style, false);
  } else {
    offset2 = getOffsetWithoutScale($startElement, $currentElement.parent());
  }
  return offset2;
};
var position = function(what, options2) {
  const $what = renderer_default(what);
  if (!options2) {
    return $what.offset();
  }
  resetPosition($what, true);
  const offset2 = getOffsetWithoutScale($what);
  const targetPosition = options2.h && options2.v ? options2 : calculatePosition($what, options2);
  const preciser = function(number) {
    return options2.precise ? number : Math.round(number);
  };
  move($what, {
    left: targetPosition.h.location - preciser(offset2.left),
    top: targetPosition.v.location - preciser(offset2.top)
  });
  return targetPosition;
};
var offset = function(element) {
  element = renderer_default(element).get(0);
  if (isWindow(element)) {
    return null;
  } else if (element && "pageY" in element && "pageX" in element) {
    return {
      top: element.pageY,
      left: element.pageX
    };
  }
  return renderer_default(element).offset();
};
if (!position.inverseAlign) {
  position.inverseAlign = inverseAlign;
}
if (!position.normalizeAlign) {
  position.normalizeAlign = normalizeAlign;
}
var position_default = {
  calculateScrollbarWidth,
  calculate: calculatePosition,
  setup: position,
  offset
};

// node_modules/devextreme/esm/__internal/events/core/m_event_registrator.js
var registerEvent = function(name2, eventObject) {
  const strategy3 = {};
  if ("noBubble" in eventObject) {
    strategy3.noBubble = eventObject.noBubble;
  }
  if ("bindType" in eventObject) {
    strategy3.bindType = eventObject.bindType;
  }
  if ("delegateType" in eventObject) {
    strategy3.delegateType = eventObject.delegateType;
  }
  each(["setup", "teardown", "add", "remove", "trigger", "handle", "_default", "dispose"], (_, methodName) => {
    if (!eventObject[methodName]) {
      return;
    }
    strategy3[methodName] = function() {
      const args = [].slice.call(arguments);
      args.unshift(this);
      return eventObject[methodName].apply(eventObject, args);
    };
  });
  event_registrator_callbacks_default.fire(name2, strategy3);
};
registerEvent.callbacks = event_registrator_callbacks_default;
var m_event_registrator_default = registerEvent;

// node_modules/devextreme/esm/__internal/events/m_remove.js
var removeEvent = "dxremove";
var eventPropName = "dxRemoveEvent";
beforeCleanData((elements) => {
  elements = [].slice.call(elements);
  for (let i = 0; i < elements.length; i++) {
    const $element = renderer_default(elements[i]);
    if ($element.prop(eventPropName)) {
      $element[0][eventPropName] = null;
      m_events_engine_default.triggerHandler($element, "dxremove");
    }
  }
});
m_event_registrator_default("dxremove", {
  noBubble: true,
  setup(element) {
    renderer_default(element).prop(eventPropName, true);
  }
});

// node_modules/devextreme/esm/common/core/animation/fx.js
var window10 = getWindow();
var removeEventName = addNamespace2(removeEvent, "dxFX");
var RELATIVE_VALUE_REGEX = /^([+-])=(.*)/i;
var TransitionAnimationStrategy = {
  initAnimation: function($element, config3) {
    $element.css({
      transitionProperty: "none"
    });
    if ("string" === typeof config3.from) {
      $element.addClass(config3.from);
    } else {
      setProps($element, config3.from);
    }
    const that = this;
    const deferred = new Deferred();
    const cleanupWhen = config3.cleanupWhen;
    config3.transitionAnimation = {
      deferred,
      finish: function() {
        that._finishTransition($element);
        if (cleanupWhen) {
          when(deferred, cleanupWhen).always(function() {
            that._cleanup($element, config3);
          });
        } else {
          that._cleanup($element, config3);
        }
        deferred.resolveWith($element, [config3, $element]);
      }
    };
    this._completeAnimationCallback($element, config3).done(function() {
      config3.transitionAnimation.finish();
    }).fail(function() {
      deferred.rejectWith($element, [config3, $element]);
    });
    if (!config3.duration) {
      config3.transitionAnimation.finish();
    }
    $element.css("transform");
  },
  animate: function($element, config3) {
    this._startAnimation($element, config3);
    return config3.transitionAnimation.deferred.promise();
  },
  _completeAnimationCallback: function($element, config3) {
    const that = this;
    const startTime = Date.now() + config3.delay;
    const deferred = new Deferred();
    const transitionEndFired = new Deferred();
    const simulatedTransitionEndFired = new Deferred();
    let simulatedEndEventTimer;
    const transitionEndEventFullName = m_support_default.transitionEndEventName() + ".dxFX";
    config3.transitionAnimation.cleanup = function() {
      clearTimeout(simulatedEndEventTimer);
      clearTimeout(waitForJSCompleteTimer);
      m_events_engine_default.off($element, transitionEndEventFullName);
      m_events_engine_default.off($element, removeEventName);
    };
    m_events_engine_default.one($element, transitionEndEventFullName, function() {
      if (Date.now() - startTime >= config3.duration) {
        transitionEndFired.reject();
      }
    });
    m_events_engine_default.off($element, removeEventName);
    m_events_engine_default.on($element, removeEventName, function() {
      that.stop($element, config3);
      deferred.reject();
    });
    const waitForJSCompleteTimer = setTimeout(function() {
      simulatedEndEventTimer = setTimeout(function() {
        simulatedTransitionEndFired.reject();
      }, config3.duration + config3.delay + fx._simulatedTransitionEndDelay);
      when(transitionEndFired, simulatedTransitionEndFired).fail(function() {
        deferred.resolve();
      }.bind(this));
    });
    return deferred.promise();
  },
  _startAnimation: function($element, config3) {
    $element.css({
      transitionProperty: "all",
      transitionDelay: config3.delay + "ms",
      transitionDuration: config3.duration + "ms",
      transitionTimingFunction: config3.easing
    });
    if ("string" === typeof config3.to) {
      $element[0].className += " " + config3.to;
    } else if (config3.to) {
      setProps($element, config3.to);
    }
  },
  _finishTransition: function($element) {
    $element.css("transition", "none");
  },
  _cleanup: function($element, config3) {
    config3.transitionAnimation.cleanup();
    if ("string" === typeof config3.from) {
      $element.removeClass(config3.from);
      $element.removeClass(config3.to);
    }
  },
  stop: function($element, config3, jumpToEnd) {
    if (!config3) {
      return;
    }
    if (jumpToEnd) {
      config3.transitionAnimation.finish();
    } else {
      if (isPlainObject(config3.to)) {
        each(config3.to, function(key) {
          $element.css(key, $element.css(key));
        });
      }
      this._finishTransition($element);
      this._cleanup($element, config3);
    }
  }
};
var FrameAnimationStrategy = {
  initAnimation: function($element, config3) {
    setProps($element, config3.from);
  },
  animate: function($element, config3) {
    const deferred = new Deferred();
    const that = this;
    if (!config3) {
      return deferred.reject().promise();
    }
    each(config3.to, function(prop) {
      if (void 0 === config3.from[prop]) {
        config3.from[prop] = that._normalizeValue($element.css(prop));
      }
    });
    if (config3.to.transform) {
      config3.from.transform = that._parseTransform(config3.from.transform);
      config3.to.transform = that._parseTransform(config3.to.transform);
    }
    config3.frameAnimation = {
      to: config3.to,
      from: config3.from,
      currentValue: config3.from,
      easing: convertTransitionTimingFuncToEasing(config3.easing),
      duration: config3.duration,
      startTime: (/* @__PURE__ */ new Date()).valueOf(),
      finish: function() {
        this.currentValue = this.to;
        this.draw();
        cancelAnimationFrame(config3.frameAnimation.animationFrameId);
        deferred.resolve();
      },
      draw: function() {
        if (config3.draw) {
          config3.draw(this.currentValue);
          return;
        }
        const currentValue = extend({}, this.currentValue);
        if (currentValue.transform) {
          currentValue.transform = map(currentValue.transform, function(value2, prop) {
            if ("translate" === prop) {
              return getTranslateCss(value2);
            } else if ("scale" === prop) {
              return "scale(" + value2 + ")";
            } else if ("rotate" === prop.substr(0, prop.length - 1)) {
              return prop + "(" + value2 + "deg)";
            }
          }).join(" ");
        }
        $element.css(currentValue);
      }
    };
    if (config3.delay) {
      config3.frameAnimation.startTime += config3.delay;
      config3.frameAnimation.delayTimeout = setTimeout(function() {
        that._startAnimation($element, config3);
      }, config3.delay);
    } else {
      that._startAnimation($element, config3);
    }
    return deferred.promise();
  },
  _startAnimation: function($element, config3) {
    m_events_engine_default.off($element, removeEventName);
    m_events_engine_default.on($element, removeEventName, function() {
      if (config3.frameAnimation) {
        cancelAnimationFrame(config3.frameAnimation.animationFrameId);
      }
    });
    this._animationStep($element, config3);
  },
  _parseTransform: function(transformString) {
    const result2 = {};
    each(transformString.match(/\w+\d*\w*\([^)]*\)\s*/g), function(i, part) {
      const translateData = parseTranslate(part);
      const scaleData = part.match(/scale\((.+?)\)/);
      const rotateData = part.match(/(rotate.)\((.+)deg\)/);
      if (translateData) {
        result2.translate = translateData;
      }
      if (scaleData && scaleData[1]) {
        result2.scale = parseFloat(scaleData[1]);
      }
      if (rotateData && rotateData[1]) {
        result2[rotateData[1]] = parseFloat(rotateData[2]);
      }
    });
    return result2;
  },
  stop: function($element, config3, jumpToEnd) {
    const frameAnimation = config3 && config3.frameAnimation;
    if (!frameAnimation) {
      return;
    }
    cancelAnimationFrame(frameAnimation.animationFrameId);
    clearTimeout(frameAnimation.delayTimeout);
    if (jumpToEnd) {
      frameAnimation.finish();
    }
    delete config3.frameAnimation;
  },
  _animationStep: function($element, config3) {
    const frameAnimation = config3 && config3.frameAnimation;
    if (!frameAnimation) {
      return;
    }
    const now = (/* @__PURE__ */ new Date()).valueOf();
    if (now >= frameAnimation.startTime + frameAnimation.duration) {
      frameAnimation.finish();
      return;
    }
    frameAnimation.currentValue = this._calcStepValue(frameAnimation, now - frameAnimation.startTime);
    frameAnimation.draw();
    const that = this;
    frameAnimation.animationFrameId = requestAnimationFrame(function() {
      that._animationStep($element, config3);
    });
  },
  _calcStepValue: function(frameAnimation, currentDuration) {
    const calcValueRecursively = function(from, to) {
      const result2 = Array.isArray(to) ? [] : {};
      each(to, function(propName, endPropValue) {
        if ("string" === typeof endPropValue && false === parseFloat(endPropValue)) {
          return true;
        }
        result2[propName] = "object" === typeof endPropValue ? calcValueRecursively(from[propName], endPropValue) : function(propName2) {
          const x = currentDuration / frameAnimation.duration;
          const t = currentDuration;
          const b = 1 * from[propName2];
          const c = to[propName2] - from[propName2];
          const d = frameAnimation.duration;
          return getEasing(frameAnimation.easing)(x, t, b, c, d);
        }(propName);
      });
      return result2;
    };
    return calcValueRecursively(frameAnimation.from, frameAnimation.to);
  },
  _normalizeValue: function(value2) {
    const numericValue = parseFloat(value2);
    if (false === numericValue) {
      return value2;
    }
    return numericValue;
  }
};
var FallbackToNoAnimationStrategy = {
  initAnimation: function() {
  },
  animate: function() {
    return new Deferred().resolve().promise();
  },
  stop: noop2,
  isSynchronous: true
};
var getAnimationStrategy = function(config3) {
  config3 = config3 || {};
  const animationStrategies = {
    transition: m_support_default.transition() ? TransitionAnimationStrategy : FrameAnimationStrategy,
    frame: FrameAnimationStrategy,
    noAnimation: FallbackToNoAnimationStrategy
  };
  let strategy3 = config3.strategy || "transition";
  if ("css" === config3.type && !m_support_default.transition()) {
    strategy3 = "noAnimation";
  }
  return animationStrategies[strategy3];
};
var baseConfigValidator = function(config3, animationType, validate, typeMessage) {
  each(["from", "to"], function() {
    if (!validate(config3[this])) {
      throw errors_default.Error("E0010", animationType, this, typeMessage);
    }
  });
};
var isObjectConfigValidator = function(config3, animationType) {
  return baseConfigValidator(config3, animationType, function(target) {
    return isPlainObject(target);
  }, "a plain object");
};
var isStringConfigValidator = function(config3, animationType) {
  return baseConfigValidator(config3, animationType, function(target) {
    return "string" === typeof target;
  }, "a string");
};
var CustomAnimationConfigurator = {
  setup: function() {
  }
};
var CssAnimationConfigurator = {
  validateConfig: function(config3) {
    isStringConfigValidator(config3, "css");
  },
  setup: function() {
  }
};
var positionAliases = {
  top: {
    my: "bottom center",
    at: "top center"
  },
  bottom: {
    my: "top center",
    at: "bottom center"
  },
  right: {
    my: "left center",
    at: "right center"
  },
  left: {
    my: "right center",
    at: "left center"
  }
};
var SlideAnimationConfigurator = {
  validateConfig: function(config3) {
    isObjectConfigValidator(config3, "slide");
  },
  setup: function($element, config3) {
    const location = locate($element);
    if ("slide" !== config3.type) {
      const positioningConfig = "slideIn" === config3.type ? config3.from : config3.to;
      positioningConfig.position = extend({
        of: window10
      }, positionAliases[config3.direction]);
      setupPosition($element, positioningConfig);
    }
    this._setUpConfig(location, config3.from);
    this._setUpConfig(location, config3.to);
    clearCache($element);
  },
  _setUpConfig: function(location, config3) {
    config3.left = "left" in config3 ? config3.left : "+=0";
    config3.top = "top" in config3 ? config3.top : "+=0";
    this._initNewPosition(location, config3);
  },
  _initNewPosition: function(location, config3) {
    const position3 = {
      left: config3.left,
      top: config3.top
    };
    delete config3.left;
    delete config3.top;
    let relativeValue = this._getRelativeValue(position3.left);
    if (void 0 !== relativeValue) {
      position3.left = relativeValue + location.left;
    } else {
      config3.left = 0;
    }
    relativeValue = this._getRelativeValue(position3.top);
    if (void 0 !== relativeValue) {
      position3.top = relativeValue + location.top;
    } else {
      config3.top = 0;
    }
    config3.transform = getTranslateCss({
      x: position3.left,
      y: position3.top
    });
  },
  _getRelativeValue: function(value2) {
    let relativeValue;
    if ("string" === typeof value2 && (relativeValue = RELATIVE_VALUE_REGEX.exec(value2))) {
      return parseInt(relativeValue[1] + "1") * relativeValue[2];
    }
  }
};
var FadeAnimationConfigurator = {
  setup: function($element, config3) {
    const from = config3.from;
    const to = config3.to;
    const defaultFromOpacity = "fadeOut" === config3.type ? 1 : 0;
    const defaultToOpacity = "fadeOut" === config3.type ? 0 : 1;
    let fromOpacity = isPlainObject(from) ? String(from.opacity ?? defaultFromOpacity) : String(from);
    let toOpacity = isPlainObject(to) ? String(to.opacity ?? defaultToOpacity) : String(to);
    if (!config3.skipElementInitialStyles) {
      fromOpacity = $element.css("opacity");
    }
    switch (config3.type) {
      case "fadeIn":
        toOpacity = 1;
        break;
      case "fadeOut":
        toOpacity = 0;
    }
    config3.from = {
      visibility: "visible",
      opacity: fromOpacity
    };
    config3.to = {
      opacity: toOpacity
    };
  }
};
var PopAnimationConfigurator = {
  validateConfig: function(config3) {
    isObjectConfigValidator(config3, "pop");
  },
  setup: function($element, config3) {
    const from = config3.from;
    const to = config3.to;
    const fromOpacity = "opacity" in from ? from.opacity : $element.css("opacity");
    const toOpacity = "opacity" in to ? to.opacity : 1;
    const fromScale = "scale" in from ? from.scale : 0;
    const toScale = "scale" in to ? to.scale : 1;
    config3.from = {
      opacity: fromOpacity
    };
    const translate = getTranslate($element);
    config3.from.transform = this._getCssTransform(translate, fromScale);
    config3.to = {
      opacity: toOpacity
    };
    config3.to.transform = this._getCssTransform(translate, toScale);
  },
  _getCssTransform: function(translate, scale) {
    return getTranslateCss(translate) + "scale(" + scale + ")";
  }
};
var animationConfigurators = {
  custom: CustomAnimationConfigurator,
  slide: SlideAnimationConfigurator,
  slideIn: SlideAnimationConfigurator,
  slideOut: SlideAnimationConfigurator,
  fade: FadeAnimationConfigurator,
  fadeIn: FadeAnimationConfigurator,
  fadeOut: FadeAnimationConfigurator,
  pop: PopAnimationConfigurator,
  css: CssAnimationConfigurator
};
var getAnimationConfigurator = function(config3) {
  const result2 = animationConfigurators[config3.type];
  if (!result2) {
    throw errors_default.Error("E0011", config3.type);
  }
  return result2;
};
var defaultJSConfig = {
  type: "custom",
  from: {},
  to: {},
  duration: 400,
  start: noop2,
  complete: noop2,
  easing: "ease",
  delay: 0
};
var defaultCssConfig = {
  duration: 400,
  easing: "ease",
  delay: 0
};
function setupAnimationOnElement() {
  const $element = this.element;
  const config3 = this.config;
  setupPosition($element, config3.from);
  setupPosition($element, config3.to);
  this.configurator.setup($element, config3);
  $element.data("dxAnimData", this);
  if (fx.off) {
    config3.duration = 0;
    config3.delay = 0;
  }
  this.strategy.initAnimation($element, config3);
  if (config3.start) {
    const element = getPublicElement($element);
    config3.start.apply(this, [element, config3]);
  }
}
var onElementAnimationComplete = function(animation3) {
  const $element = animation3.element;
  const config3 = animation3.config;
  $element.removeData("dxAnimData");
  if (config3.complete) {
    const element = getPublicElement($element);
    config3.complete.apply(this, [element, config3]);
  }
  animation3.deferred.resolveWith(this, [$element, config3]);
};
var startAnimationOnElement = function() {
  const animation3 = this;
  const $element = animation3.element;
  const config3 = animation3.config;
  animation3.isStarted = true;
  return animation3.strategy.animate($element, config3).done(function() {
    onElementAnimationComplete(animation3);
  }).fail(function() {
    animation3.deferred.rejectWith(this, [$element, config3]);
  });
};
var stopAnimationOnElement = function(jumpToEnd) {
  const animation3 = this;
  const $element = animation3.element;
  const config3 = animation3.config;
  clearTimeout(animation3.startTimeout);
  if (!animation3.isStarted) {
    animation3.start();
  }
  animation3.strategy.stop($element, config3, jumpToEnd);
};
var scopedRemoveEvent = addNamespace2(removeEvent, "dxFXStartAnimation");
var subscribeToRemoveEvent = function(animation3) {
  m_events_engine_default.off(animation3.element, scopedRemoveEvent);
  m_events_engine_default.on(animation3.element, scopedRemoveEvent, function() {
    fx.stop(animation3.element);
  });
  animation3.deferred.always(function() {
    m_events_engine_default.off(animation3.element, scopedRemoveEvent);
  });
};
var createAnimation = function(element, initialConfig) {
  const defaultConfig = "css" === initialConfig.type ? defaultCssConfig : defaultJSConfig;
  const config3 = extend(true, {}, defaultConfig, initialConfig);
  const configurator = getAnimationConfigurator(config3);
  const strategy3 = getAnimationStrategy(config3);
  const animation3 = {
    element: renderer_default(element),
    config: config3,
    configurator,
    strategy: strategy3,
    isSynchronous: strategy3.isSynchronous,
    setup: setupAnimationOnElement,
    start: startAnimationOnElement,
    stop: stopAnimationOnElement,
    deferred: new Deferred()
  };
  if (isFunction(configurator.validateConfig)) {
    configurator.validateConfig(config3);
  }
  subscribeToRemoveEvent(animation3);
  return animation3;
};
var animate = function(element, config3) {
  const $element = renderer_default(element);
  if (!$element.length) {
    return new Deferred().resolve().promise();
  }
  const animation3 = createAnimation($element, config3);
  pushInAnimationQueue($element, animation3);
  return animation3.deferred.promise();
};
function pushInAnimationQueue($element, animation3) {
  const queueData = getAnimQueueData($element);
  writeAnimQueueData($element, queueData);
  queueData.push(animation3);
  if (!isAnimating($element)) {
    shiftFromAnimationQueue($element, queueData);
  }
}
function getAnimQueueData($element) {
  return $element.data("dxAnimQueue") || [];
}
function writeAnimQueueData($element, queueData) {
  $element.data("dxAnimQueue", queueData);
}
var destroyAnimQueueData = function($element) {
  $element.removeData("dxAnimQueue");
};
function isAnimating($element) {
  return !!$element.data("dxAnimData");
}
function shiftFromAnimationQueue($element, queueData) {
  queueData = getAnimQueueData($element);
  if (!queueData.length) {
    return;
  }
  const animation3 = queueData.shift();
  if (0 === queueData.length) {
    destroyAnimQueueData($element);
  }
  executeAnimation(animation3).done(function() {
    if (!isAnimating($element)) {
      shiftFromAnimationQueue($element);
    }
  });
}
function executeAnimation(animation3) {
  animation3.setup();
  if (fx.off || animation3.isSynchronous) {
    animation3.start();
  } else {
    animation3.startTimeout = setTimeout(function() {
      animation3.start();
    });
  }
  return animation3.deferred.promise();
}
function setupPosition($element, config3) {
  if (!config3 || !config3.position) {
    return;
  }
  const win = renderer_default(window10);
  let left = 0;
  let top = 0;
  const position3 = position_default.calculate($element, config3.position);
  const offset2 = $element.offset();
  const currentPosition = $element.position();
  if (currentPosition.top > offset2.top) {
    top = win.scrollTop();
  }
  if (currentPosition.left > offset2.left) {
    left = win.scrollLeft();
  }
  extend(config3, {
    left: position3.h.location - offset2.left + currentPosition.left - left,
    top: position3.v.location - offset2.top + currentPosition.top - top
  });
  delete config3.position;
}
function setProps($element, props) {
  each(props, function(key, value2) {
    try {
      $element.css(key, isFunction(value2) ? value2() : value2);
    } catch (e) {
    }
  });
}
var stop = function(element, jumpToEnd) {
  const $element = renderer_default(element);
  const queueData = getAnimQueueData($element);
  each(queueData, function(_, animation4) {
    animation4.config.delay = 0;
    animation4.config.duration = 0;
    animation4.isSynchronous = true;
  });
  if (!isAnimating($element)) {
    shiftFromAnimationQueue($element, queueData);
  }
  const animation3 = $element.data("dxAnimData");
  if (animation3) {
    animation3.stop(jumpToEnd);
  }
  $element.removeData("dxAnimData");
  destroyAnimQueueData($element);
};
var fx = {
  off: false,
  animationTypes: animationConfigurators,
  animate,
  createAnimation,
  isAnimating,
  stop,
  _simulatedTransitionEndDelay: 100
};
var fx_default = fx;

// node_modules/devextreme/esm/__internal/core/m_action.js
var Action = class _Action {
  constructor(action, config3) {
    config3 = config3 || {};
    this._action = action;
    this._context = config3.context || getWindow();
    this._beforeExecute = config3.beforeExecute;
    this._afterExecute = config3.afterExecute;
    this._component = config3.component;
    this._validatingTargetName = config3.validatingTargetName;
    const excludeValidators = this._excludeValidators = {};
    if (config3.excludeValidators) {
      for (let i = 0; i < config3.excludeValidators.length; i++) {
        excludeValidators[config3.excludeValidators[i]] = true;
      }
    }
  }
  execute() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    const e = {
      action: this._action,
      args: Array.prototype.slice.call(args),
      context: this._context,
      component: this._component,
      validatingTargetName: this._validatingTargetName,
      cancel: false,
      handled: false
    };
    const beforeExecute = this._beforeExecute;
    const afterExecute = this._afterExecute;
    const argsBag = e.args[0] || {};
    if (!this._validateAction(e)) {
      return;
    }
    null === beforeExecute || void 0 === beforeExecute || beforeExecute.call(this._context, e);
    if (e.cancel) {
      return;
    }
    const result2 = this._executeAction(e);
    if (argsBag.cancel) {
      return;
    }
    null === afterExecute || void 0 === afterExecute || afterExecute.call(this._context, e);
    return result2;
  }
  _validateAction(e) {
    const excludeValidators = this._excludeValidators;
    const {
      executors
    } = _Action;
    for (const name2 in executors) {
      if (!excludeValidators[name2]) {
        var _executor$validate;
        const executor = executors[name2];
        null === (_executor$validate = executor.validate) || void 0 === _executor$validate || _executor$validate.call(executor, e);
        if (e.cancel) {
          return false;
        }
      }
    }
    return true;
  }
  _executeAction(e) {
    let result2;
    const {
      executors
    } = _Action;
    for (const name2 in executors) {
      var _executor$execute;
      const executor = executors[name2];
      null === (_executor$execute = executor.execute) || void 0 === _executor$execute || _executor$execute.call(executor, e);
      if (e.handled) {
        result2 = e.result;
        break;
      }
    }
    return result2;
  }
  static registerExecutor(name2, executor) {
    if (isPlainObject(name2)) {
      each(name2, _Action.registerExecutor);
      return;
    }
    _Action.executors[name2] = executor;
  }
  static unregisterExecutor() {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    each(args, function() {
      delete _Action.executors[this];
    });
  }
};
Action.executors = {};
var createValidatorByTargetElement = (condition) => (e) => {
  if (!e.args.length) {
    return;
  }
  const args = e.args[0];
  const element = args[e.validatingTargetName] || args.element;
  if (element && condition(renderer_default(element))) {
    e.cancel = true;
  }
};
Action.registerExecutor({
  disabled: {
    validate: createValidatorByTargetElement(($target) => $target.is(".dx-state-disabled, .dx-state-disabled *"))
  },
  readOnly: {
    validate: createValidatorByTargetElement(($target) => $target.is(".dx-state-readonly, .dx-state-readonly *:not(.dx-state-independent)"))
  },
  undefined: {
    execute: (e) => {
      if (!e.action) {
        e.result = void 0;
        e.handled = true;
      }
    }
  },
  func: {
    execute: (e) => {
      if (isFunction(e.action)) {
        e.result = e.action.call(e.context, e.args[0]);
        e.handled = true;
      }
    }
  }
});

// node_modules/devextreme/esm/core/action.js
var action_default = Action;

// node_modules/devextreme/esm/__internal/core/options/m_utils.js
var cachedGetters = {};
var convertRulesToOptions = (rules) => {
  const currentDevice = devices_default.current();
  return rules.reduce((options2, _ref) => {
    let {
      device,
      options: ruleOptions
    } = _ref;
    const deviceFilter = device || {};
    const match2 = isFunction(deviceFilter) ? deviceFilter(currentDevice) : deviceMatch(currentDevice, deviceFilter);
    if (match2) {
      extend(true, options2, ruleOptions);
    }
    return options2;
  }, {});
};
var normalizeOptions = (options2, value2) => "string" !== typeof options2 ? options2 : {
  [options2]: value2
};
var deviceMatch = (device, filter) => isEmptyObject(filter) || findBestMatches(device, [filter]).length > 0;
var getFieldName = (fullName) => fullName.substr(fullName.lastIndexOf(".") + 1);
var getParentName = (fullName) => fullName.substr(0, fullName.lastIndexOf("."));
var getNestedOptionValue = function(optionsObject, name2) {
  cachedGetters[name2] = cachedGetters[name2] || compileGetter(name2);
  return cachedGetters[name2](optionsObject, {
    functionsAsIs: true
  });
};
var createDefaultOptionRules = function() {
  let options2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];
  return options2;
};

// node_modules/devextreme/esm/__internal/core/utils/m_comparator.js
var hasNegation = function(oldValue, newValue) {
  return 1 / oldValue === 1 / newValue;
};
var equals = function(oldValue, newValue) {
  oldValue = toComparable(oldValue, true);
  newValue = toComparable(newValue, true);
  if (oldValue && newValue && isRenderer(oldValue) && isRenderer(newValue)) {
    return newValue.is(oldValue);
  }
  const oldValueIsNaN = oldValue !== oldValue;
  const newValueIsNaN = newValue !== newValue;
  if (oldValueIsNaN && newValueIsNaN) {
    return true;
  }
  if (0 === oldValue && 0 === newValue) {
    return hasNegation(oldValue, newValue);
  }
  if (null === oldValue || "object" !== typeof oldValue || dom_adapter_default.isElementNode(oldValue)) {
    return oldValue === newValue;
  }
  return false;
};

// node_modules/devextreme/esm/__internal/core/options/m_option_manager.js
var cachedGetters2 = {};
var cachedSetters = {};
var OptionManager = class {
  constructor(options2, optionsByReference) {
    this._options = options2;
    this._optionsByReference = optionsByReference;
    this._changingCallback;
    this._changedCallback;
    this._namePreparedCallbacks;
    this._validateOptionsCallback;
  }
  _setByReference(options2, rulesOptions) {
    extend(true, options2, rulesOptions);
    for (const fieldName in this._optionsByReference) {
      if (Object.prototype.hasOwnProperty.call(rulesOptions, fieldName)) {
        options2[fieldName] = rulesOptions[fieldName];
      }
    }
  }
  _setPreparedValue(name2, value2, merge, silent) {
    const previousValue = this.get(this._options, name2, false);
    if (!equals(previousValue, value2)) {
      const path = getPathParts(name2);
      !silent && this._changingCallback(name2, previousValue, value2);
      cachedSetters[name2] = cachedSetters[name2] || compileSetter(name2);
      cachedSetters[name2](this._options, value2, {
        functionsAsIs: true,
        merge: isDefined(merge) ? merge : !this._optionsByReference[name2],
        unwrapObservables: path.length > 1 && !!this._optionsByReference[path[0]]
      });
      !silent && this._changedCallback(name2, value2, previousValue);
    }
  }
  _prepareRelevantNames(options2, name2, value2, silent) {
    if (isPlainObject(value2)) {
      for (const valueName in value2) {
        this._prepareRelevantNames(options2, `${name2}.${valueName}`, value2[valueName]);
      }
    }
    this._namePreparedCallbacks(options2, name2, value2, silent);
  }
  get() {
    let options2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this._options;
    let name2 = arguments.length > 1 ? arguments[1] : void 0;
    let unwrapObservables = arguments.length > 2 ? arguments[2] : void 0;
    cachedGetters2[name2] = cachedGetters2[name2] || compileGetter(name2);
    return cachedGetters2[name2](options2, {
      functionsAsIs: true,
      unwrapObservables
    });
  }
  set(options2, value2, merge, silent) {
    options2 = normalizeOptions(options2, value2);
    for (const name2 in options2) {
      this._prepareRelevantNames(options2, name2, options2[name2], silent);
    }
    if (this._validateOptionsCallback) {
      options2 = this._validateOptionsCallback(options2);
    }
    for (const name2 in options2) {
      this._setPreparedValue(name2, options2[name2], merge, silent);
    }
  }
  onRelevantNamesPrepared(callBack) {
    this._namePreparedCallbacks = callBack;
  }
  onChanging(callBack) {
    this._changingCallback = callBack;
  }
  onChanged(callBack) {
    this._changedCallback = callBack;
  }
  onValidateOptions(callback) {
    this._validateOptionsCallback = callback;
  }
  dispose() {
    this._changingCallback = noop2;
    this._changedCallback = noop2;
  }
};

// node_modules/devextreme/esm/__internal/core/options/m_index.js
var Options = class {
  constructor(options2, defaultOptions4, optionsByReference, deprecatedOptions) {
    this._deprecatedCallback;
    this._startChangeCallback;
    this._endChangeCallback;
    this._validateOptionsCallback;
    this._default = defaultOptions4;
    this._deprecated = deprecatedOptions;
    this._deprecatedNames = [];
    this._initDeprecatedNames();
    this._optionManager = new OptionManager(options2, optionsByReference);
    this._optionManager.onRelevantNamesPrepared((options3, name2, value2, silent) => this._setRelevantNames(options3, name2, value2, silent));
    this._cachedOptions = {};
    this._rules = [];
  }
  set _initial(value2) {
    this._initialOptions = value2;
  }
  get _initial() {
    if (!this._initialOptions) {
      const rulesOptions = this._getByRules(this.silent("defaultOptionsRules"));
      this._initialOptions = this._default;
      this._optionManager._setByReference(this._initialOptions, rulesOptions);
    }
    return this._initialOptions;
  }
  _initDeprecatedNames() {
    for (const optionName in this._deprecated) {
      this._deprecatedNames.push(optionName);
    }
  }
  _getByRules(rules) {
    rules = Array.isArray(rules) ? this._rules.concat(rules) : this._rules;
    return convertRulesToOptions(rules);
  }
  _notifyDeprecated(option) {
    const info = this._deprecated[option];
    if (info) {
      this._deprecatedCallback(option, info);
    }
  }
  _setRelevantNames(options2, name2, value2, silent) {
    if (name2) {
      const normalizedName = this._normalizeName(name2, silent);
      if (normalizedName && normalizedName !== name2) {
        this._setField(options2, normalizedName, value2);
        this._clearField(options2, name2);
      }
    }
  }
  _setField(options2, fullName, value2) {
    let fieldName = "";
    let fieldObject = null;
    do {
      fieldName = fieldName ? `.${fieldName}` : "";
      fieldName = getFieldName(fullName) + fieldName;
      fullName = getParentName(fullName);
      fieldObject = fullName ? this._optionManager.get(options2, fullName, false) : options2;
    } while (!fieldObject);
    fieldObject[fieldName] = value2;
  }
  _clearField(options2, name2) {
    delete options2[name2];
    const previousFieldName = getParentName(name2);
    const fieldObject = previousFieldName ? this._optionManager.get(options2, previousFieldName, false) : options2;
    if (fieldObject) {
      delete fieldObject[getFieldName(name2)];
    }
  }
  _normalizeName(name2, silent) {
    if (this._deprecatedNames.length && name2) {
      for (let i = 0; i < this._deprecatedNames.length; i++) {
        if (this._deprecatedNames[i] === name2) {
          const deprecate = this._deprecated[name2];
          if (deprecate) {
            !silent && this._notifyDeprecated(name2);
            return deprecate.alias || name2;
          }
        }
      }
    }
    return name2;
  }
  addRules(rules) {
    this._rules = rules.concat(this._rules);
  }
  applyRules(rules) {
    const options2 = this._getByRules(rules);
    this.silent(options2);
  }
  dispose() {
    this._deprecatedCallback = noop2;
    this._startChangeCallback = noop2;
    this._endChangeCallback = noop2;
    this._optionManager.dispose();
  }
  onChanging(callBack) {
    this._optionManager.onChanging(callBack);
  }
  onChanged(callBack) {
    this._optionManager.onChanged(callBack);
  }
  validateOptions(callBack) {
    this._optionManager.onValidateOptions(callBack);
  }
  onDeprecated(callBack) {
    this._deprecatedCallback = callBack;
  }
  onStartChange(callBack) {
    this._startChangeCallback = callBack;
  }
  onEndChange(callBack) {
    this._endChangeCallback = callBack;
  }
  isInitial(name2) {
    const value2 = this.silent(name2);
    const initialValue = this.initial(name2);
    const areFunctions = isFunction(value2) && isFunction(initialValue);
    return areFunctions ? value2.toString() === initialValue.toString() : equalByValue(value2, initialValue);
  }
  initial(name2) {
    return getNestedOptionValue(this._initial, name2);
  }
  option(options2, value2) {
    const isGetter = arguments.length < 2 && "object" !== type(options2);
    if (isGetter) {
      return this._optionManager.get(void 0, this._normalizeName(options2));
    }
    this._startChangeCallback();
    try {
      this._optionManager.set(options2, value2);
    } finally {
      this._endChangeCallback();
    }
  }
  silent(options2, value2) {
    const isGetter = arguments.length < 2 && "object" !== type(options2);
    if (isGetter) {
      return this._optionManager.get(void 0, options2, void 0, true);
    }
    this._optionManager.set(options2, value2, void 0, true);
  }
  reset(name2) {
    if (name2) {
      const fullPath = getPathParts(name2);
      const value2 = fullPath.reduce((value3, field) => value3 ? value3[field] : this.initial(field), null);
      const defaultValue = isObject(value2) ? _extends({}, value2) : value2;
      this._optionManager.set(name2, defaultValue, false);
    }
  }
  getAliasesByName(name2) {
    return Object.keys(this._deprecated).filter((aliasName) => name2 === this._deprecated[aliasName].alias);
  }
  isDeprecated(name2) {
    return Object.prototype.hasOwnProperty.call(this._deprecated, name2);
  }
  cache(name2, options2) {
    const isGetter = arguments.length < 2;
    if (isGetter) {
      return this._cachedOptions[name2];
    }
    this._cachedOptions[name2] = extend(this._cachedOptions[name2], options2);
  }
};

// node_modules/devextreme/esm/__internal/core/m_postponed_operations.js
var PostponedOperations = class {
  constructor() {
    this._postponedOperations = {};
  }
  add(key, fn, postponedPromise) {
    if (key in this._postponedOperations) {
      postponedPromise && this._postponedOperations[key].promises.push(postponedPromise);
    } else {
      const completePromise = new Deferred();
      this._postponedOperations[key] = {
        fn,
        completePromise,
        promises: postponedPromise ? [postponedPromise] : []
      };
    }
    return this._postponedOperations[key].completePromise.promise();
  }
  callPostponedOperations() {
    for (const key in this._postponedOperations) {
      const operation = this._postponedOperations[key];
      if (isDefined(operation)) {
        if (operation.promises && operation.promises.length) {
          when(...operation.promises).done(operation.fn).then(operation.completePromise.resolve);
        } else {
          operation.fn().done(operation.completePromise.resolve);
        }
      }
    }
    this._postponedOperations = {};
  }
};

// node_modules/devextreme/esm/__internal/core/utils/m_public_component.js
var componentNames = /* @__PURE__ */ new WeakMap();
var nextAnonymousComponent = 0;
var getName = function(componentClass, newName) {
  if (isDefined(newName)) {
    componentNames.set(componentClass, newName);
    return;
  }
  if (!componentNames.has(componentClass)) {
    const generatedName = "dxPrivateComponent" + nextAnonymousComponent++;
    componentNames.set(componentClass, generatedName);
    return generatedName;
  }
  return componentNames.get(componentClass);
};
function attachInstanceToElement($element, componentInstance, disposeFn) {
  const data17 = data($element.get(0));
  const name2 = getName(componentInstance.constructor);
  data17[name2] = componentInstance;
  if (disposeFn) {
    m_events_engine_default.one($element, removeEvent, function() {
      disposeFn.call(componentInstance);
    });
  }
  if (!data17.dxComponents) {
    data17.dxComponents = [];
  }
  data17.dxComponents.push(name2);
}
function getInstanceByElement($element, componentClass) {
  const name2 = getName(componentClass);
  return data($element.get(0), name2);
}

// node_modules/devextreme/esm/__internal/core/widget/component.js
var getEventName = (actionName) => actionName.charAt(2).toLowerCase() + actionName.substr(3);
var isInnerOption = (optionName) => 0 === optionName.indexOf("_", 0);
var Component = class extends class_default.inherit({}) {
  _setDeprecatedOptions() {
    this._deprecatedOptions = {};
  }
  _getDeprecatedOptions() {
    return this._deprecatedOptions;
  }
  _getDefaultOptions() {
    return {
      onInitialized: null,
      onOptionChanged: null,
      onDisposing: null,
      defaultOptionsRules: null
    };
  }
  _defaultOptionsRules() {
    return [];
  }
  _setOptionsByDevice(rules) {
    this._options.applyRules(rules);
  }
  _convertRulesToOptions(rules) {
    return convertRulesToOptions(rules);
  }
  _isInitialOptionValue(name2) {
    return this._options.isInitial(name2);
  }
  _setOptionsByReference() {
    this._optionsByReference = {};
  }
  _getOptionsByReference() {
    return this._optionsByReference;
  }
  ctor() {
    let options2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
    const {
      _optionChangedCallbacks,
      _disposingCallbacks
    } = options2;
    this.NAME = getName(this.constructor);
    this._eventsStrategy = EventsStrategy.create(this, options2.eventsStrategy);
    this._updateLockCount = 0;
    this._optionChangedCallbacks = _optionChangedCallbacks || callbacks_default();
    this._disposingCallbacks = _disposingCallbacks || callbacks_default();
    this.postponedOperations = new PostponedOperations();
    this._createOptions(options2);
  }
  _createOptions(options2) {
    this.beginUpdate();
    try {
      this._setOptionsByReference();
      this._setDeprecatedOptions();
      this._options = new Options(this._getDefaultOptions(), this._getDefaultOptions(), this._getOptionsByReference(), this._getDeprecatedOptions());
      this._options.onChanging((name2, previousValue, value2) => this._initialized && this._optionChanging(name2, previousValue, value2));
      this._options.onDeprecated((option, info) => this._logDeprecatedOptionWarning(option, info));
      this._options.onChanged((name2, value2, previousValue) => this._notifyOptionChanged(name2, value2, previousValue));
      this._options.onStartChange(() => this.beginUpdate());
      this._options.onEndChange(() => this.endUpdate());
      this._options.addRules(this._defaultOptionsRules());
      this._options.validateOptions((o) => this._validateOptions(o));
      if (options2 && options2.onInitializing) {
        options2.onInitializing.apply(this, [options2]);
      }
      this._setOptionsByDevice(options2.defaultOptionsRules);
      this._initOptions(options2);
    } finally {
      this.endUpdate();
    }
  }
  _initOptions(options2) {
    this.option(options2);
  }
  _init() {
    this._createOptionChangedAction();
    this.on("disposing", (args) => {
      this._disposingCallbacks.fireWith(this, [args]);
    });
  }
  _logDeprecatedOptionWarning(option, info) {
    const message = info.message || `Use the '${info.alias}' option instead`;
    errors_default.log("W0001", this.NAME, option, info.since, message);
  }
  _logDeprecatedComponentWarning(since, alias) {
    errors_default.log("W0000", this.NAME, since, `Use the '${alias}' widget instead`);
  }
  _createOptionChangedAction() {
    this._optionChangedAction = this._createActionByOption("onOptionChanged", {
      excludeValidators: ["disabled", "readOnly"]
    });
  }
  _createDisposingAction() {
    this._disposingAction = this._createActionByOption("onDisposing", {
      excludeValidators: ["disabled", "readOnly"]
    });
  }
  _optionChanged(args) {
    const {
      name: name2
    } = args;
    switch (name2) {
      case "onDisposing":
      case "onInitialized":
      case "defaultOptionsRules":
      default:
        break;
      case "onOptionChanged":
        this._createOptionChangedAction();
    }
  }
  _dispose() {
    var _this$_disposingActio;
    this._optionChangedCallbacks.empty();
    this._createDisposingAction();
    null === (_this$_disposingActio = this._disposingAction) || void 0 === _this$_disposingActio || _this$_disposingActio.call(this);
    this._eventsStrategy.dispose();
    this._options.dispose();
    this._disposed = true;
  }
  _lockUpdate() {
    this._updateLockCount++;
  }
  _unlockUpdate() {
    this._updateLockCount = Math.max(this._updateLockCount - 1, 0);
  }
  _isUpdateAllowed() {
    return 0 === this._updateLockCount;
  }
  _isInitializingRequired() {
    return !this._initializing && !this._initialized;
  }
  isInitialized() {
    return this._initialized;
  }
  _commitUpdate() {
    this.postponedOperations.callPostponedOperations();
    this._isInitializingRequired() && this._initializeComponent();
  }
  _initializeComponent() {
    this._initializing = true;
    try {
      this._init();
    } finally {
      this._initializing = false;
      this._lockUpdate();
      this._createActionByOption("onInitialized", {
        excludeValidators: ["disabled", "readOnly"]
      })();
      this._unlockUpdate();
      this._initialized = true;
    }
  }
  instance() {
    return this;
  }
  beginUpdate() {
    this._lockUpdate();
  }
  endUpdate() {
    this._unlockUpdate();
    this._isUpdateAllowed() && this._commitUpdate();
  }
  _optionChanging() {
  }
  _notifyOptionChanged(option, value2, previousValue) {
    if (this._initialized) {
      const optionNames = [option].concat(this._options.getAliasesByName(option));
      for (let i = 0; i < optionNames.length; i++) {
        const name2 = optionNames[i];
        const args = {
          name: getPathParts(name2)[0],
          fullName: name2,
          value: value2,
          previousValue
        };
        if (!isInnerOption(name2)) {
          var _this$_optionChangedA;
          this._optionChangedCallbacks.fireWith(this, [extend(this._defaultActionArgs(), args)]);
          null === (_this$_optionChangedA = this._optionChangedAction) || void 0 === _this$_optionChangedA || _this$_optionChangedA.call(this, extend({}, args));
        }
        if (!this._disposed && this._cancelOptionChange !== name2) {
          this._optionChanged(args);
        }
      }
    }
  }
  initialOption(name2) {
    return this._options.initial(name2);
  }
  _defaultActionConfig() {
    return {
      context: this,
      component: this
    };
  }
  _defaultActionArgs() {
    return {
      component: this
    };
  }
  _createAction(actionSource, config3) {
    let action;
    return (e) => {
      if (!isDefined(e)) {
        e = {};
      }
      if (!isPlainObject(e)) {
        e = {
          actionValue: e
        };
      }
      action = action || new action_default(actionSource, extend({}, config3, this._defaultActionConfig()));
      return action.execute.call(action, extend(e, this._defaultActionArgs()));
    };
  }
  _createActionByOption(optionName, config3) {
    var _this = this;
    let action;
    let eventName;
    let actionFunc;
    config3 = extend({}, config3);
    const result2 = function() {
      var _config, _config2;
      if (!eventName) {
        config3 = config3 || {};
        if ("string" !== typeof optionName) {
          throw errors_default.Error("E0008");
        }
        if (optionName.startsWith("on")) {
          eventName = getEventName(optionName);
        }
        actionFunc = _this.option(optionName);
      }
      if (!action && !actionFunc && !(null !== (_config = config3) && void 0 !== _config && _config.beforeExecute) && !(null !== (_config2 = config3) && void 0 !== _config2 && _config2.afterExecute) && !_this._eventsStrategy.hasEvent(eventName)) {
        return;
      }
      if (!action) {
        const {
          beforeExecute
        } = config3;
        config3.beforeExecute = function() {
          for (var _len2 = arguments.length, props = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            props[_key2] = arguments[_key2];
          }
          beforeExecute && beforeExecute.apply(_this, props);
          _this._eventsStrategy.fireEvent(eventName, props[0].args);
        };
        action = _this._createAction(actionFunc, config3);
      }
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      if (config_default2().wrapActionsBeforeExecute) {
        const beforeActionExecute = _this.option("beforeActionExecute") || noop2;
        const wrappedAction = beforeActionExecute(_this, action, config3) || action;
        return wrappedAction.apply(_this, args);
      }
      return action.apply(_this, args);
    };
    if (config_default2().wrapActionsBeforeExecute) {
      return result2;
    }
    const onActionCreated = this.option("onActionCreated") || noop2;
    return onActionCreated(this, result2, config3) || result2;
  }
  on(eventName, eventHandler) {
    this._eventsStrategy.on(eventName, eventHandler);
    return this;
  }
  off(eventName, eventHandler) {
    this._eventsStrategy.off(eventName, eventHandler);
    return this;
  }
  hasActionSubscription(actionName) {
    return !!this._options.silent(actionName) || this._eventsStrategy.hasEvent(getEventName(actionName));
  }
  isOptionDeprecated(name2) {
    return this._options.isDeprecated(name2);
  }
  _setOptionWithoutOptionChange(name2, value2) {
    this._cancelOptionChange = name2;
    this.option(name2, value2);
    this._cancelOptionChange = false;
  }
  _getOptionValue(name2, context2) {
    const value2 = this.option(name2);
    if (isFunction(value2)) {
      return value2.bind(context2)();
    }
    return value2;
  }
  option() {
    return this._options.option(...arguments);
  }
  resetOption(name2) {
    this.beginUpdate();
    this._options.reset(name2);
    this.endUpdate();
  }
  _validateOptions(options2) {
    return options2;
  }
};

// node_modules/devextreme/esm/common/core/animation/presets/presets.js
var directionPostfixes = {
  forward: " dx-forward",
  backward: " dx-backward",
  none: " dx-no-direction",
  undefined: " dx-no-direction"
};
var AnimationPresetCollection = Component.inherit({
  ctor: function() {
    this.callBase.apply(this, arguments);
    this._registeredPresets = [];
    this.resetToDefaults();
  },
  _getDefaultOptions: function() {
    return extend(this.callBase(), {
      defaultAnimationDuration: 400,
      defaultAnimationDelay: 0,
      defaultStaggerAnimationDuration: 300,
      defaultStaggerAnimationDelay: 40,
      defaultStaggerAnimationStartDelay: 500
    });
  },
  _defaultOptionsRules: function() {
    return this.callBase().concat([{
      device: function(device) {
        return device.phone;
      },
      options: {
        defaultStaggerAnimationDuration: 350,
        defaultStaggerAnimationDelay: 50,
        defaultStaggerAnimationStartDelay: 0
      }
    }, {
      device: function() {
        return m_devices_default.current().android || m_devices_default.real.android;
      },
      options: {
        defaultAnimationDelay: 100
      }
    }]);
  },
  _getPresetOptionName: function(animationName) {
    return "preset_" + animationName;
  },
  _createAndroidSlideAnimationConfig: function(throughOpacity, widthMultiplier) {
    const that = this;
    const createBaseConfig = function(configModifier) {
      return {
        type: "slide",
        delay: void 0 === configModifier.delay ? that.option("defaultAnimationDelay") : configModifier.delay,
        duration: void 0 === configModifier.duration ? that.option("defaultAnimationDuration") : configModifier.duration
      };
    };
    return {
      enter: function($element, configModifier) {
        const width = getWidth($element.parent()) * widthMultiplier;
        const direction = configModifier.direction;
        const config3 = createBaseConfig(configModifier);
        config3.to = {
          left: 0,
          opacity: 1
        };
        if ("forward" === direction) {
          config3.from = {
            left: width,
            opacity: throughOpacity
          };
        } else if ("backward" === direction) {
          config3.from = {
            left: -width,
            opacity: throughOpacity
          };
        } else {
          config3.from = {
            left: 0,
            opacity: 0
          };
        }
        return fx_default.createAnimation($element, config3);
      },
      leave: function($element, configModifier) {
        const width = getWidth($element.parent()) * widthMultiplier;
        const direction = configModifier.direction;
        const config3 = createBaseConfig(configModifier);
        config3.from = {
          left: 0,
          opacity: 1
        };
        if ("forward" === direction) {
          config3.to = {
            left: -width,
            opacity: throughOpacity
          };
        } else if ("backward" === direction) {
          config3.to = {
            left: width,
            opacity: throughOpacity
          };
        } else {
          config3.to = {
            left: 0,
            opacity: 0
          };
        }
        return fx_default.createAnimation($element, config3);
      }
    };
  },
  _createOpenDoorConfig: function() {
    const that = this;
    const createBaseConfig = function(configModifier) {
      return {
        type: "css",
        extraCssClasses: "dx-opendoor-animation",
        delay: void 0 === configModifier.delay ? that.option("defaultAnimationDelay") : configModifier.delay,
        duration: void 0 === configModifier.duration ? that.option("defaultAnimationDuration") : configModifier.duration
      };
    };
    return {
      enter: function($element, configModifier) {
        const direction = configModifier.direction;
        const config3 = createBaseConfig(configModifier);
        config3.delay = "none" === direction ? config3.delay : config3.duration;
        config3.from = "dx-enter dx-opendoor-animation" + directionPostfixes[direction];
        config3.to = "dx-enter-active";
        return fx_default.createAnimation($element, config3);
      },
      leave: function($element, configModifier) {
        const direction = configModifier.direction;
        const config3 = createBaseConfig(configModifier);
        config3.from = "dx-leave dx-opendoor-animation" + directionPostfixes[direction];
        config3.to = "dx-leave-active";
        return fx_default.createAnimation($element, config3);
      }
    };
  },
  _createWinPopConfig: function() {
    const that = this;
    const baseConfig = {
      type: "css",
      extraCssClasses: "dx-win-pop-animation",
      duration: that.option("defaultAnimationDuration")
    };
    return {
      enter: function($element, configModifier) {
        const config3 = baseConfig;
        const direction = configModifier.direction;
        config3.delay = "none" === direction ? that.option("defaultAnimationDelay") : that.option("defaultAnimationDuration") / 2;
        config3.from = "dx-enter dx-win-pop-animation" + directionPostfixes[direction];
        config3.to = "dx-enter-active";
        return fx_default.createAnimation($element, config3);
      },
      leave: function($element, configModifier) {
        const config3 = baseConfig;
        const direction = configModifier.direction;
        config3.delay = that.option("defaultAnimationDelay");
        config3.from = "dx-leave dx-win-pop-animation" + directionPostfixes[direction];
        config3.to = "dx-leave-active";
        return fx_default.createAnimation($element, config3);
      }
    };
  },
  resetToDefaults: function() {
    this.clear();
    this.registerDefaultPresets();
    this.applyChanges();
  },
  clear: function(name2) {
    const that = this;
    const newRegisteredPresets = [];
    each(this._registeredPresets, function(index2, preset) {
      if (!name2 || name2 === preset.name) {
        that.option(that._getPresetOptionName(preset.name), void 0);
      } else {
        newRegisteredPresets.push(preset);
      }
    });
    this._registeredPresets = newRegisteredPresets;
    this.applyChanges();
  },
  registerPreset: function(name2, config3) {
    this._registeredPresets.push({
      name: name2,
      config: config3
    });
  },
  applyChanges: function() {
    const that = this;
    const customRules = [];
    each(this._registeredPresets, function(index2, preset) {
      const rule = {
        device: preset.config.device,
        options: {}
      };
      rule.options[that._getPresetOptionName(preset.name)] = preset.config.animation;
      customRules.push(rule);
    });
    this._setOptionsByDevice(customRules);
  },
  getPreset: function(name2) {
    let result2 = name2;
    while ("string" === typeof result2) {
      result2 = this.option(this._getPresetOptionName(result2));
    }
    return result2;
  },
  registerDefaultPresets: function() {
    this.registerPreset("pop", {
      animation: {
        extraCssClasses: "dx-android-pop-animation",
        delay: this.option("defaultAnimationDelay"),
        duration: this.option("defaultAnimationDuration")
      }
    });
    this.registerPreset("openDoor", {
      animation: this._createOpenDoorConfig()
    });
    this.registerPreset("win-pop", {
      animation: this._createWinPopConfig()
    });
    this.registerPreset("fade", {
      animation: {
        extraCssClasses: "dx-fade-animation",
        delay: this.option("defaultAnimationDelay"),
        duration: this.option("defaultAnimationDuration")
      }
    });
    this.registerPreset("slide", {
      device: function() {
        return m_devices_default.current().android || m_devices_default.real.android;
      },
      animation: this._createAndroidSlideAnimationConfig(1, 1)
    });
    this.registerPreset("slide", {
      device: function() {
        return !m_devices_default.current().android && !m_devices_default.real.android;
      },
      animation: {
        extraCssClasses: "dx-slide-animation",
        delay: this.option("defaultAnimationDelay"),
        duration: this.option("defaultAnimationDuration")
      }
    });
    this.registerPreset("ios7-slide", {
      animation: {
        extraCssClasses: "dx-ios7-slide-animation",
        delay: this.option("defaultAnimationDelay"),
        duration: this.option("defaultAnimationDuration")
      }
    });
    this.registerPreset("overflow", {
      animation: {
        extraCssClasses: "dx-overflow-animation",
        delay: this.option("defaultAnimationDelay"),
        duration: this.option("defaultAnimationDuration")
      }
    });
    this.registerPreset("ios7-toolbar", {
      device: function() {
        return !m_devices_default.current().android && !m_devices_default.real.android;
      },
      animation: {
        extraCssClasses: "dx-ios7-toolbar-animation",
        delay: this.option("defaultAnimationDelay"),
        duration: this.option("defaultAnimationDuration")
      }
    });
    this.registerPreset("ios7-toolbar", {
      device: function() {
        return m_devices_default.current().android || m_devices_default.real.android;
      },
      animation: this._createAndroidSlideAnimationConfig(0, 0.4)
    });
    this.registerPreset("stagger-fade", {
      animation: {
        extraCssClasses: "dx-fade-animation",
        staggerDelay: this.option("defaultStaggerAnimationDelay"),
        duration: this.option("defaultStaggerAnimationDuration"),
        delay: this.option("defaultStaggerAnimationStartDelay")
      }
    });
    this.registerPreset("stagger-slide", {
      animation: {
        extraCssClasses: "dx-slide-animation",
        staggerDelay: this.option("defaultStaggerAnimationDelay"),
        duration: this.option("defaultStaggerAnimationDuration"),
        delay: this.option("defaultStaggerAnimationStartDelay")
      }
    });
    this.registerPreset("stagger-fade-slide", {
      animation: {
        extraCssClasses: "dx-fade-slide-animation",
        staggerDelay: this.option("defaultStaggerAnimationDelay"),
        duration: this.option("defaultStaggerAnimationDuration"),
        delay: this.option("defaultStaggerAnimationStartDelay")
      }
    });
    this.registerPreset("stagger-drop", {
      animation: {
        extraCssClasses: "dx-drop-animation",
        staggerDelay: this.option("defaultStaggerAnimationDelay"),
        duration: this.option("defaultStaggerAnimationDuration"),
        delay: this.option("defaultStaggerAnimationStartDelay")
      }
    });
    this.registerPreset("stagger-fade-drop", {
      animation: {
        extraCssClasses: "dx-fade-drop-animation",
        staggerDelay: this.option("defaultStaggerAnimationDelay"),
        duration: this.option("defaultStaggerAnimationDuration"),
        delay: this.option("defaultStaggerAnimationStartDelay")
      }
    });
    this.registerPreset("stagger-fade-rise", {
      animation: {
        extraCssClasses: "dx-fade-rise-animation",
        staggerDelay: this.option("defaultStaggerAnimationDelay"),
        duration: this.option("defaultStaggerAnimationDuration"),
        delay: this.option("defaultStaggerAnimationStartDelay")
      }
    });
    this.registerPreset("stagger-3d-drop", {
      animation: {
        extraCssClasses: "dx-3d-drop-animation",
        staggerDelay: this.option("defaultStaggerAnimationDelay"),
        duration: this.option("defaultStaggerAnimationDuration"),
        delay: this.option("defaultStaggerAnimationStartDelay")
      }
    });
    this.registerPreset("stagger-fade-zoom", {
      animation: {
        extraCssClasses: "dx-fade-zoom-animation",
        staggerDelay: this.option("defaultStaggerAnimationDelay"),
        duration: this.option("defaultStaggerAnimationDuration"),
        delay: this.option("defaultStaggerAnimationStartDelay")
      }
    });
  }
});
var animationPresets = new AnimationPresetCollection();

// node_modules/devextreme/esm/common/core/animation/transition_executor/transition_executor.js
var directionPostfixes2 = {
  forward: " dx-forward",
  backward: " dx-backward",
  none: " dx-no-direction",
  undefined: " dx-no-direction"
};
var TransitionExecutor = class_default.inherit({
  ctor: function() {
    this._accumulatedDelays = {
      enter: 0,
      leave: 0
    };
    this._animations = [];
    this.reset();
  },
  _createAnimations: function($elements, initialConfig, configModifier, type2) {
    $elements = renderer_default($elements);
    const that = this;
    const result2 = [];
    configModifier = configModifier || {};
    const animationConfig = this._prepareElementAnimationConfig(initialConfig, configModifier, type2);
    if (animationConfig) {
      $elements.each(function() {
        const animation3 = that._createAnimation(renderer_default(this), animationConfig, configModifier);
        if (animation3) {
          animation3.element.addClass("dx-animating");
          animation3.setup();
          result2.push(animation3);
        }
      });
    }
    return result2;
  },
  _prepareElementAnimationConfig: function(config3, configModifier, type2) {
    let result2;
    if ("string" === typeof config3) {
      const presetName = config3;
      config3 = animationPresets.getPreset(presetName);
    }
    if (!config3) {
      result2 = void 0;
    } else if (isFunction(config3[type2])) {
      result2 = config3[type2];
    } else {
      result2 = extend({
        skipElementInitialStyles: true,
        cleanupWhen: this._completePromise
      }, config3, configModifier);
      if (!result2.type || "css" === result2.type) {
        const cssClass = "dx-" + type2;
        const extraCssClasses = (result2.extraCssClasses ? " " + result2.extraCssClasses : "") + directionPostfixes2[result2.direction];
        result2.type = "css";
        result2.from = (result2.from || cssClass) + extraCssClasses;
        result2.to = result2.to || cssClass + "-active";
      }
      result2.staggerDelay = result2.staggerDelay || 0;
      result2.delay = result2.delay || 0;
      if (result2.staggerDelay) {
        result2.delay += this._accumulatedDelays[type2];
        this._accumulatedDelays[type2] += result2.staggerDelay;
      }
    }
    return result2;
  },
  _createAnimation: function($element, animationConfig, configModifier) {
    let result2;
    if (isPlainObject(animationConfig)) {
      result2 = fx_default.createAnimation($element, animationConfig);
    } else if (isFunction(animationConfig)) {
      result2 = animationConfig($element, configModifier);
    }
    return result2;
  },
  _startAnimations: function() {
    const animations = this._animations;
    for (let i = 0; i < animations.length; i++) {
      animations[i].start();
    }
  },
  _stopAnimations: function(jumpToEnd) {
    const animations = this._animations;
    for (let i = 0; i < animations.length; i++) {
      animations[i].stop(jumpToEnd);
    }
  },
  _clearAnimations: function() {
    const animations = this._animations;
    for (let i = 0; i < animations.length; i++) {
      animations[i].element.removeClass("dx-animating");
    }
    this._animations.length = 0;
  },
  reset: function() {
    this._accumulatedDelays.enter = 0;
    this._accumulatedDelays.leave = 0;
    this._clearAnimations();
    this._completeDeferred = new Deferred();
    this._completePromise = this._completeDeferred.promise();
  },
  enter: function($elements, animationConfig, configModifier) {
    const animations = this._createAnimations($elements, animationConfig, configModifier, "enter");
    this._animations.push.apply(this._animations, animations);
  },
  leave: function($elements, animationConfig, configModifier) {
    const animations = this._createAnimations($elements, animationConfig, configModifier, "leave");
    this._animations.push.apply(this._animations, animations);
  },
  start: function() {
    const that = this;
    let result2;
    if (!this._animations.length) {
      that.reset();
      result2 = new Deferred().resolve().promise();
    } else {
      const animationDeferreds = map(this._animations, function(animation3) {
        const result3 = new Deferred();
        animation3.deferred.always(function() {
          result3.resolve();
        });
        return result3.promise();
      });
      result2 = when.apply(renderer_default, animationDeferreds).always(function() {
        that._completeDeferred.resolve();
        that.reset();
      });
      m_common_default.executeAsync(function() {
        that._startAnimations();
      });
    }
    return result2;
  },
  stop: function(jumpToEnd) {
    this._stopAnimations(jumpToEnd);
  }
});

// node_modules/devextreme/esm/__internal/events/core/m_emitter.js
var Emitter = class_default.inherit({
  ctor(element) {
    this._$element = renderer_default(element);
    this._cancelCallback = callbacks_default();
    this._acceptCallback = callbacks_default();
  },
  getElement() {
    return this._$element;
  },
  validate: (e) => !isDxMouseWheelEvent(e),
  validatePointers: (e) => 1 === hasTouches(e),
  allowInterruptionByMouseWheel: () => true,
  configure(data17) {
    extend(this, data17);
  },
  addCancelCallback(callback) {
    this._cancelCallback.add(callback);
  },
  removeCancelCallback() {
    this._cancelCallback.empty();
  },
  _cancel(e) {
    this._cancelCallback.fire(this, e);
  },
  addAcceptCallback(callback) {
    this._acceptCallback.add(callback);
  },
  removeAcceptCallback() {
    this._acceptCallback.empty();
  },
  _accept(e) {
    this._acceptCallback.fire(this, e);
  },
  _requestAccept(e) {
    this._acceptRequestEvent = e;
  },
  _forgetAccept() {
    this._accept(this._acceptRequestEvent);
    this._acceptRequestEvent = null;
  },
  start: noop2,
  move: noop2,
  end: noop2,
  cancel: noop2,
  reset() {
    if (this._acceptRequestEvent) {
      this._accept(this._acceptRequestEvent);
    }
  },
  _fireEvent(eventName, e, params) {
    const eventData2 = extend({
      type: eventName,
      originalEvent: e,
      target: this._getEmitterTarget(e),
      delegateTarget: this.getElement().get(0)
    }, params);
    e = fireEvent(eventData2);
    if (e.cancel) {
      this._cancel(e);
    }
    return e;
  },
  _getEmitterTarget(e) {
    return (this.delegateSelector ? renderer_default(e.target).closest(this.delegateSelector) : this.getElement()).get(0);
  },
  dispose: noop2
});
var m_emitter_default = Emitter;

// node_modules/devextreme/esm/__internal/events/core/m_wheel.js
var EVENT_NAME = "dxmousewheel";
var wheel = {
  setup(element) {
    const $element = renderer_default(element);
    m_events_engine_default.on($element, addNamespace2("wheel", "dxWheel"), wheel._wheelHandler.bind(wheel));
  },
  teardown(element) {
    m_events_engine_default.off(element, ".dxWheel");
  },
  _wheelHandler(e) {
    const {
      deltaMode,
      deltaY,
      deltaX,
      deltaZ
    } = e.originalEvent;
    fireEvent({
      type: EVENT_NAME,
      originalEvent: e,
      delta: this._normalizeDelta(deltaY, deltaMode),
      deltaX,
      deltaY,
      deltaZ,
      deltaMode,
      pointerType: "mouse"
    });
    e.stopPropagation();
  },
  _normalizeDelta(delta) {
    let deltaMode = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
    if (0 === deltaMode) {
      return -delta;
    }
    return -30 * delta;
  }
};
m_event_registrator_default(EVENT_NAME, wheel);

// node_modules/devextreme/esm/__internal/events/pointer/m_base.js
var BaseStrategy = class_default.inherit({
  ctor(eventName, originalEvents) {
    this._eventName = eventName;
    this._originalEvents = addNamespace2(originalEvents, "dxPointerEvents");
    this._handlerCount = 0;
    this.noBubble = this._isNoBubble();
  },
  _isNoBubble() {
    const eventName = this._eventName;
    return "dxpointerenter" === eventName || "dxpointerleave" === eventName;
  },
  _handler(e) {
    const delegateTarget = this._getDelegateTarget(e);
    const event = {
      type: this._eventName,
      pointerType: e.pointerType || eventSource(e),
      originalEvent: e,
      delegateTarget,
      timeStamp: browser_default.mozilla ? (/* @__PURE__ */ new Date()).getTime() : e.timeStamp
    };
    const target = getEventTarget(e);
    event.target = target;
    return this._fireEvent(event);
  },
  _getDelegateTarget(e) {
    let delegateTarget;
    if (this.noBubble) {
      delegateTarget = e.delegateTarget;
    }
    return delegateTarget;
  },
  _fireEvent: (args) => fireEvent(args),
  _setSelector(handleObj) {
    this._selector = this.noBubble && handleObj ? handleObj.selector : null;
  },
  _getSelector() {
    return this._selector;
  },
  setup: () => true,
  add(element, handleObj) {
    if (this._handlerCount <= 0 || this.noBubble) {
      element = this.noBubble ? element : dom_adapter_default.getDocument();
      this._setSelector(handleObj);
      const that = this;
      m_events_engine_default.on(element, this._originalEvents, this._getSelector(), (e) => {
        that._handler(e);
      });
    }
    if (!this.noBubble) {
      this._handlerCount++;
    }
  },
  remove(handleObj) {
    this._setSelector(handleObj);
    if (!this.noBubble) {
      this._handlerCount--;
    }
  },
  teardown(element) {
    if (this._handlerCount && !this.noBubble) {
      return;
    }
    element = this.noBubble ? element : dom_adapter_default.getDocument();
    if (".dxPointerEvents" !== this._originalEvents) {
      m_events_engine_default.off(element, this._originalEvents, this._getSelector());
    }
  },
  dispose(element) {
    element = this.noBubble ? element : dom_adapter_default.getDocument();
    m_events_engine_default.off(element, this._originalEvents);
  }
});
var m_base_default = BaseStrategy;

// node_modules/devextreme/esm/__internal/events/pointer/m_observer.js
var addEventsListener = function(events, handler) {
  ready_callbacks_default.add(() => {
    events.split(" ").forEach((event) => {
      dom_adapter_default.listen(dom_adapter_default.getDocument(), event, handler, true);
    });
  });
};
var Observer = function(eventMap4, pointerEquals, onPointerAdding) {
  onPointerAdding = onPointerAdding || function() {
  };
  let pointers = [];
  const getPointerIndex = function(e) {
    let index2 = -1;
    each(pointers, (i, pointer2) => {
      if (!pointerEquals(e, pointer2)) {
        return true;
      }
      index2 = i;
      return false;
    });
    return index2;
  };
  const removePointer = function(e) {
    const index2 = getPointerIndex(e);
    if (index2 > -1) {
      pointers.splice(index2, 1);
    }
  };
  addEventsListener(eventMap4.dxpointerdown, function(e) {
    if (-1 === getPointerIndex(e)) {
      onPointerAdding(e);
      pointers.push(e);
    }
  });
  addEventsListener(eventMap4.dxpointermove, function(e) {
    pointers[getPointerIndex(e)] = e;
  });
  addEventsListener(eventMap4.dxpointerup, removePointer);
  addEventsListener(eventMap4.dxpointercancel, removePointer);
  this.pointers = function() {
    return pointers;
  };
  this.reset = function() {
    pointers = [];
  };
};
var m_observer_default = Observer;

// node_modules/devextreme/esm/__internal/events/pointer/m_mouse.js
var eventMap = {
  dxpointerdown: "mousedown",
  dxpointermove: "mousemove",
  dxpointerup: "mouseup",
  dxpointercancel: "pointercancel",
  dxpointerover: "mouseover",
  dxpointerout: "mouseout",
  dxpointerenter: "mouseenter",
  dxpointerleave: "mouseleave"
};
if (browser_default.safari) {
  eventMap.dxpointercancel += " dragstart";
}
var normalizeMouseEvent = function(e) {
  e.pointerId = 1;
  return {
    pointers: observer.pointers(),
    pointerId: 1
  };
};
var observer;
var activated = false;
var activateStrategy = function() {
  if (activated) {
    return;
  }
  observer = new m_observer_default(eventMap, () => true);
  activated = true;
};
var MouseStrategy = m_base_default.inherit({
  ctor() {
    this.callBase.apply(this, arguments);
    activateStrategy();
  },
  _fireEvent(args) {
    return this.callBase(extend(normalizeMouseEvent(args.originalEvent), args));
  }
});
MouseStrategy.map = eventMap;
MouseStrategy.normalize = normalizeMouseEvent;
MouseStrategy.activate = activateStrategy;
MouseStrategy.resetObserver = function() {
  observer.reset();
};
var m_mouse_default = MouseStrategy;

// node_modules/devextreme/esm/__internal/events/pointer/m_touch.js
var eventMap2 = {
  dxpointerdown: "touchstart",
  dxpointermove: "touchmove",
  dxpointerup: "touchend",
  dxpointercancel: "touchcancel",
  dxpointerover: "",
  dxpointerout: "",
  dxpointerenter: "",
  dxpointerleave: ""
};
var normalizeTouchEvent = function(e) {
  const pointers = [];
  each(e.touches, (_, touch2) => {
    pointers.push(extend({
      pointerId: touch2.identifier
    }, touch2));
  });
  return {
    pointers,
    pointerId: e.changedTouches[0].identifier
  };
};
var skipTouchWithSameIdentifier = function(pointerEvent) {
  return "ios" === m_devices_default.real().platform && ("dxpointerdown" === pointerEvent || "dxpointerup" === pointerEvent);
};
var TouchStrategy = m_base_default.inherit({
  ctor() {
    this.callBase.apply(this, arguments);
    this._pointerId = 0;
  },
  _handler(e) {
    if (skipTouchWithSameIdentifier(this._eventName)) {
      const touch2 = e.changedTouches[0];
      if (this._pointerId === touch2.identifier && 0 !== this._pointerId) {
        return;
      }
      this._pointerId = touch2.identifier;
    }
    return this.callBase.apply(this, arguments);
  },
  _fireEvent(args) {
    return this.callBase(extend(normalizeTouchEvent(args.originalEvent), args));
  }
});
TouchStrategy.map = eventMap2;
TouchStrategy.normalize = normalizeTouchEvent;
var m_touch_default = TouchStrategy;

// node_modules/devextreme/esm/__internal/events/pointer/m_mouse_and_touch.js
var eventMap3 = {
  dxpointerdown: "touchstart mousedown",
  dxpointermove: "touchmove mousemove",
  dxpointerup: "touchend mouseup",
  dxpointercancel: "touchcancel",
  dxpointerover: "mouseover",
  dxpointerout: "mouseout",
  dxpointerenter: "mouseenter",
  dxpointerleave: "mouseleave"
};
var activated2 = false;
var activateStrategy2 = function() {
  if (activated2) {
    return;
  }
  m_mouse_default.activate();
  activated2 = true;
};
var MouseAndTouchStrategy = m_base_default.inherit({
  EVENT_LOCK_TIMEOUT: 100,
  ctor() {
    this.callBase.apply(this, arguments);
    activateStrategy2();
  },
  _handler(e) {
    const isMouse = isMouseEvent(e);
    if (!isMouse) {
      this._skipNextEvents = true;
    }
    if (isMouse && this._mouseLocked) {
      return;
    }
    if (isMouse && this._skipNextEvents) {
      this._skipNextEvents = false;
      this._mouseLocked = true;
      clearTimeout(this._unlockMouseTimer);
      const that = this;
      this._unlockMouseTimer = setTimeout(() => {
        that._mouseLocked = false;
      }, this.EVENT_LOCK_TIMEOUT);
      return;
    }
    return this.callBase(e);
  },
  _fireEvent(args) {
    const normalizer = isMouseEvent(args.originalEvent) ? m_mouse_default.normalize : m_touch_default.normalize;
    return this.callBase(extend(normalizer(args.originalEvent), args));
  },
  dispose() {
    this.callBase();
    this._skipNextEvents = false;
    this._mouseLocked = false;
    clearTimeout(this._unlockMouseTimer);
  }
});
MouseAndTouchStrategy.map = eventMap3;
MouseAndTouchStrategy.resetObserver = m_mouse_default.resetObserver;
var m_mouse_and_touch_default = MouseAndTouchStrategy;

// node_modules/devextreme/esm/__internal/events/m_pointer.js
var getStrategy = (support, _ref) => {
  let {
    tablet,
    phone
  } = _ref;
  const pointerEventStrategy = getStrategyFromGlobalConfig();
  if (pointerEventStrategy) {
    return pointerEventStrategy;
  }
  if (support.touch && !(tablet || phone)) {
    return m_mouse_and_touch_default;
  }
  if (support.touch) {
    return m_touch_default;
  }
  return m_mouse_default;
};
var EventStrategy = getStrategy(m_support_default, m_devices_default.real());
each(EventStrategy.map, (pointerEvent, originalEvents) => {
  m_event_registrator_default(pointerEvent, new EventStrategy(pointerEvent, originalEvents));
});
var pointer = {
  down: "dxpointerdown",
  up: "dxpointerup",
  move: "dxpointermove",
  cancel: "dxpointercancel",
  enter: "dxpointerenter",
  leave: "dxpointerleave",
  over: "dxpointerover",
  out: "dxpointerout"
};
function getStrategyFromGlobalConfig() {
  const eventStrategyName = config_default2().pointerEventStrategy;
  return {
    "mouse-and-touch": m_mouse_and_touch_default,
    touch: m_touch_default,
    mouse: m_mouse_default
  }[eventStrategyName];
}
var m_pointer_default = pointer;

// node_modules/devextreme/esm/__internal/events/core/m_emitter_registrator.js
var MANAGER_EVENT = "dxEventManager";
var EventManager = class_default.inherit({
  ctor() {
    this._attachHandlers();
    this.reset();
    this._proxiedCancelHandler = this._cancelHandler.bind(this);
    this._proxiedAcceptHandler = this._acceptHandler.bind(this);
  },
  _attachHandlers() {
    ready_callbacks_default.add(() => {
      const document2 = dom_adapter_default.getDocument();
      m_events_engine_default.subscribeGlobal(document2, addNamespace2(m_pointer_default.down, MANAGER_EVENT), this._pointerDownHandler.bind(this));
      m_events_engine_default.subscribeGlobal(document2, addNamespace2(m_pointer_default.move, MANAGER_EVENT), this._pointerMoveHandler.bind(this));
      m_events_engine_default.subscribeGlobal(document2, addNamespace2([m_pointer_default.up, m_pointer_default.cancel].join(" "), MANAGER_EVENT), this._pointerUpHandler.bind(this));
      m_events_engine_default.subscribeGlobal(document2, addNamespace2(EVENT_NAME, MANAGER_EVENT), this._mouseWheelHandler.bind(this));
    });
  },
  _eachEmitter(callback) {
    const activeEmitters = this._activeEmitters || [];
    let i = 0;
    while (activeEmitters.length > i) {
      const emitter = activeEmitters[i];
      if (false === callback(emitter)) {
        break;
      }
      if (activeEmitters[i] === emitter) {
        i++;
      }
    }
  },
  _applyToEmitters(method, arg) {
    this._eachEmitter((emitter) => {
      emitter[method].call(emitter, arg);
    });
  },
  reset() {
    this._eachEmitter(this._proxiedCancelHandler);
    this._activeEmitters = [];
  },
  resetEmitter(emitter) {
    this._proxiedCancelHandler(emitter);
  },
  _pointerDownHandler(e) {
    if (isMouseEvent(e) && e.which > 1) {
      return;
    }
    this._updateEmitters(e);
  },
  _updateEmitters(e) {
    if (!this._isSetChanged(e)) {
      return;
    }
    this._cleanEmitters(e);
    this._fetchEmitters(e);
  },
  _isSetChanged(e) {
    const currentSet = this._closestEmitter(e);
    const previousSet = this._emittersSet || [];
    let setChanged = currentSet.length !== previousSet.length;
    each(currentSet, (index2, emitter) => {
      setChanged = setChanged || previousSet[index2] !== emitter;
      return !setChanged;
    });
    this._emittersSet = currentSet;
    return setChanged;
  },
  _closestEmitter(e) {
    const that = this;
    const result2 = [];
    let $element = renderer_default(e.target);
    function handleEmitter(_, emitter) {
      if (!!emitter && emitter.validatePointers(e) && emitter.validate(e)) {
        emitter.addCancelCallback(that._proxiedCancelHandler);
        emitter.addAcceptCallback(that._proxiedAcceptHandler);
        result2.push(emitter);
      }
    }
    while ($element.length) {
      const emitters = data($element.get(0), "dxEmitter") || [];
      each(emitters, handleEmitter);
      $element = $element.parent();
    }
    return result2;
  },
  _acceptHandler(acceptedEmitter, e) {
    this._eachEmitter((emitter) => {
      if (emitter !== acceptedEmitter) {
        this._cancelEmitter(emitter, e);
      }
    });
  },
  _cancelHandler(canceledEmitter, e) {
    this._cancelEmitter(canceledEmitter, e);
  },
  _cancelEmitter(emitter, e) {
    const activeEmitters = this._activeEmitters;
    if (e) {
      emitter.cancel(e);
    } else {
      emitter.reset();
    }
    emitter.removeCancelCallback();
    emitter.removeAcceptCallback();
    const emitterIndex = activeEmitters.indexOf(emitter);
    if (emitterIndex > -1) {
      activeEmitters.splice(emitterIndex, 1);
    }
  },
  _cleanEmitters(e) {
    this._applyToEmitters("end", e);
    this.reset(e);
  },
  _fetchEmitters(e) {
    this._activeEmitters = this._emittersSet.slice();
    this._applyToEmitters("start", e);
  },
  _pointerMoveHandler(e) {
    this._applyToEmitters("move", e);
  },
  _pointerUpHandler(e) {
    this._updateEmitters(e);
  },
  _mouseWheelHandler(e) {
    if (!this._allowInterruptionByMouseWheel()) {
      return;
    }
    e.pointers = [null];
    this._pointerDownHandler(e);
    this._adjustWheelEvent(e);
    this._pointerMoveHandler(e);
    e.pointers = [];
    this._pointerUpHandler(e);
  },
  _allowInterruptionByMouseWheel() {
    let allowInterruption = true;
    this._eachEmitter((emitter) => {
      allowInterruption = emitter.allowInterruptionByMouseWheel() && allowInterruption;
      return allowInterruption;
    });
    return allowInterruption;
  },
  _adjustWheelEvent(e) {
    let closestGestureEmitter = null;
    this._eachEmitter((emitter) => {
      if (!emitter.gesture) {
        return;
      }
      const direction2 = emitter.getDirection(e);
      if ("horizontal" !== direction2 && !e.shiftKey || "vertical" !== direction2 && e.shiftKey) {
        closestGestureEmitter = emitter;
        return false;
      }
    });
    if (!closestGestureEmitter) {
      return;
    }
    const direction = closestGestureEmitter.getDirection(e);
    const verticalGestureDirection = "both" === direction && !e.shiftKey || "vertical" === direction;
    const prop = verticalGestureDirection ? "pageY" : "pageX";
    e[prop] += e.delta;
  },
  isActive(element) {
    let result2 = false;
    this._eachEmitter((emitter) => {
      result2 = result2 || emitter.getElement().is(element);
    });
    return result2;
  }
});
var eventManager = new EventManager();
var registerEmitter = function(emitterConfig) {
  const EmitterClass = emitterConfig.emitter;
  const emitterName = emitterConfig.events[0];
  const emitterEvents = emitterConfig.events;
  each(emitterEvents, (_, eventName) => {
    m_event_registrator_default(eventName, {
      noBubble: !emitterConfig.bubble,
      setup(element) {
        const subscriptions = data(element, "dxEmitterSubscription") || {};
        const emitters = data(element, "dxEmitter") || {};
        const emitter = emitters[emitterName] || new EmitterClass(element);
        subscriptions[eventName] = true;
        emitters[emitterName] = emitter;
        data(element, "dxEmitter", emitters);
        data(element, "dxEmitterSubscription", subscriptions);
      },
      add(element, handleObj) {
        const emitters = data(element, "dxEmitter");
        const emitter = emitters[emitterName];
        emitter.configure(extend({
          delegateSelector: handleObj.selector
        }, handleObj.data), handleObj.type);
      },
      teardown(element) {
        const subscriptions = data(element, "dxEmitterSubscription");
        const emitters = data(element, "dxEmitter");
        const emitter = emitters[emitterName];
        delete subscriptions[eventName];
        let disposeEmitter = true;
        each(emitterEvents, (_2, eventName2) => {
          disposeEmitter = disposeEmitter && !subscriptions[eventName2];
          return disposeEmitter;
        });
        if (disposeEmitter) {
          if (eventManager.isActive(element)) {
            eventManager.resetEmitter(emitter);
          }
          emitter && emitter.dispose();
          delete emitters[emitterName];
        }
      }
    });
  });
};
var m_emitter_registrator_default = registerEmitter;

// node_modules/devextreme/esm/__internal/events/utils/m_event_nodes_disposing.js
function nodesByEvent(event) {
  return event && [event.target, event.delegateTarget, event.relatedTarget, event.currentTarget].filter((node) => !!node);
}
var subscribeNodesDisposing = (event, callback) => {
  m_events_engine_default.one(nodesByEvent(event), removeEvent, callback);
};
var unsubscribeNodesDisposing = (event, callback) => {
  m_events_engine_default.off(nodesByEvent(event), removeEvent, callback);
};

// node_modules/devextreme/esm/__internal/core/utils/m_dom.js
var window11 = getWindow();
var getRootNodeHost = (element) => {
  if (!element.getRootNode) {
    return;
  }
  const {
    host
  } = element.getRootNode();
  if (isString(host)) {
    return;
  }
  return host;
};
var resetActiveElement = () => {
  const activeElement = dom_adapter_default.getActiveElement();
  if (activeElement && activeElement !== dom_adapter_default.getBody()) {
    var _activeElement$blur;
    null === (_activeElement$blur = activeElement.blur) || void 0 === _activeElement$blur || _activeElement$blur.call(activeElement);
  }
};
var clearSelection = () => {
  const selection2 = window11.getSelection();
  if (!selection2) {
    return;
  }
  if ("Caret" === selection2.type) {
    return;
  }
  if (selection2.empty) {
    selection2.empty();
  } else if (selection2.removeAllRanges) {
    try {
      selection2.removeAllRanges();
    } catch (e) {
    }
  }
};
var closestCommonParent = (startTarget, endTarget) => {
  const $startTarget = renderer_default(startTarget);
  const $endTarget = renderer_default(endTarget);
  if ($startTarget[0] === $endTarget[0]) {
    return $startTarget[0];
  }
  const $startParents = $startTarget.parents();
  const $endParents = $endTarget.parents();
  const startingParent = Math.min($startParents.length, $endParents.length);
  for (let i = -startingParent; i < 0; i++) {
    if ($startParents.get(i) === $endParents.get(i)) {
      return $startParents.get(i);
    }
  }
};
var extractTemplateMarkup = (element) => {
  element = renderer_default(element);
  const templateTag = element.length && element.filter(function() {
    const $node = renderer_default(this);
    return $node.is("script[type]") && !$node.attr("type").includes("script");
  });
  if (templateTag.length) {
    return templateTag.eq(0).html();
  }
  element = renderer_default("<div>").append(element);
  return element.html();
};
var normalizeTemplateElement = (element) => {
  let $element = renderer_default();
  if (isDefined(element) && (element.nodeType || isRenderer(element))) {
    $element = renderer_default(element);
  } else if ("object" !== typeof element) {
    $element = renderer_default("<div>").html(element).contents();
  }
  if (1 === $element.length) {
    if ($element.is("script")) {
      $element = normalizeTemplateElement($element.html().trim());
    } else if ($element.is("table")) {
      $element = $element.children("tbody").contents();
    }
  }
  return $element;
};
var clipboardText = (event, text) => {
  const clipboard = event.originalEvent && event.originalEvent.clipboardData || window11.clipboardData;
  if (!text) {
    return clipboard && clipboard.getData("Text");
  }
  clipboard && clipboard.setData("Text", text);
};
var contains2 = (container, element) => {
  if (!element) {
    return false;
  }
  if (isWindow(container)) {
    return contains2(container.document, element);
  }
  return container.contains(element) || contains2(container, getRootNodeHost(element));
};
var createTextElementHiddenCopy = (element, text, options2) => {
  const elementStyles = window11.getComputedStyle(renderer_default(element).get(0));
  const includePaddings = options2 && options2.includePaddings;
  return renderer_default("<div>").text(text).css({
    fontStyle: elementStyles.fontStyle,
    fontVariant: elementStyles.fontVariant,
    fontWeight: elementStyles.fontWeight,
    fontSize: elementStyles.fontSize,
    fontFamily: elementStyles.fontFamily,
    letterSpacing: elementStyles.letterSpacing,
    border: elementStyles.border,
    paddingTop: includePaddings ? elementStyles.paddingTop : "",
    paddingRight: includePaddings ? elementStyles.paddingRight : "",
    paddingBottom: includePaddings ? elementStyles.paddingBottom : "",
    paddingLeft: includePaddings ? elementStyles.paddingLeft : "",
    visibility: "hidden",
    whiteSpace: "pre",
    position: "absolute",
    float: "left"
  });
};
var insertBefore = (element, newElement) => {
  if (newElement) {
    dom_adapter_default.insertElement(element.parentNode, newElement, element);
  }
  return element;
};
var replaceWith = (element, newElement) => {
  if (!(newElement && newElement[0])) {
    return;
  }
  if (newElement.is(element)) {
    return element;
  }
  each(newElement, (_, currentElement) => {
    insertBefore(element[0], currentElement);
  });
  element.remove();
  return newElement;
};
var isElementInDom = ($element) => {
  const element = null === $element || void 0 === $element ? void 0 : $element.get(0);
  const shadowHost = null === element || void 0 === element ? void 0 : element.getRootNode().host;
  return !!renderer_default(shadowHost || element).closest(getWindow().document).length;
};
var m_dom_default = {
  resetActiveElement,
  clearSelection,
  closestCommonParent,
  extractTemplateMarkup,
  normalizeTemplateElement,
  clipboardText,
  contains: contains2,
  createTextElementHiddenCopy,
  insertBefore,
  replaceWith,
  isElementInDom
};

// node_modules/devextreme/esm/__internal/events/m_click.js
var CLICK_EVENT_NAME = "dxclick";
var prevented = null;
var lastFiredEvent = null;
var onNodeRemove = () => {
  lastFiredEvent = null;
};
var clickHandler = function(e) {
  const {
    originalEvent
  } = e;
  const eventAlreadyFired = lastFiredEvent === originalEvent || originalEvent && originalEvent.DXCLICK_FIRED;
  const leftButton = !e.which || 1 === e.which;
  if (leftButton && !prevented && !eventAlreadyFired) {
    if (originalEvent) {
      originalEvent.DXCLICK_FIRED = true;
    }
    unsubscribeNodesDisposing(lastFiredEvent, onNodeRemove);
    lastFiredEvent = originalEvent;
    subscribeNodesDisposing(lastFiredEvent, onNodeRemove);
    fireEvent({
      type: "dxclick",
      originalEvent: e
    });
  }
};
var ClickEmitter = m_emitter_default.inherit({
  ctor(element) {
    this.callBase(element);
    m_events_engine_default.on(this.getElement(), "click", clickHandler);
  },
  start() {
    prevented = null;
  },
  cancel() {
    prevented = true;
  },
  dispose() {
    m_events_engine_default.off(this.getElement(), "click", clickHandler);
  }
});
!function() {
  const desktopDevice = m_devices_default.real().generic;
  if (!desktopDevice) {
    let startTarget = null;
    let blurPrevented = false;
    const isInput = function(element) {
      return renderer_default(element).is("input, textarea, select, button ,:focus, :focus *");
    };
    const pointerDownHandler = function(e) {
      startTarget = e.target;
      blurPrevented = e.isDefaultPrevented();
    };
    const getTarget = function(e) {
      const target = getEventTarget(e);
      return renderer_default(target);
    };
    const clickHandler2 = function(e) {
      const $target = getTarget(e);
      if (!blurPrevented && startTarget && !$target.is(startTarget) && !renderer_default(startTarget).is("label") && isInput($target)) {
        m_dom_default.resetActiveElement();
      }
      startTarget = null;
      blurPrevented = false;
    };
    const NATIVE_CLICK_FIXER_NAMESPACE = "NATIVE_CLICK_FIXER";
    const document2 = dom_adapter_default.getDocument();
    m_events_engine_default.subscribeGlobal(document2, addNamespace2(m_pointer_default.down, NATIVE_CLICK_FIXER_NAMESPACE), pointerDownHandler);
    m_events_engine_default.subscribeGlobal(document2, addNamespace2("click", NATIVE_CLICK_FIXER_NAMESPACE), clickHandler2);
  }
}();
m_emitter_registrator_default({
  emitter: ClickEmitter,
  bubble: true,
  events: ["dxclick"]
});

// node_modules/devextreme/esm/__internal/events/m_dblclick.js
var DBLCLICK_EVENT_NAME = "dxdblclick";
var NAMESPACED_CLICK_EVENT = addNamespace2(CLICK_EVENT_NAME, "dxDblClick");
var DblClick = class_default.inherit({
  ctor() {
    this._handlerCount = 0;
    this._forgetLastClick();
  },
  _forgetLastClick() {
    this._firstClickTarget = null;
    this._lastClickTimeStamp = -300;
  },
  add() {
    if (this._handlerCount <= 0) {
      m_events_engine_default.on(dom_adapter_default.getDocument(), NAMESPACED_CLICK_EVENT, this._clickHandler.bind(this));
    }
    this._handlerCount += 1;
  },
  _clickHandler(e) {
    const timeStamp = e.timeStamp || Date.now();
    const timeBetweenClicks = timeStamp - this._lastClickTimeStamp;
    const isSimulated = timeBetweenClicks < 0;
    const isDouble = !isSimulated && timeBetweenClicks < 300;
    if (isDouble) {
      fireEvent({
        type: "dxdblclick",
        target: closestCommonParent(this._firstClickTarget, e.target),
        originalEvent: e
      });
      this._forgetLastClick();
    } else {
      this._firstClickTarget = e.target;
      this._lastClickTimeStamp = timeStamp;
      clearTimeout(this._lastClickClearTimeout);
      this._lastClickClearTimeout = setTimeout(() => {
        this._forgetLastClick();
      }, 600);
    }
  },
  remove() {
    this._handlerCount -= 1;
    if (this._handlerCount <= 0) {
      this._forgetLastClick();
      m_events_engine_default.off(dom_adapter_default.getDocument(), NAMESPACED_CLICK_EVENT, void 0);
      clearTimeout(this._lastClickClearTimeout);
      this._handlerCount = 0;
    }
  }
});
var dblClick = new DblClick();

// node_modules/devextreme/esm/common/core/events/double_click.js
m_event_registrator_default(DBLCLICK_EVENT_NAME, dblClick);

// node_modules/devextreme/esm/__internal/grids/grid_core/column_state_mixin/m_column_state_mixin.js
var ColumnStateMixin = (Base) => class extends Base {
  _applyColumnState(options2) {
    var _that$component;
    const rtlEnabled = this.option("rtlEnabled");
    const columnAlignment = this._getColumnAlignment(options2.column.alignment, rtlEnabled);
    const parameters = extend(true, {
      columnAlignment
    }, options2);
    const isGroupPanelItem = parameters.rootElement.hasClass("dx-group-panel-item");
    const $indicatorsContainer = this._createIndicatorContainer(parameters, isGroupPanelItem);
    const $span = renderer_default("<span>").addClass(this._getIndicatorClassName(options2.name));
    const columnsController = null === (_that$component = this.component) || void 0 === _that$component ? void 0 : _that$component.getController("columns");
    const indicatorAlignment = (null === columnsController || void 0 === columnsController ? void 0 : columnsController.getHeaderContentAlignment(columnAlignment)) || columnAlignment;
    parameters.container = $indicatorsContainer;
    parameters.indicator = $span;
    this._renderIndicator(parameters);
    $indicatorsContainer[(isGroupPanelItem || !options2.showColumnLines) && "left" === indicatorAlignment ? "appendTo" : "prependTo"](options2.rootElement);
    return $span;
  }
  _getIndicatorClassName(name2) {
  }
  _getColumnAlignment(alignment, rtlEnabled) {
    rtlEnabled = rtlEnabled || this.option("rtlEnabled");
    return alignment && "center" !== alignment ? alignment : getDefaultAlignment(rtlEnabled);
  }
  _createIndicatorContainer(options2, ignoreIndicatorAlignment) {
    let $indicatorsContainer = this._getIndicatorContainer(options2.rootElement);
    const indicatorAlignment = "left" === options2.columnAlignment ? "right" : "left";
    if (!$indicatorsContainer.length) {
      $indicatorsContainer = renderer_default("<div>").addClass("dx-column-indicators");
    }
    this.setAria("role", "presentation", $indicatorsContainer);
    return $indicatorsContainer.css("float", options2.showColumnLines && !ignoreIndicatorAlignment ? indicatorAlignment : null);
  }
  _getIndicatorContainer($cell) {
    return $cell && $cell.find(".dx-column-indicators");
  }
  _getIndicatorElements($cell) {
    const $indicatorContainer = this._getIndicatorContainer($cell);
    return $indicatorContainer && $indicatorContainer.children();
  }
  _renderIndicator(options2) {
    const $container = options2.container;
    const $indicator = options2.indicator;
    $container && $indicator && $container.append($indicator);
  }
  _updateIndicators(indicatorName) {
    const that = this;
    const columns7 = that.getColumns();
    const $cells = that.getColumnElements();
    let $cell;
    if (!$cells || columns7.length !== $cells.length) {
      return;
    }
    for (let i = 0; i < columns7.length; i++) {
      $cell = $cells.eq(i);
      that._updateIndicator($cell, columns7[i], indicatorName);
      const rowOptions = $cell.parent().data("options");
      if (rowOptions && rowOptions.cells) {
        rowOptions.cells[$cell.index()].column = columns7[i];
      }
    }
  }
  _updateIndicator($cell, column, indicatorName) {
    if (!column.command) {
      return this._applyColumnState({
        name: indicatorName,
        rootElement: $cell,
        column,
        showColumnLines: this.option("showColumnLines")
      });
    }
    return;
  }
};

// node_modules/devextreme/esm/ui/widget/ui.errors.js
var ui_errors_default = error_default(errors_default.ERROR_MESSAGES, {
  E1001: "Module '{0}'. Controller '{1}' is already registered",
  E1002: "Module '{0}'. Controller '{1}' does not inherit from DevExpress.ui.dxDataGrid.Controller",
  E1003: "Module '{0}'. View '{1}' is already registered",
  E1004: "Module '{0}'. View '{1}' does not inherit from DevExpress.ui.dxDataGrid.View",
  E1005: "Public method '{0}' is already registered",
  E1006: "Public method '{0}.{1}' does not exist",
  E1007: "State storing cannot be provided due to the restrictions of the browser",
  E1010: "The template does not contain the TextBox widget",
  E1011: 'Items cannot be deleted from the List. Implement the "remove" function in the data store',
  E1012: "Editing type '{0}' with the name '{1}' is unsupported",
  E1016: "Unexpected type of data source is provided for a lookup column",
  E1018: "The 'collapseAll' method cannot be called if you use a remote data source",
  E1019: "Search mode '{0}' is unavailable",
  E1020: "The type cannot be changed after initialization",
  E1021: "{0} '{1}' you are trying to remove does not exist",
  E1022: 'The "markers" option is given an invalid value. Assign an array instead',
  E1023: 'The "routes" option is given an invalid value. Assign an array instead',
  E1025: "This layout is too complex to render",
  E1026: 'The "calculateCustomSummary" function is missing from a field whose "summaryType" option is set to "custom"',
  E1031: "Unknown subscription in the Scheduler widget: '{0}'",
  E1032: "Unknown start date in an appointment: '{0}'",
  E1033: "Unknown step in the date navigator: '{0}'",
  E1034: "The browser does not implement an API for saving files",
  E1035: "The editor cannot be created: {0}",
  E1037: "Invalid structure of grouped data",
  E1038: "The browser does not support local storages for local web pages",
  E1039: "A cell's position cannot be calculated",
  E1040: "The '{0}' key value is not unique within the data array",
  E1041: "The '{0}' script is referenced after the DevExtreme scripts or not referenced at all",
  E1042: "{0} requires the key field to be specified",
  E1043: "Changes cannot be processed due to the incorrectly set key",
  E1044: "The key field specified by the keyExpr option does not match the key field specified in the data store",
  E1045: "Editing requires the key field to be specified in the data store",
  E1046: "The '{0}' key field is not found in data objects",
  E1047: 'The "{0}" field is not found in the fields array',
  E1048: 'The "{0}" operation is not found in the filterOperations array',
  E1049: "Column '{0}': filtering is allowed but the 'dataField' or 'name' option is not specified",
  E1050: "The validationRules option does not apply to third-party editors defined in the editCellTemplate",
  E1052: '{0} should have the "dataSource" option specified',
  E1053: 'The "buttons" option accepts an array that contains only objects or string values',
  E1054: "All text editor buttons must have names",
  E1055: 'One or several text editor buttons have invalid or non-unique "name" values',
  E1056: 'The {0} widget does not support buttons of the "{1}" type',
  E1058: 'The "startDayHour" and "endDayHour" options must be integers in the [0, 24] range, with "endDayHour" being greater than "startDayHour".',
  E1059: "The following column names are not unique: {0}",
  E1060: "All editable columns must have names",
  E1061: 'The "offset" option must be an integer in the [-1440, 1440] range, divisible by 5 without a remainder.',
  E1062: 'The "cellDuration" must be a positive integer, evenly dividing the ("endDayHour" - "startDayHour") interval into minutes.',
  W1001: 'The "key" option cannot be modified after initialization',
  W1002: "An item with the key '{0}' does not exist",
  W1003: "A group with the key '{0}' in which you are trying to select items does not exist",
  W1004: "The item '{0}' you are trying to select in the group '{1}' does not exist",
  W1005: "Due to column data types being unspecified, data has been loaded twice in order to apply initial filter settings. To resolve this issue, specify data types for all grid columns.",
  W1006: "The map service returned the following error: '{0}'",
  W1007: "No item with key {0} was found in the data source, but this key was used as the parent key for item {1}",
  W1008: "Cannot scroll to the '{0}' date because it does not exist on the current view",
  W1009: "Searching works only if data is specified using the dataSource option",
  W1010: "The capability to select all items works with source data of plain structure only",
  W1011: 'The "keyExpr" option is not applied when dataSource is not an array',
  W1012: "The '{0}' key field is not found in data objects",
  W1013: 'The "message" field in the dialog component was renamed to "messageHtml". Change your code correspondingly. In addition, if you used HTML code in the message, make sure that it is secure',
  W1014: "The Floating Action Button exceeds the recommended speed dial action count. If you need to display more speed dial actions, increase the maxSpeedDialActionCount option value in the global config.",
  W1017: "The 'key' property is not specified for a lookup data source. Please specify it to prevent requests for the entire dataset when users filter data.",
  W1018: "Infinite scrolling may not work properly with multiple selection. To use these features together, set 'selection.deferred' to true or set 'selection.selectAllMode' to 'page'.",
  W1019: "Filter query string exceeds maximum length limit of {0} characters.",
  W1020: "hideEvent is ignored when the shading property is true",
  W1021: `The '{0}' is not rendered because none of the DOM elements match the value of the "container" property.`,
  W1022: "{0} JSON parsing error: '{1}'",
  W1023: "Appointments require unique keys. Otherwise, the agenda view may not work correctly.",
  W1024: "The client-side export is enabled. Implement the 'onExporting' function.",
  W1025: "'scrolling.mode' is set to 'virtual' or 'infinite'. Specify the height of the component.",
  W1026: "The 'ai' toolbar item is defined, but aiIntegration is missing.",
  W1027: "A prompt should be specified for a custom command."
});

// node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js
function _objectWithoutPropertiesLoose(r, e) {
  if (null == r) return {};
  var t = {};
  for (var n in r) if ({}.hasOwnProperty.call(r, n)) {
    if (-1 !== e.indexOf(n)) continue;
    t[n] = r[n];
  }
  return t;
}

// node_modules/devextreme/esm/__internal/grids/grid_core/views/utils/update_views_borders.js
var _excluded = ["rowsView"];
var CLASSES2 = {
  borderedTop: "dx-bordered-top-view",
  borderedBottom: "dx-bordered-bottom-view"
};
var getFirstVisibleViewElement = (_ref) => {
  let {
    columnHeadersView: columnHeadersView10,
    rowsView: rowsView18
  } = _ref;
  if (null !== columnHeadersView10 && void 0 !== columnHeadersView10 && columnHeadersView10.isVisible()) {
    return columnHeadersView10.element();
  }
  return rowsView18.element();
};
var getLastVisibleViewElement = (_ref2) => {
  let {
    filterPanelView,
    footerView: footerView3,
    rowsView: rowsView18
  } = _ref2;
  if (null !== filterPanelView && void 0 !== filterPanelView && filterPanelView.isVisible()) {
    return filterPanelView.element();
  }
  if (null !== footerView3 && void 0 !== footerView3 && footerView3.isVisible()) {
    return footerView3.element();
  }
  return rowsView18.element();
};
var getViewElementWithClass = (viewsWithBorder, className) => {
  const borderedView = Object.values(viewsWithBorder).find((view) => {
    var _view$element;
    return null === view || void 0 === view || null === (_view$element = view.element()) || void 0 === _view$element ? void 0 : _view$element.hasClass(className);
  });
  return (null === borderedView || void 0 === borderedView ? void 0 : borderedView.element()) ?? null;
};
var shouldUpdateBorders = (viewName2, viewsWithBorder) => {
  var _rowsView$element;
  if (!Object.keys(viewsWithBorder).includes(viewName2)) {
    return false;
  }
  const {
    rowsView: rowsView18
  } = viewsWithBorder, otherViews = _objectWithoutPropertiesLoose(viewsWithBorder, _excluded);
  if (!isDefined(null === rowsView18 || void 0 === rowsView18 || null === (_rowsView$element = rowsView18.element) || void 0 === _rowsView$element ? void 0 : _rowsView$element.call(rowsView18))) {
    return false;
  }
  return Object.values(otherViews).filter((view) => {
    var _view$isVisible;
    return null === view || void 0 === view || null === (_view$isVisible = view.isVisible) || void 0 === _view$isVisible ? void 0 : _view$isVisible.call(view);
  }).every((view) => isDefined(null === view || void 0 === view ? void 0 : view.element()));
};
var updateViewsBorders = (viewName2, viewsWithBorder) => {
  if (!shouldUpdateBorders(viewName2, viewsWithBorder)) {
    return;
  }
  const $oldFirst = getViewElementWithClass(viewsWithBorder, CLASSES2.borderedTop);
  const $oldLast = getViewElementWithClass(viewsWithBorder, CLASSES2.borderedBottom);
  const $newFirst = getFirstVisibleViewElement(viewsWithBorder);
  const $newLast = getLastVisibleViewElement(viewsWithBorder);
  if ($oldFirst && !$oldFirst.is($newFirst)) {
    $oldFirst.removeClass(CLASSES2.borderedTop);
  }
  if ($oldLast && !$oldLast.is($newLast)) {
    $oldLast.removeClass(CLASSES2.borderedBottom);
  }
  if (!$newFirst.hasClass(CLASSES2.borderedTop)) {
    $newFirst.addClass(CLASSES2.borderedTop);
  }
  if (!$newLast.hasClass(CLASSES2.borderedBottom)) {
    $newLast.addClass(CLASSES2.borderedBottom);
  }
};

// node_modules/devextreme/esm/__internal/grids/grid_core/m_modules.js
var ModuleItem = class {
  constructor(component) {
    const that = this;
    that._updateLockCount = 0;
    that.component = component;
    that._actions = {};
    that._actionConfigs = {};
    each(this.callbackNames() || [], function(index2, name2) {
      const flags = that.callbackFlags(name2) || {};
      flags.unique = true;
      flags.syncStrategy = true;
      that[this] = callbacks_default(flags);
    });
  }
  _endUpdateCore() {
  }
  init() {
  }
  callbackNames() {
    return;
  }
  callbackFlags(name2) {
  }
  publicMethods() {
    return [];
  }
  beginUpdate() {
    this._updateLockCount++;
  }
  endUpdate() {
    if (this._updateLockCount > 0) {
      this._updateLockCount--;
      if (!this._updateLockCount) {
        this._endUpdateCore();
      }
    }
  }
  option(name2) {
    const {
      component
    } = this;
    const optionCache = component._optionCache;
    if (1 === arguments.length && optionCache) {
      if (!(name2 in optionCache)) {
        optionCache[name2] = component.option(name2);
      }
      return optionCache[name2];
    }
    return component.option.apply(component, arguments);
  }
  _silentOption(name2, value2) {
    const {
      component
    } = this;
    const optionCache = component._optionCache;
    if (optionCache) {
      optionCache[name2] = value2;
    }
    return component._setOptionWithoutOptionChange(name2, value2);
  }
  localize(name2) {
    const optionCache = this.component._optionCache;
    if (optionCache) {
      if (!(name2 in optionCache)) {
        optionCache[name2] = message_default.format(name2);
      }
      return optionCache[name2];
    }
    return message_default.format(name2);
  }
  on(event, callback) {
    return this.component.on.apply(this.component, arguments);
  }
  off() {
    return this.component.off.apply(this.component, arguments);
  }
  optionChanged(args) {
    if (args.name in this._actions) {
      this.createAction(args.name, this._actionConfigs[args.name]);
      args.handled = true;
    }
  }
  getAction(actionName) {
    return this._actions[actionName];
  }
  setAria(name2, value2, $target) {
    const target = $target.get(0);
    const prefix = "role" !== name2 && "id" !== name2 ? "aria-" : "";
    if (target.setAttribute) {
      target.setAttribute(prefix + name2, value2);
    } else {
      $target.attr(prefix + name2, value2);
    }
  }
  _createComponent($container, component, options2) {
    return this.component._createComponent($container, component, options2);
  }
  getController(name2) {
    return this.component._controllers[name2];
  }
  createAction(actionName, config3) {
    if (isFunction(actionName)) {
      const action = this.component._createAction(actionName.bind(this), config3);
      return function(e) {
        action({
          event: e
        });
      };
    }
    this._actions[actionName] = this.component._createActionByOption(actionName, config3);
    this._actionConfigs[actionName] = config3;
    return;
  }
  executeAction(actionName, options2) {
    const action = this._actions[actionName];
    return action && action(options2);
  }
  dispose() {
    const that = this;
    each(that.callbackNames() || [], function() {
      that[this].empty();
    });
  }
  addWidgetPrefix(className) {
    const componentName = this.component.NAME;
    return `dx-${componentName.slice(2).toLowerCase()}${className ? `-${className}` : ""}`;
  }
  getWidgetContainerClass() {
    const containerName = "dxDataGrid" === this.component.NAME ? null : "container";
    return this.addWidgetPrefix(containerName);
  }
  elementIsInsideGrid($element) {
    const $gridElement = $element.closest(`.${this.getWidgetContainerClass()}`).parent();
    return $gridElement.is(this.component.$element());
  }
};
var Controller = class extends ModuleItem {
};
var ViewController = class extends Controller {
  getView(name2) {
    return this.component._views[name2];
  }
  getViews() {
    return this.component._views;
  }
};
var View = class extends ModuleItem {
  constructor(component) {
    super(component);
    this.renderCompleted = callbacks_default();
    this.resizeCompleted = callbacks_default();
  }
  _isReady() {
    return this.component.isReady();
  }
  _endUpdateCore() {
    super._endUpdateCore();
    if (!this._isReady() && this._requireReady) {
      this._requireRender = false;
      this.component._requireResize = false;
    }
    if (this._requireRender) {
      this._requireRender = false;
      this.render(this._$parent);
    }
  }
  _invalidate(requireResize, requireReady) {
    this._requireRender = true;
    this.component._requireResize = hasWindow() && (this.component._requireResize || requireResize);
    this._requireReady = this._requireReady || requireReady;
  }
  _renderCore(options2) {
  }
  _resizeCore() {
  }
  _parentElement() {
    return this._$parent;
  }
  element() {
    return this._$element;
  }
  getElementHeight() {
    const $element = this.element();
    if (!$element) {
      return 0;
    }
    const marginTop = parseFloat($element.css("marginTop")) || 0;
    const marginBottom = parseFloat($element.css("marginBottom")) || 0;
    const {
      offsetHeight
    } = $element.get(0);
    return offsetHeight + marginTop + marginBottom;
  }
  isVisible() {
    return true;
  }
  getTemplate(name2) {
    return this.component._getTemplate(name2);
  }
  getView(name2) {
    return this.component._views[name2];
  }
  _getBorderedViews() {
    return {
      columnHeadersView: this.component._views.columnHeadersView,
      rowsView: this.component._views.rowsView,
      filterPanelView: this.component._views.filterPanelView,
      footerView: this.component._views.footerView
    };
  }
  render($parent, options2) {
    let $element = this._$element;
    const isVisible2 = this.isVisible();
    if (!$element && !$parent) {
      return;
    }
    this._requireReady = false;
    if (!$element) {
      $element = this._$element = renderer_default("<div>").appendTo($parent);
      this._$parent = $parent;
    }
    $element.toggleClass("dx-hidden", !isVisible2);
    if (this.component._views) {
      updateViewsBorders(this.name, this._getBorderedViews());
    }
    if (isVisible2) {
      this.component._optionCache = {};
      const deferred = this._renderCore(options2);
      this.component._optionCache = void 0;
      if (deferred) {
        deferred.done(() => {
          this.renderCompleted.fire(options2);
        });
      } else {
        this.renderCompleted.fire(options2);
      }
    }
  }
  resize() {
    this.isResizing = true;
    this._resizeCore();
    this.resizeCompleted.fire();
    this.isResizing = false;
  }
  focus(preventScroll) {
    this.element().get(0).focus({
      preventScroll
    });
  }
};
function getExtendedTypes(types2) {
  let moduleExtenders = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
  const extendTypes = {};
  Object.entries(moduleExtenders).forEach((_ref) => {
    let [name2, extender] = _ref;
    const currentType = types2[name2];
    if (currentType) {
      if (isFunction(extender)) {
        extendTypes[name2] = extender(currentType);
      } else {
        const classType = currentType;
        extendTypes[name2] = classType.inherit(extender);
      }
    }
  });
  return extendTypes;
}
function registerPublicMethods(componentInstance, name2, moduleItem) {
  const publicMethods = moduleItem.publicMethods();
  if (publicMethods) {
    each(publicMethods, (_, methodName) => {
      if (moduleItem[methodName]) {
        if (!componentInstance[methodName]) {
          componentInstance[methodName] = function() {
            return moduleItem[methodName](...arguments);
          };
        } else {
          throw ui_errors_default.Error("E1005", methodName);
        }
      } else {
        throw ui_errors_default.Error("E1006", name2, methodName);
      }
    });
  }
}
function processModules(componentInstance, componentClass) {
  const {
    modules
  } = componentClass;
  const {
    modulesOrder
  } = componentClass;
  function createModuleItems(moduleTypes) {
    const moduleItems = {};
    each(moduleTypes, (name2, moduleType) => {
      const moduleItem = new moduleType(componentInstance);
      moduleItem.name = name2;
      registerPublicMethods(componentInstance, name2, moduleItem);
      moduleItems[name2] = moduleItem;
    });
    return moduleItems;
  }
  if (modulesOrder) {
    modules.sort((module1, module2) => {
      let orderIndex1 = modulesOrder.indexOf(module1.name);
      let orderIndex2 = modulesOrder.indexOf(module2.name);
      if (orderIndex1 < 0) {
        orderIndex1 = 1e6;
      }
      if (orderIndex2 < 0) {
        orderIndex2 = 1e6;
      }
      return orderIndex1 - orderIndex2;
    });
  }
  const rootControllerTypes = {};
  const rootViewTypes = {};
  modules.forEach((_ref2) => {
    let {
      name: moduleName,
      controllers = {},
      views = {}
    } = _ref2;
    Object.entries(controllers).forEach((_ref3) => {
      let [name2, type2] = _ref3;
      if (rootControllerTypes[name2]) {
        throw ui_errors_default.Error("E1001", moduleName, name2);
      } else if (!((null === type2 || void 0 === type2 ? void 0 : type2.prototype) instanceof Controller)) {
        throw ui_errors_default.Error("E1002", moduleName, name2);
      }
      rootControllerTypes[name2] = type2;
    });
    Object.entries(views).forEach((_ref4) => {
      let [name2, type2] = _ref4;
      if (rootViewTypes[name2]) {
        throw ui_errors_default.Error("E1003", moduleName, name2);
      } else if (!((null === type2 || void 0 === type2 ? void 0 : type2.prototype) instanceof View)) {
        throw ui_errors_default.Error("E1004", moduleName, name2);
      }
      rootViewTypes[name2] = type2;
    });
  });
  const moduleExtenders = modules.filter((_ref5) => {
    let {
      extenders
    } = _ref5;
    return !!extenders;
  });
  const controllerTypes = moduleExtenders.reduce((types2, _ref6) => {
    let {
      extenders
    } = _ref6;
    return _extends({}, types2, getExtendedTypes(types2, null === extenders || void 0 === extenders ? void 0 : extenders.controllers));
  }, rootControllerTypes);
  const viewTypes = moduleExtenders.reduce((types2, _ref7) => {
    let {
      extenders
    } = _ref7;
    return _extends({}, types2, getExtendedTypes(types2, null === extenders || void 0 === extenders ? void 0 : extenders.views));
  }, rootViewTypes);
  componentInstance._controllers = createModuleItems(controllerTypes);
  componentInstance._views = createModuleItems(viewTypes);
}
var callModuleItemsMethod = function(that, methodName, args) {
  args = args || [];
  if (that._controllers) {
    each(that._controllers, function() {
      this[methodName] && this[methodName].apply(this, args);
    });
  }
  if (that._views) {
    each(that._views, function() {
      this[methodName] && this[methodName].apply(this, args);
    });
  }
};
var m_modules_default = {
  modules: [],
  View,
  ViewController,
  Controller,
  registerModule(name2, module) {
    const {
      modules
    } = this;
    for (let i = 0; i < modules.length; i++) {
      if (modules[i].name === name2) {
        return;
      }
    }
    module.name = name2;
    modules.push(module);
  },
  registerModulesOrder(moduleNames) {
    this.modulesOrder = moduleNames;
  },
  unregisterModule(name2) {
    this.modules = grep(this.modules, (module) => module.name !== name2);
  },
  processModules,
  callModuleItemsMethod
};

// node_modules/devextreme/esm/__internal/data/m_errors.js
var errors = error_default(errors_default.ERROR_MESSAGES, {
  E4000: "[DevExpress.data]: {0}",
  E4001: "Unknown aggregating function is detected: '{0}'",
  E4002: "Unsupported OData protocol version is used",
  E4003: "Unknown filter operation is used: {0}",
  E4004: "The thenby() method is called before the sortby() method",
  E4005: "Store requires a key expression for this operation",
  E4006: "ArrayStore 'data' option must be an array",
  E4007: "Compound keys cannot be auto-generated",
  E4008: "Attempt to insert an item with a duplicated key",
  E4009: "Data item cannot be found",
  E4010: "CustomStore does not support creating queries",
  E4011: "Custom Store method is not implemented or is not a function: {0}",
  E4012: "Custom Store method returns an invalid value: {0}",
  E4013: "Local Store requires the 'name' configuration option is specified",
  E4014: "Unknown data type is specified for ODataStore: {0}",
  E4015: "Unknown entity name or alias is used: {0}",
  E4016: "The compileSetter(expr) method is called with 'self' passed as a parameter",
  E4017: "Keys cannot be modified",
  E4018: "The server has returned a non-numeric value in a response to an item count request",
  E4019: "Mixing of group operators inside a single group of filter expression is not allowed",
  E4020: "Unknown store type is detected: {0}",
  E4021: "The server response does not provide the totalCount value",
  E4022: "The server response does not provide the groupCount value",
  E4023: "Could not parse the following XML: {0}",
  E4024: "String function {0} cannot be used with the data field {1} of type {2}.",
  W4000: "Data returned from the server has an incorrect structure",
  W4001: 'The {0} field is listed in both "keyType" and "fieldTypes". The value of "fieldTypes" is used.',
  W4002: "Data loading has failed for some cells due to the following error: {0}"
});
var errorHandler = null;
var handleError = function(error2) {
  var _errorHandler;
  null === (_errorHandler = errorHandler) || void 0 === _errorHandler || _errorHandler(error2);
};

// node_modules/devextreme/esm/__internal/data/m_utils.js
var ready2 = ready_callbacks_default.add;
var XHR_ERROR_UNLOAD = "DEVEXTREME_XHR_ERROR_UNLOAD";
var normalizeBinaryCriterion = function(crit) {
  return [crit[0], crit.length < 3 ? "=" : String(crit[1]).toLowerCase(), crit.length < 2 ? true : crit[crit.length - 1]];
};
var normalizeSortingInfo = function(info) {
  if (!Array.isArray(info)) {
    info = [info];
  }
  return map(info, (i) => {
    const result2 = {
      selector: isFunction(i) || "string" === typeof i ? i : i.getter || i.field || i.selector,
      desc: !!(i.desc || "d" === String(i.dir).charAt(0).toLowerCase())
    };
    if (i.compare) {
      result2.compare = i.compare;
    }
    return result2;
  });
};
var errorMessageFromXhr = function() {
  const textStatusMessages = {
    timeout: "Network connection timeout",
    error: "Unspecified network error",
    parsererror: "Unexpected server response"
  };
  let unloading;
  ready2(() => {
    const window31 = getWindow();
    dom_adapter_default.listen(window31, "beforeunload", () => {
      unloading = true;
    });
  });
  return function(xhr, textStatus) {
    if (unloading) {
      return XHR_ERROR_UNLOAD;
    }
    if (xhr.status < 400) {
      return function(textStatus2) {
        let result2 = textStatusMessages[textStatus2];
        if (!result2) {
          return textStatus2;
        }
        return result2;
      }(textStatus);
    }
    return xhr.statusText;
  };
}();
var aggregators = {
  count: {
    seed: 0,
    step: (count) => 1 + count
  },
  sum: {
    seed: 0,
    step: (sum, item) => sum + item
  },
  min: {
    step: (min, item) => item < min ? item : min
  },
  max: {
    step: (max, item) => item > max ? item : max
  },
  avg: {
    seed: [0, 0],
    step: (pair, value2) => [pair[0] + value2, pair[1] + 1],
    finalize: (pair) => pair[1] ? pair[0] / pair[1] : NaN
  }
};
var processRequestResultLock = /* @__PURE__ */ function() {
  let lockCount = 0;
  let lockDeferred;
  return {
    obtain: function() {
      if (0 === lockCount) {
        lockDeferred = new Deferred();
      }
      lockCount++;
    },
    release: function() {
      lockCount--;
      if (lockCount < 1) {
        lockDeferred.resolve();
      }
    },
    promise: function() {
      const deferred = 0 === lockCount ? new Deferred().resolve() : lockDeferred;
      return deferred.promise();
    },
    reset: function() {
      lockCount = 0;
      if (lockDeferred) {
        lockDeferred.resolve();
      }
    }
  };
}();
function isConjunctiveOperator(condition) {
  return /^(and|&&|&)$/i.test(condition);
}
var keysEqual = function(keyExpr, key1, key2) {
  if (Array.isArray(keyExpr)) {
    const names = map(key1, (v, k) => k);
    let name2;
    for (let i = 0; i < names.length; i++) {
      name2 = names[i];
      if (!equalByValue(key1[name2], key2[name2], {
        strict: false
      })) {
        return false;
      }
    }
    return true;
  }
  return equalByValue(key1, key2, {
    strict: false
  });
};
var isUnaryOperation = function(crit) {
  return "!" === crit[0] && Array.isArray(crit[1]);
};
var isGroupOperator = function(value2) {
  return "and" === value2 || "or" === value2;
};
var isUniformEqualsByOr = function(crit) {
  if (crit.length > 2 && Array.isArray(crit[0]) && "or" === crit[1] && "string" === typeof crit[0][0] && "=" === crit[0][1]) {
    const [prop] = crit[0];
    return !crit.find((el, i) => i % 2 !== 0 ? "or" !== el : !Array.isArray(el) || 3 !== el.length || el[0] !== prop || "=" !== el[1]);
  }
  return false;
};
var isGroupCriterion = function(crit) {
  const first = crit[0];
  const second = crit[1];
  if (Array.isArray(first)) {
    return true;
  }
  if (isFunction(first)) {
    if (Array.isArray(second) || isFunction(second) || isGroupOperator(second)) {
      return true;
    }
  }
  return false;
};
var trivialPromise = function() {
  const d = new Deferred();
  return d.resolve.apply(d, arguments).promise();
};
var rejectedPromise = function() {
  const d = new Deferred();
  return d.reject.apply(d, arguments).promise();
};
function throttle(func, timeout) {
  let timeoutId;
  return function() {
    if (!timeoutId) {
      timeoutId = setTimeout(() => {
        timeoutId = void 0;
        func.call(this);
      }, isFunction(timeout) ? timeout() : timeout);
    }
    return timeoutId;
  };
}
function throttleChanges(func, timeout) {
  let cache = [];
  const throttled = throttle(function() {
    func.call(this, cache);
    cache = [];
  }, timeout);
  return function(changes) {
    if (Array.isArray(changes)) {
      cache.push(...changes);
    }
    return throttled.call(this, cache);
  };
}

// node_modules/devextreme/esm/__internal/data/m_array_utils.js
function hasKey(target, keyOrKeys) {
  let key;
  const keys = "string" === typeof keyOrKeys ? keyOrKeys.split() : keyOrKeys.slice();
  while (keys.length) {
    key = keys.shift();
    if (key in target) {
      return true;
    }
  }
  return false;
}
function findItems(keyInfo, items, key, groupCount) {
  let childItems;
  let result2;
  if (groupCount) {
    for (let i = 0; i < items.length; i++) {
      childItems = items[i].items || items[i].collapsedItems || [];
      result2 = findItems(keyInfo, childItems || [], key, groupCount - 1);
      if (result2) {
        return result2;
      }
    }
  } else if (indexByKey(keyInfo, items, key) >= 0) {
    return items;
  }
}
function getItems(keyInfo, items, key, groupCount) {
  if (groupCount) {
    return findItems(keyInfo, items, key, groupCount) || [];
  }
  return items;
}
function generateDataByKeyMap(keyInfo, array) {
  if (keyInfo.key() && (!array._dataByKeyMap || array._dataByKeyMapLength !== array.length)) {
    const dataByKeyMap = {};
    const arrayLength = array.length;
    for (let i = 0; i < arrayLength; i++) {
      dataByKeyMap[JSON.stringify(keyInfo.keyOf(array[i]))] = array[i];
    }
    array._dataByKeyMap = dataByKeyMap;
    array._dataByKeyMapLength = arrayLength;
  }
}
function getCacheValue(array, key) {
  if (array._dataByKeyMap) {
    return array._dataByKeyMap[JSON.stringify(key)];
  }
}
function getHasKeyCacheValue(array, key) {
  if (array._dataByKeyMap) {
    return array._dataByKeyMap[JSON.stringify(key)];
  }
  return true;
}
function setDataByKeyMapValue(array, key, data17) {
  if (array._dataByKeyMap) {
    array._dataByKeyMap[JSON.stringify(key)] = data17;
    array._dataByKeyMapLength += data17 ? 1 : -1;
  }
}
function cloneInstanceWithChangedPaths(instance, changes, clonedInstances) {
  clonedInstances = clonedInstances || /* @__PURE__ */ new WeakMap();
  const result2 = instance ? Object.create(Object.getPrototypeOf(instance)) : {};
  if (instance) {
    clonedInstances.set(instance, result2);
  }
  const instanceWithoutPrototype = _extends({}, instance);
  deepExtendArraySafe(result2, instanceWithoutPrototype, true, true, true);
  for (const name2 in instanceWithoutPrototype) {
    const value2 = instanceWithoutPrototype[name2];
    const change = null === changes || void 0 === changes ? void 0 : changes[name2];
    if (isObject(value2) && !isPlainObject(value2) && isObject(change) && !clonedInstances.has(value2)) {
      result2[name2] = cloneInstanceWithChangedPaths(value2, change, clonedInstances);
    }
  }
  for (const name2 in result2) {
    const prop = result2[name2];
    if (isObject(prop) && clonedInstances.has(prop)) {
      result2[name2] = clonedInstances.get(prop);
    }
  }
  return result2;
}
function createObjectWithChanges(target, changes) {
  const result2 = cloneInstanceWithChangedPaths(target, changes);
  return deepExtendArraySafe(result2, changes, true, true, true);
}
function applyBatch(_ref) {
  let {
    keyInfo,
    data: data17,
    changes,
    groupCount,
    useInsertIndex,
    immutable,
    disableCache,
    logError,
    skipCopying
  } = _ref;
  const resultItems = true === immutable ? [...data17] : data17;
  changes.forEach((item) => {
    const items = "insert" === item.type ? resultItems : getItems(keyInfo, resultItems, item.key, groupCount);
    !disableCache && generateDataByKeyMap(keyInfo, items);
    switch (item.type) {
      case "update":
        update(keyInfo, items, item.key, item.data, true, immutable, logError);
        break;
      case "insert":
        insert(keyInfo, items, item.data, useInsertIndex && isDefined(item.index) ? item.index : -1, true, logError, skipCopying);
        break;
      case "remove":
        remove(keyInfo, items, item.key, true, logError);
    }
  });
  return resultItems;
}
function getErrorResult(isBatch, logError, errorCode) {
  return !isBatch ? rejectedPromise(errors.Error(errorCode)) : logError && errors.log(errorCode);
}
function update(keyInfo, array, key, data17, isBatch, immutable, logError) {
  let target;
  const keyExpr = keyInfo.key();
  if (keyExpr) {
    if (hasKey(data17, keyExpr) && !keysEqual(keyExpr, key, keyInfo.keyOf(data17))) {
      return getErrorResult(isBatch, logError, "E4017");
    }
    target = getCacheValue(array, key);
    if (!target) {
      const index2 = indexByKey(keyInfo, array, key);
      if (index2 < 0) {
        return getErrorResult(isBatch, logError, "E4009");
      }
      target = array[index2];
      if (true === immutable && isDefined(target)) {
        const newTarget = createObjectWithChanges(target, data17);
        array[index2] = newTarget;
        return !isBatch && trivialPromise(newTarget, key);
      }
    }
  } else {
    target = key;
  }
  deepExtendArraySafe(target, data17, true, false, true, true);
  if (!isBatch) {
    if (config_default2().useLegacyStoreResult) {
      return trivialPromise(key, data17);
    }
    return trivialPromise(target, key);
  }
}
function insert(keyInfo, array, data17, index2, isBatch, logError, skipCopying) {
  let keyValue;
  const keyExpr = keyInfo.key();
  const obj = isPlainObject(data17) && !skipCopying ? extend({}, data17) : data17;
  if (keyExpr) {
    keyValue = keyInfo.keyOf(obj);
    if (void 0 === keyValue || "object" === typeof keyValue && isEmptyObject(keyValue)) {
      if (Array.isArray(keyExpr)) {
        throw errors.Error("E4007");
      }
      keyValue = obj[keyExpr] = String(new guid_default2());
    } else if (void 0 !== array[indexByKey(keyInfo, array, keyValue)]) {
      return getErrorResult(isBatch, logError, "E4008");
    }
  } else {
    keyValue = obj;
  }
  if (index2 >= 0) {
    array.splice(index2, 0, obj);
  } else {
    array.push(obj);
  }
  setDataByKeyMapValue(array, keyValue, obj);
  if (!isBatch) {
    return trivialPromise(config_default2().useLegacyStoreResult ? data17 : obj, keyValue);
  }
}
function remove(keyInfo, array, key, isBatch, logError) {
  const index2 = indexByKey(keyInfo, array, key);
  if (index2 > -1) {
    array.splice(index2, 1);
    setDataByKeyMapValue(array, key, null);
  }
  if (!isBatch) {
    return trivialPromise(key);
  }
  if (index2 < 0) {
    return getErrorResult(isBatch, logError, "E4009");
  }
}
function indexByKey(keyInfo, array, key) {
  const keyExpr = keyInfo.key();
  if (!getHasKeyCacheValue(array, key)) {
    return -1;
  }
  for (let i = 0, arrayLength = array.length; i < arrayLength; i++) {
    if (keysEqual(keyExpr, keyInfo.keyOf(array[i]), key)) {
      return i;
    }
  }
  return -1;
}

// node_modules/devextreme/esm/__internal/data/m_array_query.js
var Iterator = class_default.inherit({
  toArray() {
    const result2 = [];
    this.reset();
    while (this.next()) {
      result2.push(this.current());
    }
    return result2;
  },
  countable: () => false
});
var ArrayIterator = Iterator.inherit({
  ctor(array) {
    this.array = array;
    this.index = -1;
  },
  next() {
    if (this.index + 1 < this.array.length) {
      this.index++;
      return true;
    }
    return false;
  },
  current() {
    return this.array[this.index];
  },
  reset() {
    this.index = -1;
  },
  toArray() {
    return this.array.slice(0);
  },
  countable: () => true,
  count() {
    return this.array.length;
  }
});
var WrappedIterator = Iterator.inherit({
  ctor(iter) {
    this.iter = iter;
  },
  next() {
    return this.iter.next();
  },
  current() {
    return this.iter.current();
  },
  reset() {
    return this.iter.reset();
  }
});
var MapIterator = WrappedIterator.inherit({
  ctor(iter, mapper) {
    this.callBase(iter);
    this.index = -1;
    this.mapper = mapper;
  },
  current() {
    return this.mapper(this.callBase(), this.index);
  },
  next() {
    const hasNext = this.callBase();
    if (hasNext) {
      this.index++;
    }
    return hasNext;
  }
});
var defaultCompare = function(xValue, yValue, options2) {
  if (isString(xValue) && isString(yValue) && (null !== options2 && void 0 !== options2 && options2.locale || null !== options2 && void 0 !== options2 && options2.collatorOptions)) {
    return new Intl.Collator((null === options2 || void 0 === options2 ? void 0 : options2.locale) || void 0, (null === options2 || void 0 === options2 ? void 0 : options2.collatorOptions) || void 0).compare(xValue, yValue);
  }
  xValue = toComparable(xValue, false, options2);
  yValue = toComparable(yValue, false, options2);
  if (null === xValue && null !== yValue) {
    return -1;
  }
  if (null !== xValue && null === yValue) {
    return 1;
  }
  if (void 0 === xValue && void 0 !== yValue) {
    return 1;
  }
  if (void 0 !== xValue && void 0 === yValue) {
    return -1;
  }
  if (xValue < yValue) {
    return -1;
  }
  if (xValue > yValue) {
    return 1;
  }
  return 0;
};
var SortIterator = Iterator.inherit({
  ctor(iter, getter, desc, compare3) {
    this.langParams = iter.langParams;
    if (!(iter instanceof MapIterator)) {
      iter = new MapIterator(iter, this._wrap);
      iter.langParams = this.langParams;
    }
    this.iter = iter;
    this.rules = [{
      getter,
      desc,
      compare: compare3,
      langParams: this.langParams
    }];
  },
  thenBy(getter, desc, compare3) {
    const result2 = new SortIterator(this.sortedIter || this.iter, getter, desc, compare3);
    if (!this.sortedIter) {
      result2.rules = this.rules.concat(result2.rules);
    }
    return result2;
  },
  next() {
    this._ensureSorted();
    return this.sortedIter.next();
  },
  current() {
    this._ensureSorted();
    return this.sortedIter.current();
  },
  reset() {
    delete this.sortedIter;
  },
  countable() {
    return this.sortedIter || this.iter.countable();
  },
  count() {
    if (this.sortedIter) {
      return this.sortedIter.count();
    }
    return this.iter.count();
  },
  _ensureSorted() {
    const that = this;
    if (that.sortedIter) {
      return;
    }
    each(that.rules, function() {
      this.getter = compileGetter(this.getter);
    });
    that.sortedIter = new MapIterator(new ArrayIterator(this.iter.toArray().sort((x, y) => that._compare(x, y))), that._unwrap);
  },
  _wrap: (record, index2) => ({
    index: index2,
    value: record
  }),
  _unwrap: (wrappedItem) => wrappedItem.value,
  _getDefaultCompare: (langParams) => (xValue, yValue) => defaultCompare(xValue, yValue, langParams),
  _compare(x, y) {
    const xIndex = x.index;
    const yIndex = y.index;
    x = x.value;
    y = y.value;
    if (x === y) {
      return xIndex - yIndex;
    }
    for (let i = 0, rulesCount = this.rules.length; i < rulesCount; i++) {
      const rule = this.rules[i];
      const xValue = rule.getter(x);
      const yValue = rule.getter(y);
      const compare3 = rule.compare || this._getDefaultCompare(rule.langParams);
      const compareResult = compare3(xValue, yValue);
      if (compareResult) {
        return rule.desc ? -compareResult : compareResult;
      }
    }
    return xIndex - yIndex;
  }
});
var compileCriteria = /* @__PURE__ */ function() {
  let langParams = {};
  const _toComparable = (value2) => toComparable(value2, false, langParams);
  const compileGroup = function(crit) {
    if (isUniformEqualsByOr(crit)) {
      return ((crit2) => {
        const getter = compileGetter(crit2[0][0]);
        const filterValues = crit2.reduce((acc, item, i) => {
          if (i % 2 === 0) {
            acc.push(_toComparable(item[2]));
          }
          return acc;
        }, []);
        return (obj) => {
          const value2 = _toComparable(getter(obj));
          return filterValues.some((filterValue) => useStrictComparison(filterValue) ? value2 === filterValue : value2 == filterValue);
        };
      })(crit);
    }
    const ops = [];
    let isConjunctiveOperator2 = false;
    let isConjunctiveNextOperator = false;
    each(crit, function() {
      if (Array.isArray(this) || isFunction(this)) {
        if (ops.length > 1 && isConjunctiveOperator2 !== isConjunctiveNextOperator) {
          throw errors.Error("E4019");
        }
        ops.push(compileCriteria(this, langParams));
        isConjunctiveOperator2 = isConjunctiveNextOperator;
        isConjunctiveNextOperator = true;
      } else {
        isConjunctiveNextOperator = isConjunctiveOperator(this);
      }
    });
    return function(d) {
      let result2 = isConjunctiveOperator2;
      for (let i = 0; i < ops.length; i++) {
        if (ops[i](d) !== isConjunctiveOperator2) {
          result2 = !isConjunctiveOperator2;
          break;
        }
      }
      return result2;
    };
  };
  const toString = function(value2) {
    var _langParams;
    return isDefined(value2) ? null !== (_langParams = langParams) && void 0 !== _langParams && _langParams.locale ? value2.toLocaleString(langParams.locale) : value2.toString() : "";
  };
  function compileEquals(getter, value2, negate) {
    return function(obj) {
      obj = _toComparable(getter(obj));
      let result2 = useStrictComparison(value2) ? obj === value2 : obj == value2;
      if (negate) {
        result2 = !result2;
      }
      return result2;
    };
  }
  function useStrictComparison(value2) {
    return "" === value2 || 0 === value2 || false === value2;
  }
  return function(crit, options2) {
    langParams = options2 || {};
    if (isFunction(crit)) {
      return crit;
    }
    if (isGroupCriterion(crit)) {
      return compileGroup(crit);
    }
    if (isUnaryOperation(crit)) {
      return function(crit2) {
        const op = crit2[0];
        const criteria = compileCriteria(crit2[1], langParams);
        if ("!" === op) {
          return function(obj) {
            return !criteria(obj);
          };
        }
        throw errors.Error("E4003", op);
      }(crit);
    }
    return function(crit2) {
      crit2 = normalizeBinaryCriterion(crit2);
      const getter = compileGetter(crit2[0]);
      const op = crit2[1];
      let value2 = crit2[2];
      value2 = _toComparable(value2);
      const compare3 = (obj, operatorFn) => {
        obj = _toComparable(getter(obj));
        return (null == value2 || null == obj) && value2 !== obj ? false : operatorFn(obj, value2);
      };
      switch (op.toLowerCase()) {
        case "=":
          return compileEquals(getter, value2);
        case "<>":
          return compileEquals(getter, value2, true);
        case ">":
          return (obj) => compare3(obj, (a, b) => a > b);
        case "<":
          return (obj) => compare3(obj, (a, b) => a < b);
        case ">=":
          return (obj) => compare3(obj, (a, b) => a >= b);
        case "<=":
          return (obj) => compare3(obj, (a, b) => a <= b);
        case "startswith":
          return (obj) => _toComparable(toString(getter(obj))).startsWith(value2);
        case "endswith":
          return (obj) => _toComparable(toString(getter(obj))).endsWith(value2);
        case "contains":
          return (obj) => _toComparable(toString(getter(obj))).includes(value2);
        case "notcontains":
          return (obj) => !_toComparable(toString(getter(obj))).includes(value2);
      }
      throw errors.Error("E4003", op);
    }(crit);
  };
}();
var FilterIterator = WrappedIterator.inherit({
  ctor(iter, criteria) {
    this.callBase(iter);
    this.langParams = iter.langParams;
    this.criteria = compileCriteria(criteria, this.langParams);
  },
  next() {
    while (this.iter.next()) {
      if (this.criteria(this.current())) {
        return true;
      }
    }
    return false;
  }
});
var GroupIterator = Iterator.inherit({
  ctor(iter, getter) {
    this.iter = iter;
    this.getter = getter;
  },
  next() {
    this._ensureGrouped();
    return this.groupedIter.next();
  },
  current() {
    this._ensureGrouped();
    return this.groupedIter.current();
  },
  reset() {
    delete this.groupedIter;
  },
  countable() {
    return !!this.groupedIter;
  },
  count() {
    return this.groupedIter.count();
  },
  _ensureGrouped() {
    if (this.groupedIter) {
      return;
    }
    const hash = {};
    const keys = [];
    const {
      iter
    } = this;
    const getter = compileGetter(this.getter);
    iter.reset();
    while (iter.next()) {
      const current2 = iter.current();
      const key = getter(current2);
      if (key in hash) {
        hash[key].push(current2);
      } else {
        hash[key] = [current2];
        keys.push(key);
      }
    }
    this.groupedIter = new ArrayIterator(map(keys, (key) => ({
      key,
      items: hash[key]
    })));
  }
});
var SelectIterator = WrappedIterator.inherit({
  ctor(iter, getter) {
    this.callBase(iter);
    this.getter = compileGetter(getter);
  },
  current() {
    return this.getter(this.callBase());
  },
  countable() {
    return this.iter.countable();
  },
  count() {
    return this.iter.count();
  }
});
var SliceIterator = WrappedIterator.inherit({
  ctor(iter, skip, take) {
    this.callBase(iter);
    this.skip = Math.max(0, skip);
    this.take = Math.max(0, take);
    this.pos = 0;
  },
  next() {
    if (this.pos >= this.skip + this.take) {
      return false;
    }
    while (this.pos < this.skip && this.iter.next()) {
      this.pos++;
    }
    this.pos++;
    return this.iter.next();
  },
  reset() {
    this.callBase();
    this.pos = 0;
  },
  countable() {
    return this.iter.countable();
  },
  count() {
    return Math.min(this.iter.count() - this.skip, this.take);
  }
});
var arrayQueryImpl = function(iter, queryOptions) {
  queryOptions = queryOptions || {};
  if (!(iter instanceof Iterator)) {
    iter = new ArrayIterator(iter);
  }
  if (queryOptions.langParams) {
    iter.langParams = queryOptions.langParams;
  }
  const handleError2 = function(error2) {
    const handler = queryOptions.errorHandler;
    if (handler) {
      handler(error2);
    }
    handleError(error2);
  };
  const aggregateCore = function(aggregator) {
    const d = new Deferred().fail(handleError2);
    let seed;
    const {
      step
    } = aggregator;
    const {
      finalize
    } = aggregator;
    try {
      iter.reset();
      if ("seed" in aggregator) {
        seed = aggregator.seed;
      } else {
        seed = iter.next() ? iter.current() : NaN;
      }
      let accumulator = seed;
      while (iter.next()) {
        accumulator = step(accumulator, iter.current());
      }
      d.resolve(finalize ? finalize(accumulator) : accumulator);
    } catch (x) {
      d.reject(x);
    }
    return d.promise();
  };
  const standardAggregate = function(name2) {
    return aggregateCore(aggregators[name2]);
  };
  const select = function(getter) {
    if (!isFunction(getter) && !Array.isArray(getter)) {
      getter = [].slice.call(arguments);
    }
    return chainQuery(new SelectIterator(iter, getter));
  };
  const selectProp = function(name2) {
    return select(compileGetter(name2));
  };
  function chainQuery(iter2) {
    return arrayQueryImpl(iter2, queryOptions);
  }
  return {
    toArray: () => iter.toArray(),
    enumerate() {
      const d = new Deferred().fail(handleError2);
      try {
        d.resolve(iter.toArray());
      } catch (x) {
        d.reject(x);
      }
      return d.promise();
    },
    setLangParams(options2) {
      iter.langParams = options2;
    },
    sortBy: (getter, desc, compare3) => chainQuery(new SortIterator(iter, getter, desc, compare3)),
    thenBy(getter, desc, compare3) {
      if (iter instanceof SortIterator) {
        return chainQuery(iter.thenBy(getter, desc, compare3));
      }
      throw errors.Error("E4004");
    },
    filter(criteria) {
      if (!Array.isArray(criteria)) {
        criteria = [].slice.call(arguments);
      }
      return chainQuery(new FilterIterator(iter, criteria));
    },
    slice(skip, take) {
      if (void 0 === take) {
        take = Number.MAX_VALUE;
      }
      return chainQuery(new SliceIterator(iter, skip, take));
    },
    select,
    groupBy: (getter) => chainQuery(new GroupIterator(iter, getter)),
    aggregate: function(seed, step, finalize) {
      if (arguments.length < 2) {
        return aggregateCore({
          step: arguments[0]
        });
      }
      return aggregateCore({
        seed,
        step,
        finalize
      });
    },
    count() {
      if (iter.countable()) {
        const d = new Deferred().fail(handleError2);
        try {
          d.resolve(iter.count());
        } catch (x) {
          d.reject(x);
        }
        return d.promise();
      }
      return standardAggregate("count");
    },
    sum(getter) {
      if (getter) {
        return selectProp(getter).sum();
      }
      return standardAggregate("sum");
    },
    min(getter) {
      if (getter) {
        return selectProp(getter).min();
      }
      return standardAggregate("min");
    },
    max(getter) {
      if (getter) {
        return selectProp(getter).max();
      }
      return standardAggregate("max");
    },
    avg(getter) {
      if (getter) {
        return selectProp(getter).avg();
      }
      return standardAggregate("avg");
    }
  };
};
var m_array_query_default = arrayQueryImpl;

// node_modules/devextreme/esm/__internal/data/m_store_helper.js
function multiLevelGroup(query2, groupInfo) {
  query2 = query2.groupBy(groupInfo[0].selector);
  if (groupInfo.length > 1) {
    query2 = query2.select((g) => extend({}, g, {
      items: multiLevelGroup(m_array_query_default(g.items), groupInfo.slice(1)).toArray()
    }));
  }
  return query2;
}
function arrangeSortingInfo(groupInfo, sortInfo) {
  const filteredGroup = [];
  each(groupInfo, (_, group) => {
    const collision = grep(sortInfo, (sort) => group.selector === sort.selector);
    if (collision.length < 1) {
      filteredGroup.push(group);
    }
  });
  return filteredGroup.concat(sortInfo);
}
function queryByOptions(query2, options2, isCountQuery) {
  var _options;
  options2 = options2 || {};
  const {
    filter
  } = options2;
  if (null !== (_options = options2) && void 0 !== _options && _options.langParams) {
    var _query$setLangParams, _query;
    null === (_query$setLangParams = (_query = query2).setLangParams) || void 0 === _query$setLangParams || _query$setLangParams.call(_query, options2.langParams);
  }
  if (filter) {
    query2 = query2.filter(filter);
  }
  if (isCountQuery) {
    return query2;
  }
  let {
    sort
  } = options2;
  const {
    select
  } = options2;
  let {
    group
  } = options2;
  const {
    skip
  } = options2;
  const {
    take
  } = options2;
  if (group) {
    group = normalizeSortingInfo(group);
    group.keepInitialKeyOrder = !!options2.group.keepInitialKeyOrder;
  }
  if (sort || group) {
    sort = normalizeSortingInfo(sort || []);
    if (group && !group.keepInitialKeyOrder) {
      sort = arrangeSortingInfo(group, sort);
    }
    each(sort, function(index2) {
      query2 = query2[index2 ? "thenBy" : "sortBy"](this.selector, this.desc, this.compare);
    });
  }
  if (select) {
    query2 = query2.select(select);
  }
  if (group) {
    query2 = multiLevelGroup(query2, group);
  }
  if (take || skip) {
    query2 = query2.slice(skip || 0, take);
  }
  return query2;
}
var m_store_helper_default = {
  multiLevelGroup,
  arrangeSortingInfo,
  queryByOptions
};

// node_modules/devextreme/esm/__internal/data/m_abstract_store.js
var {
  abstract: abstract2
} = class_default;
var {
  queryByOptions: queryByOptions2
} = m_store_helper_default;
var storeImpl = {};
var Store = class_default.inherit({
  _langParams: {},
  ctor(options2) {
    const that = this;
    options2 = options2 || {};
    this._eventsStrategy = new EventsStrategy(this);
    each(["onLoaded", "onLoading", "onInserted", "onInserting", "onUpdated", "onUpdating", "onPush", "onRemoved", "onRemoving", "onModified", "onModifying"], (_, optionName) => {
      if (optionName in options2) {
        that.on(optionName.slice(2).toLowerCase(), options2[optionName]);
      }
    });
    this._key = options2.key;
    this._errorHandler = options2.errorHandler;
    this._useDefaultSearch = true;
  },
  _clearCache: noop2,
  _customLoadOptions: () => null,
  key() {
    return this._key;
  },
  keyOf(obj) {
    if (!this._keyGetter) {
      this._keyGetter = compileGetter(this.key());
    }
    return this._keyGetter(obj);
  },
  _requireKey() {
    if (!this.key()) {
      throw errors.Error("E4005");
    }
  },
  load(options2) {
    const that = this;
    options2 = options2 || {};
    this._eventsStrategy.fireEvent("loading", [options2]);
    return this._withLock(this._loadImpl(options2)).done((result2) => {
      that._eventsStrategy.fireEvent("loaded", [result2, options2]);
    });
  },
  _loadImpl(options2) {
    if (!isEmptyObject(this._langParams)) {
      options2 = options2 || {};
      options2._langParams = _extends({}, this._langParams, options2._langParams);
    }
    return queryByOptions2(this.createQuery(options2), options2).enumerate();
  },
  _withLock(task) {
    const result2 = new Deferred();
    task.done(function() {
      const that = this;
      const args = arguments;
      processRequestResultLock.promise().done(() => {
        result2.resolveWith(that, args);
      });
    }).fail(function() {
      result2.rejectWith(this, arguments);
    });
    return result2;
  },
  createQuery: abstract2,
  totalCount(options2) {
    return this._totalCountImpl(options2);
  },
  _totalCountImpl(options2) {
    return queryByOptions2(this.createQuery(options2), options2, true).count();
  },
  byKey(key, extraOptions) {
    return this._addFailHandlers(this._withLock(this._byKeyImpl(key, extraOptions)));
  },
  _byKeyImpl: abstract2,
  insert(values) {
    const that = this;
    that._eventsStrategy.fireEvent("modifying");
    that._eventsStrategy.fireEvent("inserting", [values]);
    return that._addFailHandlers(that._insertImpl(values).done((callbackValues, callbackKey) => {
      that._eventsStrategy.fireEvent("inserted", [callbackValues, callbackKey]);
      that._eventsStrategy.fireEvent("modified");
    }));
  },
  _insertImpl: abstract2,
  update(key, values) {
    const that = this;
    that._eventsStrategy.fireEvent("modifying");
    that._eventsStrategy.fireEvent("updating", [key, values]);
    return that._addFailHandlers(that._updateImpl(key, values).done(() => {
      that._eventsStrategy.fireEvent("updated", [key, values]);
      that._eventsStrategy.fireEvent("modified");
    }));
  },
  _updateImpl: abstract2,
  push(changes) {
    const beforePushArgs = {
      changes,
      waitFor: []
    };
    this._eventsStrategy.fireEvent("beforePushAggregation", [beforePushArgs]);
    when(...beforePushArgs.waitFor).done(() => {
      this._pushImpl(changes);
      this._eventsStrategy.fireEvent("beforePush", [{
        changes
      }]);
      this._eventsStrategy.fireEvent("push", [changes]);
    });
  },
  _pushImpl: noop2,
  remove(key) {
    const that = this;
    that._eventsStrategy.fireEvent("modifying");
    that._eventsStrategy.fireEvent("removing", [key]);
    return that._addFailHandlers(that._removeImpl(key).done((callbackKey) => {
      that._eventsStrategy.fireEvent("removed", [callbackKey]);
      that._eventsStrategy.fireEvent("modified");
    }));
  },
  _removeImpl: abstract2,
  _addFailHandlers(deferred) {
    return deferred.fail(this._errorHandler).fail(handleError);
  },
  on(eventName, eventHandler) {
    this._eventsStrategy.on(eventName, eventHandler);
    return this;
  },
  off(eventName, eventHandler) {
    this._eventsStrategy.off(eventName, eventHandler);
    return this;
  }
});
Store.create = function(alias, options2) {
  if (!(alias in storeImpl)) {
    throw errors.Error("E4020", alias);
  }
  return new storeImpl[alias](options2);
};
Store.registerClass = function(type2, alias) {
  if (alias) {
    storeImpl[alias] = type2;
  }
  return type2;
};
Store.inherit = /* @__PURE__ */ function(inheritor) {
  return function(members, alias) {
    const type2 = inheritor.apply(this, [members]);
    Store.registerClass(type2, alias);
    return type2;
  };
}(Store.inherit);
var m_abstract_store_default = Store;

// node_modules/devextreme/esm/__internal/data/m_custom_store.js
var TOTAL_COUNT = "totalCount";
var LOAD = "load";
var BY_KEY = "byKey";
var INSERT = "insert";
var UPDATE = "update";
var REMOVE = "remove";
function isPromise2(obj) {
  return obj && isFunction(obj.then);
}
function trivialPromise2(value2) {
  return new Deferred().resolve(value2).promise();
}
function ensureRequiredFuncOption(name2, obj) {
  if (!isFunction(obj)) {
    throw errors.Error("E4011", name2);
  }
}
function throwInvalidUserFuncResult(name2) {
  throw errors.Error("E4012", name2);
}
function createUserFuncFailureHandler(pendingDeferred) {
  return function(arg) {
    let error2;
    if (arg instanceof Error) {
      error2 = arg;
    } else {
      error2 = new Error(function(promiseArguments) {
        const xhr = promiseArguments[0];
        const textStatus = promiseArguments[1];
        if (!xhr || !xhr.getResponseHeader) {
          return null;
        }
        return errorMessageFromXhr(xhr, textStatus);
      }(arguments) || arg && String(arg) || "Unknown error");
    }
    if (error2.message !== XHR_ERROR_UNLOAD) {
      pendingDeferred.reject(error2);
    }
  };
}
function invokeUserLoad(store, options2) {
  const userFunc = store._loadFunc;
  let userResult;
  ensureRequiredFuncOption(LOAD, userFunc);
  userResult = userFunc.apply(store, [options2]);
  if (Array.isArray(userResult)) {
    userResult = trivialPromise2(userResult);
  } else if (null === userResult || void 0 === userResult) {
    userResult = trivialPromise2([]);
  } else if (!isPromise2(userResult)) {
    throwInvalidUserFuncResult(LOAD);
  }
  return fromPromise(userResult);
}
function invokeUserTotalCountFunc(store, options2) {
  const userFunc = store._totalCountFunc;
  let userResult;
  if (!isFunction(userFunc)) {
    throw errors.Error("E4021");
  }
  userResult = userFunc.apply(store, [options2]);
  if (!isPromise2(userResult)) {
    userResult = Number(userResult);
    if (!isFinite(userResult)) {
      throwInvalidUserFuncResult(TOTAL_COUNT);
    }
    userResult = trivialPromise2(userResult);
  }
  return fromPromise(userResult);
}
function invokeUserByKeyFunc(store, key, extraOptions) {
  const userFunc = store._byKeyFunc;
  let userResult;
  ensureRequiredFuncOption(BY_KEY, userFunc);
  userResult = userFunc.apply(store, [key, extraOptions]);
  if (!isPromise2(userResult)) {
    userResult = trivialPromise2(userResult);
  }
  return fromPromise(userResult);
}
function runRawLoad(pendingDeferred, store, userFuncOptions, continuation) {
  if (store.__rawData) {
    continuation(store.__rawData);
  } else {
    const loadPromise = store.__rawDataPromise || invokeUserLoad(store, userFuncOptions);
    if (store._cacheRawData) {
      store.__rawDataPromise = loadPromise;
    }
    loadPromise.always(() => {
      delete store.__rawDataPromise;
    }).done((rawData) => {
      if (store._cacheRawData) {
        store.__rawData = rawData;
      }
      continuation(rawData);
    }).fail((error2) => {
      var _store$_errorHandler;
      const userFuncFailureHandler = createUserFuncFailureHandler(pendingDeferred);
      null === (_store$_errorHandler = store._errorHandler) || void 0 === _store$_errorHandler || _store$_errorHandler.call(store, error2);
      userFuncFailureHandler(error2);
    });
  }
}
function runRawLoadWithQuery(pendingDeferred, store, options2, countOnly) {
  options2 = options2 || {};
  const userFuncOptions = {};
  if ("userData" in options2) {
    userFuncOptions.userData = options2.userData;
  }
  runRawLoad(pendingDeferred, store, userFuncOptions, (rawData) => {
    const rawDataQuery = m_array_query_default(rawData, {
      errorHandler: store._errorHandler
    });
    let itemsQuery;
    let totalCountQuery;
    const waitList = [];
    let items;
    let totalCount;
    if (!countOnly) {
      itemsQuery = m_store_helper_default.queryByOptions(rawDataQuery, options2);
      if (itemsQuery === rawDataQuery) {
        items = rawData.slice(0);
      } else {
        waitList.push(itemsQuery.enumerate().done((asyncResult) => {
          items = asyncResult;
        }));
      }
    }
    if (options2.requireTotalCount || countOnly) {
      totalCountQuery = m_store_helper_default.queryByOptions(rawDataQuery, options2, true);
      if (totalCountQuery === rawDataQuery) {
        totalCount = rawData.length;
      } else {
        waitList.push(totalCountQuery.count().done((asyncResult) => {
          totalCount = asyncResult;
        }));
      }
    }
    when.apply(renderer_default, waitList).done(() => {
      if (countOnly) {
        pendingDeferred.resolve(totalCount);
      } else if (options2.requireTotalCount) {
        pendingDeferred.resolve(items, {
          totalCount
        });
      } else {
        pendingDeferred.resolve(items);
      }
    }).fail((x) => {
      pendingDeferred.reject(x);
    });
  });
}
function runRawLoadWithKey(pendingDeferred, store, key) {
  runRawLoad(pendingDeferred, store, {}, (rawData) => {
    const keyExpr = store.key();
    let item;
    for (let i = 0, len = rawData.length; i < len; i++) {
      item = rawData[i];
      if (keysEqual(keyExpr, store.keyOf(rawData[i]), key)) {
        pendingDeferred.resolve(item);
        return;
      }
    }
    pendingDeferred.reject(errors.Error("E4009"));
  });
}
var CustomStore = m_abstract_store_default.inherit({
  ctor(options2) {
    options2 = options2 || {};
    this.callBase(options2);
    this._useDefaultSearch = !!options2.useDefaultSearch || "raw" === options2.loadMode;
    this._loadMode = options2.loadMode;
    this._cacheRawData = false !== options2.cacheRawData;
    this._loadFunc = options2[LOAD];
    this._totalCountFunc = options2[TOTAL_COUNT];
    this._byKeyFunc = options2[BY_KEY];
    this._insertFunc = options2[INSERT];
    this._updateFunc = options2[UPDATE];
    this._removeFunc = options2[REMOVE];
  },
  _clearCache() {
    delete this.__rawData;
  },
  createQuery() {
    throw errors.Error("E4010");
  },
  clearRawDataCache() {
    this._clearCache();
  },
  _totalCountImpl(options2) {
    let d = new Deferred();
    if ("raw" === this._loadMode && !this._totalCountFunc) {
      runRawLoadWithQuery(d, this, options2, true);
    } else {
      invokeUserTotalCountFunc(this, options2).done((count) => {
        d.resolve(Number(count));
      }).fail(createUserFuncFailureHandler(d));
      d = this._addFailHandlers(d);
    }
    return d.promise();
  },
  _pushImpl(changes) {
    if (this.__rawData) {
      applyBatch({
        keyInfo: this,
        data: this.__rawData,
        changes
      });
    }
  },
  _loadImpl(options2) {
    let d = new Deferred();
    if ("raw" === this._loadMode) {
      runRawLoadWithQuery(d, this, options2, false);
    } else {
      invokeUserLoad(this, options2).done((data17, extra) => {
        d.resolve(data17, extra);
      }).fail(createUserFuncFailureHandler(d));
      d = this._addFailHandlers(d);
    }
    return d.promise();
  },
  _byKeyImpl(key, extraOptions) {
    const d = new Deferred();
    if (this._byKeyViaLoad()) {
      this._requireKey();
      runRawLoadWithKey(d, this, key);
    } else {
      invokeUserByKeyFunc(this, key, extraOptions).done((obj) => {
        d.resolve(obj);
      }).fail(createUserFuncFailureHandler(d));
    }
    return d.promise();
  },
  _byKeyViaLoad() {
    return "raw" === this._loadMode && !this._byKeyFunc;
  },
  _insertImpl(values) {
    const that = this;
    const userFunc = that._insertFunc;
    let userResult;
    const d = new Deferred();
    ensureRequiredFuncOption(INSERT, userFunc);
    userResult = userFunc.apply(that, [values]);
    if (!isPromise2(userResult)) {
      userResult = trivialPromise2(userResult);
    }
    fromPromise(userResult).done((serverResponse) => {
      if (config_default2().useLegacyStoreResult) {
        d.resolve(values, serverResponse);
      } else {
        d.resolve(serverResponse || values, that.keyOf(serverResponse));
      }
    }).fail(createUserFuncFailureHandler(d));
    return d.promise();
  },
  _updateImpl(key, values) {
    const userFunc = this._updateFunc;
    let userResult;
    const d = new Deferred();
    ensureRequiredFuncOption(UPDATE, userFunc);
    userResult = userFunc.apply(this, [key, values]);
    if (!isPromise2(userResult)) {
      userResult = trivialPromise2(userResult);
    }
    fromPromise(userResult).done((serverResponse) => {
      if (config_default2().useLegacyStoreResult) {
        d.resolve(key, values);
      } else {
        d.resolve(serverResponse || values, key);
      }
    }).fail(createUserFuncFailureHandler(d));
    return d.promise();
  },
  _removeImpl(key) {
    const userFunc = this._removeFunc;
    let userResult;
    const d = new Deferred();
    ensureRequiredFuncOption(REMOVE, userFunc);
    userResult = userFunc.apply(this, [key]);
    if (!isPromise2(userResult)) {
      userResult = trivialPromise2();
    }
    fromPromise(userResult).done(() => {
      d.resolve(key);
    }).fail(createUserFuncFailureHandler(d));
    return d.promise();
  }
});
var m_custom_store_default = CustomStore;

// node_modules/devextreme/esm/common/data/query_adapters.js
var query_adapters_default = {};

// node_modules/devextreme/esm/__internal/data/m_remote_query.js
var remoteQueryImpl = function(url, queryOptions, tasks) {
  tasks = tasks || [];
  queryOptions = queryOptions || {};
  const createTask = function(name2, args) {
    return {
      name: name2,
      args
    };
  };
  const exec = function(executorTask) {
    const d = new Deferred();
    let _adapterFactory;
    let _adapter;
    let _taskQueue;
    let _currentTask;
    let _mergedSortArgs;
    const rejectWithNotify = function(error2) {
      const handler = queryOptions.errorHandler;
      if (handler) {
        handler(error2);
      }
      handleError(error2);
      d.reject(error2);
    };
    function mergeSortTask(task) {
      switch (task.name) {
        case "sortBy":
          _mergedSortArgs = [task.args];
          return true;
        case "thenBy":
          if (!_mergedSortArgs) {
            throw errors.Error("E4004");
          }
          _mergedSortArgs.push(task.args);
          return true;
      }
      return false;
    }
    try {
      _adapterFactory = queryOptions.adapter;
      if (!isFunction(_adapterFactory)) {
        _adapterFactory = query_adapters_default[_adapterFactory];
      }
      _adapter = _adapterFactory(queryOptions);
      _taskQueue = [].concat(tasks).concat(executorTask);
      const {
        optimize
      } = _adapter;
      if (optimize) {
        optimize(_taskQueue);
      }
      while (_taskQueue.length) {
        _currentTask = _taskQueue[0];
        if (!mergeSortTask(_currentTask)) {
          if (_mergedSortArgs) {
            _taskQueue.unshift(createTask("multiSort", [_mergedSortArgs]));
            _mergedSortArgs = null;
            continue;
          }
          if ("enumerate" !== String(_currentTask.name)) {
            if (!_adapter[_currentTask.name] || false === _adapter[_currentTask.name].apply(_adapter, _currentTask.args)) {
              break;
            }
          }
        }
        _taskQueue.shift();
      }
      !function() {
        const head = _taskQueue[0];
        const unmergedTasks = [];
        if (head && "multiSort" === head.name) {
          _taskQueue.shift();
          each(head.args[0], function() {
            unmergedTasks.push(createTask(unmergedTasks.length ? "thenBy" : "sortBy", this));
          });
        }
        _taskQueue = unmergedTasks.concat(_taskQueue);
      }();
      _adapter.exec(url).done((result2, extra) => {
        if (!_taskQueue.length) {
          d.resolve(result2, extra);
        } else {
          let clientChain = m_array_query_default(result2, {
            errorHandler: queryOptions.errorHandler
          });
          each(_taskQueue, function() {
            clientChain = clientChain[this.name].apply(clientChain, this.args);
          });
          clientChain.done(d.resolve).fail(d.reject);
        }
      }).fail(rejectWithNotify);
    } catch (x) {
      rejectWithNotify(x);
    }
    return d.promise();
  };
  const query2 = {};
  each(["sortBy", "thenBy", "filter", "slice", "select", "groupBy"], function() {
    const name2 = String(this);
    query2[name2] = function() {
      return remoteQueryImpl(url, queryOptions, tasks.concat(createTask(name2, arguments)));
    };
  });
  each(["count", "min", "max", "sum", "avg", "aggregate", "enumerate"], function() {
    const name2 = String(this);
    query2[name2] = function() {
      return exec.call(this, createTask(name2, arguments));
    };
  });
  return query2;
};
var m_remote_query_default = remoteQueryImpl;

// node_modules/devextreme/esm/common/data/query_implementation.js
var queryImpl = {
  array: m_array_query_default,
  remote: m_remote_query_default
};

// node_modules/devextreme/esm/__internal/data/m_query.js
var query = function() {
  const impl = Array.isArray(arguments[0]) ? "array" : "remote";
  return queryImpl[impl].apply(this, arguments);
};
var m_query_default = query;

// node_modules/devextreme/esm/__internal/data/m_array_store.js
var ArrayStore = m_abstract_store_default.inherit({
  ctor(options2) {
    if (Array.isArray(options2)) {
      options2 = {
        data: options2
      };
    } else {
      options2 = options2 || {};
    }
    this.callBase(options2);
    const initialArray = options2.data;
    if (initialArray && !Array.isArray(initialArray)) {
      throw errors.Error("E4006");
    }
    this._array = initialArray || [];
  },
  createQuery() {
    return m_query_default(this._array, {
      errorHandler: this._errorHandler
    });
  },
  _byKeyImpl(key) {
    const index2 = indexByKey(this, this._array, key);
    if (-1 === index2) {
      return rejectedPromise(errors.Error("E4009"));
    }
    return trivialPromise(this._array[index2]);
  },
  _insertImpl(values) {
    return insert(this, this._array, values);
  },
  _pushImpl(changes) {
    applyBatch({
      keyInfo: this,
      data: this._array,
      changes
    });
  },
  _updateImpl(key, values) {
    return update(this, this._array, key, values);
  },
  _removeImpl(key) {
    return remove(this, this._array, key);
  },
  clear() {
    this._eventsStrategy.fireEvent("modifying");
    this._array = [];
    this._eventsStrategy.fireEvent("modified");
  }
}, "array");
var m_array_store_default = ArrayStore;

// node_modules/devextreme/esm/__internal/core/m_http_request.js
var window12 = getWindow();
var nativeXMLHttpRequest = {
  getXhr: () => new window12.XMLHttpRequest()
};
var httpRequest = dependency_injector_default(nativeXMLHttpRequest);

// node_modules/devextreme/esm/core/http_request.js
var http_request_default = httpRequest;

// node_modules/devextreme/esm/__internal/core/utils/m_ajax_utils.js
var window13 = getWindow();
var createScript = function(options2) {
  const script = dom_adapter_default.createElement("script");
  for (const name2 in options2) {
    script[name2] = options2[name2];
  }
  return script;
};
var appendToHead = function(element) {
  return dom_adapter_default.getHead().appendChild(element);
};
var removeScript = function(scriptNode) {
  scriptNode.parentNode.removeChild(scriptNode);
};
var evalScript = function(code) {
  const script = createScript({
    text: code
  });
  appendToHead(script);
  removeScript(script);
};
var evalCrossDomainScript = function(url) {
  const script = createScript({
    src: url
  });
  return new Promise((resolve, reject) => {
    const events = {
      load: resolve,
      error: reject
    };
    const loadHandler = function(e) {
      events[e.type]();
      removeScript(script);
    };
    for (const event in events) {
      dom_adapter_default.listen(script, event, loadHandler);
    }
    appendToHead(script);
  });
};
function getMethod(options2) {
  return (options2.method || "GET").toUpperCase();
}
var paramsConvert = function(params) {
  const result2 = [];
  for (const name2 in params) {
    let value2 = params[name2];
    if (void 0 === value2) {
      continue;
    }
    if (null === value2) {
      value2 = "";
    }
    if ("function" === typeof value2) {
      value2 = value2();
    }
    result2.push(`${encodeURIComponent(name2)}=${encodeURIComponent(value2)}`);
  }
  return result2.join("&");
};
var getContentTypeHeader = function(options2) {
  let defaultContentType;
  if (options2.data && !options2.upload && "GET" !== getMethod(options2)) {
    defaultContentType = "application/x-www-form-urlencoded;charset=utf-8";
  }
  return options2.contentType || defaultContentType;
};
var getAcceptHeader = function(options2) {
  const dataType = options2.dataType || "*";
  const scriptAccept = "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript";
  const accepts = {
    "*": "*/*",
    text: "text/plain",
    html: "text/html",
    xml: "application/xml, text/xml",
    json: "application/json, text/javascript",
    jsonp: scriptAccept,
    script: scriptAccept
  };
  extendFromObject(accepts, options2.accepts, true);
  return accepts[dataType] ? accepts[dataType] + ("*" !== dataType ? ", */*; q=0.01" : "") : accepts["*"];
};
var getRequestHeaders = function(options2) {
  const headers = options2.headers || {};
  headers["Content-Type"] = headers["Content-Type"] || getContentTypeHeader(options2);
  headers.Accept = headers.Accept || getAcceptHeader(options2);
  if (!options2.crossDomain && !headers["X-Requested-With"]) {
    headers["X-Requested-With"] = "XMLHttpRequest";
  }
  return headers;
};
var getJsonpOptions = function(options2) {
  if ("jsonp" === options2.dataType) {
    const random = Math.random().toString().replace(/\D/g, "");
    const callbackName = options2.jsonpCallback || `dxCallback${Date.now()}_${random}`;
    const callbackParameter = options2.jsonp || "callback";
    options2.data = options2.data || {};
    options2.data[callbackParameter] = callbackName;
    return callbackName;
  }
};
var getRequestOptions = function(options2, headers) {
  let params = options2.data;
  const paramsAlreadyString = "string" === typeof params;
  let url = options2.url || window13.location.href;
  if (!paramsAlreadyString && !options2.cache) {
    params = params || {};
    params._ = Date.now();
  }
  if (params && !options2.upload) {
    if (!paramsAlreadyString) {
      params = paramsConvert(params);
    }
    if ("GET" === getMethod(options2)) {
      if ("" !== params) {
        url += (url.indexOf("?") > -1 ? "&" : "?") + params;
      }
      params = null;
    } else if (headers["Content-Type"] && headers["Content-Type"].indexOf("application/x-www-form-urlencoded") > -1) {
      params = params.replace(/%20/g, "+");
    }
  }
  return {
    url,
    parameters: params
  };
};
var isCrossDomain = function(url) {
  if (!hasWindow()) {
    return true;
  }
  let crossDomain = false;
  const originAnchor = dom_adapter_default.createElement("a");
  const urlAnchor = dom_adapter_default.createElement("a");
  originAnchor.href = window13.location.href;
  try {
    urlAnchor.href = url;
    urlAnchor.href = urlAnchor.href;
    crossDomain = `${originAnchor.protocol}//${originAnchor.host}` !== `${urlAnchor.protocol}//${urlAnchor.host}`;
  } catch (e) {
    crossDomain = true;
  }
  return crossDomain;
};

// node_modules/devextreme/esm/__internal/core/utils/m_ajax.js
var window14 = getWindow();
var SUCCESS = "success";
var ERROR = "error";
var TIMEOUT = "timeout";
var NO_CONTENT = "nocontent";
var PARSER_ERROR = "parsererror";
var isStatusSuccess = function(status) {
  return status >= 200 && status < 300;
};
var hasContent = function(status) {
  return 204 !== status;
};
var getDataFromResponse = function(xhr) {
  return xhr.responseType && "text" !== xhr.responseType || "string" !== typeof xhr.responseText ? xhr.response : xhr.responseText;
};
var postProcess = function(deferred, xhr, dataType) {
  const data17 = getDataFromResponse(xhr);
  switch (dataType) {
    case "jsonp":
      evalScript(data17);
      break;
    case "script":
      evalScript(data17);
      deferred.resolve(data17, SUCCESS, xhr);
      break;
    case "json":
      try {
        deferred.resolve(JSON.parse(data17), SUCCESS, xhr);
      } catch (e) {
        deferred.reject(xhr, PARSER_ERROR, e);
      }
      break;
    default:
      deferred.resolve(data17, SUCCESS, xhr);
  }
};
var setHttpTimeout = function(timeout, xhr) {
  return timeout && setTimeout(function() {
    xhr.customStatus = TIMEOUT;
    xhr.abort();
  }, timeout);
};
var sendRequest = function(options2) {
  const xhr = http_request_default.getXhr();
  const d = new Deferred();
  const result2 = d.promise();
  const async = isDefined(options2.async) ? options2.async : true;
  const {
    dataType
  } = options2;
  const timeout = options2.timeout || 0;
  let timeoutId;
  options2.crossDomain = isCrossDomain(options2.url);
  const needScriptEvaluation = "jsonp" === dataType || "script" === dataType;
  if (void 0 === options2.cache) {
    options2.cache = !needScriptEvaluation;
  }
  const callbackName = getJsonpOptions(options2);
  const headers = getRequestHeaders(options2);
  const requestOptions = getRequestOptions(options2, headers);
  const {
    url
  } = requestOptions;
  const {
    parameters
  } = requestOptions;
  if (callbackName) {
    window14[callbackName] = function(data17) {
      d.resolve(data17, SUCCESS, xhr);
    };
  }
  if (options2.crossDomain && needScriptEvaluation) {
    const reject = function() {
      d.reject(xhr, ERROR);
    };
    const resolve = function() {
      if ("jsonp" === dataType) {
        return;
      }
      d.resolve(null, SUCCESS, xhr);
    };
    evalCrossDomainScript(url).then(resolve, reject);
    return result2;
  }
  if (options2.crossDomain && !("withCredentials" in xhr)) {
    d.reject(xhr, ERROR);
    return result2;
  }
  xhr.open(getMethod(options2), url, async, options2.username, options2.password);
  if (async) {
    xhr.timeout = timeout;
    timeoutId = setHttpTimeout(timeout, xhr);
  }
  xhr.onreadystatechange = function(e) {
    if (4 === xhr.readyState) {
      clearTimeout(timeoutId);
      if (isStatusSuccess(xhr.status)) {
        if (hasContent(xhr.status)) {
          postProcess(d, xhr, dataType);
        } else {
          d.resolve(null, NO_CONTENT, xhr);
        }
      } else {
        d.reject(xhr, xhr.customStatus || ERROR);
      }
    }
  };
  if (options2.upload) {
    xhr.upload.onprogress = options2.upload.onprogress;
    xhr.upload.onloadstart = options2.upload.onloadstart;
    xhr.upload.onabort = options2.upload.onabort;
  }
  if (options2.xhrFields) {
    for (const field in options2.xhrFields) {
      xhr[field] = options2.xhrFields[field];
    }
  }
  if ("arraybuffer" === options2.responseType) {
    xhr.responseType = options2.responseType;
  }
  for (const name2 in headers) {
    if (Object.prototype.hasOwnProperty.call(headers, name2) && isDefined(headers[name2])) {
      xhr.setRequestHeader(name2, headers[name2]);
    }
  }
  if (options2.beforeSend) {
    options2.beforeSend(xhr);
  }
  xhr.send(parameters);
  result2.abort = function() {
    xhr.abort();
  };
  return result2;
};
var Ajax = dependency_injector_default({
  sendRequest
});

// node_modules/devextreme/esm/core/utils/ajax.js
var ajax_default = Ajax;

// node_modules/devextreme/esm/__internal/data/data_source/m_utils.js
var _excluded2 = ["items"];
var CANCELED_TOKEN = "canceled";
var isPending = (deferred) => "pending" === deferred.state();
var normalizeStoreLoadOptionAccessorArguments = (originalArguments) => {
  switch (originalArguments.length) {
    case 0:
      return;
    case 1:
      return originalArguments[0];
  }
  return [].slice.call(originalArguments);
};
var mapGroup = (group, level, mapper) => map(group, (item) => {
  const restItem = _objectWithoutPropertiesLoose(item, _excluded2);
  return _extends({}, restItem, {
    items: mapRecursive(item.items, level - 1, mapper)
  });
});
var mapRecursive = (items, level, mapper) => {
  if (!Array.isArray(items)) {
    return items;
  }
  return level ? mapGroup(items, level, mapper) : map(items, mapper);
};
var mapDataRespectingGrouping = (items, mapper, groupInfo) => {
  const level = groupInfo ? normalizeSortingInfo(groupInfo).length : 0;
  return mapRecursive(items, level, mapper);
};
var normalizeLoadResult = (data17, extra) => {
  var _data;
  if (null !== (_data = data17) && void 0 !== _data && _data.data) {
    extra = data17;
    data17 = data17.data;
  }
  if (!Array.isArray(data17)) {
    data17 = [data17];
  }
  return {
    data: data17,
    extra
  };
};
var createCustomStoreFromLoadFunc = (options2) => {
  const storeConfig = {};
  each(["useDefaultSearch", "key", "load", "loadMode", "cacheRawData", "byKey", "lookup", "totalCount", "insert", "update", "remove"], function() {
    storeConfig[this] = options2[this];
    delete options2[this];
  });
  return new m_custom_store_default(storeConfig);
};
var createStoreFromConfig = (storeConfig) => {
  const alias = storeConfig.type;
  delete storeConfig.type;
  return m_abstract_store_default.create(alias, storeConfig);
};
var createCustomStoreFromUrl = (url, normalizationOptions) => new m_custom_store_default({
  load: () => ajax_default.sendRequest({
    url,
    dataType: "json"
  }),
  loadMode: null === normalizationOptions || void 0 === normalizationOptions ? void 0 : normalizationOptions.fromUrlLoadMode
});
var normalizeDataSourceOptions = (options2, normalizationOptions) => {
  let store;
  if ("string" === typeof options2) {
    options2 = {
      paginate: false,
      store: createCustomStoreFromUrl(options2, normalizationOptions)
    };
  }
  if (void 0 === options2) {
    options2 = [];
  }
  if (Array.isArray(options2) || options2 instanceof m_abstract_store_default) {
    options2 = {
      store: options2
    };
  } else {
    options2 = extend({}, options2);
  }
  if (void 0 === options2.store) {
    options2.store = [];
  }
  store = options2.store;
  if ("load" in options2) {
    store = createCustomStoreFromLoadFunc(options2);
  } else if (Array.isArray(store)) {
    store = new m_array_store_default(store);
  } else if (isPlainObject(store)) {
    store = createStoreFromConfig(extend({}, store));
  }
  options2.store = store;
  return options2;
};

// node_modules/devextreme/esm/__internal/data/data_source/m_operation_manager.js
var OperationManager = class {
  constructor() {
    this._counter = -1;
    this._deferreds = {};
  }
  add(deferred) {
    this._counter++;
    this._deferreds[this._counter] = deferred;
    return this._counter;
  }
  remove(operationId) {
    return delete this._deferreds[operationId];
  }
  cancel(operationId) {
    if (operationId in this._deferreds) {
      this._deferreds[operationId].reject(CANCELED_TOKEN);
      return true;
    }
    return false;
  }
  cancelAll() {
    while (this._counter > -1) {
      this.cancel(this._counter);
      this._counter--;
    }
  }
};

// node_modules/devextreme/esm/__internal/core/utils/m_queue.js
function createQueue2(discardPendingTasks) {
  let _tasks = [];
  let _busy = false;
  function exec() {
    while (_tasks.length) {
      _busy = true;
      const task = _tasks.shift();
      const result2 = task();
      if (void 0 === result2) {
        continue;
      }
      if (result2.then) {
        when(result2).always(exec);
        return;
      }
      throw errors_default.Error("E0015");
    }
    _busy = false;
  }
  return {
    add: function(task, removeTaskCallback) {
      if (!discardPendingTasks) {
        _tasks.push(task);
      } else {
        if (_tasks[0] && removeTaskCallback) {
          removeTaskCallback(_tasks[0]);
        }
        _tasks = [task];
      }
      if (!_busy) {
        exec();
      }
    },
    busy: function() {
      return _busy;
    }
  };
}
var enqueue = createQueue2().add;

// node_modules/devextreme/esm/__internal/data/data_source/m_data_source.js
var DataSource = class_default.inherit({
  ctor(options2) {
    options2 = normalizeDataSourceOptions(options2);
    this._eventsStrategy = new EventsStrategy(this, {
      syncStrategy: true
    });
    this._store = options2.store;
    this._changedTime = 0;
    const needThrottling = 0 !== options2.pushAggregationTimeout;
    if (needThrottling) {
      const throttlingTimeout = void 0 === options2.pushAggregationTimeout ? () => 5 * this._changedTime : options2.pushAggregationTimeout;
      let pushDeferred;
      let lastPushWaiters;
      const throttlingPushHandler = throttleChanges((changes) => {
        pushDeferred.resolve();
        const storePushPending = when(...lastPushWaiters);
        storePushPending.done(() => this._onPush(changes));
        lastPushWaiters = void 0;
        pushDeferred = void 0;
      }, throttlingTimeout);
      this._onPushHandler = (args) => {
        this._aggregationTimeoutId = throttlingPushHandler(args.changes);
        if (!pushDeferred) {
          pushDeferred = new Deferred();
        }
        lastPushWaiters = args.waitFor;
        args.waitFor.push(pushDeferred.promise());
      };
      this._store.on("beforePushAggregation", this._onPushHandler);
    } else {
      this._onPushHandler = (changes) => this._onPush(changes);
      this._store.on("push", this._onPushHandler);
    }
    this._storeLoadOptions = this._extractLoadOptions(options2);
    this._mapFunc = options2.map;
    this._postProcessFunc = options2.postProcess;
    this._pageIndex = void 0 !== options2.pageIndex ? options2.pageIndex : 0;
    this._pageSize = void 0 !== options2.pageSize ? options2.pageSize : 20;
    this._loadingCount = 0;
    this._loadQueue = this._createLoadQueue();
    this._searchValue = "searchValue" in options2 ? options2.searchValue : null;
    this._searchOperation = options2.searchOperation || "contains";
    this._searchExpr = options2.searchExpr;
    this._paginate = options2.paginate;
    this._reshapeOnPush = options2.reshapeOnPush ?? false;
    each(["onChanged", "onLoadError", "onLoadingChanged", "onCustomizeLoadResult", "onCustomizeStoreLoadOptions"], (_, optionName) => {
      if (optionName in options2) {
        this.on(optionName.substr(2, 1).toLowerCase() + optionName.substr(3), options2[optionName]);
      }
    });
    this._operationManager = new OperationManager();
    this._init();
  },
  _init() {
    this._items = [];
    this._userData = {};
    this._totalCount = -1;
    this._isLoaded = false;
    if (!isDefined(this._paginate)) {
      this._paginate = !this.group();
    }
    this._isLastPage = !this._paginate;
  },
  dispose() {
    var _this$_delayedLoadTas;
    this._store.off("beforePushAggregation", this._onPushHandler);
    this._store.off("push", this._onPushHandler);
    this._eventsStrategy.dispose();
    clearTimeout(this._aggregationTimeoutId);
    null === (_this$_delayedLoadTas = this._delayedLoadTask) || void 0 === _this$_delayedLoadTas || _this$_delayedLoadTas.abort();
    this._operationManager.cancelAll();
    delete this._store;
    delete this._items;
    delete this._delayedLoadTask;
    this._disposed = true;
  },
  _extractLoadOptions(options2) {
    const result2 = {};
    let names = ["sort", "filter", "langParams", "select", "group", "requireTotalCount"];
    const customNames = this._store._customLoadOptions();
    if (customNames) {
      names = names.concat(customNames);
    }
    each(names, function() {
      result2[this] = options2[this];
    });
    return result2;
  },
  loadOptions() {
    return this._storeLoadOptions;
  },
  items() {
    return this._items;
  },
  pageIndex(newIndex) {
    if (!isNumeric(newIndex)) {
      return this._pageIndex;
    }
    this._pageIndex = newIndex;
    this._isLastPage = !this._paginate;
  },
  paginate(value2) {
    if (!isBoolean(value2)) {
      return this._paginate;
    }
    if (this._paginate !== value2) {
      this._paginate = value2;
      this.pageIndex(0);
    }
  },
  pageSize(value2) {
    if (!isNumeric(value2)) {
      return this._pageSize;
    }
    this._pageSize = value2;
  },
  isLastPage() {
    return this._isLastPage;
  },
  generateStoreLoadOptionAccessor(optionName) {
    return (args) => {
      const normalizedArgs = normalizeStoreLoadOptionAccessorArguments(args);
      if (void 0 === normalizedArgs) {
        return this._storeLoadOptions[optionName];
      }
      this._storeLoadOptions[optionName] = normalizedArgs;
    };
  },
  sort() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return this.generateStoreLoadOptionAccessor("sort")(args);
  },
  filter() {
    const newFilter = normalizeStoreLoadOptionAccessorArguments(arguments);
    if (void 0 === newFilter) {
      return this._storeLoadOptions.filter;
    }
    this._storeLoadOptions.filter = newFilter;
    this.pageIndex(0);
  },
  group() {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    return this.generateStoreLoadOptionAccessor("group")(args);
  },
  select() {
    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      args[_key3] = arguments[_key3];
    }
    return this.generateStoreLoadOptionAccessor("select")(args);
  },
  requireTotalCount(value2) {
    if (!isBoolean(value2)) {
      return this._storeLoadOptions.requireTotalCount;
    }
    this._storeLoadOptions.requireTotalCount = value2;
  },
  searchValue(value2) {
    if (arguments.length < 1) {
      return this._searchValue;
    }
    this._searchValue = value2;
    this.pageIndex(0);
  },
  searchOperation(op) {
    if (!isString(op)) {
      return this._searchOperation;
    }
    this._searchOperation = op;
    this.pageIndex(0);
  },
  searchExpr(expr) {
    const argc = arguments.length;
    if (0 === argc) {
      return this._searchExpr;
    }
    if (argc > 1) {
      expr = [].slice.call(arguments);
    }
    this._searchExpr = expr;
    this.pageIndex(0);
  },
  store() {
    return this._store;
  },
  key() {
    var _this$_store;
    return null === (_this$_store = this._store) || void 0 === _this$_store ? void 0 : _this$_store.key();
  },
  totalCount() {
    return this._totalCount;
  },
  isLoaded() {
    return this._isLoaded;
  },
  isLoading() {
    return this._loadingCount > 0;
  },
  beginLoading() {
    this._changeLoadingCount(1);
  },
  endLoading() {
    this._changeLoadingCount(-1);
  },
  _createLoadQueue: () => createQueue2(),
  _changeLoadingCount(increment) {
    const oldLoading = this.isLoading();
    this._loadingCount += increment;
    const newLoading = this.isLoading();
    if (oldLoading ^ newLoading) {
      this._eventsStrategy.fireEvent("loadingChanged", [newLoading]);
    }
  },
  _scheduleLoadCallbacks(deferred) {
    this.beginLoading();
    deferred.always(() => {
      this.endLoading();
    });
  },
  _scheduleFailCallbacks(deferred) {
    var _this = this;
    deferred.fail(function() {
      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        args[_key4] = arguments[_key4];
      }
      if (args[0] === CANCELED_TOKEN) {
        return;
      }
      _this._eventsStrategy.fireEvent("loadError", args);
    });
  },
  _fireChanged(args) {
    const date = /* @__PURE__ */ new Date();
    this._eventsStrategy.fireEvent("changed", args);
    this._changedTime = /* @__PURE__ */ new Date() - date;
  },
  _scheduleChangedCallbacks(deferred) {
    deferred.done(() => this._fireChanged());
  },
  loadSingle(propName, propValue) {
    const d = new Deferred();
    const key = this.key();
    const store = this._store;
    const options2 = this._createStoreLoadOptions();
    this._scheduleFailCallbacks(d);
    if (arguments.length < 2) {
      propValue = propName;
      propName = key;
    }
    delete options2.skip;
    delete options2.group;
    delete options2.refresh;
    delete options2.pageIndex;
    delete options2.searchString;
    (() => {
      if (propName === key || store instanceof m_custom_store_default && !store._byKeyViaLoad()) {
        return store.byKey(propValue, options2);
      }
      options2.take = 1;
      options2.filter = options2.filter ? [options2.filter, [propName, propValue]] : [propName, propValue];
      return store.load(options2);
    })().fail(d.reject).done((data17) => {
      const isEmptyArray = Array.isArray(data17) && !data17.length;
      if (!isDefined(data17) || isEmptyArray) {
        d.reject(errors.Error("E4009"));
      } else {
        if (!Array.isArray(data17)) {
          data17 = [data17];
        }
        d.resolve(this._applyMapFunction(data17)[0]);
      }
    });
    return d.promise();
  },
  load() {
    const d = new Deferred();
    const loadTask = () => {
      if (this._disposed) {
        return;
      }
      if (!isPending(d)) {
        return;
      }
      return this._loadFromStore(loadOperation, d);
    };
    this._scheduleLoadCallbacks(d);
    this._scheduleFailCallbacks(d);
    this._scheduleChangedCallbacks(d);
    const loadOperation = this._createLoadOperation(d);
    this._eventsStrategy.fireEvent("customizeStoreLoadOptions", [loadOperation]);
    this._loadQueue.add(() => {
      if ("number" === typeof loadOperation.delay) {
        this._delayedLoadTask = m_common_default.executeAsync(loadTask, loadOperation.delay);
      } else {
        loadTask();
      }
      return d.promise();
    });
    return d.promise({
      operationId: loadOperation.operationId
    });
  },
  _onPush(changes) {
    if (this._reshapeOnPush) {
      this.load();
    } else {
      const changingArgs = {
        changes
      };
      this._eventsStrategy.fireEvent("changing", [changingArgs]);
      const group = this.group();
      const items = this.items();
      let groupLevel = 0;
      let dataSourceChanges = this.paginate() || group ? changes.filter((item) => "update" === item.type) : changes;
      if (group) {
        groupLevel = Array.isArray(group) ? group.length : 1;
      }
      if (this._mapFunc) {
        dataSourceChanges.forEach((item) => {
          if ("insert" === item.type) {
            item.data = this._mapFunc(item.data);
          }
        });
      }
      if (changingArgs.postProcessChanges) {
        dataSourceChanges = changingArgs.postProcessChanges(dataSourceChanges);
      }
      applyBatch({
        keyInfo: this.store(),
        data: items,
        changes: dataSourceChanges,
        groupCount: groupLevel,
        useInsertIndex: true
      });
      this._fireChanged([{
        changes
      }]);
    }
  },
  _createLoadOperation(deferred) {
    const operationId = this._operationManager.add(deferred);
    const storeLoadOptions = this._createStoreLoadOptions();
    if (this._store && !isEmptyObject(null === storeLoadOptions || void 0 === storeLoadOptions ? void 0 : storeLoadOptions.langParams)) {
      this._store._langParams = _extends({}, this._store._langParams, storeLoadOptions.langParams);
    }
    deferred.always(() => this._operationManager.remove(operationId));
    return {
      operationId,
      storeLoadOptions
    };
  },
  reload() {
    const store = this.store();
    store._clearCache();
    this._init();
    return this.load();
  },
  cancel(operationId) {
    return this._operationManager.cancel(operationId);
  },
  cancelAll() {
    return this._operationManager.cancelAll();
  },
  _addSearchOptions(storeLoadOptions) {
    if (this._disposed) {
      return;
    }
    if (this.store()._useDefaultSearch) {
      this._addSearchFilter(storeLoadOptions);
    } else {
      storeLoadOptions.searchOperation = this._searchOperation;
      storeLoadOptions.searchValue = this._searchValue;
      storeLoadOptions.searchExpr = this._searchExpr;
    }
  },
  _createStoreLoadOptions() {
    const result2 = extend({}, this._storeLoadOptions);
    this._addSearchOptions(result2);
    if (this._paginate) {
      if (this._pageSize) {
        result2.skip = this._pageIndex * this._pageSize;
        result2.take = this._pageSize;
      }
    }
    result2.userData = this._userData;
    return result2;
  },
  _addSearchFilter(storeLoadOptions) {
    const value2 = this._searchValue;
    const op = this._searchOperation;
    let selector = this._searchExpr;
    const searchFilter = [];
    if (!value2) {
      return;
    }
    if (!selector) {
      selector = "this";
    }
    if (!Array.isArray(selector)) {
      selector = [selector];
    }
    each(selector, (i, item) => {
      if (searchFilter.length) {
        searchFilter.push("or");
      }
      searchFilter.push([item, op, value2]);
    });
    if (storeLoadOptions.filter) {
      storeLoadOptions.filter = [searchFilter, storeLoadOptions.filter];
    } else {
      storeLoadOptions.filter = searchFilter;
    }
  },
  _loadFromStore(loadOptions, pendingDeferred) {
    const handleSuccess = (data17, extra) => {
      if (this._disposed) {
        return;
      }
      if (!isPending(pendingDeferred)) {
        return;
      }
      const loadResult = extend(normalizeLoadResult(data17, extra), loadOptions);
      this._eventsStrategy.fireEvent("customizeLoadResult", [loadResult]);
      when(loadResult.data).done((data18) => {
        loadResult.data = data18;
        this._processStoreLoadResult(loadResult, pendingDeferred);
      }).fail(pendingDeferred.reject);
    };
    if (loadOptions.data) {
      return new Deferred().resolve(loadOptions.data).done(handleSuccess);
    }
    return this.store().load(loadOptions.storeLoadOptions).done(handleSuccess).fail(pendingDeferred.reject);
  },
  _processStoreLoadResult(loadResult, pendingDeferred) {
    let {
      data: data17
    } = loadResult;
    let {
      extra
    } = loadResult;
    const {
      storeLoadOptions
    } = loadResult;
    const resolvePendingDeferred = () => {
      this._isLoaded = true;
      this._totalCount = isFinite(extra.totalCount) ? extra.totalCount : -1;
      return pendingDeferred.resolve(data17, extra);
    };
    const proceedLoadingTotalCount = () => {
      this.store().totalCount(storeLoadOptions).done((count) => {
        extra.totalCount = count;
        resolvePendingDeferred();
      }).fail(pendingDeferred.reject);
    };
    if (this._disposed) {
      return;
    }
    data17 = this._applyPostProcessFunction(this._applyMapFunction(data17));
    if (!isObject(extra)) {
      extra = {};
    }
    this._items = data17;
    if (!data17.length || !this._paginate || this._pageSize && data17.length < this._pageSize) {
      this._isLastPage = true;
    }
    if (storeLoadOptions.requireTotalCount && !isFinite(extra.totalCount)) {
      proceedLoadingTotalCount();
    } else {
      resolvePendingDeferred();
    }
  },
  _applyMapFunction(data17) {
    if (this._mapFunc) {
      return mapDataRespectingGrouping(data17, this._mapFunc, this.group());
    }
    return data17;
  },
  _applyPostProcessFunction(data17) {
    if (this._postProcessFunc) {
      return this._postProcessFunc(data17);
    }
    return data17;
  },
  on(eventName, eventHandler) {
    this._eventsStrategy.on(eventName, eventHandler);
    return this;
  },
  off(eventName, eventHandler) {
    this._eventsStrategy.off(eventName, eventHandler);
    return this;
  }
});

// node_modules/devextreme/esm/common/data/data_source.js
var data_source_default = DataSource;

// node_modules/devextreme/esm/common/core/localization/utils.js
function roundByAbs(value2) {
  const valueSign = sign(value2);
  return valueSign * Math.round(Math.abs(value2));
}
function adjustValue(value2, precision) {
  const precisionMultiplier = Math.pow(10, precision);
  const intermediateValue = multiplyInExponentialForm(value2, precision);
  return roundByAbs(intermediateValue) / precisionMultiplier;
}
function toFixed(value2, precision) {
  const valuePrecision = precision || 0;
  const adjustedValue = valuePrecision > 0 ? adjustValue(...arguments) : value2;
  return adjustedValue.toFixed(valuePrecision);
}

// node_modules/devextreme/esm/common/core/localization/ldml/number.js
var DEFAULT_CONFIG = {
  thousandsSeparator: ",",
  decimalSeparator: "."
};
function getGroupSizes(formatString) {
  return formatString.split(",").slice(1).map(function(str) {
    let singleQuotesLeft = 0;
    return str.split("").filter(function(char, index2) {
      singleQuotesLeft += "'" === char;
      const isDigit = "#" === char || "0" === char;
      const isInStub = singleQuotesLeft % 2;
      return isDigit && !isInStub;
    }).length;
  });
}
function splitSignParts(format2) {
  let separatorChar = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : ";";
  let escapingChar = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "'";
  const parts = [];
  let currentPart = "";
  let state = "searchingSeparator";
  for (let i = 0; i < format2.length; i++) {
    const char = format2[i];
    if ("searchingSeparator" === state && char === escapingChar) {
      state = "skippingSeparationInsideEscaping";
    } else if ("skippingSeparationInsideEscaping" === state && char === escapingChar) {
      state = "searchingSeparator";
    } else if ("searchingSeparator" === state && char === separatorChar) {
      state = "separating";
      parts.push(currentPart);
      currentPart = "";
    }
    if ("separating" !== state) {
      currentPart += char;
    } else {
      state = "searchingSeparator";
    }
  }
  parts.push(currentPart);
  return parts;
}
function getSignParts(format2) {
  const signParts = splitSignParts(format2);
  if (1 === signParts.length) {
    signParts.push("-" + signParts[0]);
  }
  return signParts;
}
function reverseString(str) {
  return str.toString().split("").reverse().join("");
}
function isPercentFormat(format2) {
  return -1 !== format2.indexOf("%") && !format2.match(/'[^']*%[^']*'/g);
}
function removeStubs(str) {
  return str.replace(/'[^']*'/g, "");
}
function getNonRequiredDigitCount(floatFormat) {
  if (!floatFormat) {
    return 0;
  }
  const format2 = removeStubs(floatFormat);
  return format2.length - format2.replace(/[#]/g, "").length;
}
function getRequiredDigitCount(floatFormat) {
  if (!floatFormat) {
    return 0;
  }
  const format2 = removeStubs(floatFormat);
  return format2.length - format2.replace(/[0]/g, "").length;
}
function normalizeValueString(valuePart, minDigitCount, maxDigitCount) {
  if (!valuePart) {
    return "";
  }
  if (valuePart.length > maxDigitCount) {
    valuePart = valuePart.substr(0, maxDigitCount);
  }
  while (valuePart.length > minDigitCount && "0" === valuePart.slice(-1)) {
    valuePart = valuePart.substr(0, valuePart.length - 1);
  }
  while (valuePart.length < minDigitCount) {
    valuePart += "0";
  }
  return valuePart;
}
function applyGroups(valueString, groupSizes, thousandsSeparator) {
  if (!groupSizes.length) {
    return valueString;
  }
  const groups = [];
  let index2 = 0;
  while (valueString) {
    const groupSize = groupSizes[index2];
    if (!groupSize) {
      break;
    }
    groups.push(valueString.slice(0, groupSize));
    valueString = valueString.slice(groupSize);
    if (index2 < groupSizes.length - 1) {
      index2++;
    }
  }
  return groups.join(thousandsSeparator);
}
function formatNumberPart(format2, valueString) {
  return format2.split("'").map(function(formatPart, escapeIndex) {
    const isEscape = escapeIndex % 2;
    if (!formatPart && isEscape) {
      return "'";
    }
    return isEscape ? formatPart : formatPart.replace(/[,#0]+/, valueString);
  }).join("");
}
function getFloatPointIndex(format2) {
  let isEscape = false;
  for (let index2 = 0; index2 < format2.length; index2++) {
    if ("'" === format2[index2]) {
      isEscape = !isEscape;
    }
    if ("." === format2[index2] && !isEscape) {
      return index2;
    }
  }
  return format2.length;
}
function getFormatter2(format2, config3) {
  config3 = config3 || DEFAULT_CONFIG;
  return function(value2) {
    if ("number" !== typeof value2 || isNaN(value2)) {
      return "";
    }
    const signFormatParts = getSignParts(format2);
    const isPositiveZero = 1 / value2 === 1 / 0;
    const isPositive = value2 > 0 || isPositiveZero;
    const numberFormat = signFormatParts[isPositive ? 0 : 1];
    const floatPointIndex = getFloatPointIndex(numberFormat);
    const floatFormatParts = [numberFormat.substr(0, floatPointIndex), numberFormat.substr(floatPointIndex + 1)];
    const minFloatPrecision = getRequiredDigitCount(floatFormatParts[1]);
    const maxFloatPrecision = minFloatPrecision + getNonRequiredDigitCount(floatFormatParts[1]);
    if (isPercentFormat(numberFormat)) {
      value2 = multiplyInExponentialForm(value2, 2);
    }
    if (!isPositive) {
      value2 = -value2;
    }
    const minIntegerPrecision = getRequiredDigitCount(floatFormatParts[0]);
    const maxIntegerPrecision = getNonRequiredDigitCount(floatFormatParts[0]) || config3.unlimitedIntegerDigits ? void 0 : minIntegerPrecision;
    const integerLength = Math.floor(value2).toString().length;
    const floatPrecision = fitIntoRange(maxFloatPrecision, 0, 15 - integerLength);
    const groupSizes = getGroupSizes(floatFormatParts[0]).reverse();
    const valueParts = toFixed(value2, floatPrecision < 0 ? 0 : floatPrecision).split(".");
    let valueIntegerPart = normalizeValueString(reverseString(valueParts[0]), minIntegerPrecision, maxIntegerPrecision);
    const valueFloatPart = normalizeValueString(valueParts[1], minFloatPrecision, maxFloatPrecision);
    valueIntegerPart = applyGroups(valueIntegerPart, groupSizes, config3.thousandsSeparator);
    const integerString = reverseString(formatNumberPart(reverseString(floatFormatParts[0]), valueIntegerPart));
    const floatString = maxFloatPrecision ? formatNumberPart(floatFormatParts[1], valueFloatPart) : "";
    const result2 = integerString + (floatString.match(/\d/) ? config3.decimalSeparator : "") + floatString;
    return result2;
  };
}
function parseValue(text, isPercent, isNegative) {
  const value2 = (isPercent ? 0.01 : 1) * parseFloat(text) || 0;
  return isNegative ? -value2 : value2;
}
function prepareValueText(valueText, formatter, isPercent, isIntegerPart) {
  let nextValueText = valueText;
  let char;
  let text;
  let nextText;
  do {
    if (nextText) {
      char = text.length === nextText.length ? "0" : "1";
      valueText = isIntegerPart ? char + valueText : valueText + char;
    }
    text = nextText || formatter(parseValue(nextValueText, isPercent));
    nextValueText = isIntegerPart ? "1" + nextValueText : nextValueText + "1";
    nextText = formatter(parseValue(nextValueText, isPercent));
  } while (text !== nextText && (isIntegerPart ? text.length === nextText.length : text.length <= nextText.length));
  if (isIntegerPart && nextText.length > text.length) {
    const hasGroups = -1 === formatter(12345).indexOf("12345");
    do {
      valueText = "1" + valueText;
    } while (hasGroups && parseValue(valueText, isPercent) < 1e5);
  }
  return valueText;
}
function getFormatByValueText(valueText, formatter, isPercent, isNegative) {
  let format2 = formatter(parseValue(valueText, isPercent, isNegative));
  const valueTextParts = valueText.split(".");
  const valueTextWithModifiedFloat = valueTextParts[0] + ".3" + valueTextParts[1].slice(1);
  const valueWithModifiedFloat = parseValue(valueTextWithModifiedFloat, isPercent, isNegative);
  const decimalSeparatorIndex = formatter(valueWithModifiedFloat).indexOf("3") - 1;
  format2 = format2.replace(/(\d)\D(\d)/g, "$1,$2");
  if (decimalSeparatorIndex >= 0) {
    format2 = format2.slice(0, decimalSeparatorIndex) + "." + format2.slice(decimalSeparatorIndex + 1);
  }
  format2 = format2.replace(/1+/, "1").replace(/1/g, "#");
  if (!isPercent) {
    format2 = format2.replace(/%/g, "'%'");
  }
  return format2;
}
function getFormat(formatter) {
  let valueText = ".";
  const isPercent = formatter(1).indexOf("100") >= 0;
  valueText = prepareValueText(valueText, formatter, isPercent, true);
  valueText = prepareValueText(valueText, formatter, isPercent, false);
  const positiveFormat = getFormatByValueText(valueText, formatter, isPercent, false);
  const negativeFormat = getFormatByValueText(valueText, formatter, isPercent, true);
  return negativeFormat === "-" + positiveFormat ? positiveFormat : positiveFormat + ";" + negativeFormat;
}

// node_modules/devextreme/esm/common/core/localization/currency.js
var currency_default = {
  _formatNumberCore: function(value2, format2, formatConfig) {
    if ("currency" === format2) {
      formatConfig.precision = formatConfig.precision || 0;
      let result2 = this.format(value2, extend({}, formatConfig, {
        type: "fixedpoint"
      }));
      const currencyPart = this.getCurrencySymbol().symbol.replace(/\$/g, "$$$$");
      result2 = result2.replace(/^(\D*)(\d.*)/, "$1" + currencyPart + "$2");
      return result2;
    }
    return this.callBase.apply(this, arguments);
  },
  getCurrencySymbol: function() {
    return {
      symbol: "$"
    };
  },
  getOpenXmlCurrencyFormat: function() {
    return "$#,##0{0}_);\\($#,##0{0}\\)";
  }
};

// node_modules/devextreme/esm/common/core/localization/open_xml_currency_format.js
var open_xml_currency_format_default = (currencySymbol, accountingFormat) => {
  if (!accountingFormat) {
    return;
  }
  let encodedCurrencySymbol = currencySymbol;
  if ("string" === typeof currencySymbol) {
    encodedCurrencySymbol = "";
    for (let i = 0; i < currencySymbol.length; i++) {
      if ("$" !== currencySymbol[i]) {
        encodedCurrencySymbol += "\\";
      }
      encodedCurrencySymbol += currencySymbol[i];
    }
  }
  const encodeSymbols = {
    ".00": "{0}",
    "'": "\\'",
    "\\(": "\\(",
    "\\)": "\\)",
    " ": "\\ ",
    '"': "&quot;",
    "\\¤": encodedCurrencySymbol
  };
  const result2 = accountingFormat.split(";");
  for (let i = 0; i < result2.length; i++) {
    for (const symbol in encodeSymbols) {
      if (Object.prototype.hasOwnProperty.call(encodeSymbols, symbol)) {
        result2[i] = result2[i].replace(new RegExp(symbol, "g"), encodeSymbols[symbol]);
      }
    }
  }
  return 2 === result2.length ? result2[0] + "_);" + result2[1] : result2[0];
};

// node_modules/devextreme/esm/common/core/localization/cldr-data/accounting_formats.js
var accounting_formats_default = {
  af: "¤#,##0.00;(¤#,##0.00)",
  "af-NA": "¤#,##0.00;(¤#,##0.00)",
  agq: "#,##0.00¤",
  ak: "¤#,##0.00",
  am: "¤#,##0.00;(¤#,##0.00)",
  ar: "¤#,##0.00;(¤#,##0.00)",
  "ar-AE": "¤#,##0.00;(¤#,##0.00)",
  "ar-BH": "¤#,##0.00;(¤#,##0.00)",
  "ar-DJ": "¤#,##0.00;(¤#,##0.00)",
  "ar-DZ": "¤#,##0.00;(¤#,##0.00)",
  "ar-EG": "¤#,##0.00;(¤#,##0.00)",
  "ar-EH": "¤#,##0.00;(¤#,##0.00)",
  "ar-ER": "¤#,##0.00;(¤#,##0.00)",
  "ar-IL": "¤#,##0.00;(¤#,##0.00)",
  "ar-IQ": "¤#,##0.00;(¤#,##0.00)",
  "ar-JO": "¤#,##0.00;(¤#,##0.00)",
  "ar-KM": "¤#,##0.00;(¤#,##0.00)",
  "ar-KW": "¤#,##0.00;(¤#,##0.00)",
  "ar-LB": "¤#,##0.00;(¤#,##0.00)",
  "ar-LY": "¤#,##0.00;(¤#,##0.00)",
  "ar-MA": "¤#,##0.00;(¤#,##0.00)",
  "ar-MR": "¤#,##0.00;(¤#,##0.00)",
  "ar-OM": "¤#,##0.00;(¤#,##0.00)",
  "ar-PS": "¤#,##0.00;(¤#,##0.00)",
  "ar-QA": "¤#,##0.00;(¤#,##0.00)",
  "ar-SA": "¤#,##0.00;(¤#,##0.00)",
  "ar-SD": "¤#,##0.00;(¤#,##0.00)",
  "ar-SO": "¤#,##0.00;(¤#,##0.00)",
  "ar-SS": "¤#,##0.00;(¤#,##0.00)",
  "ar-SY": "¤#,##0.00;(¤#,##0.00)",
  "ar-TD": "¤#,##0.00;(¤#,##0.00)",
  "ar-TN": "¤#,##0.00;(¤#,##0.00)",
  "ar-YE": "¤#,##0.00;(¤#,##0.00)",
  as: "¤ #,##,##0.00",
  asa: "#,##0.00 ¤",
  ast: "#,##0.00 ¤",
  az: "#,##0.00 ¤",
  "az-Cyrl": "#,##0.00 ¤",
  "az-Latn": "#,##0.00 ¤",
  bas: "#,##0.00 ¤",
  be: "#,##0.00 ¤",
  "be-tarask": "#,##0.00 ¤",
  bem: "¤#,##0.00;(¤#,##0.00)",
  bez: "#,##0.00¤",
  bg: "0.00 ¤;(0.00 ¤)",
  bm: "¤#,##0.00;(¤#,##0.00)",
  bn: "#,##,##0.00¤;(#,##,##0.00¤)",
  "bn-IN": "#,##,##0.00¤;(#,##,##0.00¤)",
  bo: "¤ #,##0.00",
  "bo-IN": "¤ #,##0.00",
  br: "#,##0.00 ¤",
  brx: "¤ #,##,##0.00",
  bs: "#,##0.00 ¤",
  "bs-Cyrl": "#,##0.00 ¤",
  "bs-Latn": "#,##0.00 ¤",
  ca: "#,##0.00 ¤;(#,##0.00 ¤)",
  "ca-AD": "#,##0.00 ¤;(#,##0.00 ¤)",
  "ca-ES-valencia": "#,##0.00 ¤;(#,##0.00 ¤)",
  "ca-FR": "#,##0.00 ¤;(#,##0.00 ¤)",
  "ca-IT": "#,##0.00 ¤;(#,##0.00 ¤)",
  ccp: "#,##,##0.00¤;(#,##,##0.00¤)",
  "ccp-IN": "#,##,##0.00¤;(#,##,##0.00¤)",
  ce: "#,##0.00 ¤",
  ceb: "¤#,##0.00;(¤#,##0.00)",
  cgg: "¤#,##0.00",
  chr: "¤#,##0.00;(¤#,##0.00)",
  ckb: "¤ #,##0.00",
  "ckb-IR": "¤ #,##0.00",
  cs: "#,##0.00 ¤",
  cy: "¤#,##0.00;(¤#,##0.00)",
  da: "#,##0.00 ¤",
  "da-GL": "#,##0.00 ¤",
  dav: "¤#,##0.00;(¤#,##0.00)",
  de: "#,##0.00 ¤",
  "de-AT": "#,##0.00 ¤",
  "de-BE": "#,##0.00 ¤",
  "de-CH": "#,##0.00 ¤",
  "de-IT": "#,##0.00 ¤",
  "de-LI": "#,##0.00 ¤",
  "de-LU": "#,##0.00 ¤",
  dje: "#,##0.00¤",
  doi: "¤#,##0.00",
  dsb: "#,##0.00 ¤",
  dua: "#,##0.00 ¤",
  dyo: "#,##0.00 ¤",
  dz: "¤#,##,##0.00",
  ebu: "¤#,##0.00;(¤#,##0.00)",
  ee: "¤#,##0.00;(¤#,##0.00)",
  "ee-TG": "¤#,##0.00;(¤#,##0.00)",
  el: "#,##0.00 ¤",
  "el-CY": "#,##0.00 ¤",
  en: "¤#,##0.00;(¤#,##0.00)",
  "en-001": "¤#,##0.00;(¤#,##0.00)",
  "en-150": "#,##0.00 ¤",
  "en-AE": "¤#,##0.00;(¤#,##0.00)",
  "en-AG": "¤#,##0.00;(¤#,##0.00)",
  "en-AI": "¤#,##0.00;(¤#,##0.00)",
  "en-AS": "¤#,##0.00;(¤#,##0.00)",
  "en-AT": "¤ #,##0.00",
  "en-AU": "¤#,##0.00;(¤#,##0.00)",
  "en-BB": "¤#,##0.00;(¤#,##0.00)",
  "en-BE": "#,##0.00 ¤",
  "en-BI": "¤#,##0.00;(¤#,##0.00)",
  "en-BM": "¤#,##0.00;(¤#,##0.00)",
  "en-BS": "¤#,##0.00;(¤#,##0.00)",
  "en-BW": "¤#,##0.00;(¤#,##0.00)",
  "en-BZ": "¤#,##0.00;(¤#,##0.00)",
  "en-CA": "¤#,##0.00;(¤#,##0.00)",
  "en-CC": "¤#,##0.00;(¤#,##0.00)",
  "en-CH": "¤ #,##0.00;¤-#,##0.00",
  "en-CK": "¤#,##0.00;(¤#,##0.00)",
  "en-CM": "¤#,##0.00;(¤#,##0.00)",
  "en-CX": "¤#,##0.00;(¤#,##0.00)",
  "en-CY": "¤#,##0.00;(¤#,##0.00)",
  "en-DE": "#,##0.00 ¤",
  "en-DG": "¤#,##0.00;(¤#,##0.00)",
  "en-DK": "#,##0.00 ¤",
  "en-DM": "¤#,##0.00;(¤#,##0.00)",
  "en-ER": "¤#,##0.00;(¤#,##0.00)",
  "en-FI": "#,##0.00 ¤",
  "en-FJ": "¤#,##0.00;(¤#,##0.00)",
  "en-FK": "¤#,##0.00;(¤#,##0.00)",
  "en-FM": "¤#,##0.00;(¤#,##0.00)",
  "en-GB": "¤#,##0.00;(¤#,##0.00)",
  "en-GD": "¤#,##0.00;(¤#,##0.00)",
  "en-GG": "¤#,##0.00;(¤#,##0.00)",
  "en-GH": "¤#,##0.00;(¤#,##0.00)",
  "en-GI": "¤#,##0.00;(¤#,##0.00)",
  "en-GM": "¤#,##0.00;(¤#,##0.00)",
  "en-GU": "¤#,##0.00;(¤#,##0.00)",
  "en-GY": "¤#,##0.00;(¤#,##0.00)",
  "en-HK": "¤#,##0.00;(¤#,##0.00)",
  "en-IE": "¤#,##0.00;(¤#,##0.00)",
  "en-IL": "¤#,##0.00;(¤#,##0.00)",
  "en-IM": "¤#,##0.00;(¤#,##0.00)",
  "en-IN": "¤#,##0.00;(¤#,##0.00)",
  "en-IO": "¤#,##0.00;(¤#,##0.00)",
  "en-JE": "¤#,##0.00;(¤#,##0.00)",
  "en-JM": "¤#,##0.00;(¤#,##0.00)",
  "en-KE": "¤#,##0.00;(¤#,##0.00)",
  "en-KI": "¤#,##0.00;(¤#,##0.00)",
  "en-KN": "¤#,##0.00;(¤#,##0.00)",
  "en-KY": "¤#,##0.00;(¤#,##0.00)",
  "en-LC": "¤#,##0.00;(¤#,##0.00)",
  "en-LR": "¤#,##0.00;(¤#,##0.00)",
  "en-LS": "¤#,##0.00;(¤#,##0.00)",
  "en-MG": "¤#,##0.00;(¤#,##0.00)",
  "en-MH": "¤#,##0.00;(¤#,##0.00)",
  "en-MO": "¤#,##0.00;(¤#,##0.00)",
  "en-MP": "¤#,##0.00;(¤#,##0.00)",
  "en-MS": "¤#,##0.00;(¤#,##0.00)",
  "en-MT": "¤#,##0.00;(¤#,##0.00)",
  "en-MU": "¤#,##0.00;(¤#,##0.00)",
  "en-MV": "¤ #,##0.00",
  "en-MW": "¤#,##0.00;(¤#,##0.00)",
  "en-MY": "¤#,##0.00;(¤#,##0.00)",
  "en-NA": "¤#,##0.00;(¤#,##0.00)",
  "en-NF": "¤#,##0.00;(¤#,##0.00)",
  "en-NG": "¤#,##0.00;(¤#,##0.00)",
  "en-NL": "¤ #,##0.00;(¤ #,##0.00)",
  "en-NR": "¤#,##0.00;(¤#,##0.00)",
  "en-NU": "¤#,##0.00;(¤#,##0.00)",
  "en-NZ": "¤#,##0.00;(¤#,##0.00)",
  "en-PG": "¤#,##0.00;(¤#,##0.00)",
  "en-PH": "¤#,##0.00;(¤#,##0.00)",
  "en-PK": "¤#,##0.00;(¤#,##0.00)",
  "en-PN": "¤#,##0.00;(¤#,##0.00)",
  "en-PR": "¤#,##0.00;(¤#,##0.00)",
  "en-PW": "¤#,##0.00;(¤#,##0.00)",
  "en-RW": "¤#,##0.00;(¤#,##0.00)",
  "en-SB": "¤#,##0.00;(¤#,##0.00)",
  "en-SC": "¤#,##0.00;(¤#,##0.00)",
  "en-SD": "¤#,##0.00;(¤#,##0.00)",
  "en-SE": "#,##0.00 ¤",
  "en-SG": "¤#,##0.00;(¤#,##0.00)",
  "en-SH": "¤#,##0.00;(¤#,##0.00)",
  "en-SI": "#,##0.00 ¤;(#,##0.00 ¤)",
  "en-SL": "¤#,##0.00;(¤#,##0.00)",
  "en-SS": "¤#,##0.00;(¤#,##0.00)",
  "en-SX": "¤#,##0.00;(¤#,##0.00)",
  "en-SZ": "¤#,##0.00;(¤#,##0.00)",
  "en-TC": "¤#,##0.00;(¤#,##0.00)",
  "en-TK": "¤#,##0.00;(¤#,##0.00)",
  "en-TO": "¤#,##0.00;(¤#,##0.00)",
  "en-TT": "¤#,##0.00;(¤#,##0.00)",
  "en-TV": "¤#,##0.00;(¤#,##0.00)",
  "en-TZ": "¤#,##0.00;(¤#,##0.00)",
  "en-UG": "¤#,##0.00;(¤#,##0.00)",
  "en-UM": "¤#,##0.00;(¤#,##0.00)",
  "en-VC": "¤#,##0.00;(¤#,##0.00)",
  "en-VG": "¤#,##0.00;(¤#,##0.00)",
  "en-VI": "¤#,##0.00;(¤#,##0.00)",
  "en-VU": "¤#,##0.00;(¤#,##0.00)",
  "en-WS": "¤#,##0.00;(¤#,##0.00)",
  "en-ZA": "¤#,##0.00;(¤#,##0.00)",
  "en-ZM": "¤#,##0.00;(¤#,##0.00)",
  "en-ZW": "¤#,##0.00;(¤#,##0.00)",
  eo: "¤ #,##0.00",
  es: "#,##0.00 ¤",
  "es-419": "¤#,##0.00",
  "es-AR": "¤ #,##0.00;(¤ #,##0.00)",
  "es-BO": "¤#,##0.00",
  "es-BR": "¤#,##0.00",
  "es-BZ": "¤#,##0.00",
  "es-CL": "¤#,##0.00",
  "es-CO": "¤#,##0.00",
  "es-CR": "¤#,##0.00",
  "es-CU": "¤#,##0.00",
  "es-DO": "¤#,##0.00;(¤#,##0.00)",
  "es-EA": "#,##0.00 ¤",
  "es-EC": "¤#,##0.00",
  "es-GQ": "#,##0.00 ¤",
  "es-GT": "¤#,##0.00",
  "es-HN": "¤#,##0.00",
  "es-IC": "#,##0.00 ¤",
  "es-MX": "¤#,##0.00",
  "es-NI": "¤#,##0.00",
  "es-PA": "¤#,##0.00",
  "es-PE": "¤#,##0.00",
  "es-PH": "#,##0.00 ¤",
  "es-PR": "¤#,##0.00",
  "es-PY": "¤#,##0.00",
  "es-SV": "¤#,##0.00",
  "es-US": "¤#,##0.00",
  "es-UY": "¤ #,##0.00;(¤ #,##0.00)",
  "es-VE": "¤#,##0.00",
  et: "#,##0.00 ¤;(#,##0.00 ¤)",
  eu: "#,##0.00 ¤;(#,##0.00 ¤)",
  ewo: "#,##0.00 ¤",
  fa: "‎¤ #,##0.00;‎(¤ #,##0.00)",
  "fa-AF": "¤ #,##0.00;‎(¤ #,##0.00)",
  ff: "#,##0.00 ¤",
  "ff-Adlm": "¤ #,##0.00",
  "ff-Adlm-BF": "¤ #,##0.00",
  "ff-Adlm-CM": "¤ #,##0.00",
  "ff-Adlm-GH": "¤ #,##0.00",
  "ff-Adlm-GM": "¤ #,##0.00",
  "ff-Adlm-GW": "¤ #,##0.00",
  "ff-Adlm-LR": "¤ #,##0.00",
  "ff-Adlm-MR": "¤ #,##0.00",
  "ff-Adlm-NE": "¤ #,##0.00",
  "ff-Adlm-NG": "¤ #,##0.00",
  "ff-Adlm-SL": "¤ #,##0.00",
  "ff-Adlm-SN": "¤ #,##0.00",
  "ff-Latn": "#,##0.00 ¤",
  "ff-Latn-BF": "#,##0.00 ¤",
  "ff-Latn-CM": "#,##0.00 ¤",
  "ff-Latn-GH": "#,##0.00 ¤",
  "ff-Latn-GM": "#,##0.00 ¤",
  "ff-Latn-GN": "#,##0.00 ¤",
  "ff-Latn-GW": "#,##0.00 ¤",
  "ff-Latn-LR": "#,##0.00 ¤",
  "ff-Latn-MR": "#,##0.00 ¤",
  "ff-Latn-NE": "#,##0.00 ¤",
  "ff-Latn-NG": "#,##0.00 ¤",
  "ff-Latn-SL": "#,##0.00 ¤",
  fi: "#,##0.00 ¤",
  fil: "¤#,##0.00;(¤#,##0.00)",
  fo: "#,##0.00 ¤;(#,##0.00 ¤)",
  "fo-DK": "#,##0.00 ¤;(#,##0.00 ¤)",
  fr: "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-BE": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-BF": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-BI": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-BJ": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-BL": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-CA": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-CD": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-CF": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-CG": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-CH": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-CI": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-CM": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-DJ": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-DZ": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-GA": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-GF": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-GN": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-GP": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-GQ": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-HT": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-KM": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-LU": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-MA": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-MC": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-MF": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-MG": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-ML": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-MQ": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-MR": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-MU": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-NC": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-NE": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-PF": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-PM": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-RE": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-RW": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-SC": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-SN": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-SY": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-TD": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-TG": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-TN": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-VU": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-WF": "#,##0.00 ¤;(#,##0.00 ¤)",
  "fr-YT": "#,##0.00 ¤;(#,##0.00 ¤)",
  fur: "¤ #,##0.00",
  fy: "¤ #,##0.00;(¤ #,##0.00)",
  ga: "¤#,##0.00;(¤#,##0.00)",
  "ga-GB": "¤#,##0.00;(¤#,##0.00)",
  gd: "¤#,##0.00;(¤#,##0.00)",
  gl: "#,##0.00 ¤",
  gsw: "#,##0.00 ¤",
  "gsw-FR": "#,##0.00 ¤",
  "gsw-LI": "#,##0.00 ¤",
  gu: "¤#,##,##0.00;(¤#,##,##0.00)",
  guz: "¤#,##0.00;(¤#,##0.00)",
  gv: "¤#,##0.00",
  ha: "¤ #,##0.00",
  "ha-GH": "¤ #,##0.00",
  "ha-NE": "¤ #,##0.00",
  haw: "¤#,##0.00;(¤#,##0.00)",
  he: "#,##0.00 ¤",
  hi: "¤#,##,##0.00",
  "hi-Latn": "¤#,##,##0.00",
  hr: "#,##0.00 ¤",
  "hr-BA": "#,##0.00 ¤",
  hsb: "#,##0.00 ¤",
  hu: "#,##0.00 ¤",
  hy: "#,##0.00 ¤",
  ia: "¤ #,##0.00;(¤ #,##0.00)",
  id: "¤#,##0.00",
  ig: "¤#,##0.00;(¤#,##0.00)",
  ii: "¤ #,##0.00",
  is: "#,##0.00 ¤",
  it: "#,##0.00 ¤",
  "it-CH": "#,##0.00 ¤",
  "it-SM": "#,##0.00 ¤",
  "it-VA": "#,##0.00 ¤",
  ja: "¤#,##0.00;(¤#,##0.00)",
  jgo: "¤ #,##0.00",
  jmc: "¤#,##0.00",
  jv: "¤ #,##0.00",
  ka: "#,##0.00 ¤",
  kab: "#,##0.00¤",
  kam: "¤#,##0.00;(¤#,##0.00)",
  kde: "¤#,##0.00;(¤#,##0.00)",
  kea: "#,##0.00 ¤;(#,##0.00 ¤)",
  kgp: "¤ #,##0.00",
  khq: "#,##0.00¤",
  ki: "¤#,##0.00;(¤#,##0.00)",
  kk: "#,##0.00 ¤",
  kkj: "¤ #,##0.00",
  kl: "¤#,##0.00;¤-#,##0.00",
  kln: "¤#,##0.00;(¤#,##0.00)",
  km: "#,##0.00¤;(#,##0.00¤)",
  kn: "¤#,##0.00;(¤#,##0.00)",
  ko: "¤#,##0.00;(¤#,##0.00)",
  "ko-KP": "¤#,##0.00;(¤#,##0.00)",
  kok: "¤#,##0.00;(¤#,##0.00)",
  ks: "¤#,##0.00",
  "ks-Arab": "¤#,##0.00",
  "ks-Deva": "¤ #,##0.00",
  ksb: "#,##0.00¤",
  ksf: "#,##0.00 ¤",
  ksh: "#,##0.00 ¤",
  ku: "#,##0.00 ¤;(#,##0.00 ¤)",
  kw: "¤#,##0.00",
  ky: "#,##0.00 ¤",
  lag: "¤ #,##0.00",
  lb: "#,##0.00 ¤",
  lg: "#,##0.00¤",
  lkt: "¤ #,##0.00",
  ln: "#,##0.00 ¤",
  "ln-AO": "#,##0.00 ¤",
  "ln-CF": "#,##0.00 ¤",
  "ln-CG": "#,##0.00 ¤",
  lo: "¤#,##0.00;¤-#,##0.00",
  lrc: "¤ #,##0.00",
  "lrc-IQ": "¤ #,##0.00",
  lt: "#,##0.00 ¤",
  lu: "#,##0.00¤",
  luo: "#,##0.00¤",
  luy: "¤#,##0.00;¤- #,##0.00",
  lv: "#,##0.00 ¤",
  mai: "¤ #,##0.00",
  mas: "¤#,##0.00;(¤#,##0.00)",
  "mas-TZ": "¤#,##0.00;(¤#,##0.00)",
  mer: "¤#,##0.00;(¤#,##0.00)",
  mfe: "¤ #,##0.00",
  mg: "¤#,##0.00",
  mgh: "¤ #,##0.00",
  mgo: "¤ #,##0.00",
  mi: "¤ #,##0.00",
  mk: "#,##0.00 ¤",
  ml: "¤#,##0.00;(¤#,##0.00)",
  mn: "¤ #,##0.00",
  mni: "¤ #,##0.00",
  "mni-Beng": "¤ #,##0.00",
  mr: "¤#,##0.00;(¤#,##0.00)",
  ms: "¤#,##0.00;(¤#,##0.00)",
  "ms-BN": "¤#,##0.00;(¤#,##0.00)",
  "ms-ID": "¤#,##0.00",
  "ms-SG": "¤#,##0.00;(¤#,##0.00)",
  mt: "¤#,##0.00",
  mua: "¤#,##0.00;(¤#,##0.00)",
  my: "¤ #,##0.00",
  mzn: "¤ #,##0.00",
  naq: "¤#,##0.00",
  nb: "¤ #,##0.00;(¤ #,##0.00)",
  "nb-SJ": "¤ #,##0.00;(¤ #,##0.00)",
  nd: "¤#,##0.00;(¤#,##0.00)",
  nds: "¤ #,##0.00",
  "nds-NL": "¤ #,##0.00",
  ne: "¤ #,##,##0.00",
  "ne-IN": "¤ #,##,##0.00",
  nl: "¤ #,##0.00;(¤ #,##0.00)",
  "nl-AW": "¤ #,##0.00;(¤ #,##0.00)",
  "nl-BE": "¤ #,##0.00;(¤ #,##0.00)",
  "nl-BQ": "¤ #,##0.00;(¤ #,##0.00)",
  "nl-CW": "¤ #,##0.00;(¤ #,##0.00)",
  "nl-SR": "¤ #,##0.00;(¤ #,##0.00)",
  "nl-SX": "¤ #,##0.00;(¤ #,##0.00)",
  nmg: "#,##0.00 ¤",
  nn: "#,##0.00 ¤",
  nnh: "¤ #,##0.00",
  no: "¤ #,##0.00;(¤ #,##0.00)",
  nus: "¤#,##0.00;(¤#,##0.00)",
  nyn: "¤#,##0.00",
  om: "¤#,##0.00",
  "om-KE": "¤#,##0.00",
  or: "¤#,##0.00;(¤#,##0.00)",
  os: "¤ #,##0.00",
  "os-RU": "¤ #,##0.00",
  pa: "¤ #,##0.00",
  "pa-Arab": "¤ #,##0.00",
  "pa-Guru": "¤ #,##0.00",
  pcm: "¤#,##0.00",
  pl: "#,##0.00 ¤;(#,##0.00 ¤)",
  ps: "¤#,##0.00;(¤#,##0.00)",
  "ps-PK": "¤#,##0.00;(¤#,##0.00)",
  pt: "¤ #,##0.00",
  "pt-AO": "#,##0.00 ¤;(#,##0.00 ¤)",
  "pt-CH": "#,##0.00 ¤;(#,##0.00 ¤)",
  "pt-CV": "#,##0.00 ¤;(#,##0.00 ¤)",
  "pt-GQ": "#,##0.00 ¤;(#,##0.00 ¤)",
  "pt-GW": "#,##0.00 ¤;(#,##0.00 ¤)",
  "pt-LU": "#,##0.00 ¤;(#,##0.00 ¤)",
  "pt-MO": "#,##0.00 ¤;(#,##0.00 ¤)",
  "pt-MZ": "#,##0.00 ¤;(#,##0.00 ¤)",
  "pt-PT": "#,##0.00 ¤;(#,##0.00 ¤)",
  "pt-ST": "#,##0.00 ¤;(#,##0.00 ¤)",
  "pt-TL": "#,##0.00 ¤;(#,##0.00 ¤)",
  qu: "¤ #,##0.00",
  "qu-BO": "¤ #,##0.00",
  "qu-EC": "¤ #,##0.00",
  rm: "#,##0.00 ¤",
  rn: "#,##0.00¤",
  ro: "#,##0.00 ¤;(#,##0.00 ¤)",
  "ro-MD": "#,##0.00 ¤;(#,##0.00 ¤)",
  rof: "¤#,##0.00",
  ru: "#,##0.00 ¤",
  "ru-BY": "#,##0.00 ¤",
  "ru-KG": "#,##0.00 ¤",
  "ru-KZ": "#,##0.00 ¤",
  "ru-MD": "#,##0.00 ¤",
  "ru-UA": "#,##0.00 ¤",
  rw: "¤ #,##0.00",
  rwk: "#,##0.00¤",
  sa: "¤ #,##0.00",
  sah: "#,##0.00 ¤",
  saq: "¤#,##0.00;(¤#,##0.00)",
  sat: "¤ #,##0.00",
  "sat-Olck": "¤ #,##0.00",
  sbp: "#,##0.00¤",
  sc: "#,##0.00 ¤",
  sd: "¤ #,##0.00",
  "sd-Arab": "¤ #,##0.00",
  "sd-Deva": "¤ #,##0.00",
  se: "#,##0.00 ¤",
  "se-FI": "#,##0.00 ¤",
  "se-SE": "#,##0.00 ¤",
  seh: "#,##0.00¤",
  ses: "#,##0.00¤",
  sg: "¤#,##0.00;¤-#,##0.00",
  shi: "#,##0.00¤",
  "shi-Latn": "#,##0.00¤",
  "shi-Tfng": "#,##0.00¤",
  si: "¤#,##0.00;(¤#,##0.00)",
  sk: "#,##0.00 ¤;(#,##0.00 ¤)",
  sl: "#,##0.00 ¤;(#,##0.00 ¤)",
  smn: "#,##0.00 ¤",
  sn: "¤#,##0.00;(¤#,##0.00)",
  so: "¤#,##0.00;(¤#,##0.00)",
  "so-DJ": "¤#,##0.00;(¤#,##0.00)",
  "so-ET": "¤#,##0.00;(¤#,##0.00)",
  "so-KE": "¤#,##0.00;(¤#,##0.00)",
  sq: "#,##0.00 ¤;(#,##0.00 ¤)",
  "sq-MK": "#,##0.00 ¤;(#,##0.00 ¤)",
  "sq-XK": "#,##0.00 ¤;(#,##0.00 ¤)",
  sr: "#,##0.00 ¤;(#,##0.00 ¤)",
  "sr-Cyrl": "#,##0.00 ¤;(#,##0.00 ¤)",
  "sr-Cyrl-BA": "#,##0.00 ¤;(#,##0.00 ¤)",
  "sr-Cyrl-ME": "#,##0.00 ¤;(#,##0.00 ¤)",
  "sr-Cyrl-XK": "#,##0.00 ¤;(#,##0.00 ¤)",
  "sr-Latn": "#,##0.00 ¤;(#,##0.00 ¤)",
  "sr-Latn-BA": "#,##0.00 ¤;(#,##0.00 ¤)",
  "sr-Latn-ME": "#,##0.00 ¤;(#,##0.00 ¤)",
  "sr-Latn-XK": "#,##0.00 ¤;(#,##0.00 ¤)",
  su: "¤#,##0.00",
  "su-Latn": "¤#,##0.00",
  sv: "#,##0.00 ¤",
  "sv-AX": "#,##0.00 ¤",
  "sv-FI": "#,##0.00 ¤",
  sw: "¤ #,##0.00",
  "sw-CD": "¤ #,##0.00",
  "sw-KE": "¤ #,##0.00",
  "sw-UG": "¤ #,##0.00",
  ta: "¤#,##0.00;(¤#,##0.00)",
  "ta-LK": "¤#,##0.00;(¤#,##0.00)",
  "ta-MY": "¤#,##0.00;(¤#,##0.00)",
  "ta-SG": "¤#,##0.00;(¤#,##0.00)",
  te: "¤#,##0.00;(¤#,##0.00)",
  teo: "¤#,##0.00;(¤#,##0.00)",
  "teo-KE": "¤#,##0.00;(¤#,##0.00)",
  tg: "#,##0.00 ¤",
  th: "¤#,##0.00;(¤#,##0.00)",
  ti: "¤#,##0.00",
  "ti-ER": "¤#,##0.00",
  tk: "#,##0.00 ¤",
  to: "¤ #,##0.00",
  tr: "¤#,##0.00;(¤#,##0.00)",
  "tr-CY": "¤#,##0.00;(¤#,##0.00)",
  tt: "#,##0.00 ¤",
  twq: "#,##0.00¤",
  tzm: "#,##0.00 ¤",
  ug: "¤#,##0.00;(¤#,##0.00)",
  uk: "#,##0.00 ¤",
  und: "¤ #,##0.00",
  ur: "¤#,##0.00;(¤#,##0.00)",
  "ur-IN": "¤#,##0.00;(¤#,##0.00)",
  uz: "#,##0.00 ¤",
  "uz-Arab": "¤ #,##0.00",
  "uz-Cyrl": "#,##0.00 ¤",
  "uz-Latn": "#,##0.00 ¤",
  vai: "¤#,##0.00;(¤#,##0.00)",
  "vai-Latn": "¤#,##0.00;(¤#,##0.00)",
  "vai-Vaii": "¤#,##0.00;(¤#,##0.00)",
  vi: "#,##0.00 ¤",
  vun: "¤#,##0.00",
  wae: "¤ #,##0.00",
  wo: "¤ #,##0.00",
  xh: "¤#,##0.00",
  xog: "#,##0.00 ¤",
  yav: "#,##0.00 ¤;(#,##0.00 ¤)",
  yi: "¤ #,##0.00",
  yo: "¤#,##0.00;(¤#,##0.00)",
  "yo-BJ": "¤#,##0.00;(¤#,##0.00)",
  yrl: "¤ #,##0.00",
  "yrl-CO": "¤ #,##0.00",
  "yrl-VE": "¤ #,##0.00",
  yue: "¤#,##0.00;(¤#,##0.00)",
  "yue-Hans": "¤#,##0.00;(¤#,##0.00)",
  "yue-Hant": "¤#,##0.00;(¤#,##0.00)",
  zgh: "#,##0.00¤",
  zh: "¤#,##0.00;(¤#,##0.00)",
  "zh-Hans": "¤#,##0.00;(¤#,##0.00)",
  "zh-Hans-HK": "¤#,##0.00;(¤#,##0.00)",
  "zh-Hans-MO": "¤#,##0.00;(¤#,##0.00)",
  "zh-Hans-SG": "¤#,##0.00;(¤#,##0.00)",
  "zh-Hant": "¤#,##0.00;(¤#,##0.00)",
  "zh-Hant-HK": "¤#,##0.00;(¤#,##0.00)",
  "zh-Hant-MO": "¤#,##0.00;(¤#,##0.00)",
  zu: "¤#,##0.00;(¤#,##0.00)"
};

// node_modules/devextreme/esm/common/core/localization/intl/number.js
var CURRENCY_STYLES = ["standard", "accounting"];
var detectCurrencySymbolRegex = /([^\s0]+)?(\s*)0*[.,]*0*(\s*)([^\s0]+)?/;
var formattersCache = {};
var getFormatter3 = (format2) => {
  const key = core_default.locale() + "/" + JSON.stringify(format2);
  if (!formattersCache[key]) {
    formattersCache[key] = new Intl.NumberFormat(core_default.locale(), format2).format;
  }
  return formattersCache[key];
};
var getCurrencyFormatter = (currency) => new Intl.NumberFormat(core_default.locale(), {
  style: "currency",
  currency
});
var number_default = {
  engine: function() {
    return "intl";
  },
  _formatNumberCore: function(value2, format2, formatConfig) {
    if ("exponential" === format2) {
      return this.callBase.apply(this, arguments);
    }
    return getFormatter3(this._normalizeFormatConfig(format2, formatConfig, value2))(value2);
  },
  _normalizeFormatConfig: function(format2, formatConfig, value2) {
    let config3;
    if ("decimal" === format2) {
      const fractionDigits = String(value2).split(".")[1];
      config3 = {
        minimumIntegerDigits: formatConfig.precision || void 0,
        useGrouping: false,
        maximumFractionDigits: fractionDigits && fractionDigits.length,
        round: value2 < 0 ? "ceil" : "floor"
      };
    } else {
      config3 = this._getPrecisionConfig(formatConfig.precision);
    }
    if ("percent" === format2) {
      config3.style = "percent";
    } else if ("currency" === format2) {
      const useAccountingStyle = formatConfig.useCurrencyAccountingStyle ?? config_default().defaultUseCurrencyAccountingStyle;
      config3.style = "currency";
      config3.currency = formatConfig.currency || config_default().defaultCurrency;
      config3.currencySign = CURRENCY_STYLES[+useAccountingStyle];
    }
    return config3;
  },
  _getPrecisionConfig: function(precision) {
    let config3;
    if (null === precision) {
      config3 = {
        minimumFractionDigits: 0,
        maximumFractionDigits: 20
      };
    } else {
      config3 = {
        minimumFractionDigits: precision || 0,
        maximumFractionDigits: precision || 0
      };
    }
    return config3;
  },
  format: function(value2, format2) {
    if ("number" !== typeof value2) {
      return value2;
    }
    format2 = this._normalizeFormat(format2);
    if ("default" === format2.currency) {
      format2.currency = config_default().defaultCurrency;
    }
    if (!format2 || "function" !== typeof format2 && !format2.type && !format2.formatter) {
      return getFormatter3(format2)(value2);
    }
    const result2 = this.callBase.apply(this, arguments);
    return result2;
  },
  _getCurrencySymbolInfo: function(currency) {
    const formatter = getCurrencyFormatter(currency);
    return this._extractCurrencySymbolInfo(formatter.format(0));
  },
  _extractCurrencySymbolInfo: function(currencyValueString) {
    const match2 = detectCurrencySymbolRegex.exec(currencyValueString) || [];
    const position3 = match2[1] ? "before" : "after";
    const symbol = match2[1] || match2[4] || "";
    const delimiter = match2[2] || match2[3] || "";
    return {
      position: position3,
      symbol,
      delimiter
    };
  },
  getCurrencySymbol: function(currency) {
    if (!currency) {
      currency = config_default().defaultCurrency;
    }
    const symbolInfo = this._getCurrencySymbolInfo(currency);
    return {
      symbol: symbolInfo.symbol
    };
  },
  getOpenXmlCurrencyFormat: function(currency) {
    const targetCurrency = currency || config_default().defaultCurrency;
    const currencySymbol = this._getCurrencySymbolInfo(targetCurrency).symbol;
    const closestAccountingFormat = core_default.getValueByClosestLocale((locale) => accounting_formats_default[locale]);
    return open_xml_currency_format_default(currencySymbol, closestAccountingFormat);
  }
};

// node_modules/devextreme/esm/common/core/localization/number.js
var hasIntl = "undefined" !== typeof Intl;
var NUMERIC_FORMATS = ["currency", "fixedpoint", "exponential", "percent", "decimal"];
var LargeNumberFormatPostfixes = {
  1: "K",
  2: "M",
  3: "B",
  4: "T"
};
var LargeNumberFormatPowers = {
  largenumber: "auto",
  thousands: 1,
  millions: 2,
  billions: 3,
  trillions: 4
};
var numberLocalization = dependency_injector_default({
  engine: function() {
    return "base";
  },
  numericFormats: NUMERIC_FORMATS,
  defaultLargeNumberFormatPostfixes: LargeNumberFormatPostfixes,
  _parseNumberFormatString: function(formatType) {
    const formatObject = {};
    if (!formatType || "string" !== typeof formatType) {
      return;
    }
    const formatList = formatType.toLowerCase().split(" ");
    each(formatList, (index2, value2) => {
      if (NUMERIC_FORMATS.includes(value2)) {
        formatObject.formatType = value2;
      } else if (value2 in LargeNumberFormatPowers) {
        formatObject.power = LargeNumberFormatPowers[value2];
      }
    });
    if (formatObject.power && !formatObject.formatType) {
      formatObject.formatType = "fixedpoint";
    }
    if (formatObject.formatType) {
      return formatObject;
    }
  },
  _calculateNumberPower: function(value2, base2, minPower, maxPower) {
    let number = Math.abs(value2);
    let power = 0;
    if (number > 1) {
      while (number && number >= base2 && (void 0 === maxPower || power < maxPower)) {
        power++;
        number /= base2;
      }
    } else if (number > 0 && number < 1) {
      while (number < 1 && (void 0 === minPower || power > minPower)) {
        power--;
        number *= base2;
      }
    }
    return power;
  },
  _getNumberByPower: function(number, power, base2) {
    let result2 = number;
    while (power > 0) {
      result2 /= base2;
      power--;
    }
    while (power < 0) {
      result2 *= base2;
      power++;
    }
    return result2;
  },
  _formatNumber: function(value2, formatObject, formatConfig) {
    if ("auto" === formatObject.power) {
      formatObject.power = this._calculateNumberPower(value2, 1e3, 0, 4);
    }
    if (formatObject.power) {
      value2 = this._getNumberByPower(value2, formatObject.power, 1e3);
    }
    const powerPostfix = this.defaultLargeNumberFormatPostfixes[formatObject.power] || "";
    let result2 = this._formatNumberCore(value2, formatObject.formatType, formatConfig);
    result2 = result2.replace(/(\d|.$)(\D*)$/, "$1" + powerPostfix + "$2");
    return result2;
  },
  _formatNumberExponential: function(value2, formatConfig) {
    let power = this._calculateNumberPower(value2, 10);
    let number = this._getNumberByPower(value2, power, 10);
    if (void 0 === formatConfig.precision) {
      formatConfig.precision = 1;
    }
    if (number.toFixed(formatConfig.precision || 0) >= 10) {
      power++;
      number /= 10;
    }
    const powString = (power >= 0 ? "+" : "") + power.toString();
    return this._formatNumberCore(number, "fixedpoint", formatConfig) + "E" + powString;
  },
  _addZeroes: function(value2, precision) {
    const multiplier = Math.pow(10, precision);
    const sign2 = value2 < 0 ? "-" : "";
    value2 = (Math.abs(value2) * multiplier >>> 0) / multiplier;
    let result2 = value2.toString();
    while (result2.length < precision) {
      result2 = "0" + result2;
    }
    return sign2 + result2;
  },
  _addGroupSeparators: function(value2) {
    const parts = value2.toString().split(".");
    return parts[0].replace(/\B(?=(\d{3})+(?!\d))/g, config_default2().thousandsSeparator) + (parts[1] ? config_default2().decimalSeparator + parts[1] : "");
  },
  _formatNumberCore: function(value2, format2, formatConfig) {
    if ("exponential" === format2) {
      return this._formatNumberExponential(value2, formatConfig);
    }
    if ("decimal" !== format2 && null !== formatConfig.precision) {
      formatConfig.precision = formatConfig.precision || 0;
    }
    if ("percent" === format2) {
      value2 *= 100;
    }
    if (void 0 !== formatConfig.precision) {
      if ("decimal" === format2) {
        value2 = this._addZeroes(value2, formatConfig.precision);
      } else {
        value2 = null === formatConfig.precision ? value2.toPrecision() : toFixed(value2, formatConfig.precision);
      }
    }
    if ("decimal" !== format2) {
      value2 = this._addGroupSeparators(value2);
    } else {
      value2 = value2.toString().replace(".", config_default2().decimalSeparator);
    }
    if ("percent" === format2) {
      value2 += "%";
    }
    return value2;
  },
  _normalizeFormat: function(format2) {
    if (!format2) {
      return {};
    }
    if ("function" === typeof format2) {
      return format2;
    }
    if (!isPlainObject(format2)) {
      format2 = {
        type: format2
      };
    }
    return format2;
  },
  _getSeparators: function() {
    return {
      decimalSeparator: this.getDecimalSeparator(),
      thousandsSeparator: this.getThousandsSeparator()
    };
  },
  getThousandsSeparator: function() {
    return this.format(1e4, "fixedPoint")[2];
  },
  getDecimalSeparator: function() {
    return this.format(1.2, {
      type: "fixedPoint",
      precision: 1
    })[1];
  },
  convertDigits: function(value2, toStandard) {
    const digits = this.format(90, "decimal");
    if ("string" !== typeof value2 || "0" === digits[1]) {
      return value2;
    }
    const fromFirstDigit = toStandard ? digits[1] : "0";
    const toFirstDigit = toStandard ? "0" : digits[1];
    const fromLastDigit = toStandard ? digits[0] : "9";
    const regExp = new RegExp("[" + fromFirstDigit + "-" + fromLastDigit + "]", "g");
    return value2.replace(regExp, (char) => String.fromCharCode(char.charCodeAt(0) + (toFirstDigit.charCodeAt(0) - fromFirstDigit.charCodeAt(0))));
  },
  getNegativeEtalonRegExp: function(format2) {
    const separators = this._getSeparators();
    const digitalRegExp = new RegExp("[0-9" + escapeRegExp(separators.decimalSeparator + separators.thousandsSeparator) + "]+", "g");
    let negativeEtalon = this.format(-1, format2).replace(digitalRegExp, "1");
    ["\\", "(", ")", "[", "]", "*", "+", "$", "^", "?", "|", "{", "}"].forEach((char) => {
      negativeEtalon = negativeEtalon.replace(new RegExp(`\\${char}`, "g"), `\\${char}`);
    });
    negativeEtalon = negativeEtalon.replace(/ /g, "\\s");
    negativeEtalon = negativeEtalon.replace(/1/g, ".*");
    return new RegExp(negativeEtalon, "g");
  },
  getSign: function(text, format2) {
    if (!format2) {
      if ("-" === text.replace(/[^0-9-]/g, "").charAt(0)) {
        return -1;
      }
      return 1;
    }
    const negativeEtalon = this.getNegativeEtalonRegExp(format2);
    return text.match(negativeEtalon) ? -1 : 1;
  },
  format: function(value2, format2) {
    if ("number" !== typeof value2) {
      return value2;
    }
    if ("number" === typeof format2) {
      return value2;
    }
    format2 = format2 && format2.formatter || format2;
    if ("function" === typeof format2) {
      return format2(value2);
    }
    format2 = this._normalizeFormat(format2);
    if (!format2.type) {
      format2.type = "decimal";
    }
    const numberConfig = this._parseNumberFormatString(format2.type);
    if (!numberConfig) {
      const formatterConfig = this._getSeparators();
      formatterConfig.unlimitedIntegerDigits = format2.unlimitedIntegerDigits;
      const formatter = getFormatter2(format2.type, formatterConfig)(value2);
      const result2 = this.convertDigits(formatter);
      return result2;
    }
    return this._formatNumber(value2, numberConfig, format2);
  },
  parse: function(text, format2) {
    if (!text) {
      return;
    }
    if (format2 && format2.parser) {
      return format2.parser(text);
    }
    text = this.convertDigits(text, true);
    if (format2 && "string" !== typeof format2) {
      errors_default.log("W0011");
    }
    const decimalSeparator = this.getDecimalSeparator();
    const regExp = new RegExp("[^0-9" + escapeRegExp(decimalSeparator) + "]", "g");
    const cleanedText = text.replace(regExp, "").replace(decimalSeparator, ".").replace(/\.$/g, "");
    if ("." === cleanedText || "" === cleanedText) {
      return null;
    }
    if (this._calcSignificantDigits(cleanedText) > 15) {
      return NaN;
    }
    let parsed = +cleanedText * this.getSign(text, format2);
    format2 = this._normalizeFormat(format2);
    const formatConfig = this._parseNumberFormatString(format2.type);
    let power = null === formatConfig || void 0 === formatConfig ? void 0 : formatConfig.power;
    if (power) {
      if ("auto" === power) {
        const match2 = text.match(/\d(K|M|B|T)/);
        if (match2) {
          power = Object.keys(LargeNumberFormatPostfixes).find((power2) => LargeNumberFormatPostfixes[power2] === match2[1]);
        }
      }
      parsed *= Math.pow(10, 3 * power);
    }
    if ("percent" === (null === formatConfig || void 0 === formatConfig ? void 0 : formatConfig.formatType)) {
      parsed /= 100;
    }
    return parsed;
  },
  _calcSignificantDigits: function(text) {
    const [integer, fractional] = text.split(".");
    const calcDigitsAfterLeadingZeros = (digits) => {
      let index2 = -1;
      for (let i = 0; i < digits.length; i++) {
        if ("0" !== digits[i]) {
          index2 = i;
          break;
        }
      }
      return index2 > -1 ? digits.length - index2 : 0;
    };
    let result2 = 0;
    if (integer) {
      result2 += calcDigitsAfterLeadingZeros(integer.split(""));
    }
    if (fractional) {
      result2 += calcDigitsAfterLeadingZeros(fractional.split("").reverse());
    }
    return result2;
  }
});
numberLocalization.inject(currency_default);
if (hasIntl) {
  numberLocalization.inject(number_default);
}
var number_default2 = numberLocalization;

// node_modules/devextreme/esm/common/core/localization/ldml/date.format.js
var FORMAT_SEPARATORS = " .,:;/\\<>()-[]،";
var checkDigit = function(char) {
  const code = char && number_default2.convertDigits(char, false).charCodeAt(0);
  const zeroCode = number_default2.convertDigits("0", false).charCodeAt(0);
  return zeroCode <= code && code < zeroCode + 10;
};
var checkPatternContinue = function(text, patterns, index2, isDigit) {
  const char = text[index2];
  const nextChar = text[index2 + 1];
  if (!isDigit) {
    if ("." === char || " " === char && ". m." === text.slice(index2 - 1, index2 + 3)) {
      return true;
    }
    if ("-" === char && !checkDigit(nextChar)) {
      return true;
    }
  }
  const isDigitChanged = isDigit && patterns.some((pattern) => text[index2] !== pattern[index2]);
  return FORMAT_SEPARATORS.indexOf(char) < 0 && isDigit === checkDigit(char) && (!isDigit || isDigitChanged);
};
var getPatternStartIndex = function(defaultPattern, index2) {
  if (!checkDigit(defaultPattern[index2])) {
    while (index2 > 0 && !checkDigit(defaultPattern[index2 - 1]) && ("." === defaultPattern[index2 - 1] || FORMAT_SEPARATORS.indexOf(defaultPattern[index2 - 1]) < 0)) {
      index2--;
    }
  }
  return index2;
};
var getDifference = function(defaultPattern, patterns, processedIndexes, isDigit) {
  let i = 0;
  const result2 = [];
  const patternsFilter = function(pattern) {
    return defaultPattern[i] !== pattern[i] && (void 0 === isDigit || checkDigit(defaultPattern[i]) === isDigit);
  };
  if (!Array.isArray(patterns)) {
    patterns = [patterns];
  }
  for (i = 0; i < defaultPattern.length; i++) {
    if (processedIndexes.indexOf(i) < 0 && patterns.filter(patternsFilter).length) {
      i = getPatternStartIndex(defaultPattern, i);
      do {
        isDigit = checkDigit(defaultPattern[i]);
        if (!result2.length && !isDigit && checkDigit(patterns[0][i])) {
          break;
        }
        result2.push(i);
        processedIndexes.unshift(i);
        i++;
      } while (defaultPattern[i] && checkPatternContinue(defaultPattern, patterns, i, isDigit));
      break;
    }
  }
  if (1 === result2.length && ("0" === defaultPattern[processedIndexes[0] - 1] || "٠" === defaultPattern[processedIndexes[0] - 1])) {
    processedIndexes.unshift(processedIndexes[0] - 1);
  }
  return result2;
};
var replaceCharsCore = function(pattern, indexes, char, patternPositions) {
  const baseCharIndex = indexes[0];
  const patternIndex = baseCharIndex < patternPositions.length ? patternPositions[baseCharIndex] : baseCharIndex;
  indexes.forEach(function(_, index2) {
    pattern = pattern.substr(0, patternIndex + index2) + (char.length > 1 ? char[index2] : char) + pattern.substr(patternIndex + index2 + 1);
  });
  if (1 === indexes.length) {
    pattern = pattern.replace("0" + char, char + char);
    pattern = pattern.replace("٠" + char, char + char);
  }
  return pattern;
};
var replaceChars = function(pattern, indexes, char, patternPositions) {
  let i;
  let index2;
  let patternIndex;
  if (!checkDigit(pattern[indexes[0]] || "0")) {
    const letterCount = Math.max(indexes.length <= 3 ? 3 : 4, char.length);
    while (indexes.length > letterCount) {
      index2 = indexes.pop();
      patternIndex = patternPositions[index2];
      patternPositions[index2] = -1;
      for (i = index2 + 1; i < patternPositions.length; i++) {
        patternPositions[i]--;
      }
      pattern = pattern.substr(0, patternIndex) + pattern.substr(patternIndex + 1);
    }
    index2 = indexes[indexes.length - 1] + 1, patternIndex = index2 < patternPositions.length ? patternPositions[index2] : index2;
    while (indexes.length < letterCount) {
      indexes.push(indexes[indexes.length - 1] + 1);
      for (i = index2; i < patternPositions.length; i++) {
        patternPositions[i]++;
      }
      pattern = pattern.substr(0, patternIndex) + " " + pattern.substr(patternIndex);
    }
  }
  pattern = replaceCharsCore(pattern, indexes, char, patternPositions);
  return pattern;
};
var formatValue = function(value2, formatter) {
  if (Array.isArray(value2)) {
    return value2.map(function(value3) {
      return (formatter(value3) || "").toString();
    });
  }
  return (formatter(value2) || "").toString();
};
var ESCAPE_CHARS_REGEXP = /[a-zA-Z]/g;
var escapeChars = function(pattern, defaultPattern, processedIndexes, patternPositions) {
  const escapeIndexes = defaultPattern.split("").map(function(char, index2) {
    if (processedIndexes.indexOf(index2) < 0 && (char.match(ESCAPE_CHARS_REGEXP) || "'" === char)) {
      return patternPositions[index2];
    }
    return -1;
  });
  pattern = pattern.split("").map(function(char, index2) {
    let result2 = char;
    const isCurrentCharEscaped = escapeIndexes.indexOf(index2) >= 0;
    const isPrevCharEscaped = index2 > 0 && escapeIndexes.indexOf(index2 - 1) >= 0;
    const isNextCharEscaped = escapeIndexes.indexOf(index2 + 1) >= 0;
    if (isCurrentCharEscaped) {
      if (!isPrevCharEscaped) {
        result2 = "'" + result2;
      }
      if (!isNextCharEscaped) {
        result2 += "'";
      }
    }
    return result2;
  }).join("");
  return pattern;
};
var getFormat2 = function(formatter) {
  const processedIndexes = [];
  const defaultPattern = formatValue(new Date(2009, 8, 8, 6, 5, 4), formatter);
  const patternPositions = defaultPattern.split("").map(function(_, index2) {
    return index2;
  });
  let result2 = defaultPattern;
  const replacedPatterns = {};
  const datePatterns = [{
    date: new Date(2009, 8, 8, 6, 5, 4, 111),
    pattern: "S"
  }, {
    date: new Date(2009, 8, 8, 6, 5, 2),
    pattern: "s"
  }, {
    date: new Date(2009, 8, 8, 6, 2, 4),
    pattern: "m"
  }, {
    date: new Date(2009, 8, 8, 18, 5, 4),
    pattern: "H",
    isDigit: true
  }, {
    date: new Date(2009, 8, 8, 2, 5, 4),
    pattern: "h",
    isDigit: true
  }, {
    date: new Date(2009, 8, 8, 18, 5, 4),
    pattern: "a",
    isDigit: false
  }, {
    date: new Date(2009, 8, 1, 6, 5, 4),
    pattern: "d"
  }, {
    date: [new Date(2009, 8, 2, 6, 5, 4), new Date(2009, 8, 3, 6, 5, 4), new Date(2009, 8, 4, 6, 5, 4)],
    pattern: "E"
  }, {
    date: new Date(2009, 9, 6, 6, 5, 4),
    pattern: "M"
  }, {
    date: new Date(1998, 8, 8, 6, 5, 4),
    pattern: "y"
  }];
  if (!result2) {
    return;
  }
  datePatterns.forEach(function(test) {
    const diff = getDifference(defaultPattern, formatValue(test.date, formatter), processedIndexes, test.isDigit);
    const pattern = "M" === test.pattern && !replacedPatterns.d ? "L" : test.pattern;
    result2 = replaceChars(result2, diff, pattern, patternPositions);
    replacedPatterns[pattern] = diff.length;
  });
  result2 = escapeChars(result2, defaultPattern, processedIndexes, patternPositions);
  if (processedIndexes.length) {
    return result2;
  }
};

// node_modules/devextreme/esm/common/core/localization/ldml/date.parser.js
var FORMAT_TYPES2 = {
  3: "abbreviated",
  4: "wide",
  5: "narrow"
};
var monthRegExpGenerator = function(count, dateParts) {
  if (count > 2) {
    return Object.keys(FORMAT_TYPES2).map(function(count2) {
      return ["format", "standalone"].map(function(type2) {
        return dateParts.getMonthNames(FORMAT_TYPES2[count2], type2).join("|");
      }).join("|");
    }).join("|");
  }
  return 2 === count ? "1[012]|0?[1-9]" : "0??[1-9]|1[012]";
};
var PATTERN_REGEXPS = {
  ":": function(count, dateParts) {
    const countSuffix = count > 1 ? `{${count}}` : "";
    let timeSeparator = escapeRegExp(dateParts.getTimeSeparator());
    ":" !== timeSeparator && (timeSeparator = `${timeSeparator}|:`);
    return `${timeSeparator}${countSuffix}`;
  },
  y: function(count) {
    return 2 === count ? `[0-9]{${count}}` : "[0-9]+?";
  },
  M: monthRegExpGenerator,
  L: monthRegExpGenerator,
  Q: function(count, dateParts) {
    if (count > 2) {
      return dateParts.getQuarterNames(FORMAT_TYPES2[count], "format").join("|");
    }
    return "0?[1-4]";
  },
  E: function(count, dateParts) {
    return "\\D*";
  },
  a: function(count, dateParts) {
    return dateParts.getPeriodNames(FORMAT_TYPES2[count < 3 ? 3 : count], "format").join("|");
  },
  d: function(count) {
    return 2 === count ? "3[01]|[12][0-9]|0?[1-9]" : "0??[1-9]|[12][0-9]|3[01]";
  },
  H: function(count) {
    return 2 === count ? "2[0-3]|1[0-9]|0?[0-9]" : "0??[0-9]|1[0-9]|2[0-3]";
  },
  h: function(count) {
    return 2 === count ? "1[012]|0?[1-9]" : "0??[1-9]|1[012]";
  },
  m: function(count) {
    return 2 === count ? "[1-5][0-9]|0?[0-9]" : "0??[0-9]|[1-5][0-9]";
  },
  s: function(count) {
    return 2 === count ? "[1-5][0-9]|0?[0-9]" : "0??[0-9]|[1-5][0-9]";
  },
  S: function(count) {
    return `[0-9]{1,${count}}`;
  },
  w: function(count) {
    return 2 === count ? "[1-5][0-9]|0?[0-9]" : "0??[0-9]|[1-5][0-9]";
  },
  x: function(count) {
    return 3 === count ? "[+-](?:2[0-3]|[01][0-9]):(?:[0-5][0-9])|Z" : "[+-](?:2[0-3]|[01][0-9])(?:[0-5][0-9])|Z";
  }
};
var parseNumber = Number;
var caseInsensitiveIndexOf = function(array, value2) {
  return array.map((item) => item.toLowerCase()).indexOf(value2.toLowerCase());
};
var monthPatternParser = function(text, count, dateParts) {
  if (count > 2) {
    return ["format", "standalone"].map(function(type2) {
      return Object.keys(FORMAT_TYPES2).map(function(count2) {
        const monthNames = dateParts.getMonthNames(FORMAT_TYPES2[count2], type2);
        return caseInsensitiveIndexOf(monthNames, text);
      });
    }).reduce(function(a, b) {
      return a.concat(b);
    }).filter(function(index2) {
      return index2 >= 0;
    })[0];
  }
  return parseNumber(text) - 1;
};
var PATTERN_PARSERS = {
  y: function(text, count) {
    const year = parseNumber(text);
    if (2 === count) {
      return year < 30 ? 2e3 + year : 1900 + year;
    }
    return year;
  },
  M: monthPatternParser,
  L: monthPatternParser,
  Q: function(text, count, dateParts) {
    if (count > 2) {
      return dateParts.getQuarterNames(FORMAT_TYPES2[count], "format").indexOf(text);
    }
    return parseNumber(text) - 1;
  },
  E: function(text, count, dateParts) {
    const dayNames = dateParts.getDayNames(FORMAT_TYPES2[count < 3 ? 3 : count], "format");
    return caseInsensitiveIndexOf(dayNames, text);
  },
  a: function(text, count, dateParts) {
    const periodNames = dateParts.getPeriodNames(FORMAT_TYPES2[count < 3 ? 3 : count], "format");
    return caseInsensitiveIndexOf(periodNames, text);
  },
  d: parseNumber,
  H: parseNumber,
  h: parseNumber,
  m: parseNumber,
  s: parseNumber,
  S: function(text, count) {
    count = Math.max(count, 3);
    text = text.slice(0, 3);
    while (count < 3) {
      text += "0";
      count++;
    }
    return parseNumber(text);
  }
};
var ORDERED_PATTERNS = ["y", "M", "d", "h", "m", "s", "S"];
var PATTERN_SETTERS = {
  y: "setFullYear",
  M: "setMonth",
  L: "setMonth",
  a: function(date, value2, datePartValues) {
    let hours = date.getHours();
    const hourPartValue = datePartValues.h;
    if (void 0 !== hourPartValue && hourPartValue !== hours) {
      hours--;
    }
    if (!value2 && 12 === hours) {
      hours = 0;
    } else if (value2 && 12 !== hours) {
      hours += 12;
    }
    date.setHours(hours);
  },
  d: "setDate",
  H: "setHours",
  h: "setHours",
  m: "setMinutes",
  s: "setSeconds",
  S: "setMilliseconds"
};
var getSameCharCount = function(text, index2) {
  const char = text[index2];
  if (!char) {
    return 0;
  }
  let count = 0;
  do {
    index2++;
    count++;
  } while (text[index2] === char);
  return count;
};
var createPattern = function(char, count) {
  let result2 = "";
  for (let i = 0; i < count; i++) {
    result2 += char;
  }
  return result2;
};
var getRegExpInfo = function(format2, dateParts) {
  let regexpText = "";
  let stubText = "";
  let isEscaping;
  const patterns = [];
  const addPreviousStub = function() {
    if (stubText) {
      patterns.push(`'${stubText}'`);
      regexpText += `${escapeRegExp(stubText)})`;
      stubText = "";
    }
  };
  for (let i = 0; i < format2.length; i++) {
    const char = format2[i];
    const isEscapeChar = "'" === char;
    const regexpPart = PATTERN_REGEXPS[char];
    if (isEscapeChar) {
      isEscaping = !isEscaping;
      if ("'" !== format2[i - 1]) {
        continue;
      }
    }
    if (regexpPart && !isEscaping) {
      const count = getSameCharCount(format2, i);
      const pattern = createPattern(char, count);
      addPreviousStub();
      patterns.push(pattern);
      regexpText += `(${regexpPart(count, dateParts)})`;
      i += count - 1;
    } else {
      if (!stubText) {
        regexpText += "(";
      }
      stubText += char;
    }
  }
  addPreviousStub();
  if (!isPossibleForParsingFormat(patterns)) {
    logger.warn(`The following format may be parsed incorrectly: ${format2}.`);
  }
  return {
    patterns,
    regexp: new RegExp(`^${regexpText}$`, "i")
  };
};
var digitFieldSymbols = ["d", "H", "h", "m", "s", "w", "M", "L", "Q"];
var isPossibleForParsingFormat = function(patterns) {
  const isDigitPattern = (pattern) => {
    if (!pattern) {
      return false;
    }
    const char = pattern[0];
    return ["y", "S"].includes(char) || digitFieldSymbols.includes(char) && pattern.length < 3;
  };
  let possibleForParsing = true;
  let ambiguousDigitPatternsCount = 0;
  return patterns.every((pattern, index2, patterns2) => {
    if (isDigitPattern(pattern)) {
      if (((pattern2) => "S" !== pattern2[0] && 2 !== pattern2.length)(pattern)) {
        possibleForParsing = ++ambiguousDigitPatternsCount < 2;
      }
      if (!isDigitPattern(patterns2[index2 + 1])) {
        ambiguousDigitPatternsCount = 0;
      }
    }
    return possibleForParsing;
  });
};
var getPatternSetters = function() {
  return PATTERN_SETTERS;
};
var setPatternPart = function(date, pattern, text, dateParts, datePartValues) {
  const patternChar = pattern[0];
  const partSetter = PATTERN_SETTERS[patternChar];
  const partParser = PATTERN_PARSERS[patternChar];
  if (partSetter && partParser) {
    const value2 = partParser(text, pattern.length, dateParts);
    datePartValues[pattern] = value2;
    if (date[partSetter]) {
      date[partSetter](value2);
    } else {
      partSetter(date, value2, datePartValues);
    }
  }
};
var setPatternPartFromNow = function(date, pattern, now) {
  const setterName = PATTERN_SETTERS[pattern];
  const getterName = "g" + setterName.substr(1);
  const value2 = now[getterName]();
  date[setterName](value2);
};
var getShortPatterns = function(fullPatterns) {
  return fullPatterns.map(function(pattern) {
    if ("'" === pattern[0]) {
      return "";
    } else {
      return "H" === pattern[0] ? "h" : pattern[0];
    }
  });
};
var getMaxOrderedPatternIndex = function(patterns) {
  const indexes = patterns.map(function(pattern) {
    return ORDERED_PATTERNS.indexOf(pattern);
  });
  return Math.max.apply(Math, indexes);
};
var getOrderedFormatPatterns = function(formatPatterns) {
  const otherPatterns = formatPatterns.filter(function(pattern) {
    return ORDERED_PATTERNS.indexOf(pattern) < 0;
  });
  return ORDERED_PATTERNS.concat(otherPatterns);
};
var getParser = function(format2, dateParts) {
  const regExpInfo = getRegExpInfo(format2, dateParts);
  return function(text) {
    const regExpResult = regExpInfo.regexp.exec(text);
    if (regExpResult) {
      const now = /* @__PURE__ */ new Date();
      const date = new Date(now.getFullYear(), 0, 1);
      const formatPatterns = getShortPatterns(regExpInfo.patterns);
      const maxPatternIndex = getMaxOrderedPatternIndex(formatPatterns);
      const orderedFormatPatterns = getOrderedFormatPatterns(formatPatterns);
      const datePartValues = {};
      orderedFormatPatterns.forEach(function(pattern, index2) {
        if (!pattern || index2 < ORDERED_PATTERNS.length && index2 > maxPatternIndex) {
          return;
        }
        const patternIndex = formatPatterns.indexOf(pattern);
        if (patternIndex >= 0) {
          const regExpPattern = regExpInfo.patterns[patternIndex];
          const regExpText = regExpResult[patternIndex + 1];
          setPatternPart(date, regExpPattern, regExpText, dateParts, datePartValues);
        } else {
          setPatternPartFromNow(date, pattern, now);
        }
      });
      return date;
    }
    return null;
  };
};

// node_modules/devextreme/esm/common/core/localization/cldr-data/first_day_of_week_data.js
var first_day_of_week_data_default = {
  "af-NA": 1,
  agq: 1,
  ak: 1,
  ar: 6,
  "ar-EH": 1,
  "ar-ER": 1,
  "ar-KM": 1,
  "ar-LB": 1,
  "ar-MA": 1,
  "ar-MR": 1,
  "ar-PS": 1,
  "ar-SO": 1,
  "ar-SS": 1,
  "ar-TD": 1,
  "ar-TN": 1,
  asa: 1,
  ast: 1,
  az: 1,
  "az-Cyrl": 1,
  bas: 1,
  be: 1,
  bem: 1,
  bez: 1,
  bg: 1,
  bm: 1,
  br: 1,
  bs: 1,
  "bs-Cyrl": 1,
  ca: 1,
  ce: 1,
  cgg: 1,
  ckb: 6,
  cs: 1,
  cy: 1,
  da: 1,
  de: 1,
  dje: 1,
  dsb: 1,
  dua: 1,
  dyo: 1,
  ee: 1,
  el: 1,
  "en-001": 1,
  "en-AE": 6,
  "en-BI": 1,
  "en-MP": 1,
  "en-MV": 5,
  "en-SD": 6,
  eo: 1,
  es: 1,
  et: 1,
  eu: 1,
  ewo: 1,
  fa: 6,
  ff: 1,
  "ff-Adlm": 1,
  fi: 1,
  fo: 1,
  fr: 1,
  "fr-DJ": 6,
  "fr-DZ": 6,
  "fr-SY": 6,
  fur: 1,
  fy: 1,
  ga: 1,
  gd: 1,
  gl: 1,
  gsw: 1,
  gv: 1,
  ha: 1,
  hr: 1,
  hsb: 1,
  hu: 1,
  hy: 1,
  ia: 1,
  ig: 1,
  is: 1,
  it: 1,
  jgo: 1,
  jmc: 1,
  ka: 1,
  kab: 6,
  kde: 1,
  kea: 1,
  khq: 1,
  kk: 1,
  kkj: 1,
  kl: 1,
  "ko-KP": 1,
  ksb: 1,
  ksf: 1,
  ksh: 1,
  ku: 1,
  kw: 1,
  ky: 1,
  lag: 1,
  lb: 1,
  lg: 1,
  ln: 1,
  lrc: 6,
  lt: 1,
  lu: 1,
  lv: 1,
  "mas-TZ": 1,
  mfe: 1,
  mg: 1,
  mgo: 1,
  mi: 1,
  mk: 1,
  mn: 1,
  ms: 1,
  mua: 1,
  mzn: 6,
  naq: 1,
  nds: 1,
  nl: 1,
  nmg: 1,
  nnh: 1,
  no: 1,
  nus: 1,
  nyn: 1,
  os: 1,
  pcm: 1,
  pl: 1,
  ps: 6,
  "pt-AO": 1,
  "pt-CH": 1,
  "pt-CV": 1,
  "pt-GQ": 1,
  "pt-GW": 1,
  "pt-LU": 1,
  "pt-ST": 1,
  "pt-TL": 1,
  "qu-BO": 1,
  "qu-EC": 1,
  rm: 1,
  rn: 1,
  ro: 1,
  rof: 1,
  ru: 1,
  rw: 1,
  rwk: 1,
  sah: 1,
  sbp: 1,
  sc: 1,
  se: 1,
  ses: 1,
  sg: 1,
  shi: 1,
  "shi-Latn": 1,
  si: 1,
  sk: 1,
  sl: 1,
  smn: 1,
  so: 1,
  "so-DJ": 6,
  sq: 1,
  sr: 1,
  "sr-Latn": 1,
  sv: 1,
  sw: 1,
  "ta-LK": 1,
  "ta-MY": 1,
  teo: 1,
  tg: 1,
  "ti-ER": 1,
  tk: 1,
  to: 1,
  tr: 1,
  tt: 1,
  twq: 1,
  tzm: 1,
  uk: 1,
  uz: 1,
  "uz-Arab": 6,
  "uz-Cyrl": 1,
  vai: 1,
  "vai-Latn": 1,
  vi: 1,
  vun: 1,
  wae: 1,
  wo: 1,
  xog: 1,
  yav: 1,
  yi: 1,
  yo: 1,
  zgh: 1
};

// node_modules/devextreme/esm/common/core/localization/intl/date.js
var SYMBOLS_TO_REMOVE_REGEX = /[\u200E\u200F]/g;
var NARROW_NO_BREAK_SPACE_REGEX = /[\u202F]/g;
var getIntlFormatter = (format2) => (date) => {
  if (!format2.timeZoneName) {
    const year = date.getFullYear();
    const recognizableAsTwentyCentury = String(year).length < 3;
    const safeYearShift = 400;
    const temporaryYearValue = recognizableAsTwentyCentury ? year + safeYearShift : year;
    const utcDate = new Date(Date.UTC(temporaryYearValue, date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds()));
    if (recognizableAsTwentyCentury) {
      utcDate.setFullYear(year);
    }
    const utcFormat = extend({
      timeZone: "UTC"
    }, format2);
    return formatDateTime(utcDate, utcFormat);
  }
  return formatDateTime(date, format2);
};
var formattersCache2 = {};
var getFormatter4 = (format2) => {
  const key = core_default.locale() + "/" + JSON.stringify(format2);
  if (!formattersCache2[key]) {
    formattersCache2[key] = new Intl.DateTimeFormat(core_default.locale(), format2).format;
  }
  return formattersCache2[key];
};
function formatDateTime(date, format2) {
  return getFormatter4(format2)(date).replace(SYMBOLS_TO_REMOVE_REGEX, "").replace(NARROW_NO_BREAK_SPACE_REGEX, " ");
}
var formatNumber = (number) => new Intl.NumberFormat(core_default.locale()).format(number);
var getAlternativeNumeralsMap = /* @__PURE__ */ (() => {
  const numeralsMapCache = {};
  return (locale) => {
    if (!(locale in numeralsMapCache)) {
      if ("0" === formatNumber(0)) {
        numeralsMapCache[locale] = false;
        return false;
      }
      numeralsMapCache[locale] = {};
      for (let i = 0; i < 10; ++i) {
        numeralsMapCache[locale][formatNumber(i)] = i;
      }
    }
    return numeralsMapCache[locale];
  };
})();
var normalizeNumerals = (dateString) => {
  const alternativeNumeralsMap = getAlternativeNumeralsMap(core_default.locale());
  if (!alternativeNumeralsMap) {
    return dateString;
  }
  return dateString.split("").map((sign2) => sign2 in alternativeNumeralsMap ? String(alternativeNumeralsMap[sign2]) : sign2).join("");
};
var removeLeadingZeroes = (str) => str.replace(/(\D)0+(\d)/g, "$1$2");
var dateStringEquals = (actual, expected) => removeLeadingZeroes(actual) === removeLeadingZeroes(expected);
var normalizeMonth = (text) => text.replace("d’", "de ");
var intlFormats = {
  day: {
    day: "numeric"
  },
  date: {
    year: "numeric",
    month: "long",
    day: "numeric"
  },
  dayofweek: {
    weekday: "long"
  },
  longdate: {
    weekday: "long",
    year: "numeric",
    month: "long",
    day: "numeric"
  },
  longdatelongtime: {
    weekday: "long",
    year: "numeric",
    month: "long",
    day: "numeric",
    hour: "numeric",
    minute: "numeric",
    second: "numeric"
  },
  longtime: {
    hour: "numeric",
    minute: "numeric",
    second: "numeric"
  },
  month: {
    month: "long"
  },
  monthandday: {
    month: "long",
    day: "numeric"
  },
  monthandyear: {
    year: "numeric",
    month: "long"
  },
  shortdate: {},
  shorttime: {
    hour: "numeric",
    minute: "numeric"
  },
  shortyear: {
    year: "2-digit"
  },
  year: {
    year: "numeric"
  }
};
Object.defineProperty(intlFormats, "shortdateshorttime", {
  get: function() {
    const defaultOptions4 = Intl.DateTimeFormat(core_default.locale()).resolvedOptions();
    return {
      year: defaultOptions4.year,
      month: defaultOptions4.month,
      day: defaultOptions4.day,
      hour: "numeric",
      minute: "numeric"
    };
  }
});
var getIntlFormat = (format2) => "string" === typeof format2 && intlFormats[format2.toLowerCase()];
var monthNameStrategies = {
  standalone: function(monthIndex, monthFormat) {
    const date = new Date(1999, monthIndex, 13, 1);
    const dateString = getIntlFormatter({
      month: monthFormat
    })(date);
    return dateString;
  },
  format: function(monthIndex, monthFormat) {
    const date = new Date(0, monthIndex, 13, 1);
    const dateString = normalizeMonth(getIntlFormatter({
      day: "numeric",
      month: monthFormat
    })(date));
    const parts = dateString.split(" ").filter((part) => part.indexOf("13") < 0);
    if (1 === parts.length) {
      return parts[0];
    } else if (2 === parts.length) {
      return parts[0].length > parts[1].length ? parts[0] : parts[1];
    }
    return monthNameStrategies.standalone(monthIndex, monthFormat);
  }
};
var date_default2 = {
  engine: function() {
    return "intl";
  },
  getMonthNames: function(format2, type2) {
    const monthFormat = {
      wide: "long",
      abbreviated: "short",
      narrow: "narrow"
    }[format2 || "wide"];
    type2 = "format" === type2 ? type2 : "standalone";
    return Array.apply(null, new Array(12)).map((_, monthIndex) => monthNameStrategies[type2](monthIndex, monthFormat));
  },
  getDayNames: function(format2) {
    const result2 = ((format3) => Array.apply(null, new Array(7)).map((_, dayIndex) => getIntlFormatter({
      weekday: format3
    })(new Date(0, 0, dayIndex))))({
      wide: "long",
      abbreviated: "short",
      short: "narrow",
      narrow: "narrow"
    }[format2 || "wide"]);
    return result2;
  },
  getPeriodNames: function() {
    const hour12Formatter = getIntlFormatter({
      hour: "numeric",
      hour12: true
    });
    return [1, 13].map((hours) => {
      const hourNumberText = formatNumber(1);
      const timeParts = hour12Formatter(new Date(0, 0, 1, hours)).split(hourNumberText);
      if (2 !== timeParts.length) {
        return "";
      }
      const biggerPart = timeParts[0].length > timeParts[1].length ? timeParts[0] : timeParts[1];
      return biggerPart.trim();
    });
  },
  format: function(date, format2) {
    if (!date) {
      return;
    }
    if (!format2) {
      return date;
    }
    if ("function" !== typeof format2 && !format2.formatter) {
      format2 = format2.type || format2;
    }
    const intlFormat = getIntlFormat(format2);
    if (intlFormat) {
      return getIntlFormatter(intlFormat)(date);
    }
    const formatType = typeof format2;
    if (format2.formatter || "function" === formatType || "string" === formatType) {
      return this.callBase.apply(this, arguments);
    }
    return getIntlFormatter(format2)(date);
  },
  parse: function(dateString, format2) {
    let formatter;
    if (format2 && !format2.parser && "string" === typeof dateString) {
      dateString = normalizeMonth(dateString);
      formatter = (date) => normalizeMonth(this.format(date, format2));
    }
    return this.callBase(dateString, formatter || format2);
  },
  _parseDateBySimpleFormat: function(dateString, format2) {
    dateString = normalizeNumerals(dateString);
    const formatParts = this.getFormatParts(format2);
    const dateParts = dateString.split(/\D+/).filter((part) => part.length > 0);
    if (formatParts.length !== dateParts.length) {
      return;
    }
    const dateArgs = this._generateDateArgs(formatParts, dateParts);
    const constructValidDate = (ampmShift) => {
      const parsedDate = ((dateArgs2, ampmShift2) => {
        const hoursShift = ampmShift2 ? 12 : 0;
        return new Date(dateArgs2.year, dateArgs2.month, dateArgs2.day, (dateArgs2.hours + hoursShift) % 24, dateArgs2.minutes, dateArgs2.seconds);
      })(dateArgs, ampmShift);
      if (dateStringEquals(normalizeNumerals(this.format(parsedDate, format2)), dateString)) {
        return parsedDate;
      }
    };
    return constructValidDate(false) || constructValidDate(true);
  },
  _generateDateArgs: function(formatParts, dateParts) {
    const currentDate = /* @__PURE__ */ new Date();
    const dateArgs = {
      year: currentDate.getFullYear(),
      month: currentDate.getMonth(),
      day: currentDate.getDate(),
      hours: 0,
      minutes: 0,
      seconds: 0
    };
    formatParts.forEach((formatPart, index2) => {
      const datePart = dateParts[index2];
      let parsed = parseInt(datePart, 10);
      if ("month" === formatPart) {
        parsed -= 1;
      }
      dateArgs[formatPart] = parsed;
    });
    return dateArgs;
  },
  formatUsesMonthName: function(format2) {
    if ("object" === typeof format2 && !(format2.type || format2.format)) {
      return "long" === format2.month;
    }
    return this.callBase.apply(this, arguments);
  },
  formatUsesDayName: function(format2) {
    if ("object" === typeof format2 && !(format2.type || format2.format)) {
      return "long" === format2.weekday;
    }
    return this.callBase.apply(this, arguments);
  },
  getTimeSeparator: function() {
    return normalizeNumerals(formatDateTime(new Date(2001, 1, 1, 11, 11), {
      hour: "numeric",
      minute: "numeric",
      hour12: false
    })).replace(/\d/g, "");
  },
  getFormatParts: function(format2) {
    if ("string" === typeof format2) {
      return this.callBase(format2);
    }
    const intlFormat = extend({}, intlFormats[format2.toLowerCase()]);
    const date = new Date(2001, 2, 4, 5, 6, 7);
    let formattedDate = getIntlFormatter(intlFormat)(date);
    formattedDate = normalizeNumerals(formattedDate);
    return [{
      name: "year",
      value: 1
    }, {
      name: "month",
      value: 3
    }, {
      name: "day",
      value: 4
    }, {
      name: "hours",
      value: 5
    }, {
      name: "minutes",
      value: 6
    }, {
      name: "seconds",
      value: 7
    }].map((part) => ({
      name: part.name,
      index: formattedDate.indexOf(part.value)
    })).filter((part) => part.index > -1).sort((a, b) => a.index - b.index).map((part) => part.name);
  }
};

// node_modules/devextreme/esm/common/core/localization/date.js
var hasIntl2 = "undefined" !== typeof Intl;
var FORMATS_TO_PATTERN_MAP = {
  shortdate: "M/d/y",
  shorttime: "h:mm a",
  longdate: "EEEE, MMMM d, y",
  longtime: "h:mm:ss a",
  monthandday: "MMMM d",
  monthandyear: "MMMM y",
  quarterandyear: "QQQ y",
  day: "d",
  year: "y",
  shortdateshorttime: "M/d/y, h:mm a",
  longdatelongtime: "EEEE, MMMM d, y, h:mm:ss a",
  month: "LLLL",
  shortyear: "yy",
  dayofweek: "EEEE",
  quarter: "QQQ",
  hour: "HH",
  minute: "mm",
  second: "ss",
  millisecond: "SSS",
  "datetime-local": "yyyy-MM-ddTHH':'mm':'ss"
};
var possiblePartPatterns = {
  year: ["y", "yy", "yyyy"],
  day: ["d", "dd"],
  month: ["M", "MM", "MMM", "MMMM"],
  hours: ["H", "HH", "h", "hh", "ah"],
  minutes: ["m", "mm"],
  seconds: ["s", "ss"],
  milliseconds: ["S", "SS", "SSS"]
};
var dateLocalization = dependency_injector_default({
  engine: function() {
    return "base";
  },
  _getPatternByFormat: function(format2) {
    return FORMATS_TO_PATTERN_MAP[format2.toLowerCase()];
  },
  _expandPattern: function(pattern) {
    return this._getPatternByFormat(pattern) || pattern;
  },
  formatUsesMonthName: function(format2) {
    return -1 !== this._expandPattern(format2).indexOf("MMMM");
  },
  formatUsesDayName: function(format2) {
    return -1 !== this._expandPattern(format2).indexOf("EEEE");
  },
  getFormatParts: function(format2) {
    const pattern = this._getPatternByFormat(format2) || format2;
    const result2 = [];
    each(pattern.split(/\W+/), (_, formatPart) => {
      each(possiblePartPatterns, (partName, possiblePatterns) => {
        if (possiblePatterns.includes(formatPart)) {
          result2.push(partName);
        }
      });
    });
    return result2;
  },
  getMonthNames: function(format2) {
    return default_date_names_default.getMonthNames(format2);
  },
  getDayNames: function(format2) {
    return default_date_names_default.getDayNames(format2);
  },
  getQuarterNames: function(format2) {
    return default_date_names_default.getQuarterNames(format2);
  },
  getPeriodNames: function(format2) {
    return default_date_names_default.getPeriodNames(format2);
  },
  getTimeSeparator: function() {
    return ":";
  },
  is24HourFormat: function(format2) {
    const amTime = new Date(2017, 0, 20, 11, 0, 0, 0);
    const pmTime = new Date(2017, 0, 20, 23, 0, 0, 0);
    const amTimeFormatted = this.format(amTime, format2);
    const pmTimeFormatted = this.format(pmTime, format2);
    for (let i = 0; i < amTimeFormatted.length; i++) {
      if (amTimeFormatted[i] !== pmTimeFormatted[i]) {
        return !isNaN(parseInt(amTimeFormatted[i]));
      }
    }
  },
  format: function(date, format2) {
    if (!date) {
      return;
    }
    if (!format2) {
      return date;
    }
    let formatter;
    if ("function" === typeof format2) {
      formatter = format2;
    } else if (format2.formatter) {
      formatter = format2.formatter;
    } else {
      format2 = format2.type || format2;
      if (isString(format2)) {
        format2 = FORMATS_TO_PATTERN_MAP[format2.toLowerCase()] || format2;
        return number_default2.convertDigits(getFormatter(format2, this)(date));
      }
    }
    if (!formatter) {
      return;
    }
    return formatter(date);
  },
  parse: function(text, format2) {
    const that = this;
    let ldmlFormat;
    let formatter;
    if (!text) {
      return;
    }
    if (!format2) {
      return this.parse(text, "shortdate");
    }
    if (format2.parser) {
      return format2.parser(text);
    }
    if ("string" === typeof format2 && !FORMATS_TO_PATTERN_MAP[format2.toLowerCase()]) {
      ldmlFormat = format2;
    } else {
      formatter = (value2) => {
        const text2 = that.format(value2, format2);
        return number_default2.convertDigits(text2, true);
      };
      try {
        ldmlFormat = getFormat2(formatter);
      } catch (e) {
      }
    }
    if (ldmlFormat) {
      text = number_default2.convertDigits(text, true);
      return getParser(ldmlFormat, this)(text);
    }
    errors_default.log("W0012");
    const result2 = new Date(text);
    if (!result2 || isNaN(result2.getTime())) {
      return;
    }
    return result2;
  },
  firstDayOfWeekIndex: function() {
    const index2 = core_default.getValueByClosestLocale((locale) => first_day_of_week_data_default[locale]);
    return void 0 === index2 ? 0 : index2;
  }
});
if (hasIntl2) {
  dateLocalization.inject(date_default2);
}
var date_default3 = dateLocalization;

// node_modules/devextreme/esm/format_helper.js
var format_helper_default = dependency_injector_default({
  format: function(value2, format2) {
    const formatIsValid = isString(format2) && "" !== format2 || isPlainObject(format2) || isFunction(format2);
    const valueIsValid = isNumeric(value2) || isDate(value2);
    if (!formatIsValid || !valueIsValid) {
      return isDefined(value2) ? value2.toString() : "";
    }
    if (isFunction(format2)) {
      return format2(value2);
    }
    if (isString(format2)) {
      format2 = {
        type: format2
      };
    }
    if (isNumeric(value2)) {
      return number_default2.format(value2, format2);
    }
    if (isDate(value2)) {
      return date_default3.format(value2, format2);
    }
  },
  getTimeFormat: function(showSecond) {
    return showSecond ? "longtime" : "shorttime";
  },
  _normalizeFormat: function(format2) {
    if (!Array.isArray(format2)) {
      return format2;
    }
    if (1 === format2.length) {
      return format2[0];
    }
    return function(date) {
      return format2.map(function(formatPart) {
        return date_default3.format(date, formatPart);
      }).join(" ");
    };
  },
  getDateFormatByDifferences: function(dateDifferences, intervalFormat) {
    const resultFormat = [];
    const needSpecialSecondFormatter = intervalFormat && dateDifferences.millisecond && !(dateDifferences.year || dateDifferences.month || dateDifferences.day);
    if (needSpecialSecondFormatter) {
      const secondFormatter = function(date) {
        return date.getSeconds() + date.getMilliseconds() / 1e3 + "s";
      };
      resultFormat.push(secondFormatter);
    } else if (dateDifferences.millisecond) {
      resultFormat.push("millisecond");
    }
    if (dateDifferences.hour || dateDifferences.minute || !needSpecialSecondFormatter && dateDifferences.second) {
      resultFormat.unshift(this.getTimeFormat(dateDifferences.second));
    }
    if (dateDifferences.year && dateDifferences.month && dateDifferences.day) {
      if (intervalFormat && "month" === intervalFormat) {
        return "monthandyear";
      } else {
        resultFormat.unshift("shortdate");
        return this._normalizeFormat(resultFormat);
      }
    }
    if (dateDifferences.year && dateDifferences.month) {
      return "monthandyear";
    }
    if (dateDifferences.year && dateDifferences.quarter) {
      return "quarterandyear";
    }
    if (dateDifferences.year) {
      return "year";
    }
    if (dateDifferences.quarter) {
      return "quarter";
    }
    if (dateDifferences.month && dateDifferences.day) {
      if (intervalFormat) {
        const monthDayFormatter = function(date) {
          return date_default3.getMonthNames("abbreviated")[date.getMonth()] + " " + date_default3.format(date, "day");
        };
        resultFormat.unshift(monthDayFormatter);
      } else {
        resultFormat.unshift("monthandday");
      }
      return this._normalizeFormat(resultFormat);
    }
    if (dateDifferences.month) {
      return "month";
    }
    if (dateDifferences.day) {
      if (intervalFormat) {
        resultFormat.unshift("day");
      } else {
        const dayFormatter = function(date) {
          return date_default3.format(date, "dayofweek") + ", " + date_default3.format(date, "day");
        };
        resultFormat.unshift(dayFormatter);
      }
      return this._normalizeFormat(resultFormat);
    }
    return this._normalizeFormat(resultFormat);
  },
  getDateFormatByTicks: function(ticks) {
    let maxDiff;
    let currentDiff;
    let i;
    if (ticks.length > 1) {
      maxDiff = date_default.getDatesDifferences(ticks[0], ticks[1]);
      for (i = 1; i < ticks.length - 1; i++) {
        currentDiff = date_default.getDatesDifferences(ticks[i], ticks[i + 1]);
        if (maxDiff.count < currentDiff.count) {
          maxDiff = currentDiff;
        }
      }
    } else {
      maxDiff = {
        year: true,
        month: true,
        day: true,
        hour: ticks[0].getHours() > 0,
        minute: ticks[0].getMinutes() > 0,
        second: ticks[0].getSeconds() > 0,
        millisecond: ticks[0].getMilliseconds() > 0
      };
    }
    const resultFormat = this.getDateFormatByDifferences(maxDiff);
    return resultFormat;
  },
  getDateFormatByTickInterval: function(startValue, endValue, tickInterval) {
    let dateUnitInterval;
    const correctDateDifferences = function(dateDifferences2, tickInterval2, value2) {
      switch (tickInterval2) {
        case "year":
        case "quarter":
          dateDifferences2.month = value2;
        case "month":
          dateDifferences2.day = value2;
        case "week":
        case "day":
          dateDifferences2.hour = value2;
        case "hour":
          dateDifferences2.minute = value2;
        case "minute":
          dateDifferences2.second = value2;
        case "second":
          dateDifferences2.millisecond = value2;
      }
    };
    tickInterval = isString(tickInterval) ? tickInterval.toLowerCase() : tickInterval;
    const dateDifferences = date_default.getDatesDifferences(startValue, endValue);
    if (startValue !== endValue) {
      !function(differences, minDate, maxDate) {
        if (!maxDate.getMilliseconds() && maxDate.getSeconds()) {
          if (maxDate.getSeconds() - minDate.getSeconds() === 1) {
            differences.millisecond = true;
            differences.second = false;
          }
        } else if (!maxDate.getSeconds() && maxDate.getMinutes()) {
          if (maxDate.getMinutes() - minDate.getMinutes() === 1) {
            differences.second = true;
            differences.minute = false;
          }
        } else if (!maxDate.getMinutes() && maxDate.getHours()) {
          if (maxDate.getHours() - minDate.getHours() === 1) {
            differences.minute = true;
            differences.hour = false;
          }
        } else if (!maxDate.getHours() && maxDate.getDate() > 1) {
          if (maxDate.getDate() - minDate.getDate() === 1) {
            differences.hour = true;
            differences.day = false;
          }
        } else if (1 === maxDate.getDate() && maxDate.getMonth()) {
          if (maxDate.getMonth() - minDate.getMonth() === 1) {
            differences.day = true;
            differences.month = false;
          }
        } else if (!maxDate.getMonth() && maxDate.getFullYear()) {
          if (maxDate.getFullYear() - minDate.getFullYear() === 1) {
            differences.month = true;
            differences.year = false;
          }
        }
      }(dateDifferences, startValue > endValue ? endValue : startValue, startValue > endValue ? startValue : endValue);
    }
    dateUnitInterval = date_default.getDateUnitInterval(dateDifferences);
    correctDateDifferences(dateDifferences, dateUnitInterval, true);
    dateUnitInterval = date_default.getDateUnitInterval(tickInterval || "second");
    correctDateDifferences(dateDifferences, dateUnitInterval, false);
    dateDifferences[{
      week: "day"
    }[dateUnitInterval] || dateUnitInterval] = true;
    const resultFormat = this.getDateFormatByDifferences(dateDifferences);
    return resultFormat;
  }
});

// node_modules/devextreme/esm/__internal/core/m_component_registrator_callbacks.js
var componentRegistratorCallbacks = new memorized_callbacks_default();

// node_modules/devextreme/esm/core/component_registrator_callbacks.js
var component_registrator_callbacks_default = componentRegistratorCallbacks;

// node_modules/devextreme/esm/__internal/core/m_component_registrator.js
var registerComponent = function(name2, namespace, componentClass) {
  if (!componentClass) {
    componentClass = namespace;
  } else {
    namespace[name2] = componentClass;
  }
  getName(componentClass, name2);
  component_registrator_callbacks_default.fire(name2, componentClass);
};
var registerRendererComponent = function(name2, componentClass) {
  renderer_default.fn[name2] = function(options2) {
    const isMemberInvoke = "string" === typeof options2;
    let result2;
    if (isMemberInvoke) {
      const memberName = options2;
      const memberArgs = [].slice.call(arguments).slice(1);
      this.each(function() {
        const instance = componentClass.getInstance(this);
        if (!instance) {
          throw errors_default.Error("E0009", name2);
        }
        const member = instance[memberName];
        const memberValue = member.apply(instance, memberArgs);
        if (void 0 === result2) {
          result2 = memberValue;
        }
      });
    } else {
      this.each(function() {
        const instance = componentClass.getInstance(this);
        if (instance) {
          instance.option(options2);
        } else {
          new componentClass(this, options2);
        }
      });
      result2 = this;
    }
    return result2;
  };
};
component_registrator_callbacks_default.add(registerRendererComponent);

// node_modules/devextreme/esm/core/component_registrator.js
var component_registrator_default = registerComponent;

// node_modules/devextreme/esm/ui/themes_callback.js
var themeReadyCallback = callbacks_default();

// node_modules/devextreme/esm/ui/themes.js
var window15 = getWindow();
var ready3 = ready_callbacks_default.add;
var viewPort = value;
var viewPortChanged = changeCallback;
var initDeferred = new Deferred();
var DX_LINK_SELECTOR = "link[rel=dx-theme]";
var THEME_ATTR = "data-theme";
var ACTIVE_ATTR = "data-active";
var context;
var $activeThemeLink;
var knownThemes;
var currentThemeName;
var pendingThemeName;
var defaultTimeout = 15e3;
function readThemeMarker() {
  if (!hasWindow()) {
    return null;
  }
  const element = renderer_default("<div>", context).addClass("dx-theme-marker").appendTo(context.documentElement);
  let result2;
  try {
    result2 = window15.getComputedStyle(element.get(0)).fontFamily;
    if (!result2) {
      return null;
    }
    result2 = result2.replace(/["']/g, "");
    if ("dx." !== result2.substr(0, 3)) {
      return null;
    }
    return result2.substr(3);
  } finally {
    element.remove();
  }
}
function waitForThemeLoad(themeName) {
  let waitStartTime;
  let timerId;
  let intervalCleared = true;
  pendingThemeName = themeName;
  function handleLoaded() {
    pendingThemeName = null;
    clearInterval(timerId);
    intervalCleared = true;
    themeReadyCallback.fire();
    themeReadyCallback.empty();
    initDeferred.resolve();
  }
  if (isPendingThemeLoaded() || !defaultTimeout) {
    handleLoaded();
  } else {
    if (!intervalCleared) {
      if (pendingThemeName) {
        pendingThemeName = themeName;
      }
      return;
    }
    waitStartTime = Date.now();
    intervalCleared = false;
    timerId = setInterval(function() {
      const isLoaded = isPendingThemeLoaded();
      const isTimeout = !isLoaded && Date.now() - waitStartTime > defaultTimeout;
      if (isTimeout) {
        ui_errors_default.log("W0004", pendingThemeName);
      }
      if (isLoaded || isTimeout) {
        handleLoaded();
      }
    }, 10);
  }
}
function isPendingThemeLoaded() {
  if (!pendingThemeName) {
    return true;
  }
  const anyThemePending = "any" === pendingThemeName;
  if ("resolved" === initDeferred.state() && anyThemePending) {
    return true;
  }
  const themeMarker = readThemeMarker();
  if (themeMarker && anyThemePending) {
    return true;
  }
  return themeMarker === pendingThemeName;
}
function processMarkup() {
  const $allThemeLinks = renderer_default(DX_LINK_SELECTOR, context);
  if (!$allThemeLinks.length) {
    return;
  }
  knownThemes = {};
  $activeThemeLink = renderer_default(parseHTML("<link rel=stylesheet>"), context);
  $allThemeLinks.each(function() {
    const link = renderer_default(this, context);
    const fullThemeName = link.attr(THEME_ATTR);
    const url = link.attr("href");
    const isActive = "true" === link.attr(ACTIVE_ATTR);
    knownThemes[fullThemeName] = {
      url,
      isActive
    };
  });
  $allThemeLinks.last().after($activeThemeLink);
  $allThemeLinks.remove();
}
function resolveFullThemeName(desiredThemeName) {
  const desiredThemeParts = desiredThemeName ? desiredThemeName.split(".") : [];
  let result2 = null;
  if (knownThemes) {
    if (desiredThemeName in knownThemes) {
      return desiredThemeName;
    }
    each(knownThemes, function(knownThemeName, themeData) {
      const knownThemeParts = knownThemeName.split(".");
      if (desiredThemeParts[0] && knownThemeParts[0] !== desiredThemeParts[0]) {
        return;
      }
      if (desiredThemeParts[1] && desiredThemeParts[1] !== knownThemeParts[1]) {
        return;
      }
      if (desiredThemeParts[2] && desiredThemeParts[2] !== knownThemeParts[2]) {
        return;
      }
      if (!result2 || themeData.isActive) {
        result2 = knownThemeName;
      }
      if (themeData.isActive) {
        return false;
      }
    });
  }
  return result2;
}
function initContext(newContext) {
  try {
    if (newContext !== context) {
      knownThemes = null;
    }
  } catch (x) {
    knownThemes = null;
  }
  context = newContext;
}
function init(options2) {
  options2 = options2 || {};
  initContext(options2.context || dom_adapter_default.getDocument());
  if (!context) {
    return;
  }
  processMarkup();
  currentThemeName = void 0;
  current(options2);
}
function current(options2) {
  if (!arguments.length) {
    currentThemeName = currentThemeName || readThemeMarker();
    return currentThemeName;
  }
  detachCssClasses(viewPort());
  options2 = options2 || {};
  if ("string" === typeof options2) {
    options2 = {
      theme: options2
    };
  }
  const isAutoInit = options2._autoInit;
  const loadCallback = options2.loadCallback;
  let currentThemeData;
  currentThemeName = resolveFullThemeName(options2.theme || currentThemeName);
  if (currentThemeName) {
    currentThemeData = knownThemes[currentThemeName];
  }
  if (loadCallback) {
    themeReadyCallback.add(loadCallback);
  }
  if (currentThemeData) {
    $activeThemeLink.attr("href", knownThemes[currentThemeName].url);
    if (themeReadyCallback.has() || "resolved" !== initDeferred.state() || options2._forceTimeout) {
      waitForThemeLoad(currentThemeName);
    }
  } else if (isAutoInit) {
    if (hasWindow()) {
      waitForThemeLoad("any");
    }
    themeReadyCallback.fire();
    themeReadyCallback.empty();
  } else {
    throw ui_errors_default.Error("E0021", currentThemeName);
  }
  initDeferred.done(() => attachCssClasses(originalViewPort(), currentThemeName));
}
function getCssClasses(themeName) {
  themeName = themeName || current();
  const result2 = [];
  const themeNameParts = themeName && themeName.split(".");
  if (themeNameParts) {
    result2.push("dx-theme-" + themeNameParts[0], "dx-theme-" + themeNameParts[0] + "-typography");
    if (themeNameParts.length > 1) {
      result2.push("dx-color-scheme-" + themeNameParts[1] + (isMaterialBased(themeName) ? "-" + themeNameParts[2] : ""));
    }
  }
  return result2;
}
var themeClasses;
function _attachCssClasses(element, themeName) {
  themeClasses = getCssClasses(themeName).join(" ");
  renderer_default(element).addClass(themeClasses);
  !function() {
    const pixelRatio = hasWindow() && window15.devicePixelRatio;
    if (!pixelRatio || pixelRatio < 2) {
      return;
    }
    const $tester = renderer_default("<div>");
    $tester.css("border", ".5px solid transparent");
    renderer_default("body").append($tester);
    if (1 === getOuterHeight($tester)) {
      renderer_default(element).addClass("dx-hairlines");
      themeClasses += " dx-hairlines";
    }
    $tester.remove();
  }();
}
function attachCssClasses(element, themeName) {
  when(uiLayerInitialized).done(() => {
    _attachCssClasses(element, themeName);
  });
}
function detachCssClasses(element) {
  when(uiLayerInitialized).done(() => {
    renderer_default(element).removeClass(themeClasses);
  });
}
function isTheme(themeRegExp, themeName) {
  if (!themeName) {
    themeName = currentThemeName || readThemeMarker();
  }
  return new RegExp(themeRegExp).test(themeName);
}
function isMaterialBased(themeName) {
  return isMaterial(themeName) || isFluent(themeName);
}
function isMaterial(themeName) {
  return isTheme("material", themeName);
}
function isFluent(themeName) {
  return isTheme("fluent", themeName);
}
function isGeneric(themeName) {
  return isTheme("generic", themeName);
}
function isWebFontLoaded(text, fontWeight) {
  const document2 = dom_adapter_default.getDocument();
  const testElement = document2.createElement("span");
  testElement.style.position = "absolute";
  testElement.style.top = "-9999px";
  testElement.style.left = "-9999px";
  testElement.style.visibility = "hidden";
  testElement.style.fontFamily = "Arial";
  testElement.style.fontSize = "250px";
  testElement.style.fontWeight = fontWeight;
  testElement.innerHTML = text;
  document2.body.appendChild(testElement);
  const etalonFontWidth = testElement.offsetWidth;
  testElement.style.fontFamily = "Roboto, RobotoFallback, Arial";
  const testedFontWidth = testElement.offsetWidth;
  testElement.parentNode.removeChild(testElement);
  return etalonFontWidth !== testedFontWidth;
}
function waitWebFont(text, fontWeight) {
  return new Promise((resolve) => {
    const clear = () => {
      clearInterval(intervalId);
      clearTimeout(timeoutId);
      resolve();
    };
    const intervalId = setInterval(() => {
      if (isWebFontLoaded(text, fontWeight)) {
        clear();
      }
    }, 15);
    const timeoutId = setTimeout(clear, 2e3);
  });
}
function autoInit() {
  init({
    _autoInit: true,
    _forceTimeout: true
  });
  if (renderer_default(DX_LINK_SELECTOR, context).length) {
    throw ui_errors_default.Error("E0022");
  }
}
if (hasWindow()) {
  autoInit();
} else {
  ready3(autoInit);
}
viewPortChanged.add(function(viewPort2, prevViewPort) {
  initDeferred.done(function() {
    detachCssClasses(prevViewPort);
    attachCssClasses(viewPort2);
  });
});
devices_default.changed.add(function() {
  init({
    _autoInit: true
  });
});

// node_modules/devextreme/esm/__internal/events/core/m_emitter.feedback.js
var ACTIVE_EVENT_NAME = "dxactive";
var FeedbackEvent = class_default.inherit({
  ctor(timeout, fire) {
    this._timeout = timeout;
    this._fire = fire;
  },
  start() {
    const that = this;
    this._schedule(() => {
      that.force();
    });
  },
  _schedule(fn) {
    this.stop();
    this._timer = setTimeout(fn, this._timeout);
  },
  stop() {
    clearTimeout(this._timer);
  },
  force() {
    if (this._fired) {
      return;
    }
    this.stop();
    this._fire();
    this._fired = true;
  },
  fired() {
    return this._fired;
  }
});
var activeFeedback;
var FeedbackEmitter = m_emitter_default.inherit({
  ctor() {
    this.callBase.apply(this, arguments);
    this._active = new FeedbackEvent(0, noop2);
    this._inactive = new FeedbackEvent(0, noop2);
  },
  configure(data17, eventName) {
    switch (eventName) {
      case "dxactive":
        data17.activeTimeout = data17.timeout;
        break;
      case "dxinactive":
        data17.inactiveTimeout = data17.timeout;
    }
    this.callBase(data17);
  },
  start(e) {
    if (activeFeedback) {
      const activeChildExists = contains2(this.getElement().get(0), activeFeedback.getElement().get(0));
      const childJustActivated = !activeFeedback._active.fired();
      if (activeChildExists && childJustActivated) {
        this._cancel();
        return;
      }
      activeFeedback._inactive.force();
    }
    activeFeedback = this;
    this._initEvents(e);
    this._active.start();
  },
  _initEvents(e) {
    const that = this;
    const eventTarget = this._getEmitterTarget(e);
    const mouseEvent = isMouseEvent(e);
    const isSimulator = m_devices_default.isSimulator();
    const deferFeedback = isSimulator || !mouseEvent;
    const activeTimeout = ensureDefined(this.activeTimeout, 30);
    const inactiveTimeout = ensureDefined(this.inactiveTimeout, 400);
    this._active = new FeedbackEvent(deferFeedback ? activeTimeout : 0, () => {
      that._fireEvent("dxactive", e, {
        target: eventTarget
      });
    });
    this._inactive = new FeedbackEvent(deferFeedback ? inactiveTimeout : 0, () => {
      that._fireEvent("dxinactive", e, {
        target: eventTarget
      });
      activeFeedback = null;
    });
  },
  cancel(e) {
    this.end(e);
  },
  end(e) {
    const skipTimers = e.type !== m_pointer_default.up;
    if (skipTimers) {
      this._active.stop();
    } else {
      this._active.force();
    }
    this._inactive.start();
    if (skipTimers) {
      this._inactive.force();
    }
  },
  dispose() {
    this._active.stop();
    this._inactive.stop();
    if (activeFeedback === this) {
      activeFeedback = null;
    }
    this.callBase();
  },
  lockInactive() {
    this._active.force();
    this._inactive.stop();
    activeFeedback = null;
    this._cancel();
    return this._inactive.force.bind(this._inactive);
  }
});
FeedbackEmitter.lock = function(deferred) {
  const lockInactive = activeFeedback ? activeFeedback.lockInactive() : noop2;
  deferred.done(lockInactive);
};
m_emitter_registrator_default({
  emitter: FeedbackEmitter,
  events: ["dxactive", "dxinactive"]
});
var {
  lock
} = FeedbackEmitter;

// node_modules/devextreme/esm/__internal/events/m_hover.js
var HOVERSTART = "dxhoverstart";
var POINTERENTER_NAMESPACED_EVENT_NAME = addNamespace2(m_pointer_default.enter, "dxHoverStart");
var HOVEREND = "dxhoverend";
var POINTERLEAVE_NAMESPACED_EVENT_NAME = addNamespace2(m_pointer_default.leave, "dxHoverEnd");
var Hover = class_default.inherit({
  noBubble: true,
  ctor() {
    this._handlerArrayKeyPath = `${this._eventNamespace}_HandlerStore`;
  },
  setup(element) {
    data(element, this._handlerArrayKeyPath, {});
  },
  add(element, handleObj) {
    const that = this;
    const handler = function(e) {
      that._handler(e);
    };
    m_events_engine_default.on(element, this._originalEventName, handleObj.selector, handler);
    data(element, this._handlerArrayKeyPath)[handleObj.guid] = handler;
  },
  _handler(e) {
    if (isTouchEvent(e) || m_devices_default.isSimulator()) {
      return;
    }
    fireEvent({
      type: this._eventName,
      originalEvent: e,
      delegateTarget: e.delegateTarget
    });
  },
  remove(element, handleObj) {
    const handler = data(element, this._handlerArrayKeyPath)[handleObj.guid];
    m_events_engine_default.off(element, this._originalEventName, handleObj.selector, handler);
  },
  teardown(element) {
    removeData(element, this._handlerArrayKeyPath);
  }
});
var HoverStart = Hover.inherit({
  ctor() {
    this._eventNamespace = "dxHoverStart";
    this._eventName = HOVERSTART;
    this._originalEventName = POINTERENTER_NAMESPACED_EVENT_NAME;
    this.callBase();
  },
  _handler(e) {
    const pointers = e.pointers || [];
    if (!pointers.length) {
      this.callBase(e);
    }
  }
});
var HoverEnd = Hover.inherit({
  ctor() {
    this._eventNamespace = "dxHoverEnd";
    this._eventName = HOVEREND;
    this._originalEventName = POINTERLEAVE_NAMESPACED_EVENT_NAME;
    this.callBase();
  }
});
m_event_registrator_default(HOVERSTART, new HoverStart());
m_event_registrator_default(HOVEREND, new HoverEnd());

// node_modules/devextreme/esm/__internal/events/core/m_keyboard_processor.js
var NAMESPACE = "KeyboardProcessor";
var createKeyDownOptions = (e) => ({
  keyName: normalizeKeyName(e),
  key: e.key,
  code: e.code,
  ctrl: e.ctrlKey,
  location: e.location,
  metaKey: e.metaKey,
  shift: e.shiftKey,
  alt: e.altKey,
  which: e.which,
  originalEvent: e
});
var KeyboardProcessor = class_default.inherit({
  _keydown: addNamespace2("keydown", NAMESPACE),
  _compositionStart: addNamespace2("compositionstart", NAMESPACE),
  _compositionEnd: addNamespace2("compositionend", NAMESPACE),
  ctor(options2) {
    options2 = options2 || {};
    if (options2.element) {
      this._element = renderer_default(options2.element);
    }
    if (options2.focusTarget) {
      this._focusTarget = options2.focusTarget;
    }
    this._handler = options2.handler;
    if (this._element) {
      this._processFunction = (e) => {
        const focusTargets = renderer_default(this._focusTarget).toArray();
        const isNotFocusTarget = this._focusTarget && this._focusTarget !== e.target && !focusTargets.includes(e.target);
        const shouldSkipProcessing = this._isComposingJustFinished && 229 === e.which || this._isComposing || isNotFocusTarget;
        this._isComposingJustFinished = false;
        if (!shouldSkipProcessing) {
          this.process(e);
        }
      };
      this._toggleProcessingWithContext = this.toggleProcessing.bind(this);
      m_events_engine_default.on(this._element, this._keydown, this._processFunction);
      m_events_engine_default.on(this._element, this._compositionStart, this._toggleProcessingWithContext);
      m_events_engine_default.on(this._element, this._compositionEnd, this._toggleProcessingWithContext);
    }
  },
  dispose() {
    if (this._element) {
      m_events_engine_default.off(this._element, this._keydown, this._processFunction);
      m_events_engine_default.off(this._element, this._compositionStart, this._toggleProcessingWithContext);
      m_events_engine_default.off(this._element, this._compositionEnd, this._toggleProcessingWithContext);
    }
    this._element = void 0;
    this._handler = void 0;
  },
  process(e) {
    this._handler(createKeyDownOptions(e));
  },
  toggleProcessing(_ref) {
    let {
      type: type2
    } = _ref;
    this._isComposing = "compositionstart" === type2;
    this._isComposingJustFinished = !this._isComposing;
  }
});
KeyboardProcessor.createKeyDownOptions = createKeyDownOptions;
var m_keyboard_processor_default = KeyboardProcessor;

// node_modules/devextreme/esm/__internal/events/m_short.js
function addNamespace3(event, namespace) {
  return namespace ? addNamespace2(event, namespace) : event;
}
function executeAction(action, args) {
  return "function" === typeof action ? action(args) : action.execute(args);
}
var active = {
  on: ($el, active2, inactive, opts) => {
    const {
      selector,
      showTimeout,
      hideTimeout,
      namespace
    } = opts;
    m_events_engine_default.on($el, addNamespace3("dxactive", namespace), selector, {
      timeout: showTimeout
    }, (event) => executeAction(active2, {
      event,
      element: event.currentTarget
    }));
    m_events_engine_default.on($el, addNamespace3("dxinactive", namespace), selector, {
      timeout: hideTimeout
    }, (event) => executeAction(inactive, {
      event,
      element: event.currentTarget
    }));
  },
  off: ($el, _ref) => {
    let {
      namespace,
      selector
    } = _ref;
    m_events_engine_default.off($el, addNamespace3("dxactive", namespace), selector);
    m_events_engine_default.off($el, addNamespace3("dxinactive", namespace), selector);
  }
};
var resize = {
  on: function($el, resize2) {
    let {
      namespace
    } = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
    m_events_engine_default.on($el, addNamespace3("dxresize", namespace), resize2);
  },
  off: function($el) {
    let {
      namespace
    } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    m_events_engine_default.off($el, addNamespace3("dxresize", namespace));
  }
};
var hover = {
  on: ($el, start, end, _ref2) => {
    let {
      selector,
      namespace
    } = _ref2;
    m_events_engine_default.on($el, addNamespace3("dxhoverend", namespace), selector, (event) => end(event));
    m_events_engine_default.on($el, addNamespace3("dxhoverstart", namespace), selector, (event) => executeAction(start, {
      element: event.target,
      event
    }));
  },
  off: ($el, _ref3) => {
    let {
      selector,
      namespace
    } = _ref3;
    m_events_engine_default.off($el, addNamespace3("dxhoverstart", namespace), selector);
    m_events_engine_default.off($el, addNamespace3("dxhoverend", namespace), selector);
  }
};
var visibility = {
  on: ($el, shown, hiding, _ref4) => {
    let {
      namespace
    } = _ref4;
    m_events_engine_default.on($el, addNamespace3("dxhiding", namespace), hiding);
    m_events_engine_default.on($el, addNamespace3("dxshown", namespace), shown);
  },
  off: ($el, _ref5) => {
    let {
      namespace
    } = _ref5;
    m_events_engine_default.off($el, addNamespace3("dxhiding", namespace));
    m_events_engine_default.off($el, addNamespace3("dxshown", namespace));
  }
};
var focus = {
  on: ($el, focusIn, focusOut, _ref6) => {
    let {
      namespace
    } = _ref6;
    m_events_engine_default.on($el, addNamespace3("focusin", namespace), focusIn);
    m_events_engine_default.on($el, addNamespace3("focusout", namespace), focusOut);
  },
  off: ($el, _ref7) => {
    let {
      namespace
    } = _ref7;
    m_events_engine_default.off($el, addNamespace3("focusin", namespace));
    m_events_engine_default.off($el, addNamespace3("focusout", namespace));
  },
  trigger: ($el) => m_events_engine_default.trigger($el, "focus")
};
var dxClick = {
  on: function($el, click2) {
    let {
      namespace
    } = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
    m_events_engine_default.on($el, addNamespace3("dxclick", namespace), click2);
  },
  off: function($el) {
    let {
      namespace
    } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    m_events_engine_default.off($el, addNamespace3("dxclick", namespace));
  }
};
var click = {
  on: function($el, click2) {
    let {
      namespace
    } = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
    m_events_engine_default.on($el, addNamespace3("click", namespace), click2);
  },
  off: function($el) {
    let {
      namespace
    } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    m_events_engine_default.off($el, addNamespace3("click", namespace));
  }
};
var index = 0;
var keyboardProcessors = {};
var generateListenerId = () => "keyboardProcessorId" + index++;
var keyboard = {
  on: (element, focusTarget, handler) => {
    const listenerId = generateListenerId();
    keyboardProcessors[listenerId] = new m_keyboard_processor_default({
      element,
      focusTarget,
      handler
    });
    return listenerId;
  },
  off: (listenerId) => {
    if (listenerId && keyboardProcessors[listenerId]) {
      keyboardProcessors[listenerId].dispose();
      delete keyboardProcessors[listenerId];
    }
  },
  _getProcessor: (listenerId) => keyboardProcessors[listenerId]
};

// node_modules/devextreme/esm/__internal/core/utils/m_version.js
function compare(x, y, maxLevel) {
  function normalizeArg(value2) {
    if ("string" === typeof value2) {
      return value2.split(".");
    }
    if ("number" === typeof value2) {
      return [value2];
    }
    return value2;
  }
  x = normalizeArg(x);
  y = normalizeArg(y);
  let length = Math.max(x.length, y.length);
  if (isFinite(maxLevel)) {
    length = Math.min(length, maxLevel);
  }
  for (let i = 0; i < length; i++) {
    const xItem = parseInt(x[i] || 0, 10);
    const yItem = parseInt(y[i] || 0, 10);
    if (xItem < yItem) {
      return -1;
    }
    if (xItem > yItem) {
      return 1;
    }
  }
  return 0;
}

// node_modules/devextreme/esm/__internal/utils/version.js
var assertedVersions = [];
function stringifyVersion(version2) {
  const {
    major,
    minor,
    patch: patch2
  } = version2;
  return [major, minor, patch2].join(".");
}
function parseVersion(version2) {
  const [major, minor, patch2] = version2.split(".").map(Number);
  return {
    major,
    minor,
    patch: patch2
  };
}
function stringifyVersionList(assertedVersionList) {
  return assertedVersionList.map((assertedVersion) => `${assertedVersion.packageName}: ${assertedVersion.version}`).join("\n");
}
function versionsEqual(versionA, versionB) {
  return versionA.major === versionB.major && versionA.minor === versionB.minor && versionA.patch === versionB.patch;
}
function getPreviousMajorVersion(_ref) {
  let {
    major,
    minor,
    patch: patch2
  } = _ref;
  const previousMajorVersion = 1 === minor ? {
    major: major - 1,
    minor: 2,
    patch: patch2
  } : {
    major,
    minor: minor - 1,
    patch: patch2
  };
  return previousMajorVersion;
}
function assertedVersionsCompatible(currentVersion) {
  const mismatchingVersions = assertedVersions.filter((assertedVersion) => !versionsEqual(parseVersion(assertedVersion.version), currentVersion));
  if (mismatchingVersions.length) {
    errors_default.log("W0023", stringifyVersionList([{
      packageName: "devextreme",
      version: stringifyVersion(currentVersion)
    }, ...mismatchingVersions]));
    return false;
  }
  return true;
}

// node_modules/devextreme/esm/__internal/core/license/byte_utils.js
function base64ToBytes(base64) {
  return new Uint8Array(atob(base64).split("").map((s) => s.charCodeAt(0)));
}
function hexToBytes(string) {
  var _string$match;
  return new Uint8Array((null === (_string$match = string.match(/.{1,2}/g)) || void 0 === _string$match ? void 0 : _string$match.map((byte) => parseInt(byte, 16))) ?? []);
}
function stringToBytes(string) {
  const bytes = new Uint8Array(string.length);
  for (let k = 0; k < string.length; k += 1) {
    bytes[k] = 255 & string.charCodeAt(k);
  }
  return bytes;
}
function wordsToBytes(words) {
  const bytes = new Uint8Array(4 * words.length);
  for (let k = 0; k < bytes.length; k += 1) {
    bytes[k] = words[k >> 2] >>> 8 * (3 - k % 4);
  }
  return bytes;
}
function bytesToWords(bytes) {
  const words = new Uint32Array(1 + (bytes.length - 1 >> 2));
  for (let k = 0; k < bytes.length; k += 1) {
    words[k >> 2] |= bytes[k] << 8 * (3 - k % 4);
  }
  return words;
}
function leftRotate(x, n) {
  return (x << n | x >>> 32 - n) >>> 0;
}
function concatBytes(a, b) {
  const result2 = new Uint8Array(a.length + b.length);
  result2.set(a, 0);
  result2.set(b, a.length);
  return result2;
}

// node_modules/devextreme/esm/__internal/core/license/key.js
var PUBLIC_KEY = {
  e: 65537,
  n: new Uint8Array([200, 219, 153, 203, 140, 7, 228, 253, 193, 243, 62, 137, 139, 60, 68, 242, 48, 142, 113, 88, 185, 235, 253, 105, 80, 74, 32, 170, 96, 74, 111, 250, 7, 205, 154, 3, 146, 115, 153, 53, 45, 132, 123, 56, 61, 208, 184, 201, 63, 24, 109, 223, 0, 179, 169, 102, 139, 224, 73, 233, 45, 173, 138, 66, 98, 88, 69, 76, 177, 111, 113, 218, 192, 33, 101, 152, 25, 134, 34, 173, 32, 82, 230, 44, 247, 200, 253, 170, 192, 246, 30, 12, 96, 205, 100, 249, 181, 93, 0, 231])
};
var INTERNAL_USAGE_ID = "V2QpQmJVXWy6Nexkq9Xk9o";

// node_modules/devextreme/esm/__internal/core/license/pkcs1.js
var ASN1_SHA1 = "3021300906052b0e03021a05000414";
function pad(hash) {
  const dataLength = (8 * PUBLIC_KEY.n.length + 6) / 8;
  const data17 = concatBytes(hexToBytes(ASN1_SHA1), hash);
  if (data17.length + 10 > dataLength) {
    throw Error("Key is too short for SHA1 signing algorithm");
  }
  const padding = new Uint8Array(dataLength - data17.length);
  padding.fill(255, 0, padding.length - 1);
  padding[0] = 0;
  padding[1] = 1;
  padding[padding.length - 1] = 0;
  return concatBytes(padding, data17);
}

// node_modules/devextreme/esm/__internal/core/license/rsa_bigint.js
function compareSignatures(args) {
  try {
    const zero = BigInt(0);
    const one2 = BigInt(1);
    const eight = BigInt(8);
    const modExp = (base2, exponent2, modulus2) => {
      let result2 = one2;
      let b = base2;
      let e = exponent2;
      while (e) {
        if (e & one2) {
          result2 = result2 * b % modulus2;
        }
        b = b * b % modulus2;
        e >>= one2;
      }
      return result2;
    };
    const bigIntFromBytes = (bytes) => bytes.reduce((acc, cur) => (acc << eight) + BigInt(cur), zero);
    const actual = bigIntFromBytes(args.actual);
    const signature = bigIntFromBytes(args.signature);
    const exponent = BigInt(args.key.e);
    const modulus = bigIntFromBytes(args.key.n);
    const expected = modExp(signature, exponent, modulus);
    return expected === actual;
  } catch {
    return true;
  }
}

// node_modules/devextreme/esm/__internal/core/license/sha1.js
function preprocess(text) {
  const bytes = new Uint8Array(text.length + 1);
  bytes.set(stringToBytes(text));
  bytes[bytes.length - 1] = 128;
  const words = bytesToWords(new Uint8Array(bytes));
  const result2 = new Uint32Array(16 * Math.ceil((words.length + 2) / 16));
  result2.set(words, 0);
  result2[result2.length - 1] = 8 * (bytes.length - 1);
  return result2;
}
function sha1(text) {
  const message = preprocess(text);
  const h3 = new Uint32Array([1732584193, 4023233417, 2562383102, 271733878, 3285377520]);
  for (let i = 0; i < message.length; i += 16) {
    const w = new Uint32Array(80);
    for (let j = 0; j < 16; j += 1) {
      w[j] = message[i + j];
    }
    for (let j = 16; j < 80; j += 1) {
      const n = w[j - 3] ^ w[j - 8] ^ w[j - 14] ^ w[j - 16];
      w[j] = n << 1 | n >>> 31;
    }
    let a = h3[0];
    let b = h3[1];
    let c = h3[2];
    let d = h3[3];
    let e = h3[4];
    for (let j = 0; j < 80; j += 1) {
      const [f, k] = j < 20 ? [b & c | ~b & d, 1518500249] : j < 40 ? [b ^ c ^ d, 1859775393] : j < 60 ? [b & c | b & d | c & d, 2400959708] : [b ^ c ^ d, 3395469782];
      const temp = leftRotate(a, 5) + f + e + k + w[j];
      e = d;
      d = c;
      c = leftRotate(b, 30);
      b = a;
      a = temp;
    }
    h3[0] += a;
    h3[1] += b;
    h3[2] += c;
    h3[3] += d;
    h3[4] += e;
  }
  return wordsToBytes(h3);
}

// node_modules/devextreme/esm/__internal/core/license/trial_panel.client.js
var isClient = () => "undefined" !== typeof HTMLElement && "undefined" !== typeof customElements;
var SafeHTMLElement = isClient() ? HTMLElement : class {
};
var componentNames2 = {
  trigger: "dx-license-trigger",
  panel: "dx-license"
};
var attributeNames = {
  buyNow: "buy-now",
  licensingDoc: "licensing-doc",
  version: "version"
};
var commonStyles = {
  opacity: "1",
  visibility: "visible",
  "clip-path": "none",
  filter: "none"
};
var contentStyles = _extends({}, commonStyles, {
  width: "100%",
  height: "auto",
  "line-height": "normal",
  display: "block",
  "z-index": "1500",
  position: "static",
  transform: "translate(0px, 0px)",
  "background-color": "#FF7200",
  border: "none",
  margin: "auto",
  "box-sizing": "border-box",
  "text-align": "center"
});
var containerStyles = _extends({}, contentStyles, {
  display: "flex",
  "align-items": "center",
  "flex-direction": "row",
  position: "relative",
  top: "0px",
  left: "0px",
  padding: "0.5rem"
});
var buttonStyles = {
  width: "1rem",
  cursor: "pointer",
  height: "1rem"
};
var textStyles = _extends({}, commonStyles, {
  display: "inline",
  position: "static",
  padding: "0px",
  margin: "0px",
  color: "white",
  "font-family": "'Segoe UI','Open Sans Condensed',-apple-system,BlinkMacSystemFont,avenir next,avenir,helvetica neue,helvetica,Cantarell,Ubuntu,roboto,noto,arial,sans-serif",
  "font-size": "0.875rem",
  "font-wight": "600"
});
function createImportantStyles(defaultStyles, customStyles) {
  const styles = customStyles ? _extends({}, defaultStyles, customStyles) : defaultStyles;
  return Object.keys(styles).reduce((cssString, currentKey) => `${cssString}${[currentKey, `${styles[currentKey]} !important;`].join(": ")}`, "");
}
var DxLicense = class _DxLicense extends SafeHTMLElement {
  constructor() {
    var _DxLicense$customStyl, _DxLicense$customStyl2, _DxLicense$customStyl3, _DxLicense$customStyl4, _DxLicense$customStyl5;
    super();
    this._observer = null;
    this._inReassign = false;
    this._spanStyles = createImportantStyles(textStyles, null === (_DxLicense$customStyl = _DxLicense.customStyles) || void 0 === _DxLicense$customStyl ? void 0 : _DxLicense$customStyl.textStyles);
    this._linkStyles = createImportantStyles(textStyles, null === (_DxLicense$customStyl2 = _DxLicense.customStyles) || void 0 === _DxLicense$customStyl2 ? void 0 : _DxLicense$customStyl2.linkStyles);
    this._containerStyles = createImportantStyles(containerStyles, null === (_DxLicense$customStyl3 = _DxLicense.customStyles) || void 0 === _DxLicense$customStyl3 ? void 0 : _DxLicense$customStyl3.containerStyles);
    this._contentStyles = createImportantStyles(contentStyles, null === (_DxLicense$customStyl4 = _DxLicense.customStyles) || void 0 === _DxLicense$customStyl4 ? void 0 : _DxLicense$customStyl4.contentStyles);
    this._buttonStyles = createImportantStyles(buttonStyles, null === (_DxLicense$customStyl5 = _DxLicense.customStyles) || void 0 === _DxLicense$customStyl5 ? void 0 : _DxLicense$customStyl5.contentStyles);
  }
  _createSpan(text) {
    const span = document.createElement("span");
    span.innerText = text;
    span.style.cssText = this._spanStyles;
    return span;
  }
  _createLink(text, href) {
    const link = document.createElement("a");
    link.innerText = text;
    link.style.cssText = this._linkStyles;
    link.href = href;
    link.target = "_blank";
    return link;
  }
  _createButton() {
    const button = document.createElement("div");
    button.style.cssText = this._buttonStyles;
    const polygon = document.createElementNS("http://www.w3.org/2000/svg", "polygon");
    const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    polygon.setAttribute("points", "13.4 12.7 8.7 8 13.4 3.4 12.6 2.6 8 7.3 3.4 2.6 2.6 3.4 7.3 8 2.6 12.6 3.4 13.4 8 8.7 12.7 13.4 13.4 12.7");
    polygon.style.cssText = createImportantStyles({
      fill: "#fff",
      opacity: ".5",
      "stroke-width": "0px"
    });
    svg.setAttribute("id", "Layer_1");
    svg.setAttribute("data-name", "Layer 1");
    svg.setAttribute("version", "1.1");
    svg.setAttribute("viewBox", "0 0 16 16");
    svg.style.cssText = createImportantStyles({
      "vertical-align": "baseline"
    });
    svg.appendChild(polygon);
    button.appendChild(svg);
    button.onclick = () => {
      _DxLicense.closed = true;
      this.style.cssText = createImportantStyles({
        display: "none"
      });
    };
    return button;
  }
  _createContentContainer() {
    const contentContainer = document.createElement("div");
    contentContainer.style.cssText = this._contentStyles;
    contentContainer.append(this._createSpan("For evaluation purposes only. Redistribution prohibited. Please "), this._createLink("register", this.getAttribute(attributeNames.licensingDoc)), this._createSpan(" an existing license or "), this._createLink("purchase a new license", this.getAttribute(attributeNames.buyNow)), this._createSpan(` to continue use of DevExpress product libraries (v${this.getAttribute(attributeNames.version)}).`));
    return contentContainer;
  }
  _reassignComponent() {
    this.innerHTML = "";
    this.style.cssText = this._containerStyles;
    this.append(this._createContentContainer(), this._createButton());
  }
  connectedCallback() {
    this._reassignComponent();
    if (!this._observer) {
      this._observer = new MutationObserver(() => {
        if (_DxLicense.closed) {
          var _this$_observer;
          null === (_this$_observer = this._observer) || void 0 === _this$_observer || _this$_observer.disconnect();
          return;
        }
        if (this._inReassign) {
          this._inReassign = false;
        } else {
          this._inReassign = true;
          this._reassignComponent();
        }
      });
      this._observer.observe(this, {
        childList: true,
        attributes: true,
        subtree: true
      });
    }
  }
  disconnectedCallback() {
    if (_DxLicense.closed) {
      return;
    }
    Promise.resolve().then(() => {
      if (!document) {
        return;
      }
      const licensePanel = document.getElementsByTagName(componentNames2.panel);
      if (!licensePanel.length) {
        document.body.prepend(this);
      }
    });
  }
};
DxLicense.customStyles = void 0;
DxLicense.closed = false;
var DxLicenseTrigger = class extends SafeHTMLElement {
  connectedCallback() {
    this.style.cssText = createImportantStyles({
      display: "none"
    });
    const licensePanel = document.getElementsByTagName(componentNames2.panel);
    if (!licensePanel.length && !DxLicense.closed) {
      const license = document.createElement(componentNames2.panel);
      license.setAttribute(attributeNames.version, this.getAttribute(attributeNames.version));
      license.setAttribute(attributeNames.buyNow, this.getAttribute(attributeNames.buyNow));
      license.setAttribute(attributeNames.licensingDoc, this.getAttribute(attributeNames.licensingDoc));
      license.setAttribute("data-permanent", "");
      document.body.prepend(license);
    }
  }
};
function registerCustomComponents(customStyles) {
  if (!customElements.get(componentNames2.trigger)) {
    DxLicense.customStyles = customStyles;
    customElements.define(componentNames2.trigger, DxLicenseTrigger);
    customElements.define(componentNames2.panel, DxLicense);
  }
}
function renderTrialPanel(buyNowUrl, licensingDocUrl, version2, customStyles) {
  registerCustomComponents(customStyles);
  const trialPanelTrigger = document.createElement(componentNames2.trigger);
  trialPanelTrigger.setAttribute(attributeNames.buyNow, buyNowUrl);
  trialPanelTrigger.setAttribute(attributeNames.licensingDoc, licensingDocUrl);
  trialPanelTrigger.setAttribute(attributeNames.version, version2);
  document.body.appendChild(trialPanelTrigger);
}

// node_modules/devextreme/esm/__internal/core/license/trial_panel.js
function showTrialPanel(buyNowUrl, licensingDocUrl, version2, customStyles) {
  if (isClient()) {
    renderTrialPanel(buyNowUrl, licensingDocUrl, version2, customStyles);
  }
}

// node_modules/devextreme/esm/__internal/core/license/types.js
var TokenKind;
!function(TokenKind2) {
  TokenKind2.corrupted = "corrupted";
  TokenKind2.verified = "verified";
  TokenKind2.internal = "internal";
}(TokenKind || (TokenKind = {}));

// node_modules/devextreme/esm/__internal/core/license/license_validation.js
var _excluded3 = ["customerId", "maxVersionAllowed", "format", "internalUsageId"];
var BUY_NOW_LINK = "https://go.devexpress.com/Licensing_Installer_Watermark_DevExtremeJQuery.aspx";
var LICENSING_DOC_LINK = "https://go.devexpress.com/Licensing_Documentation_DevExtremeJQuery.aspx";
var GENERAL_ERROR = {
  kind: TokenKind.corrupted,
  error: "general"
};
var VERIFICATION_ERROR = {
  kind: TokenKind.corrupted,
  error: "verification"
};
var DECODING_ERROR = {
  kind: TokenKind.corrupted,
  error: "decoding"
};
var DESERIALIZATION_ERROR = {
  kind: TokenKind.corrupted,
  error: "deserialization"
};
var PAYLOAD_ERROR = {
  kind: TokenKind.corrupted,
  error: "payload"
};
var VERSION_ERROR = {
  kind: TokenKind.corrupted,
  error: "version"
};
var validationPerformed = false;
function verifySignature(_ref) {
  let {
    text,
    signature: encodedSignature
  } = _ref;
  return compareSignatures({
    key: PUBLIC_KEY,
    signature: base64ToBytes(encodedSignature),
    actual: pad(sha1(text))
  });
}
function parseLicenseKey(encodedKey) {
  if (void 0 === encodedKey) {
    return GENERAL_ERROR;
  }
  const parts = encodedKey.split(".");
  if (2 !== parts.length || 0 === parts[0].length || 0 === parts[1].length) {
    return GENERAL_ERROR;
  }
  if (!verifySignature({
    text: parts[0],
    signature: parts[1]
  })) {
    return VERIFICATION_ERROR;
  }
  let decodedPayload = "";
  try {
    decodedPayload = atob(parts[0]);
  } catch {
    return DECODING_ERROR;
  }
  let payload = {};
  try {
    payload = JSON.parse(decodedPayload);
  } catch {
    return DESERIALIZATION_ERROR;
  }
  const {
    customerId,
    maxVersionAllowed,
    format: format2,
    internalUsageId
  } = payload, rest = _objectWithoutPropertiesLoose(payload, _excluded3);
  if (void 0 !== internalUsageId) {
    return {
      kind: TokenKind.internal,
      internalUsageId
    };
  }
  if (void 0 === customerId || void 0 === maxVersionAllowed || void 0 === format2) {
    return PAYLOAD_ERROR;
  }
  if (1 !== format2) {
    return VERSION_ERROR;
  }
  return {
    kind: TokenKind.verified,
    payload: _extends({
      customerId,
      maxVersionAllowed
    }, rest)
  };
}
function isPreview(patch2) {
  return isNaN(patch2) || patch2 < 3;
}
function getLicenseCheckParams(_ref2) {
  let {
    licenseKey,
    version: version2
  } = _ref2;
  let preview = false;
  try {
    preview = isPreview(version2.patch);
    const {
      major,
      minor
    } = preview ? getPreviousMajorVersion(version2) : version2;
    if (!licenseKey) {
      return {
        preview,
        error: "W0019"
      };
    }
    const license = parseLicenseKey(licenseKey);
    if (license.kind === TokenKind.corrupted) {
      return {
        preview,
        error: "W0021"
      };
    }
    if (license.kind === TokenKind.internal) {
      return {
        preview,
        internal: true,
        error: license.internalUsageId === INTERNAL_USAGE_ID ? void 0 : "W0020"
      };
    }
    if (!(major && minor)) {
      return {
        preview,
        error: "W0021"
      };
    }
    if (10 * major + minor > license.payload.maxVersionAllowed) {
      return {
        preview,
        error: "W0020"
      };
    }
    return {
      preview,
      error: void 0
    };
  } catch {
    return {
      preview,
      error: "W0021"
    };
  }
}
function validateLicense(licenseKey) {
  let versionStr = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : fullVersion;
  if (validationPerformed) {
    return;
  }
  validationPerformed = true;
  const version2 = parseVersion(versionStr);
  const versionsCompatible = assertedVersionsCompatible(version2);
  const {
    internal,
    error: error2
  } = getLicenseCheckParams({
    licenseKey,
    version: version2
  });
  if (!versionsCompatible && internal) {
    return;
  }
  if (error2 && !internal) {
    const buyNowLink = config_default2().buyNowLink ?? BUY_NOW_LINK;
    const licensingDocLink = config_default2().licensingDocLink ?? LICENSING_DOC_LINK;
    showTrialPanel(buyNowLink, licensingDocLink, fullVersion);
  }
  const preview = isPreview(version2.patch);
  if (error2) {
    errors_default.log(preview ? "W0022" : error2);
    return;
  }
  if (preview && !internal) {
    errors_default.log("W0022");
  }
}
function peekValidationPerformed() {
  return validationPerformed;
}
var license_validation_default = {
  validateLicense
};

// node_modules/devextreme/esm/__internal/events/m_visibility_change.js
var triggerVisibilityChangeEvent = function(eventName) {
  return function(element) {
    const $element = renderer_default(element || "body");
    const changeHandlers = $element.filter(".dx-visibility-change-handler").add($element.find(".dx-visibility-change-handler"));
    for (let i = 0; i < changeHandlers.length; i++) {
      m_events_engine_default.triggerHandler(changeHandlers[i], eventName);
    }
  };
};
var triggerShownEvent = triggerVisibilityChangeEvent("dxshown");
var triggerHidingEvent = triggerVisibilityChangeEvent("dxhiding");
var triggerResizeEvent = triggerVisibilityChangeEvent("dxresize");
var m_visibility_change_default = {
  triggerHidingEvent,
  triggerResizeEvent,
  triggerShownEvent
};

// node_modules/devextreme/esm/common/core/events/visibility_change.js
var triggerShownEvent2 = m_visibility_change_default.triggerShownEvent;
var triggerHidingEvent2 = m_visibility_change_default.triggerHidingEvent;
var triggerResizeEvent2 = m_visibility_change_default.triggerResizeEvent;

// node_modules/devextreme/esm/__internal/core/templates/m_template_base.js
var renderedCallbacks = callbacks_default({
  syncStrategy: true
});
var TemplateBase = class {
  render(options2) {
    options2 = options2 || {};
    const {
      onRendered
    } = options2;
    delete options2.onRendered;
    let $result;
    if (options2.renovated && options2.transclude && this._element) {
      $result = renderer_default("<div>").append(this._element).contents();
    } else {
      $result = this._renderCore(options2);
    }
    this._ensureResultInContainer($result, options2.container);
    renderedCallbacks.fire($result, options2.container);
    onRendered && onRendered();
    return $result;
  }
  _ensureResultInContainer($result, container) {
    if (!container) {
      return;
    }
    const $container = renderer_default(container);
    const resultInContainer = contains2($container.get(0), $result.get(0));
    $container.append($result);
    if (resultInContainer) {
      return;
    }
    const resultInBody = contains2(dom_adapter_default.getBody(), $container.get(0));
    if (!resultInBody) {
      return;
    }
    triggerShownEvent2($result);
  }
  _renderCore() {
    throw errors_default.Error("E0001");
  }
};

// node_modules/devextreme/esm/__internal/core/templates/m_empty_template.js
var EmptyTemplate = class extends TemplateBase {
  _renderCore() {
    return renderer_default();
  }
};

// node_modules/devextreme/esm/__internal/core/templates/m_function_template.js
var FunctionTemplate = class extends TemplateBase {
  constructor(render3) {
    super();
    this._render = render3;
  }
  _renderCore(options2) {
    return normalizeTemplateElement(this._render(options2));
  }
};

// node_modules/devextreme/esm/__internal/core/templates/m_child_default_template.js
var ChildDefaultTemplate = class extends TemplateBase {
  constructor(name2) {
    super();
    this.name = name2;
  }
};

// node_modules/devextreme/esm/__internal/core/templates/m_template.js
registerTemplateEngine("default", {
  compile: (element) => normalizeTemplateElement(element),
  render: (template, model, index2) => template.clone()
});
setTemplateEngine("default");
var Template = class extends TemplateBase {
  constructor(element) {
    super();
    this._element = element;
  }
  _renderCore(options2) {
    const {
      transclude
    } = options2;
    if (!transclude && !this._compiledTemplate) {
      this._compiledTemplate = getCurrentTemplateEngine().compile(this._element);
    }
    return renderer_default("<div>").append(transclude ? this._element : getCurrentTemplateEngine().render(this._compiledTemplate, options2.model, options2.index)).contents();
  }
  source() {
    return renderer_default(this._element).clone();
  }
};

// node_modules/devextreme/esm/__internal/core/utils/m_array.js
function createOccurrenceMap(array) {
  return array.reduce((map3, value2) => {
    const count = (map3.get(value2) ?? 0) + 1;
    map3.set(value2, count);
    return map3;
  }, /* @__PURE__ */ new Map());
}
var wrapToArray = function(item) {
  return Array.isArray(item) ? item : [item];
};
var getUniqueValues = function(values) {
  return [...new Set(values)];
};
var removeDuplicates = function() {
  let from = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];
  let toRemove = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [];
  const toRemoveMap = createOccurrenceMap(toRemove);
  return from.filter((value2) => {
    const occurrencesCount = toRemoveMap.get(value2);
    occurrencesCount && toRemoveMap.set(value2, occurrencesCount - 1);
    return !occurrencesCount;
  });
};
var normalizeIndexes = function(items, indexPropName, currentItem, needIndexCallback) {
  const indexedItems = {};
  const {
    useLegacyVisibleIndex
  } = config_default2();
  let currentIndex = 0;
  const shouldUpdateIndex = (item) => !isDefined(item[indexPropName]) && (!needIndexCallback || needIndexCallback(item));
  items.forEach((item) => {
    const index2 = item[indexPropName];
    if (index2 >= 0) {
      indexedItems[index2] = indexedItems[index2] || [];
      if (item === currentItem) {
        indexedItems[index2].unshift(item);
      } else {
        indexedItems[index2].push(item);
      }
    } else {
      item[indexPropName] = void 0;
    }
  });
  if (!useLegacyVisibleIndex) {
    items.forEach((item) => {
      if (shouldUpdateIndex(item)) {
        while (indexedItems[currentIndex]) {
          currentIndex++;
        }
        indexedItems[currentIndex] = [item];
        currentIndex++;
      }
    });
  }
  currentIndex = 0;
  orderEach(indexedItems, function(index2, items2) {
    items2.forEach((item) => {
      if (index2 >= 0) {
        item[indexPropName] = currentIndex++;
      }
    });
  });
  if (useLegacyVisibleIndex) {
    items.forEach((item) => {
      if (shouldUpdateIndex(item)) {
        item[indexPropName] = currentIndex++;
      }
    });
  }
};
var groupBy = (array, getGroupName) => array.reduce((groupedResult, item) => {
  const groupName = getGroupName(item);
  groupedResult[groupName] = groupedResult[groupName] ?? [];
  groupedResult[groupName].push(item);
  return groupedResult;
}, {});

// node_modules/devextreme/esm/__internal/core/utils/m_template_manager.js
var findTemplates = (element, name2) => {
  const templates = renderer_default(element).contents().filter(`[data-options*="${name2}"]`);
  return [].slice.call(templates).map((element2) => {
    const optionsString = renderer_default(element2).attr("data-options") || "";
    return {
      element: element2,
      options: config_default2().optionsParser(optionsString)[name2]
    };
  }).filter((template) => !!template.options);
};
var suitableTemplatesByName = (rawTemplates) => {
  const templatesMap = groupBy(rawTemplates, (template) => template.options.name);
  if (templatesMap.undefined) {
    throw errors_default.Error("E0023");
  }
  const result2 = {};
  Object.keys(templatesMap).forEach((name2) => {
    var _findBestMatches$;
    const suitableTemplate = null === (_findBestMatches$ = findBestMatches(devices_default.current(), templatesMap[name2], (template) => template.options)[0]) || void 0 === _findBestMatches$ ? void 0 : _findBestMatches$.element;
    if (suitableTemplate) {
      result2[name2] = suitableTemplate;
    }
  });
  return result2;
};
var addOneRenderedCall = (template) => {
  const render3 = template.render.bind(template);
  return extend({}, template, {
    render(options2) {
      const templateResult = render3(options2);
      options2 && options2.onRendered && options2.onRendered();
      return templateResult;
    }
  });
};
var addPublicElementNormalization = (template) => {
  const render3 = template.render.bind(template);
  return extend({}, template, {
    render(options2) {
      const $container = renderer_default(options2.container);
      return render3(_extends({}, options2, {
        container: getPublicElement($container)
      }));
    }
  });
};
var getNormalizedTemplateArgs = (options2) => {
  const args = [];
  if ("model" in options2) {
    args.push(options2.model);
  }
  if ("index" in options2) {
    args.push(options2.index);
  }
  args.push(options2.container);
  return args;
};
var validateTemplateSource = (templateSource) => "string" === typeof templateSource ? m_dom_default.normalizeTemplateElement(templateSource) : templateSource;
var templateKey = (templateSource) => m_type_default.isRenderer(templateSource) && templateSource[0] || templateSource;
var defaultCreateElement = (element) => new Template(element);
var acquireIntegrationTemplate = (templateSource, templates, isAsyncTemplate, skipTemplates) => {
  let integrationTemplate = null;
  if (!skipTemplates || -1 === skipTemplates.indexOf(templateSource)) {
    integrationTemplate = templates[templateSource];
    if (integrationTemplate && !(integrationTemplate instanceof TemplateBase)) {
      if (m_type_default.isFunction(integrationTemplate.render)) {
        integrationTemplate = addPublicElementNormalization(integrationTemplate);
      }
      if (!isAsyncTemplate) {
        integrationTemplate = addOneRenderedCall(integrationTemplate);
      }
    }
  }
  return integrationTemplate;
};
var acquireTemplate = (templateSource, createTemplate, templates, isAsyncTemplate, skipTemplates, defaultTemplates) => {
  if (null == templateSource) {
    return new EmptyTemplate();
  }
  if (templateSource instanceof ChildDefaultTemplate) {
    return defaultTemplates[templateSource.name];
  }
  if (templateSource instanceof TemplateBase) {
    return templateSource;
  }
  if (m_type_default.isFunction(templateSource.render) && !m_type_default.isRenderer(templateSource)) {
    return isAsyncTemplate ? templateSource : addOneRenderedCall(templateSource);
  }
  if (templateSource.nodeType || m_type_default.isRenderer(templateSource)) {
    return createTemplate(renderer_default(templateSource));
  }
  return acquireIntegrationTemplate(templateSource, templates, isAsyncTemplate, skipTemplates) || defaultTemplates[templateSource] || createTemplate(templateSource);
};

// node_modules/devextreme/esm/__internal/core/m_template_manager.js
var DX_POLYMORPH_WIDGET_TEMPLATE = new FunctionTemplate((_ref) => {
  let {
    model,
    parent
  } = _ref;
  const widgetName = model.widget;
  if (!widgetName) {
    return renderer_default();
  }
  const widgetElement = renderer_default("<div>");
  const widgetOptions = model.options || {};
  if (parent) {
    parent._createComponent(widgetElement, widgetName, widgetOptions);
  } else {
    widgetElement[widgetName](widgetOptions);
  }
  return widgetElement;
});
var TemplateManager = class {
  constructor(createElement2, anonymousTemplateName) {
    this._tempTemplates = [];
    this._defaultTemplates = {};
    this._anonymousTemplateName = anonymousTemplateName || "template";
    this._createElement = createElement2 || defaultCreateElement;
    this._createTemplateIfNeeded = this._createTemplateIfNeeded.bind(this);
  }
  static createDefaultOptions() {
    return {
      integrationOptions: {
        watchMethod: function(fn, callback) {
          let options2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
          if (!options2.skipImmediate) {
            callback(fn());
          }
          return noop2;
        },
        templates: {
          "dx-polymorph-widget": DX_POLYMORPH_WIDGET_TEMPLATE
        },
        useDeferUpdateForTemplates: true
      }
    };
  }
  get anonymousTemplateName() {
    return this._anonymousTemplateName;
  }
  addDefaultTemplates(templates) {
    this._defaultTemplates = extend({}, this._defaultTemplates, templates);
  }
  dispose() {
    this._tempTemplates.forEach((tempTemplate) => {
      tempTemplate.template.dispose && tempTemplate.template.dispose();
    });
    this._tempTemplates = [];
  }
  extractTemplates($el) {
    const templates = this._extractTemplates($el);
    const anonymousTemplateMeta = this._extractAnonymousTemplate($el);
    return {
      templates,
      anonymousTemplateMeta
    };
  }
  _extractTemplates($el) {
    const templates = findTemplates($el, "dxTemplate");
    const suitableTemplates = suitableTemplatesByName(templates);
    templates.forEach((_ref2) => {
      let {
        element,
        options: {
          name: name2
        }
      } = _ref2;
      if (element === suitableTemplates[name2]) {
        renderer_default(element).addClass("dx-template-wrapper").detach();
      } else {
        renderer_default(element).remove();
      }
    });
    return Object.keys(suitableTemplates).map((name2) => ({
      name: name2,
      template: this._createTemplate(suitableTemplates[name2])
    }));
  }
  _extractAnonymousTemplate($el) {
    const $anonymousTemplate = $el.contents().detach();
    const $notJunkTemplateContent = $anonymousTemplate.filter((_, element) => {
      const isTextNode = 3 === element.nodeType;
      const isEmptyText = renderer_default(element).text().trim().length < 1;
      return !(isTextNode && isEmptyText);
    });
    return $notJunkTemplateContent.length > 0 ? {
      template: this._createTemplate($anonymousTemplate),
      name: this._anonymousTemplateName
    } : {};
  }
  _createTemplateIfNeeded(templateSource) {
    const cachedTemplate = this._tempTemplates.filter((tempTemplate) => tempTemplate.source === templateKey(templateSource))[0];
    if (cachedTemplate) {
      return cachedTemplate.template;
    }
    const template = this._createTemplate(templateSource);
    this._tempTemplates.push({
      template,
      source: templateKey(templateSource)
    });
    return template;
  }
  _createTemplate(templateSource) {
    return this._createElement(validateTemplateSource(templateSource));
  }
  getTemplate(templateSource, templates, _ref3, context2) {
    let {
      isAsyncTemplate,
      skipTemplates
    } = _ref3;
    if (!isFunction(templateSource)) {
      return acquireTemplate(templateSource, this._createTemplateIfNeeded, templates, isAsyncTemplate, skipTemplates, this._defaultTemplates);
    }
    return new FunctionTemplate((options2) => {
      const templateSourceResult = templateSource.apply(context2, getNormalizedTemplateArgs(options2));
      if (!isDefined(templateSourceResult)) {
        return new EmptyTemplate();
      }
      let dispose2 = false;
      const template = acquireTemplate(templateSourceResult, (templateSource2) => {
        if (templateSource2.nodeType || isRenderer(templateSource2) && !renderer_default(templateSource2).is("script")) {
          return new FunctionTemplate(() => templateSource2);
        }
        dispose2 = true;
        return this._createTemplate(templateSource2);
      }, templates, isAsyncTemplate, skipTemplates, this._defaultTemplates);
      const result2 = template.render(options2);
      dispose2 && template.dispose && template.dispose();
      return result2;
    });
  }
};
var m_template_manager_default = {
  TemplateManager
};

// node_modules/devextreme/esm/__internal/core/widget/dom_component.js
var DOMComponent = class _DOMComponent extends Component {
  static getInstance(element) {
    return getInstanceByElement(renderer_default(element), this);
  }
  static defaultOptions(rule) {
    this._classCustomRules = Object.hasOwnProperty.bind(this)("_classCustomRules") && this._classCustomRules ? this._classCustomRules : [];
    this._classCustomRules.push(rule);
  }
  _getDefaultOptions() {
    return extend(super._getDefaultOptions(), {
      width: void 0,
      height: void 0,
      rtlEnabled: config_default2().rtlEnabled,
      elementAttr: {},
      disabled: false,
      integrationOptions: {}
    }, this._useTemplates() ? m_template_manager_default.TemplateManager.createDefaultOptions() : {});
  }
  ctor(element, options2) {
    this._customClass = null;
    this._createElement(element);
    attachInstanceToElement(this._$element, this, this._dispose);
    super.ctor(options2);
    const validationAlreadyPerformed = peekValidationPerformed();
    license_validation_default.validateLicense(config_default2().licenseKey);
    if (!validationAlreadyPerformed && peekValidationPerformed()) {
      config_default2({
        licenseKey: ""
      });
    }
    uiLayerInitialized.resolve();
  }
  _createElement(element) {
    this._$element = renderer_default(element);
  }
  _getSynchronizableOptionsForCreateComponent() {
    return ["rtlEnabled", "disabled", "templatesRenderAsynchronously"];
  }
  _checkFunctionValueDeprecation(optionNames) {
    if (!this.option("_ignoreFunctionValueDeprecation")) {
      optionNames.forEach((optionName) => {
        if (isFunction(this.option(optionName))) {
          errors_default.log("W0017", optionName);
        }
      });
    }
  }
  _visibilityChanged(value2) {
  }
  _dimensionChanged() {
  }
  _init() {
    super._init();
    this._checkFunctionValueDeprecation(["width", "height", "maxHeight", "maxWidth", "minHeight", "minWidth", "popupHeight", "popupWidth"]);
    this._attachWindowResizeCallback();
    this._initTemplateManager();
  }
  _setOptionsByDevice(instanceCustomRules) {
    const ctor = this.constructor;
    const hasOwnCustomRules = Object.prototype.hasOwnProperty.call(ctor, "_classCustomRules");
    const hasOwnDefaultOptions = Object.prototype.hasOwnProperty.call(ctor, "defaultOptions");
    const ownClassCustomRules = hasOwnCustomRules || hasOwnDefaultOptions ? ctor._classCustomRules : [];
    super._setOptionsByDevice([].concat(ownClassCustomRules || [], instanceCustomRules || []));
  }
  _isInitialOptionValue(name2) {
    const isCustomOption = this.constructor._classCustomRules && Object.prototype.hasOwnProperty.call(this._convertRulesToOptions(this.constructor._classCustomRules), name2);
    return !isCustomOption && super._isInitialOptionValue(name2);
  }
  _attachWindowResizeCallback() {
    if (this._isDimensionChangeSupported()) {
      const windowResizeCallBack = this._windowResizeCallBack = this._dimensionChanged.bind(this);
      resize_callbacks_default.add(windowResizeCallBack);
    }
  }
  _isDimensionChangeSupported() {
    return this._dimensionChanged !== _DOMComponent.prototype._dimensionChanged;
  }
  _renderComponent() {
    addShadowDomStyles(this.$element());
    this._initMarkup();
    hasWindow() && this._render();
  }
  _initMarkup() {
    const {
      rtlEnabled
    } = this.option() || {};
    this._renderElementAttributes();
    this._toggleRTLDirection(rtlEnabled);
    this._renderVisibilityChange();
    this._renderDimensions();
  }
  _render() {
    this._attachVisibilityChangeHandlers();
  }
  _renderElementAttributes() {
    const {
      elementAttr
    } = this.option() || {};
    const attributes = extend({}, elementAttr);
    const classNames2 = attributes.class;
    delete attributes.class;
    this.$element().attr(attributes).removeClass(this._customClass).addClass(classNames2);
    this._customClass = classNames2;
  }
  _renderVisibilityChange() {
    if (this._isDimensionChangeSupported()) {
      this._attachDimensionChangeHandlers();
    }
    if (this._isVisibilityChangeSupported()) {
      const $element = this.$element();
      $element.addClass("dx-visibility-change-handler");
    }
  }
  _renderDimensions() {
    const $element = this.$element();
    const element = $element.get(0);
    const width = this._getOptionValue("width", element);
    const height = this._getOptionValue("height", element);
    if (this._isCssUpdateRequired(element, height, width)) {
      $element.css({
        width: null === width ? "" : width,
        height: null === height ? "" : height
      });
    }
  }
  _isCssUpdateRequired(element, height, width) {
    return !!(isDefined(width) || isDefined(height) || element.style.width || element.style.height);
  }
  _attachDimensionChangeHandlers() {
    const $el = this.$element();
    const namespace = `${this.NAME}VisibilityChange`;
    resize.off($el, {
      namespace
    });
    resize.on($el, () => this._dimensionChanged(), {
      namespace
    });
  }
  _attachVisibilityChangeHandlers() {
    if (this._isVisibilityChangeSupported()) {
      const $el = this.$element();
      const namespace = `${this.NAME}VisibilityChange`;
      this._isHidden = !this._isVisible();
      visibility.off($el, {
        namespace
      });
      visibility.on($el, () => this._checkVisibilityChanged("shown"), () => this._checkVisibilityChanged("hiding"), {
        namespace
      });
    }
  }
  _isVisible() {
    const $element = this.$element();
    return $element.is(":visible");
  }
  _checkVisibilityChanged(action) {
    const isVisible2 = this._isVisible();
    if (isVisible2) {
      if ("hiding" === action && !this._isHidden) {
        this._visibilityChanged(false);
        this._isHidden = true;
      } else if ("shown" === action && this._isHidden) {
        this._isHidden = false;
        this._visibilityChanged(true);
      }
    }
  }
  _isVisibilityChangeSupported() {
    return this._visibilityChanged !== _DOMComponent.prototype._visibilityChanged && hasWindow();
  }
  _clean() {
  }
  _modelByElement(element) {
    const {
      modelByElement
    } = this.option();
    const $element = this.$element();
    return modelByElement ? modelByElement($element) : void 0;
  }
  _invalidate() {
    if (this._isUpdateAllowed()) {
      throw errors_default.Error("E0007");
    }
    this._requireRefresh = true;
  }
  _refresh() {
    this._clean();
    this._renderComponent();
  }
  _dispose() {
    this._templateManager && this._templateManager.dispose();
    super._dispose();
    this._clean();
    this._detachWindowResizeCallback();
  }
  _detachWindowResizeCallback() {
    if (this._isDimensionChangeSupported()) {
      resize_callbacks_default.remove(this._windowResizeCallBack);
    }
  }
  _toggleRTLDirection(rtl) {
    const $element = this.$element();
    $element.toggleClass("dx-rtl", rtl);
  }
  _createComponent(element, component, componentConfiguration) {
    const configuration = componentConfiguration ?? {};
    const synchronizableOptions = grep(this._getSynchronizableOptionsForCreateComponent(), (value2) => !(value2 in configuration));
    const {
      integrationOptions
    } = this.option();
    let {
      nestedComponentOptions
    } = this.option();
    nestedComponentOptions = nestedComponentOptions ?? noop2;
    const nestedComponentConfig = extend({
      integrationOptions
    }, nestedComponentOptions(this));
    synchronizableOptions.forEach((optionName) => nestedComponentConfig[optionName] = this.option(optionName));
    this._extendConfig(configuration, nestedComponentConfig);
    let instance;
    if (isString(component)) {
      const $element = renderer_default(element)[component](configuration);
      instance = $element[component]("instance");
    } else if (element) {
      instance = component.getInstance(element);
      if (instance) {
        instance.option(configuration);
      } else {
        instance = new component(element, configuration);
      }
    }
    if (instance) {
      const optionChangedHandler = (_ref) => {
        let {
          name: name2,
          value: value2
        } = _ref;
        if (synchronizableOptions.includes(name2)) {
          instance.option(name2, value2);
        }
      };
      this.on("optionChanged", optionChangedHandler);
      instance.on("disposing", () => this.off("optionChanged", optionChangedHandler));
    }
    return instance;
  }
  _extendConfig(configuration, extendConfig) {
    each(extendConfig, (key, value2) => {
      !Object.prototype.hasOwnProperty.call(configuration, key) && (configuration[key] = value2);
    });
  }
  _defaultActionConfig() {
    const $element = this.$element();
    const context2 = this._modelByElement($element);
    return extend(super._defaultActionConfig(), {
      context: context2
    });
  }
  _defaultActionArgs() {
    const $element = this.$element();
    const model = this._modelByElement($element);
    const element = this.element();
    return extend(super._defaultActionArgs(), {
      element,
      model
    });
  }
  _optionChanged(args) {
    const {
      name: name2
    } = args;
    switch (name2) {
      case "width":
      case "height":
        this._renderDimensions();
        break;
      case "rtlEnabled":
        this._invalidate();
        break;
      case "elementAttr":
        this._renderElementAttributes();
        break;
      case "disabled":
      case "integrationOptions":
        break;
      default:
        super._optionChanged(args);
    }
  }
  _removeAttributes(element) {
    const attrs = element.attributes;
    for (let i = attrs.length - 1; i >= 0; i--) {
      const attr = attrs[i];
      if (attr) {
        const {
          name: name2
        } = attr;
        if (!name2.indexOf("aria-") || -1 !== name2.indexOf("dx-") || "role" === name2 || "style" === name2 || "tabindex" === name2) {
          element.removeAttribute(name2);
        }
      }
    }
  }
  _removeClasses(element) {
    element.className = element.className.split(" ").filter((cssClass) => 0 !== cssClass.lastIndexOf("dx-", 0)).join(" ");
  }
  _updateDOMComponent(renderRequired) {
    if (renderRequired) {
      this._renderComponent();
    } else if (this._requireRefresh) {
      this._requireRefresh = false;
      this._refresh();
    }
  }
  endUpdate() {
    const renderRequired = this._isInitializingRequired();
    super.endUpdate();
    this._isUpdateAllowed() && this._updateDOMComponent(renderRequired);
  }
  $element() {
    return this._$element;
  }
  element() {
    const $element = this.$element();
    return getPublicElement($element);
  }
  dispose() {
    const element = this.$element().get(0);
    cleanDataRecursive(element, true);
    element.textContent = "";
    this._removeAttributes(element);
    this._removeClasses(element);
  }
  resetOption(optionName) {
    super.resetOption(optionName);
    if ("width" === optionName || "height" === optionName) {
      const initialOption = this.initialOption(optionName);
      !isDefined(initialOption) && this.$element().css(optionName, "");
    }
  }
  _getAnonymousTemplateName() {
    return;
  }
  _initTemplateManager() {
    if (this._templateManager || !this._useTemplates()) {
      return;
    }
    const {
      integrationOptions = {}
    } = this.option();
    const {
      createTemplate
    } = integrationOptions;
    this._templateManager = new m_template_manager_default.TemplateManager(createTemplate, this._getAnonymousTemplateName());
    this._initTemplates();
    return;
  }
  _initTemplates() {
    const {
      templates,
      anonymousTemplateMeta
    } = this._templateManager.extractTemplates(this.$element());
    const anonymousTemplate = this.option(`integrationOptions.templates.${anonymousTemplateMeta.name}`);
    templates.forEach((_ref2) => {
      let {
        name: name2,
        template
      } = _ref2;
      this._options.silent(`integrationOptions.templates.${name2}`, template);
    });
    if (anonymousTemplateMeta.name && !anonymousTemplate) {
      this._options.silent(`integrationOptions.templates.${anonymousTemplateMeta.name}`, anonymousTemplateMeta.template);
      this._options.silent("_hasAnonymousTemplateContent", true);
    }
  }
  _getTemplateByOption(optionName) {
    return this._getTemplate(this.option(optionName));
  }
  _getTemplate(templateSource) {
    const templates = this.option("integrationOptions.templates");
    const isAsyncTemplate = this.option("templatesRenderAsynchronously");
    const skipTemplates = this.option("integrationOptions.skipTemplates");
    return this._templateManager.getTemplate(templateSource, templates, {
      isAsyncTemplate,
      skipTemplates
    }, this);
  }
  _saveTemplate(name2, template) {
    this._setOptionWithoutOptionChange(`integrationOptions.templates.${name2}`, this._templateManager._createTemplate(template));
  }
  _useTemplates() {
    return true;
  }
};
var dom_component_default = DOMComponent;

// node_modules/devextreme/esm/__internal/core/widget/widget.js
var FOCUSED_STATE_CLASS = "dx-state-focused";
function setAttribute(name2, value2, target) {
  name2 = "role" === name2 || "id" === name2 ? name2 : `aria-${name2}`;
  value2 = isDefined(value2) ? value2.toString() : null;
  target.attr(name2, value2);
}
var Widget = class _Widget extends dom_component_default {
  constructor() {
    super(...arguments);
    this._feedbackHideTimeout = 400;
    this._feedbackShowTimeout = 30;
  }
  static getOptionsFromContainer(_ref) {
    let {
      name: name2,
      fullName,
      value: value2
    } = _ref;
    let options2 = {};
    if (name2 === fullName) {
      options2 = value2;
    } else {
      const option = fullName.split(".").pop();
      options2[option] = value2;
    }
    return options2;
  }
  _supportedKeys() {
    return {};
  }
  _getDefaultOptions() {
    return extend(super._getDefaultOptions(), {
      hoveredElement: null,
      isActive: false,
      disabled: false,
      visible: true,
      hint: void 0,
      activeStateEnabled: false,
      onContentReady: null,
      hoverStateEnabled: false,
      focusStateEnabled: false,
      tabIndex: 0,
      accessKey: void 0,
      onFocusIn: null,
      onFocusOut: null,
      onKeyboardHandled: null,
      ignoreParentReadOnly: false,
      useResizeObserver: true
    });
  }
  _defaultOptionsRules() {
    return super._defaultOptionsRules().concat([{
      device() {
        const device = devices_default.real();
        const {
          platform
        } = device;
        const {
          version: version2
        } = device;
        return "ios" === platform && compare(version2, "13.3") <= 0;
      },
      options: {
        useResizeObserver: false
      }
    }]);
  }
  _init() {
    super._init();
    this._initContentReadyAction();
  }
  _innerWidgetOptionChanged(innerWidget, args) {
    const options2 = _Widget.getOptionsFromContainer(args);
    innerWidget && innerWidget.option(options2);
    this._options.cache(args.name, options2);
  }
  _bindInnerWidgetOptions(innerWidget, optionsContainer) {
    const syncOptions = () => this._options.silent(optionsContainer, extend({}, innerWidget.option()));
    syncOptions();
    innerWidget.on("optionChanged", syncOptions);
  }
  _getAriaTarget() {
    return this._focusTarget();
  }
  _initContentReadyAction() {
    this._contentReadyAction = this._createActionByOption("onContentReady", {
      excludeValidators: ["disabled", "readOnly"]
    });
  }
  _initMarkup() {
    const {
      disabled,
      visible: visible2
    } = this.option();
    this.$element().addClass("dx-widget");
    this._toggleDisabledState(disabled);
    this._toggleVisibility(visible2);
    this._renderHint();
    this._isFocusable() && this._renderFocusTarget();
    super._initMarkup();
  }
  _render() {
    super._render();
    this._renderContent();
    this._renderFocusState();
    this._attachFeedbackEvents();
    this._attachHoverEvents();
    this._toggleIndependentState();
  }
  _renderHint() {
    const {
      hint
    } = this.option();
    this.$element().attr("title", hint || null);
  }
  _renderContent() {
    deferRender(() => !this._disposed ? this._renderContentImpl() : void 0).done(() => !this._disposed ? this._fireContentReadyAction() : void 0);
  }
  _renderContentImpl() {
  }
  _fireContentReadyAction() {
    return deferRender(() => {
      var _this$_contentReadyAc;
      return null === (_this$_contentReadyAc = this._contentReadyAction) || void 0 === _this$_contentReadyAc ? void 0 : _this$_contentReadyAc.call(this);
    });
  }
  _dispose() {
    this._contentReadyAction = null;
    this._detachKeyboardEvents();
    super._dispose();
  }
  _resetActiveState() {
    this._toggleActiveState(this._eventBindingTarget(), false);
  }
  _clean() {
    this._cleanFocusState();
    this._resetActiveState();
    super._clean();
    this.$element().empty();
  }
  _toggleVisibility(visible2) {
    this.$element().toggleClass("dx-state-invisible", !visible2);
  }
  _renderFocusState() {
    this._attachKeyboardEvents();
    if (this._isFocusable()) {
      this._renderFocusTarget();
      this._attachFocusEvents();
      this._renderAccessKey();
    }
  }
  _renderAccessKey() {
    const $el = this._focusTarget();
    const {
      accessKey
    } = this.option();
    $el.attr("accesskey", accessKey);
  }
  _isFocusable() {
    const {
      focusStateEnabled,
      disabled
    } = this.option();
    return focusStateEnabled && !disabled;
  }
  _eventBindingTarget() {
    return this.$element();
  }
  _focusTarget() {
    return this._getActiveElement();
  }
  _isFocusTarget(element) {
    const focusTargets = renderer_default(this._focusTarget()).toArray();
    return focusTargets.includes(element);
  }
  _findActiveTarget($element) {
    return $element.find(this._activeStateUnit).not(".dx-state-disabled");
  }
  _getActiveElement() {
    const activeElement = this._eventBindingTarget();
    if (this._activeStateUnit) {
      return this._findActiveTarget(activeElement);
    }
    return activeElement;
  }
  _renderFocusTarget() {
    const {
      tabIndex
    } = this.option();
    this._focusTarget().attr("tabIndex", tabIndex);
  }
  _keyboardEventBindingTarget() {
    return this._eventBindingTarget();
  }
  _refreshFocusEvent() {
    this._detachFocusEvents();
    this._attachFocusEvents();
  }
  _focusEventTarget() {
    return this._focusTarget();
  }
  _focusInHandler(event) {
    if (!event.isDefaultPrevented()) {
      this._createActionByOption("onFocusIn", {
        beforeExecute: () => this._updateFocusState(event, true),
        excludeValidators: ["readOnly"]
      })({
        event
      });
    }
  }
  _focusOutHandler(event) {
    if (!event.isDefaultPrevented()) {
      this._createActionByOption("onFocusOut", {
        beforeExecute: () => this._updateFocusState(event, false),
        excludeValidators: ["readOnly", "disabled"]
      })({
        event
      });
    }
  }
  _updateFocusState(_ref2, isFocused) {
    let {
      target
    } = _ref2;
    if (this._isFocusTarget(target)) {
      this._toggleFocusClass(isFocused, renderer_default(target));
    }
  }
  _toggleFocusClass(isFocused, $element) {
    const $focusTarget = $element && $element.length ? $element : this._focusTarget();
    $focusTarget.toggleClass("dx-state-focused", isFocused);
  }
  _hasFocusClass(element) {
    const $focusTarget = renderer_default(element ?? this._focusTarget());
    return $focusTarget.hasClass("dx-state-focused");
  }
  _isFocused() {
    return this._hasFocusClass();
  }
  _getKeyboardListeners() {
    return [];
  }
  _attachKeyboardEvents() {
    this._detachKeyboardEvents();
    const {
      focusStateEnabled,
      onKeyboardHandled
    } = this.option();
    const hasChildListeners = this._getKeyboardListeners().length;
    const hasKeyboardEventHandler = !!onKeyboardHandled;
    const shouldAttach = focusStateEnabled || hasChildListeners || hasKeyboardEventHandler;
    if (shouldAttach) {
      this._keyboardListenerId = keyboard.on(this._keyboardEventBindingTarget(), this._focusTarget(), (opts) => this._keyboardHandler(opts));
    }
  }
  _keyboardHandler(options2, onlyChildProcessing) {
    if (!onlyChildProcessing) {
      const {
        originalEvent,
        keyName,
        which
      } = options2;
      const keys = this._supportedKeys(originalEvent);
      const func = keys[keyName] || keys[which];
      if (void 0 !== func) {
        const handler = func.bind(this);
        const result2 = handler(originalEvent, options2);
        if (!result2) {
          return false;
        }
      }
    }
    const keyboardListeners = this._getKeyboardListeners();
    const {
      onKeyboardHandled
    } = this.option();
    keyboardListeners.forEach((listener) => listener && listener._keyboardHandler(options2));
    onKeyboardHandled && onKeyboardHandled(options2);
    return true;
  }
  _refreshFocusState() {
    this._cleanFocusState();
    this._renderFocusState();
  }
  _cleanFocusState() {
    const $element = this._focusTarget();
    $element.removeAttr("tabIndex");
    this._toggleFocusClass(false);
    this._detachFocusEvents();
    this._detachKeyboardEvents();
  }
  _detachKeyboardEvents() {
    keyboard.off(this._keyboardListenerId);
    this._keyboardListenerId = null;
  }
  _attachHoverEvents() {
    const {
      hoverStateEnabled
    } = this.option();
    const selector = this._activeStateUnit;
    const $el = this._eventBindingTarget();
    hover.off($el, {
      selector,
      namespace: "UIFeedback"
    });
    if (hoverStateEnabled) {
      hover.on($el, new action_default((_ref3) => {
        let {
          event,
          element
        } = _ref3;
        this._hoverStartHandler(event);
        this.option("hoveredElement", renderer_default(element));
      }, {
        excludeValidators: ["readOnly"]
      }), (event) => {
        this.option("hoveredElement", null);
        this._hoverEndHandler(event);
      }, {
        selector,
        namespace: "UIFeedback"
      });
    }
  }
  _attachFeedbackEvents() {
    const {
      activeStateEnabled
    } = this.option();
    const selector = this._activeStateUnit;
    const $el = this._eventBindingTarget();
    active.off($el, {
      namespace: "UIFeedback",
      selector
    });
    if (activeStateEnabled) {
      active.on($el, new action_default((_ref4) => {
        let {
          event,
          element
        } = _ref4;
        return this._toggleActiveState(renderer_default(element), true, event);
      }), new action_default((_ref5) => {
        let {
          event,
          element
        } = _ref5;
        return this._toggleActiveState(renderer_default(element), false, event);
      }, {
        excludeValidators: ["disabled", "readOnly"]
      }), {
        showTimeout: this._feedbackShowTimeout,
        hideTimeout: this._feedbackHideTimeout,
        selector,
        namespace: "UIFeedback"
      });
    }
  }
  _detachFocusEvents() {
    const $el = this._focusEventTarget();
    focus.off($el, {
      namespace: `${this.NAME}Focus`
    });
  }
  _attachFocusEvents() {
    const $el = this._focusEventTarget();
    focus.on($el, (e) => this._focusInHandler(e), (e) => this._focusOutHandler(e), {
      namespace: `${this.NAME}Focus`,
      isFocusable: (index2, el) => renderer_default(el).is(focusable)
    });
  }
  _hoverStartHandler(event) {
  }
  _hoverEndHandler(event) {
  }
  _toggleActiveState($element, value2, event) {
    this.option("isActive", value2);
    $element.toggleClass("dx-state-active", value2);
  }
  _updatedHover() {
    const hoveredElement = this._options.silent("hoveredElement");
    this._hover(hoveredElement, hoveredElement);
  }
  _findHoverTarget($el) {
    return $el && $el.closest(this._activeStateUnit || this._eventBindingTarget());
  }
  _hover($el, $previous) {
    const {
      hoverStateEnabled,
      disabled,
      isActive
    } = this.option();
    $previous = this._findHoverTarget($previous);
    $previous && $previous.toggleClass("dx-state-hover", false);
    if ($el && hoverStateEnabled && !disabled && !isActive) {
      const newHoveredElement = this._findHoverTarget($el);
      newHoveredElement && newHoveredElement.toggleClass("dx-state-hover", true);
    }
  }
  _toggleDisabledState(value2) {
    this.$element().toggleClass("dx-state-disabled", Boolean(value2));
    this.setAria("disabled", value2 || void 0);
  }
  _toggleIndependentState() {
    const {
      ignoreParentReadOnly
    } = this.option();
    this.$element().toggleClass("dx-state-independent", ignoreParentReadOnly);
  }
  _setWidgetOption(widgetName, args) {
    if (!this[widgetName]) {
      return;
    }
    if (isPlainObject(args[0])) {
      each(args[0], (option, value3) => this._setWidgetOption(widgetName, [option, value3]));
      return;
    }
    const optionName = args[0];
    let value2 = args[1];
    if (1 === args.length) {
      value2 = this.option(optionName);
    }
    const widgetOptionMap = this[`${widgetName}OptionMap`];
    this[widgetName].option(widgetOptionMap ? widgetOptionMap(optionName) : optionName, value2);
  }
  _optionChanged(args) {
    const {
      name: name2,
      value: value2,
      previousValue
    } = args;
    switch (name2) {
      case "disabled":
        this._toggleDisabledState(value2);
        this._updatedHover();
        this._refreshFocusState();
        break;
      case "hint":
        this._renderHint();
        break;
      case "ignoreParentReadOnly":
        this._toggleIndependentState();
        break;
      case "activeStateEnabled":
        this._attachFeedbackEvents();
        break;
      case "hoverStateEnabled":
        this._attachHoverEvents();
        this._updatedHover();
        break;
      case "tabIndex":
      case "focusStateEnabled":
        this._refreshFocusState();
        break;
      case "onFocusIn":
      case "onFocusOut":
      case "useResizeObserver":
        break;
      case "accessKey":
        this._renderAccessKey();
        break;
      case "hoveredElement":
        this._hover(value2, previousValue);
        break;
      case "isActive":
        this._updatedHover();
        break;
      case "visible":
        this._toggleVisibility(value2);
        if (this._isVisibilityChangeSupported()) {
          this._checkVisibilityChanged(value2 ? "shown" : "hiding");
        }
        break;
      case "onKeyboardHandled":
        this._attachKeyboardEvents();
        break;
      case "onContentReady":
        this._initContentReadyAction();
        break;
      default:
        super._optionChanged(args);
    }
  }
  _isVisible() {
    const {
      visible: visible2
    } = this.option();
    return super._isVisible() && visible2;
  }
  beginUpdate() {
    this._ready(false);
    super.beginUpdate();
  }
  endUpdate() {
    super.endUpdate();
    if (this._initialized) {
      this._ready(true);
    }
  }
  _ready(value2) {
    if (0 === arguments.length) {
      return !!this._isReady;
    }
    this._isReady = !!value2;
    return this._isReady;
  }
  setAria() {
    if (!isPlainObject(arguments.length <= 0 ? void 0 : arguments[0])) {
      setAttribute(arguments.length <= 0 ? void 0 : arguments[0], arguments.length <= 1 ? void 0 : arguments[1], (arguments.length <= 2 ? void 0 : arguments[2]) || this._getAriaTarget());
    } else {
      const target = (arguments.length <= 1 ? void 0 : arguments[1]) || this._getAriaTarget();
      each(arguments.length <= 0 ? void 0 : arguments[0], (name2, value2) => setAttribute(name2, value2, target));
    }
  }
  isReady() {
    return this._ready();
  }
  repaint() {
    this._refresh();
  }
  focus() {
    focus.trigger(this._focusTarget());
  }
  registerKeyHandler(key, handler) {
    const currentKeys = this._supportedKeys();
    this._supportedKeys = () => extend(currentKeys, {
      [key]: handler
    });
  }
};
var widget_default = Widget;

// node_modules/devextreme/esm/__internal/ui/m_load_indicator.js
var LOADINDICATOR_CONTENT_CLASS = "dx-loadindicator-content";
var AnimationType;
!function(AnimationType2) {
  AnimationType2.Circle = "circle";
  AnimationType2.Sparkle = "sparkle";
}(AnimationType || (AnimationType = {}));
var ANIMATION_TYPE_CLASSES = {
  [AnimationType.Circle]: "dx-loadindicator-content-circle",
  [AnimationType.Sparkle]: "dx-loadindicator-content-sparkle"
};
var LoadIndicator = class extends widget_default {
  _getDefaultOptions() {
    return _extends({}, super._getDefaultOptions(), {
      _animatingSegmentCount: 1,
      _animatingSegmentInner: false,
      _animationType: AnimationType.Circle,
      activeStateEnabled: false,
      hoverStateEnabled: false,
      indicatorSrc: ""
    });
  }
  _defaultOptionsRules() {
    const themeName = current();
    return super._defaultOptionsRules().concat([{
      device: () => isMaterialBased(themeName),
      options: {
        _animatingSegmentCount: 2,
        _animatingSegmentInner: true
      }
    }, {
      device: () => isGeneric(themeName),
      options: {
        _animatingSegmentCount: 7
      }
    }]);
  }
  _useTemplates() {
    return false;
  }
  _init() {
    super._init();
    this.$element().addClass("dx-loadindicator");
    const label = message_default.format("Loading");
    const aria = {
      role: "alert",
      label
    };
    this.setAria(aria);
  }
  _initMarkup() {
    super._initMarkup();
    this._renderWrapper();
    this._renderIndicatorContent();
    this._renderMarkup();
  }
  _renderWrapper() {
    this._$wrapper = renderer_default("<div>").addClass("dx-loadindicator-wrapper");
    this.$element().append(this._$wrapper);
  }
  _getAnimationTypeContentClass() {
    const {
      _animationType: animationType
    } = this.option();
    return ANIMATION_TYPE_CLASSES[animationType];
  }
  _renderIndicatorContent() {
    const animationClass = this._getAnimationTypeContentClass() ?? "";
    const contentClasses = [LOADINDICATOR_CONTENT_CLASS, animationClass].join(" ");
    this._$content = renderer_default("<div>").addClass(contentClasses);
    this._$wrapper.append(this._$content);
  }
  _renderMarkup() {
    const {
      indicatorSrc
    } = this.option();
    const isAnimationAvailable = m_support_default.animation();
    if (indicatorSrc) {
      this._renderImageMarkup();
    } else if (isAnimationAvailable) {
      this._renderAnimationMarkup();
    }
  }
  _getSegmentParams() {
    const {
      _animationType: animationType,
      _animatingSegmentCount: animatingSegmentCount,
      _animatingSegmentInner: animatingSegmentInner
    } = this.option();
    switch (animationType) {
      case AnimationType.Sparkle:
        return {
          segmentCount: 2,
          segmentInner: false
        };
      case AnimationType.Circle:
      default:
        return {
          segmentCount: animatingSegmentCount ?? 0,
          segmentInner: Boolean(animatingSegmentInner)
        };
    }
  }
  _renderAnimationMarkup() {
    this._$indicator = renderer_default("<div>").addClass("dx-loadindicator-icon");
    this._$content.append(this._$indicator);
    const params = this._getSegmentParams();
    this._renderSegments(params);
  }
  _renderSegments(params) {
    const {
      segmentCount,
      segmentInner
    } = params;
    for (let i = segmentCount; i >= 0; i -= 1) {
      var _this$_$indicator;
      const $segment = renderer_default("<div>").addClass("dx-loadindicator-segment").addClass(`dx-loadindicator-segment${i}`);
      if (segmentInner) {
        const $segmentInner = renderer_default("<div>").addClass("dx-loadindicator-segment-inner");
        $segment.append($segmentInner);
      }
      null === (_this$_$indicator = this._$indicator) || void 0 === _this$_$indicator || _this$_$indicator.append($segment);
    }
  }
  _renderImageMarkup() {
    const {
      indicatorSrc
    } = this.option();
    this._$wrapper.addClass("dx-loadindicator-image");
    this._$wrapper.css("backgroundImage", `url(${indicatorSrc})`);
  }
  _renderDimensions() {
    super._renderDimensions();
    this._updateContentSizeForAnimation();
  }
  _updateContentSizeForAnimation() {
    if (!this._$indicator) {
      return;
    }
    let {
      width,
      height
    } = this.option();
    if (width || height) {
      width = getWidth(this.$element());
      height = getHeight(this.$element());
      const minDimension = Math.min(height, width);
      this._$wrapper.css({
        height: minDimension,
        width: minDimension,
        fontSize: minDimension
      });
    }
  }
  _clean() {
    super._clean();
    this._removeMarkupForAnimation();
    this._removeMarkupForImage();
  }
  _removeMarkupForAnimation() {
    if (!this._$indicator) {
      return;
    }
    this._$indicator.remove();
    delete this._$indicator;
  }
  _removeMarkupForImage() {
    this._$wrapper.css("backgroundImage", "none");
  }
  _optionChanged(args) {
    switch (args.name) {
      case "_animatingSegmentCount":
      case "_animatingSegmentInner":
      case "_animationType":
      case "indicatorSrc":
        this._invalidate();
        break;
      default:
        super._optionChanged(args);
    }
  }
};
component_registrator_default("dxLoadIndicator", LoadIndicator);
var m_load_indicator_default = LoadIndicator;

// node_modules/devextreme/esm/ui/load_indicator.js
var load_indicator_default = m_load_indicator_default;

// node_modules/devextreme/esm/__internal/events/gesture/m_emitter.gesture.js
var ready4 = ready_callbacks_default.add;
var {
  abs
} = Math;
var TOUCH_BOUNDARY = 10;
var supportPointerEvents = function() {
  return styleProp("pointer-events");
};
var setGestureCover = call_once_default(() => {
  const isDesktop = "desktop" === m_devices_default.real().deviceType;
  if (!supportPointerEvents() || !isDesktop) {
    return noop2;
  }
  const $cover = renderer_default("<div>").addClass("dx-gesture-cover").css("pointerEvents", "none");
  m_events_engine_default.subscribeGlobal($cover, "dxmousewheel", (e) => {
    e.preventDefault();
  });
  ready4(() => {
    $cover.appendTo("body");
  });
  return function(toggle, cursor) {
    $cover.css("pointerEvents", toggle ? "all" : "none");
    toggle && $cover.css("cursor", cursor);
  };
});
var gestureCover = function(toggle, cursor) {
  const gestureCoverStrategy = setGestureCover();
  gestureCoverStrategy(toggle, cursor);
};
var GestureEmitter = m_emitter_default.inherit({
  gesture: true,
  configure(data17) {
    this.getElement().css("msTouchAction", data17.immediate ? "pinch-zoom" : "");
    this.callBase(data17);
  },
  allowInterruptionByMouseWheel() {
    return 2 !== this._stage;
  },
  getDirection() {
    return this.direction;
  },
  _cancel() {
    this.callBase.apply(this, arguments);
    this._toggleGestureCover(false);
    this._stage = 0;
  },
  start(e) {
    if (e._needSkipEvent || needSkipEvent(e)) {
      this._cancel(e);
      return;
    }
    this._startEvent = createEvent(e);
    this._startEventData = eventData(e);
    this._stage = 1;
    this._init(e);
    this._setupImmediateTimer();
  },
  _setupImmediateTimer() {
    clearTimeout(this._immediateTimer);
    this._immediateAccepted = false;
    if (!this.immediate) {
      return;
    }
    if (0 === this.immediateTimeout) {
      this._immediateAccepted = true;
      return;
    }
    this._immediateTimer = setTimeout(() => {
      this._immediateAccepted = true;
    }, this.immediateTimeout ?? 180);
  },
  move(e) {
    if (1 === this._stage && this._directionConfirmed(e)) {
      this._stage = 2;
      this._resetActiveElement();
      this._toggleGestureCover(true);
      this._clearSelection(e);
      this._adjustStartEvent(e);
      this._start(this._startEvent);
      if (0 === this._stage) {
        return;
      }
      this._requestAccept(e);
      this._move(e);
      this._forgetAccept();
    } else if (2 === this._stage) {
      this._clearSelection(e);
      this._move(e);
    }
  },
  _directionConfirmed(e) {
    const touchBoundary = this._getTouchBoundary(e);
    const delta = eventDelta(this._startEventData, eventData(e));
    const deltaX = abs(delta.x);
    const deltaY = abs(delta.y);
    const horizontalMove = this._validateMove(touchBoundary, deltaX, deltaY);
    const verticalMove = this._validateMove(touchBoundary, deltaY, deltaX);
    const direction = this.getDirection(e);
    const bothAccepted = "both" === direction && (horizontalMove || verticalMove);
    const horizontalAccepted = "horizontal" === direction && horizontalMove;
    const verticalAccepted = "vertical" === direction && verticalMove;
    return bothAccepted || horizontalAccepted || verticalAccepted || this._immediateAccepted;
  },
  _validateMove(touchBoundary, mainAxis, crossAxis) {
    return mainAxis && mainAxis >= touchBoundary && (this.immediate ? mainAxis >= crossAxis : true);
  },
  _getTouchBoundary(e) {
    return this.immediate || isDxMouseWheelEvent(e) ? 0 : TOUCH_BOUNDARY;
  },
  _adjustStartEvent(e) {
    const touchBoundary = this._getTouchBoundary(e);
    const delta = eventDelta(this._startEventData, eventData(e));
    this._startEvent.pageX += sign(delta.x) * touchBoundary;
    this._startEvent.pageY += sign(delta.y) * touchBoundary;
  },
  _resetActiveElement() {
    if ("ios" === m_devices_default.real().platform && this.getElement().find(":focus").length) {
      m_dom_default.resetActiveElement();
    }
  },
  _toggleGestureCover(toggle) {
    this._toggleGestureCoverImpl(toggle);
  },
  _toggleGestureCoverImpl(toggle) {
    const isStarted = 2 === this._stage;
    if (isStarted) {
      gestureCover(toggle, this.getElement().css("cursor"));
    }
  },
  _clearSelection(e) {
    if (isDxMouseWheelEvent(e) || isTouchEvent(e)) {
      return;
    }
    m_dom_default.clearSelection();
  },
  end(e) {
    this._toggleGestureCover(false);
    if (2 === this._stage) {
      this._end(e);
    } else if (1 === this._stage) {
      this._stop(e);
    }
    this._stage = 0;
  },
  dispose() {
    clearTimeout(this._immediateTimer);
    this.callBase.apply(this, arguments);
    this._toggleGestureCover(false);
  },
  _init: noop2,
  _start: noop2,
  _move: noop2,
  _stop: noop2,
  _end: noop2
});
GestureEmitter.initialTouchBoundary = TOUCH_BOUNDARY;
GestureEmitter.touchBoundary = function(newBoundary) {
  if (isDefined(newBoundary)) {
    TOUCH_BOUNDARY = newBoundary;
    return;
  }
  return TOUCH_BOUNDARY;
};
var m_emitter_gesture_default = GestureEmitter;

// node_modules/devextreme/esm/__internal/events/m_drag.js
var DRAG_START_EVENT = "dxdragstart";
var DRAG_EVENT = "dxdrag";
var DRAG_END_EVENT = "dxdragend";
var DRAG_ENTER_EVENT = "dxdragenter";
var DRAG_LEAVE_EVENT = "dxdragleave";
var DROP_EVENT = "dxdrop";
var knownDropTargets = [];
var knownDropTargetSelectors = [];
var knownDropTargetConfigs = [];
var dropTargetRegistration = {
  setup(element, data17) {
    const knownDropTarget = knownDropTargets.includes(element);
    if (!knownDropTarget) {
      knownDropTargets.push(element);
      knownDropTargetSelectors.push([]);
      knownDropTargetConfigs.push(data17 || {});
    }
  },
  add(element, handleObj) {
    const index2 = knownDropTargets.indexOf(element);
    this.updateEventsCounter(element, handleObj.type, 1);
    const {
      selector
    } = handleObj;
    if (!knownDropTargetSelectors[index2].includes(selector)) {
      knownDropTargetSelectors[index2].push(selector);
    }
  },
  updateEventsCounter(element, event, value2) {
    if ([DRAG_ENTER_EVENT, DRAG_LEAVE_EVENT, DROP_EVENT].includes(event)) {
      const eventsCount = data(element, "dxDragEventsCount") || 0;
      data(element, "dxDragEventsCount", Math.max(0, eventsCount + value2));
    }
  },
  remove(element, handleObj) {
    this.updateEventsCounter(element, handleObj.type, -1);
  },
  teardown(element) {
    const handlersCount = data(element, "dxDragEventsCount");
    if (!handlersCount) {
      const index2 = knownDropTargets.indexOf(element);
      knownDropTargets.splice(index2, 1);
      knownDropTargetSelectors.splice(index2, 1);
      knownDropTargetConfigs.splice(index2, 1);
      removeData(element, "dxDragEventsCount");
    }
  }
};
m_event_registrator_default(DRAG_ENTER_EVENT, dropTargetRegistration);
m_event_registrator_default(DRAG_LEAVE_EVENT, dropTargetRegistration);
m_event_registrator_default(DROP_EVENT, dropTargetRegistration);
var getItemDelegatedTargets = function($element) {
  const dropTargetIndex = knownDropTargets.indexOf($element.get(0));
  const dropTargetSelectors = knownDropTargetSelectors[dropTargetIndex].filter((selector) => selector);
  let $delegatedTargets = $element.find(dropTargetSelectors.join(", "));
  if (knownDropTargetSelectors[dropTargetIndex].includes(void 0)) {
    $delegatedTargets = $delegatedTargets.add($element);
  }
  return $delegatedTargets;
};
var getItemConfig = function($element) {
  const dropTargetIndex = knownDropTargets.indexOf($element.get(0));
  return knownDropTargetConfigs[dropTargetIndex];
};
var getItemPosition = function(dropTargetConfig, $element) {
  if (dropTargetConfig.itemPositionFunc) {
    return dropTargetConfig.itemPositionFunc($element);
  }
  return $element.offset();
};
var getItemSize = function(dropTargetConfig, $element) {
  if (dropTargetConfig.itemSizeFunc) {
    return dropTargetConfig.itemSizeFunc($element);
  }
  return {
    width: $element.get(0).getBoundingClientRect().width,
    height: $element.get(0).getBoundingClientRect().height
  };
};
var DragEmitter = m_emitter_gesture_default.inherit({
  ctor(element) {
    this.callBase(element);
    this.direction = "both";
  },
  _init(e) {
    this._initEvent = e;
  },
  _start(e) {
    e = this._fireEvent("dxdragstart", this._initEvent);
    this._maxLeftOffset = e.maxLeftOffset;
    this._maxRightOffset = e.maxRightOffset;
    this._maxTopOffset = e.maxTopOffset;
    this._maxBottomOffset = e.maxBottomOffset;
    if (e.targetElements || null === e.targetElements) {
      const dropTargets = wrapToArray(e.targetElements || []);
      this._dropTargets = map(dropTargets, (element) => renderer_default(element).get(0));
    } else {
      this._dropTargets = knownDropTargets;
    }
  },
  _move(e) {
    const eventData2 = eventData(e);
    const dragOffset = this._calculateOffset(eventData2);
    e = this._fireEvent("dxdrag", e, {
      offset: dragOffset
    });
    this._processDropTargets(e);
    if (!e._cancelPreventDefault) {
      e.preventDefault();
    }
  },
  _calculateOffset(eventData2) {
    return {
      x: this._calculateXOffset(eventData2),
      y: this._calculateYOffset(eventData2)
    };
  },
  _calculateXOffset(eventData2) {
    if ("vertical" !== this.direction) {
      const offset2 = eventData2.x - this._startEventData.x;
      return this._fitOffset(offset2, this._maxLeftOffset, this._maxRightOffset);
    }
    return 0;
  },
  _calculateYOffset(eventData2) {
    if ("horizontal" !== this.direction) {
      const offset2 = eventData2.y - this._startEventData.y;
      return this._fitOffset(offset2, this._maxTopOffset, this._maxBottomOffset);
    }
    return 0;
  },
  _fitOffset(offset2, minOffset, maxOffset) {
    if (null != minOffset) {
      offset2 = Math.max(offset2, -minOffset);
    }
    if (null != maxOffset) {
      offset2 = Math.min(offset2, maxOffset);
    }
    return offset2;
  },
  _processDropTargets(e) {
    const target = this._findDropTarget(e);
    const sameTarget = target === this._currentDropTarget;
    if (!sameTarget) {
      this._fireDropTargetEvent(e, DRAG_LEAVE_EVENT);
      this._currentDropTarget = target;
      this._fireDropTargetEvent(e, DRAG_ENTER_EVENT);
    }
  },
  _fireDropTargetEvent(event, eventName) {
    if (!this._currentDropTarget) {
      return;
    }
    const eventData2 = {
      type: eventName,
      originalEvent: event,
      draggingElement: this._$element.get(0),
      target: this._currentDropTarget
    };
    fireEvent(eventData2);
  },
  _findDropTarget(e) {
    const that = this;
    let result2;
    each(knownDropTargets, (_, target) => {
      if (!that._checkDropTargetActive(target)) {
        return;
      }
      const $target = renderer_default(target);
      each(getItemDelegatedTargets($target), (_2, delegatedTarget) => {
        const $delegatedTarget = renderer_default(delegatedTarget);
        if (that._checkDropTarget(getItemConfig($target), $delegatedTarget, renderer_default(result2), e)) {
          result2 = delegatedTarget;
        }
      });
    });
    return result2;
  },
  _checkDropTargetActive(target) {
    let active2 = false;
    each(this._dropTargets, (_, activeTarget) => {
      active2 = active2 || activeTarget === target || contains2(activeTarget, target);
      return !active2;
    });
    return active2;
  },
  _checkDropTarget(config3, $target, $prevTarget, e) {
    const isDraggingElement = $target.get(0) === renderer_default(e.target).get(0);
    if (isDraggingElement) {
      return false;
    }
    const targetPosition = getItemPosition(config3, $target);
    if (e.pageX < targetPosition.left) {
      return false;
    }
    if (e.pageY < targetPosition.top) {
      return false;
    }
    const targetSize = getItemSize(config3, $target);
    if (e.pageX > targetPosition.left + targetSize.width) {
      return false;
    }
    if (e.pageY > targetPosition.top + targetSize.height) {
      return false;
    }
    if ($prevTarget.length && $prevTarget.closest($target).length) {
      return false;
    }
    if (config3.checkDropTarget && !config3.checkDropTarget($target, e)) {
      return false;
    }
    return $target;
  },
  _end(e) {
    const eventData2 = eventData(e);
    this._fireEvent("dxdragend", e, {
      offset: this._calculateOffset(eventData2)
    });
    this._fireDropTargetEvent(e, DROP_EVENT);
    delete this._currentDropTarget;
  }
});
m_emitter_registrator_default({
  emitter: DragEmitter,
  events: ["dxdragstart", "dxdrag", "dxdragend"]
});

// node_modules/devextreme/esm/ui/widget/swatch_container.js
var getSwatchContainer = (element) => {
  const $element = renderer_default(element);
  const swatchContainer = $element.closest('[class^="dx-swatch-"], [class*=" dx-swatch-"]');
  const viewport = value();
  if (!swatchContainer.length) {
    return viewport;
  }
  const swatchClassRegex = new RegExp("(\\s|^)(dx-swatch-.*?)(\\s|$)");
  const swatchClass = swatchContainer[0].className.match(swatchClassRegex)[2];
  let viewportSwatchContainer = viewport.children("." + swatchClass);
  if (!viewportSwatchContainer.length) {
    viewportSwatchContainer = renderer_default("<div>").addClass(swatchClass).appendTo(viewport);
  }
  return viewportSwatchContainer;
};
var swatch_container_default = {
  getSwatchContainer
};

// node_modules/devextreme/esm/__internal/ui/overlay/m_overlay_position_controller.js
var window16 = m_window_default.getWindow();
var OVERLAY_POSITION_ALIASES = {
  top: {
    my: "top center",
    at: "top center"
  },
  bottom: {
    my: "bottom center",
    at: "bottom center"
  },
  right: {
    my: "right center",
    at: "right center"
  },
  left: {
    my: "left center",
    at: "left center"
  },
  center: {
    my: "center",
    at: "center"
  },
  "right bottom": {
    my: "right bottom",
    at: "right bottom"
  },
  "right top": {
    my: "right top",
    at: "right top"
  },
  "left bottom": {
    my: "left bottom",
    at: "left bottom"
  },
  "left top": {
    my: "left top",
    at: "left top"
  }
};
var OVERLAY_DEFAULT_BOUNDARY_OFFSET = {
  h: 0,
  v: 0
};
var OverlayPositionController = class {
  constructor(_ref) {
    let {
      position: position3,
      container,
      visualContainer,
      $root,
      $content,
      $wrapper,
      onPositioned,
      onVisualPositionChanged,
      restorePosition,
      _fixWrapperPosition,
      _skipContentPositioning
    } = _ref;
    this._props = {
      position: position3,
      container,
      visualContainer,
      restorePosition,
      onPositioned,
      onVisualPositionChanged,
      _fixWrapperPosition,
      _skipContentPositioning
    };
    this._$root = $root;
    this._$content = $content;
    this._$wrapper = $wrapper;
    this._$markupContainer = void 0;
    this._$visualContainer = void 0;
    this._shouldRenderContentInitialPosition = true;
    this._visualPosition = void 0;
    this._initialPosition = void 0;
    this._previousVisualPosition = void 0;
    this.updateContainer(container);
    this.updatePosition(position3);
    this.updateVisualContainer(visualContainer);
  }
  get $container() {
    this.updateContainer();
    return this._$markupContainer;
  }
  get $visualContainer() {
    return this._$visualContainer;
  }
  get position() {
    return this._position;
  }
  set fixWrapperPosition(fixWrapperPosition) {
    this._props._fixWrapperPosition = fixWrapperPosition;
    this.styleWrapperPosition();
  }
  set restorePosition(restorePosition) {
    this._props.restorePosition = restorePosition;
  }
  restorePositionOnNextRender(value2) {
    this._shouldRenderContentInitialPosition = value2 || !this._visualPosition;
  }
  openingHandled() {
    const shouldRestorePosition = this._props.restorePosition;
    this.restorePositionOnNextRender(shouldRestorePosition);
  }
  updatePosition(positionProp) {
    this._props.position = positionProp;
    this._position = this._normalizePosition(positionProp);
    this.updateVisualContainer();
  }
  updateContainer() {
    let containerProp = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this._props.container;
    this._props.container = containerProp;
    this._$markupContainer = containerProp ? renderer_default(containerProp) : swatch_container_default.getSwatchContainer(this._$root);
    this.updateVisualContainer(this._props.visualContainer);
  }
  updateVisualContainer() {
    let visualContainer = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this._props.visualContainer;
    this._props.visualContainer = visualContainer;
    this._$visualContainer = this._getVisualContainer();
  }
  detectVisualPositionChange(event) {
    this._updateVisualPositionValue();
    this._raisePositionedEvents(event);
  }
  positionContent() {
    if (this._shouldRenderContentInitialPosition) {
      this._renderContentInitialPosition();
    } else {
      move(this._$content, this._visualPosition);
      this.detectVisualPositionChange();
    }
  }
  positionWrapper() {
    if (this._$visualContainer) {
      position_default.setup(this._$wrapper, {
        my: "top left",
        at: "top left",
        of: this._$visualContainer
      });
    }
  }
  styleWrapperPosition() {
    const useFixed = isWindow(this.$visualContainer.get(0)) || this._props._fixWrapperPosition;
    const positionStyle = useFixed ? "fixed" : "absolute";
    this._$wrapper.css("position", positionStyle);
  }
  _updateVisualPositionValue() {
    this._previousVisualPosition = this._visualPosition;
    this._visualPosition = locate(this._$content);
  }
  _renderContentInitialPosition() {
    this._renderBoundaryOffset();
    resetPosition(this._$content);
    const wrapperOverflow = this._$wrapper.css("overflow");
    this._$wrapper.css("overflow", "hidden");
    if (!this._props._skipContentPositioning) {
      const resultPosition = position_default.setup(this._$content, this._position);
      this._initialPosition = resultPosition;
    }
    this._$wrapper.css("overflow", wrapperOverflow);
    this.detectVisualPositionChange();
  }
  _raisePositionedEvents(event) {
    const previousPosition = this._previousVisualPosition;
    const newPosition = this._visualPosition;
    const isVisualPositionChanged = (null === previousPosition || void 0 === previousPosition ? void 0 : previousPosition.top) !== newPosition.top || (null === previousPosition || void 0 === previousPosition ? void 0 : previousPosition.left) !== newPosition.left;
    if (isVisualPositionChanged) {
      this._props.onVisualPositionChanged({
        previousPosition,
        position: newPosition,
        event
      });
    }
    this._props.onPositioned({
      position: this._initialPosition
    });
  }
  _renderBoundaryOffset() {
    const boundaryOffset = this._position ?? {
      boundaryOffset: OVERLAY_DEFAULT_BOUNDARY_OFFSET
    };
    this._$content.css("margin", `${boundaryOffset.v}px ${boundaryOffset.h}px`);
  }
  _getVisualContainer() {
    var _this$_props$position, _this$_props$position2;
    const containerProp = this._props.container;
    const visualContainerProp = this._props.visualContainer;
    const positionOf = isEvent(null === (_this$_props$position = this._props.position) || void 0 === _this$_props$position ? void 0 : _this$_props$position.of) ? this._props.position.of.target : null === (_this$_props$position2 = this._props.position) || void 0 === _this$_props$position2 ? void 0 : _this$_props$position2.of;
    if (visualContainerProp) {
      return renderer_default(visualContainerProp);
    }
    if (containerProp) {
      return renderer_default(containerProp);
    }
    if (positionOf) {
      return renderer_default(positionOf);
    }
    return renderer_default(window16);
  }
  _normalizePosition(positionProp) {
    const defaultPositionConfig = {
      boundaryOffset: OVERLAY_DEFAULT_BOUNDARY_OFFSET
    };
    if (isDefined(positionProp)) {
      return extend(true, {}, defaultPositionConfig, this._positionToObject(positionProp));
    }
    return defaultPositionConfig;
  }
  _positionToObject(position3) {
    if (isString(position3)) {
      return extend({}, OVERLAY_POSITION_ALIASES[position3]);
    }
    return position3;
  }
};

// node_modules/devextreme/esm/__internal/ui/overlay/m_z_index.js
var baseZIndex = 1500;
var zIndexStack = [];
var base = (ZIndex) => {
  baseZIndex = ensureDefined(ZIndex, baseZIndex);
  return baseZIndex;
};
var create = function() {
  let baseIndex = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : baseZIndex;
  const {
    length
  } = zIndexStack;
  const index2 = (length ? zIndexStack[length - 1] : baseIndex) + 1;
  zIndexStack.push(index2);
  return index2;
};
var remove2 = (zIndex) => {
  const position3 = zIndexStack.indexOf(zIndex);
  if (position3 >= 0) {
    zIndexStack.splice(position3, 1);
  }
};
var isLastZIndexInStack = (zIndex) => zIndexStack.length && zIndexStack[zIndexStack.length - 1] === zIndex;

// node_modules/devextreme/esm/__internal/ui/overlay/m_overlay.js
var ready5 = ready_callbacks_default.add;
var window17 = m_window_default.getWindow();
var viewPortChanged2 = changeCallback;
var OVERLAY_STACK = [];
ready5(() => {
  m_events_engine_default.subscribeGlobal(dom_adapter_default.getDocument(), m_pointer_default.down, (e) => {
    for (let i = OVERLAY_STACK.length - 1; i >= 0; i--) {
      if (!OVERLAY_STACK[i]._proxiedDocumentDownHandler(e)) {
        return;
      }
    }
  });
});
var Overlay = class _Overlay extends widget_default {
  _supportedKeys() {
    return _extends({}, super._supportedKeys(), {
      escape() {
        this.hide();
      }
    });
  }
  _getDefaultOptions() {
    return _extends({}, super._getDefaultOptions(), {
      activeStateEnabled: false,
      visible: false,
      deferRendering: true,
      shading: true,
      shadingColor: "",
      wrapperAttr: {},
      position: extend({}, OVERLAY_POSITION_ALIASES.center),
      width: "80vw",
      minWidth: null,
      maxWidth: null,
      height: "80vh",
      minHeight: null,
      maxHeight: null,
      animation: {
        show: {
          type: "pop",
          duration: 300,
          from: {
            scale: 0.55
          }
        },
        hide: {
          type: "pop",
          duration: 300,
          from: {
            opacity: 1,
            scale: 1
          },
          to: {
            opacity: 0,
            scale: 0.55
          }
        }
      },
      hideOnOutsideClick: false,
      _ignorePreventScrollEventsDeprecation: false,
      onShowing: null,
      onShown: null,
      onHiding: null,
      onHidden: null,
      contentTemplate: "content",
      innerOverlay: false,
      restorePosition: true,
      hideTopOverlayHandler: () => {
        this.hide();
      },
      hideOnParentScroll: false,
      preventScrollEvents: true,
      onPositioned: null,
      propagateOutsideClick: false,
      ignoreChildEvents: true,
      _checkParentVisibility: true,
      _fixWrapperPosition: false,
      _loopFocus: false
    });
  }
  _defaultOptionsRules() {
    return super._defaultOptionsRules().concat([{
      device: () => !m_window_default.hasWindow(),
      options: {
        width: null,
        height: null,
        animation: null,
        _checkParentVisibility: false
      }
    }]);
  }
  _setOptionsByReference() {
    super._setOptionsByReference();
    extend(this._optionsByReference, {
      animation: true
    });
  }
  $wrapper() {
    return this._$wrapper;
  }
  _eventBindingTarget() {
    return this._$content;
  }
  ctor(element, options2) {
    super.ctor(element, options2);
    if (options2) {
      if ("preventScrollEvents" in options2 && !options2._ignorePreventScrollEventsDeprecation) {
        this._logDeprecatedPreventScrollEventsInfo();
      }
    }
  }
  _logDeprecatedPreventScrollEventsInfo() {
    this._logDeprecatedOptionWarning("preventScrollEvents", {
      since: "23.1",
      message: "If you enable this option, end-users may experience scrolling issues."
    });
  }
  _init() {
    super._init();
    this._initActions();
    this._initHideOnOutsideClickHandler();
    this._initTabTerminatorHandler();
    this._customWrapperClass = null;
    this._$wrapper = renderer_default("<div>").addClass("dx-overlay-wrapper");
    this._$content = renderer_default("<div>").addClass("dx-overlay-content");
    this._initInnerOverlayClass();
    const $element = this.$element();
    $element.addClass("dx-overlay");
    this._$wrapper.attr("data-bind", "dxControlsDescendantBindings: true");
    this._toggleViewPortSubscription(true);
    const {
      hideTopOverlayHandler
    } = this.option();
    this._initHideTopOverlayHandler(hideTopOverlayHandler);
    this._parentsScrollSubscriptionInfo = {
      handler: (e) => {
        this._hideOnParentsScrollHandler(e);
      }
    };
    this.warnPositionAsFunction();
  }
  warnPositionAsFunction() {
    if (isFunction(this.option("position"))) {
      errors_default.log("W0018");
    }
  }
  _initInnerOverlayClass() {
    const {
      innerOverlay
    } = this.option();
    this._$content.toggleClass("dx-inner-overlay", innerOverlay);
  }
  _initHideTopOverlayHandler(handler) {
    this._hideTopOverlayHandler = handler;
  }
  _getActionsList() {
    return ["onShowing", "onShown", "onHiding", "onHidden", "onPositioned", "onVisualPositionChanged"];
  }
  _initActions() {
    this._actions = {};
    const actions = this._getActionsList();
    each(actions, (_, action) => {
      this._actions[action] = this._createActionByOption(action, {
        excludeValidators: ["disabled", "readOnly"]
      }) || noop2;
    });
  }
  _initHideOnOutsideClickHandler() {
    var _this = this;
    this._proxiedDocumentDownHandler = function() {
      return _this._documentDownHandler(...arguments);
    };
  }
  _initMarkup() {
    super._initMarkup();
    this._renderWrapperAttributes();
    this._initPositionController();
  }
  _documentDownHandler(e) {
    if (this._showAnimationProcessing) {
      this._stopAnimation();
    }
    const isAttachedTarget = renderer_default(window17.document).is(e.target) || m_dom_default.contains(window17.document, e.target);
    const isInnerOverlay = renderer_default(e.target).closest(".dx-inner-overlay").length;
    const outsideClick = isAttachedTarget && !isInnerOverlay && !(this._$content.is(e.target) || m_dom_default.contains(this._$content.get(0), e.target));
    if (outsideClick && this._shouldHideOnOutsideClick(e)) {
      this._outsideClickHandler(e);
    }
    const {
      propagateOutsideClick
    } = this.option();
    return propagateOutsideClick;
  }
  _shouldHideOnOutsideClick(e) {
    const {
      hideOnOutsideClick
    } = this.option();
    if (isFunction(hideOnOutsideClick)) {
      return hideOnOutsideClick(e);
    }
    return hideOnOutsideClick;
  }
  _outsideClickHandler(e) {
    if (this.option("shading")) {
      e.preventDefault();
    }
    this.hide();
  }
  _getAnonymousTemplateName() {
    return "content";
  }
  _initTemplates() {
    this._templateManager.addDefaultTemplates({
      content: new EmptyTemplate()
    });
    super._initTemplates();
  }
  _isTopOverlay() {
    const overlayStack = this._overlayStack();
    for (let i = overlayStack.length - 1; i >= 0; i--) {
      const tabbableElements = overlayStack[i]._findTabbableBounds();
      if (tabbableElements.first || tabbableElements.last) {
        return overlayStack[i] === this;
      }
    }
    return false;
  }
  _overlayStack() {
    return OVERLAY_STACK;
  }
  _zIndexInitValue() {
    return _Overlay.baseZIndex();
  }
  _toggleViewPortSubscription(toggle) {
    var _this2 = this;
    viewPortChanged2.remove(this._viewPortChangeHandle);
    if (toggle) {
      this._viewPortChangeHandle = function() {
        _this2._viewPortChangeHandler(...arguments);
      };
      viewPortChanged2.add(this._viewPortChangeHandle);
    }
  }
  _viewPortChangeHandler() {
    this._positionController.updateContainer(this.option("container"));
    this._refresh();
  }
  _renderWrapperAttributes() {
    const {
      wrapperAttr
    } = this.option();
    const attributes = extend({}, wrapperAttr);
    const classNames2 = attributes.class;
    delete attributes.class;
    this.$wrapper().attr(attributes).removeClass(this._customWrapperClass).addClass(classNames2);
    this._customWrapperClass = classNames2;
  }
  _renderVisibilityAnimate(visible2) {
    this._stopAnimation();
    return visible2 ? this._show() : this._hide();
  }
  _getAnimationConfig() {
    return this._getOptionValue("animation", this);
  }
  _toggleBodyScroll(enabled) {
  }
  _animateShowing() {
    var _this3 = this;
    const animation3 = this._getAnimationConfig() ?? {};
    const showAnimation = this._normalizeAnimation(animation3.show, "to");
    const startShowAnimation = (null === showAnimation || void 0 === showAnimation ? void 0 : showAnimation.start) ?? noop2;
    const completeShowAnimation = (null === showAnimation || void 0 === showAnimation ? void 0 : showAnimation.complete) ?? noop2;
    this._animate(showAnimation, function() {
      if (_this3._isAnimationPaused) {
        return;
      }
      if (_this3.option("focusStateEnabled")) {
        m_events_engine_default.trigger(_this3._focusTarget(), "focus");
      }
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      completeShowAnimation.call(_this3, ...args);
      _this3._showAnimationProcessing = false;
      _this3._isHidden = false;
      _this3._actions.onShown();
      _this3._toggleSafariScrolling();
      _this3._showingDeferred.resolve();
    }, function() {
      if (_this3._isAnimationPaused) {
        return;
      }
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      startShowAnimation.call(_this3, ...args);
      _this3._showAnimationProcessing = true;
    });
  }
  _processShowingHidingCancel(cancelArg, applyFunction, cancelFunction) {
    if (isPromise(cancelArg)) {
      cancelArg.then((shouldCancel) => {
        if (shouldCancel) {
          cancelFunction();
        } else {
          applyFunction();
        }
      }).catch(() => applyFunction());
    } else {
      cancelArg ? cancelFunction() : applyFunction();
    }
  }
  _show() {
    this._showingDeferred = Deferred();
    this._parentHidden = this._isParentHidden();
    this._showingDeferred.done(() => {
      delete this._parentHidden;
    });
    if (this._parentHidden) {
      this._isHidden = true;
      return this._showingDeferred.resolve();
    }
    if (this._currentVisible) {
      return Deferred().resolve().promise();
    }
    this._currentVisible = true;
    if (this._isHidingActionCanceled) {
      delete this._isHidingActionCanceled;
      this._showingDeferred.reject();
    } else {
      const show = () => {
        this._stopAnimation();
        const {
          enableBodyScroll
        } = this.option();
        this._toggleBodyScroll(enableBodyScroll);
        this._toggleVisibility(true);
        this._$content.css("visibility", "hidden");
        this._$content.toggleClass("dx-state-invisible", false);
        this._updateZIndexStackPosition(true);
        this._positionController.openingHandled();
        this._renderContent();
        const showingArgs = {
          cancel: false
        };
        this._actions.onShowing(showingArgs);
        this._processShowingHidingCancel(showingArgs.cancel, () => {
          this._$content.css("visibility", "");
          this._renderVisibility(true);
          this._animateShowing();
        }, () => {
          this._toggleVisibility(false);
          this._$content.css("visibility", "");
          this._$content.toggleClass("dx-state-invisible", true);
          this._isShowingActionCanceled = true;
          this._moveFromContainer();
          this._toggleBodyScroll(true);
          this.option("visible", false);
          this._showingDeferred.resolve();
        });
      };
      if (this.option("templatesRenderAsynchronously")) {
        this._stopShowTimer();
        this._asyncShowTimeout = setTimeout(show);
      } else {
        show();
      }
    }
    return this._showingDeferred.promise();
  }
  _normalizeAnimation(showHideConfig, direction) {
    if (showHideConfig) {
      showHideConfig = extend({
        type: "slide",
        skipElementInitialStyles: true
      }, showHideConfig);
      if (isObject(showHideConfig[direction])) {
        extend(showHideConfig[direction], {
          position: this._positionController.position
        });
      }
    }
    return showHideConfig;
  }
  _animateHiding() {
    var _this4 = this;
    const animation3 = this._getAnimationConfig() ?? {};
    const hideAnimation = this._normalizeAnimation(animation3.hide, "from");
    const startHideAnimation = (null === hideAnimation || void 0 === hideAnimation ? void 0 : hideAnimation.start) ?? noop2;
    const completeHideAnimation = (null === hideAnimation || void 0 === hideAnimation ? void 0 : hideAnimation.complete) ?? noop2;
    this._animate(hideAnimation, function() {
      var _this4$_actions;
      _this4._$content.css("pointerEvents", "");
      _this4._renderVisibility(false);
      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }
      completeHideAnimation.call(_this4, ...args);
      _this4._hideAnimationProcessing = false;
      null === (_this4$_actions = _this4._actions) || void 0 === _this4$_actions || _this4$_actions.onHidden();
      _this4._hidingDeferred.resolve();
    }, function() {
      _this4._$content.css("pointerEvents", "none");
      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        args[_key4] = arguments[_key4];
      }
      startHideAnimation.call(_this4, ...args);
      _this4._hideAnimationProcessing = true;
    });
  }
  _hide() {
    if (!this._currentVisible) {
      return Deferred().resolve().promise();
    }
    this._currentVisible = false;
    this._hidingDeferred = Deferred();
    const hidingArgs = {
      cancel: false
    };
    if (this._isShowingActionCanceled) {
      delete this._isShowingActionCanceled;
      this._hidingDeferred.reject();
    } else {
      this._actions.onHiding(hidingArgs);
      this._toggleSafariScrolling();
      this._toggleBodyScroll(true);
      const cancelHide = () => {
        this._isHidingActionCanceled = true;
        const {
          enableBodyScroll
        } = this.option();
        this._toggleBodyScroll(enableBodyScroll);
        this.option("visible", true);
        this._hidingDeferred.resolve();
      };
      const applyHide = () => {
        this._forceFocusLost();
        this._toggleShading(false);
        this._toggleSubscriptions(false);
        this._stopShowTimer();
        this._animateHiding();
      };
      this._processShowingHidingCancel(hidingArgs.cancel, applyHide, cancelHide);
    }
    return this._hidingDeferred.promise();
  }
  _forceFocusLost() {
    const activeElement = dom_adapter_default.getActiveElement();
    const shouldResetActiveElement = !!this._$content.find(activeElement).length;
    if (shouldResetActiveElement) {
      m_dom_default.resetActiveElement();
    }
  }
  _animate(animation3, completeCallback, startCallback) {
    if (animation3) {
      startCallback = startCallback || animation3.start || noop2;
      fx_default.animate(this._$content, extend({}, animation3, {
        start: startCallback,
        complete: completeCallback
      }));
    } else {
      completeCallback();
    }
  }
  _stopAnimation() {
    fx_default.stop(this._$content, true);
  }
  _renderVisibility(visible2) {
    if (visible2 && this._isParentHidden()) {
      return;
    }
    this._currentVisible = visible2;
    this._stopAnimation();
    if (!visible2) {
      triggerHidingEvent2(this._$content);
    }
    if (visible2) {
      this._checkContainerExists();
      this._moveToContainer();
      this._renderGeometry();
      triggerShownEvent2(this._$content);
      triggerResizeEvent2(this._$content);
    } else {
      this._toggleVisibility(visible2);
      this._$content.toggleClass("dx-state-invisible", !visible2);
      this._updateZIndexStackPosition(visible2);
      this._moveFromContainer();
    }
    this._toggleShading(visible2);
    this._toggleSubscriptions(visible2);
  }
  _updateZIndexStackPosition(pushToStack) {
    const overlayStack = this._overlayStack();
    const index2 = overlayStack.indexOf(this);
    if (pushToStack) {
      if (-1 === index2) {
        this._zIndex = create(this._zIndexInitValue());
        overlayStack.push(this);
      }
      this._$wrapper.css("zIndex", this._zIndex);
      this._$content.css("zIndex", this._zIndex);
    } else if (-1 !== index2) {
      overlayStack.splice(index2, 1);
      remove2(this._zIndex);
    }
  }
  _toggleShading(visible2) {
    const {
      shading,
      shadingColor
    } = this.option();
    this._$wrapper.toggleClass("dx-overlay-shader", visible2 && shading);
    this._$wrapper.css("backgroundColor", shading ? shadingColor : "");
    this._toggleTabTerminator(visible2 && shading);
  }
  _initTabTerminatorHandler() {
    var _this5 = this;
    this._proxiedTabTerminatorHandler = function() {
      _this5._tabKeyHandler(...arguments);
    };
  }
  _toggleTabTerminator(enabled) {
    const {
      _loopFocus
    } = this.option();
    const eventName = addNamespace2("keydown", this.NAME);
    if (_loopFocus || enabled) {
      m_events_engine_default.on(dom_adapter_default.getDocument(), eventName, this._proxiedTabTerminatorHandler);
    } else {
      this._destroyTabTerminator();
    }
  }
  _destroyTabTerminator() {
    const eventName = addNamespace2("keydown", this.NAME);
    m_events_engine_default.off(dom_adapter_default.getDocument(), eventName, this._proxiedTabTerminatorHandler);
  }
  _findTabbableBounds() {
    const $elements = this._$wrapper.find("*");
    const elementsCount = $elements.length - 1;
    let first = null;
    let last = null;
    for (let i = 0; i <= elementsCount; i += 1) {
      if (!first && $elements.eq(i).is(tabbable)) {
        first = $elements.eq(i);
      }
      if (!last && $elements.eq(elementsCount - i).is(tabbable)) {
        last = $elements.eq(elementsCount - i);
      }
      if (first && last) {
        break;
      }
    }
    return {
      first,
      last
    };
  }
  _tabKeyHandler(e) {
    if ("tab" !== normalizeKeyName(e) || !this._isTopOverlay()) {
      return;
    }
    const wrapper = this._$wrapper.get(0);
    const activeElement = dom_adapter_default.getActiveElement(wrapper);
    const {
      first: $firstTabbable,
      last: $lastTabbable
    } = this._findTabbableBounds();
    const isTabOnLast = !e.shiftKey && activeElement === (null === $lastTabbable || void 0 === $lastTabbable ? void 0 : $lastTabbable.get(0));
    const isShiftTabOnFirst = e.shiftKey && activeElement === (null === $firstTabbable || void 0 === $firstTabbable ? void 0 : $firstTabbable.get(0));
    const isOutsideTarget = !m_dom_default.contains(wrapper, activeElement);
    const shouldPreventDefault = isTabOnLast || isShiftTabOnFirst || isOutsideTarget;
    if (shouldPreventDefault) {
      e.preventDefault();
      const $focusElement = e.shiftKey ? $lastTabbable : $firstTabbable;
      m_events_engine_default.trigger($focusElement, "focusin");
      m_events_engine_default.trigger($focusElement, "focus");
    }
  }
  _toggleSubscriptions(enabled) {
    if (m_window_default.hasWindow()) {
      this._toggleHideTopOverlayCallback(enabled);
      this._toggleHideOnParentsScrollSubscription(enabled);
    }
  }
  _toggleHideTopOverlayCallback(subscribe) {
    if (!this._hideTopOverlayHandler) {
      return;
    }
    if (subscribe) {
      hideCallback.add(this._hideTopOverlayHandler);
    } else {
      hideCallback.remove(this._hideTopOverlayHandler);
    }
  }
  _toggleHideOnParentsScrollSubscription(needSubscribe) {
    const scrollEvent = addNamespace2("scroll", this.NAME);
    const {
      prevTargets,
      handler
    } = this._parentsScrollSubscriptionInfo ?? {};
    m_events_engine_default.off(prevTargets, scrollEvent, handler);
    const hideOnScroll = this.option("hideOnParentScroll");
    if (needSubscribe && hideOnScroll) {
      let $parents = this._getHideOnParentScrollTarget().parents();
      if ("desktop" === devices_default.real().deviceType) {
        $parents = $parents.add(window17);
      }
      m_events_engine_default.on($parents, scrollEvent, handler);
      this._parentsScrollSubscriptionInfo.prevTargets = $parents;
    }
  }
  _hideOnParentsScrollHandler(e) {
    let hideHandled = false;
    const hideOnScroll = this.option("hideOnParentScroll");
    if (isFunction(hideOnScroll)) {
      hideHandled = hideOnScroll(e);
    }
    if (!hideHandled && !this._showAnimationProcessing) {
      this.hide();
    }
  }
  _getHideOnParentScrollTarget() {
    const {
      _hideOnParentScrollTarget
    } = this.option();
    const $hideOnParentScrollTarget = renderer_default(_hideOnParentScrollTarget);
    if ($hideOnParentScrollTarget.length) {
      return $hideOnParentScrollTarget;
    }
    return this._$wrapper;
  }
  _render() {
    super._render();
    this._appendContentToElement();
    this._renderVisibilityAnimate(this.option("visible"));
  }
  _appendContentToElement() {
    if (!this._$content.parent().is(this.$element())) {
      this._$content.appendTo(this.$element());
    }
  }
  _renderContent() {
    const shouldDeferRendering = !this._currentVisible && this.option("deferRendering");
    const isParentHidden = this.option("visible") && this._isParentHidden();
    if (isParentHidden) {
      this._isHidden = true;
      return;
    }
    if (this._contentAlreadyRendered || shouldDeferRendering) {
      return;
    }
    this._contentAlreadyRendered = true;
    this._appendContentToElement();
    super._renderContent();
  }
  _isParentHidden() {
    if (!this.option("_checkParentVisibility")) {
      return false;
    }
    if (void 0 !== this._parentHidden) {
      return this._parentHidden;
    }
    const $parent = this.$element().parent();
    if ($parent.is(":visible")) {
      return false;
    }
    let isHidden = false;
    $parent.add($parent.parents()).each((index2, element) => {
      const $element = renderer_default(element);
      if ("none" === $element.css("display")) {
        isHidden = true;
        return false;
      }
    });
    return isHidden || !dom_adapter_default.getBody().contains($parent.get(0));
  }
  _renderContentImpl() {
    const whenContentRendered = Deferred();
    const contentTemplateOption = this.option("contentTemplate");
    const contentTemplate = this._getTemplate(contentTemplateOption);
    const transclude = this._templateManager.anonymousTemplateName === contentTemplateOption;
    null === contentTemplate || void 0 === contentTemplate || contentTemplate.render({
      container: getPublicElement(this.$content()),
      noModel: true,
      transclude,
      onRendered: () => {
        whenContentRendered.resolve();
        if (this.option("templatesRenderAsynchronously")) {
          this._dimensionChanged();
        }
      }
    });
    const {
      preventScrollEvents
    } = this.option();
    this._toggleWrapperScrollEventsSubscription(preventScrollEvents);
    whenContentRendered.done(() => {
      if (this.option("visible")) {
        this._moveToContainer();
      }
    });
    return whenContentRendered.promise();
  }
  _getPositionControllerConfig() {
    const {
      container,
      visualContainer,
      _fixWrapperPosition,
      restorePosition,
      _skipContentPositioning
    } = this.option();
    return {
      container,
      visualContainer,
      $root: this.$element(),
      $content: this._$content,
      $wrapper: this._$wrapper,
      onPositioned: this._actions.onPositioned,
      onVisualPositionChanged: this._actions.onVisualPositionChanged,
      restorePosition,
      _fixWrapperPosition,
      _skipContentPositioning
    };
  }
  _initPositionController() {
    this._positionController = new OverlayPositionController(this._getPositionControllerConfig());
  }
  _toggleWrapperScrollEventsSubscription(enabled) {
    const eventName = addNamespace2(DRAG_EVENT, this.NAME);
    m_events_engine_default.off(this._$wrapper, eventName);
    if (enabled) {
      m_events_engine_default.on(this._$wrapper, eventName, {
        validate: () => true,
        getDirection: () => "both",
        _toggleGestureCover(toggle) {
          if (!toggle) {
            this._toggleGestureCoverImpl(toggle);
          }
        },
        _clearSelection: noop2,
        isNative: true
      }, (e) => {
        const {
          originalEvent
        } = e.originalEvent;
        const {
          type: type2
        } = originalEvent || {};
        const isWheel = "wheel" === type2;
        const isMouseMove = "mousemove" === type2;
        const isScrollByWheel = isWheel && !isCommandKeyPressed(e);
        e._cancelPreventDefault = true;
        if (originalEvent && false !== e.cancelable && (!isMouseMove && !isWheel || isScrollByWheel)) {
          e.preventDefault();
        }
      });
    }
  }
  _moveFromContainer() {
    this._$content.appendTo(this.$element());
    this._$wrapper.detach();
  }
  _checkContainerExists() {
    const $wrapperContainer = this._positionController.$container;
    if (void 0 === $wrapperContainer) {
      return;
    }
    const containerExists = $wrapperContainer.length > 0;
    if (!containerExists) {
      ui_errors_default.log("W1021", this.NAME);
    }
  }
  _moveToContainer() {
    const $wrapperContainer = this._positionController.$container;
    this._$wrapper.appendTo($wrapperContainer);
    this._$content.appendTo(this._$wrapper);
  }
  _renderGeometry(options2) {
    const {
      visible: visible2
    } = this.option();
    if (visible2 && m_window_default.hasWindow()) {
      this._stopAnimation();
      this._renderGeometryImpl();
    }
  }
  _renderGeometryImpl() {
    this._positionController.updatePosition(this._getOptionValue("position"));
    this._renderWrapper();
    this._renderDimensions();
    this._renderPosition();
  }
  _renderPosition(state) {
    this._positionController.positionContent();
  }
  _isAllWindowCovered() {
    const {
      shading
    } = this.option();
    return isWindow(this._positionController.$visualContainer.get(0)) && shading;
  }
  _toggleSafariScrolling() {
    const visible2 = this.option("visible");
    const $body = renderer_default(dom_adapter_default.getBody());
    const isIosSafari = "ios" === devices_default.real().platform && browser_default.safari;
    const isAllWindowCovered = this._isAllWindowCovered();
    const isScrollingPrevented = $body.hasClass("dx-prevent-safari-scrolling");
    const shouldPreventScrolling = !isScrollingPrevented && visible2 && isAllWindowCovered;
    const shouldEnableScrolling = isScrollingPrevented && (!visible2 || !isAllWindowCovered || this._disposed);
    if (isIosSafari) {
      if (shouldEnableScrolling) {
        $body.removeClass("dx-prevent-safari-scrolling");
        window17.scrollTo(0, this._cachedBodyScrollTop);
        this._cachedBodyScrollTop = void 0;
      } else if (shouldPreventScrolling) {
        this._cachedBodyScrollTop = window17.pageYOffset;
        $body.addClass("dx-prevent-safari-scrolling");
      }
    }
  }
  _renderWrapper() {
    this._positionController.styleWrapperPosition();
    this._renderWrapperDimensions();
    this._positionController.positionWrapper();
  }
  _renderWrapperDimensions() {
    const {
      $visualContainer
    } = this._positionController;
    const documentElement = dom_adapter_default.getDocumentElement();
    const isVisualContainerWindow = isWindow($visualContainer.get(0));
    const wrapperWidth = isVisualContainerWindow ? documentElement.clientWidth : getOuterWidth($visualContainer);
    const wrapperHeight = isVisualContainerWindow ? window17.innerHeight : getOuterHeight($visualContainer);
    this._$wrapper.css({
      width: wrapperWidth,
      height: wrapperHeight
    });
  }
  _renderDimensions() {
    const content = this._$content.get(0);
    this._$content.css({
      minWidth: this._getOptionValue("minWidth", content),
      maxWidth: this._getOptionValue("maxWidth", content),
      minHeight: this._getOptionValue("minHeight", content),
      maxHeight: this._getOptionValue("maxHeight", content),
      width: this._getOptionValue("width", content),
      height: this._getOptionValue("height", content)
    });
  }
  _focusTarget() {
    return this._$content;
  }
  _attachKeyboardEvents() {
    this._keyboardListenerId = keyboard.on(this._$content, null, (options2) => this._keyboardHandler(options2));
  }
  _keyboardHandler(options2) {
    const e = options2.originalEvent;
    const $target = renderer_default(e.target);
    if ($target.is(this._$content) || !this.option("ignoreChildEvents")) {
      super._keyboardHandler(...arguments);
    }
  }
  _isVisible() {
    const {
      visible: visible2
    } = this.option();
    return visible2;
  }
  _visibilityChanged(visible2) {
    if (visible2) {
      if (this.option("visible")) {
        this._renderVisibilityAnimate(visible2);
      }
    } else {
      this._renderVisibilityAnimate(visible2);
    }
  }
  _dimensionChanged() {
    this._renderGeometry();
  }
  _clean() {
    const {
      isRenovated
    } = this.option();
    if (!this._contentAlreadyRendered && !isRenovated) {
      this.$content().empty();
    }
    this._renderVisibility(false);
    this._stopShowTimer();
    this._cleanFocusState();
  }
  _stopShowTimer() {
    if (this._asyncShowTimeout) {
      clearTimeout(this._asyncShowTimeout);
    }
    this._asyncShowTimeout = null;
  }
  _dispose() {
    fx_default.stop(this._$content, false);
    this._toggleViewPortSubscription(false);
    this._toggleSubscriptions(false);
    this._updateZIndexStackPosition(false);
    this._actions = null;
    this._parentsScrollSubscriptionInfo = null;
    super._dispose();
    this._toggleSafariScrolling();
    this.option("visible") && remove2(this._zIndex);
    this._$wrapper.remove();
    this._$content.remove();
    this._destroyTabTerminator();
  }
  _toggleRTLDirection(rtl) {
    this._$content.toggleClass("dx-rtl", rtl);
  }
  _optionChanged(args) {
    const {
      value: value2,
      name: name2
    } = args;
    if (this._getActionsList().includes(name2)) {
      this._initActions();
      return;
    }
    switch (name2) {
      case "animation":
      case "hideOnOutsideClick":
      case "propagateOutsideClick":
        break;
      case "_loopFocus":
      case "shading": {
        const {
          visible: visible2
        } = this.option();
        this._toggleShading(visible2);
        this._toggleSafariScrolling();
        break;
      }
      case "shadingColor": {
        const {
          visible: visible2
        } = this.option();
        this._toggleShading(visible2);
        break;
      }
      case "width":
      case "height":
      case "minWidth":
      case "maxWidth":
      case "minHeight":
      case "maxHeight":
        this._renderGeometry();
        break;
      case "position":
        this._positionController.updatePosition(this.option("position"));
        this._positionController.restorePositionOnNextRender(true);
        this._renderGeometry();
        this._toggleSafariScrolling();
        break;
      case "visible":
        this._renderVisibilityAnimate(value2).done(() => {
          var _this$_animateDeferre;
          return null === (_this$_animateDeferre = this._animateDeferred) || void 0 === _this$_animateDeferre ? void 0 : _this$_animateDeferre.resolveWith(this);
        }).fail(() => {
          var _this$_animateDeferre2;
          return null === (_this$_animateDeferre2 = this._animateDeferred) || void 0 === _this$_animateDeferre2 ? void 0 : _this$_animateDeferre2.reject();
        });
        break;
      case "container":
        this._positionController.updateContainer(value2);
        this._invalidate();
        this._toggleSafariScrolling();
        break;
      case "visualContainer":
        this._positionController.updateVisualContainer(value2);
        this._renderWrapper();
        this._toggleSafariScrolling();
        break;
      case "innerOverlay":
        this._initInnerOverlayClass();
        break;
      case "deferRendering":
      case "contentTemplate":
        this._contentAlreadyRendered = false;
        this._clean();
        this._invalidate();
        break;
      case "hideTopOverlayHandler":
        this._toggleHideTopOverlayCallback(false);
        this._initHideTopOverlayHandler(value2);
        this._toggleHideTopOverlayCallback(this.option("visible"));
        break;
      case "hideOnParentScroll":
      case "_hideOnParentScrollTarget": {
        const {
          visible: visible2
        } = this.option();
        this._toggleHideOnParentsScrollSubscription(visible2);
        break;
      }
      case "rtlEnabled":
        this._contentAlreadyRendered = false;
        super._optionChanged(args);
        break;
      case "_fixWrapperPosition":
        this._positionController.fixWrapperPosition = value2;
        break;
      case "wrapperAttr":
        this._renderWrapperAttributes();
        break;
      case "restorePosition":
        this._positionController.restorePosition = value2;
        break;
      case "preventScrollEvents":
        this._logDeprecatedPreventScrollEventsInfo();
        this._toggleWrapperScrollEventsSubscription(value2);
        break;
      default:
        super._optionChanged(args);
    }
  }
  toggle(showing) {
    showing = void 0 === showing ? !this.option("visible") : showing;
    const result2 = Deferred();
    if (showing === this.option("visible")) {
      return result2.resolveWith(this, [showing]).promise();
    }
    const animateDeferred = Deferred();
    this._animateDeferred = animateDeferred;
    this.option("visible", showing);
    animateDeferred.promise().done(() => {
      delete this._animateDeferred;
      result2.resolveWith(this, [this.option("visible")]);
    }).fail(() => {
      delete this._animateDeferred;
      result2.reject();
    });
    return result2.promise();
  }
  $content() {
    return this._$content;
  }
  show() {
    return this.toggle(true);
  }
  hide() {
    return this.toggle(false);
  }
  content() {
    return getPublicElement(this._$content);
  }
  repaint() {
    if (this._contentAlreadyRendered) {
      this._positionController.restorePositionOnNextRender(true);
      this._renderGeometry({
        forceStopAnimation: true
      });
      triggerResizeEvent2(this._$content);
    } else {
      super.repaint();
    }
  }
};
Overlay.baseZIndex = (zIndex) => base(zIndex);
component_registrator_default("dxOverlay", Overlay);
var m_overlay_default = Overlay;

// node_modules/devextreme/esm/__internal/ui/m_load_panel.js
var LoadPanel = class extends m_overlay_default {
  _supportedKeys() {
    return _extends({}, super._supportedKeys(), {
      escape: noop2
    });
  }
  _getDefaultOptions() {
    return _extends({}, super._getDefaultOptions(), {
      message: message_default.format("Loading"),
      width: 222,
      height: 90,
      animation: null,
      showIndicator: true,
      indicatorSrc: "",
      showPane: true,
      delay: 0,
      templatesRenderAsynchronously: false,
      hideTopOverlayHandler: null,
      focusStateEnabled: false,
      propagateOutsideClick: true,
      preventScrollEvents: false
    });
  }
  _defaultOptionsRules() {
    return super._defaultOptionsRules().concat([{
      device: {
        platform: "generic"
      },
      options: {
        shadingColor: "transparent"
      }
    }, {
      device: () => isMaterial(),
      options: {
        message: "",
        width: 60,
        height: 60,
        maxHeight: 60,
        maxWidth: 60
      }
    }, {
      device: () => isFluent(),
      options: {
        width: "auto",
        height: "auto"
      }
    }]);
  }
  _init() {
    super._init.apply(this, arguments);
  }
  _render() {
    super._render();
    this.$element().addClass("dx-loadpanel");
    this.$wrapper().addClass("dx-loadpanel-wrapper");
    this._updateWrapperAria();
  }
  _updateWrapperAria() {
    this.$wrapper().removeAttr("aria-label").removeAttr("role");
    const showIndicator = this.option("showIndicator");
    if (!showIndicator) {
      const aria = this._getAriaAttributes();
      this.$wrapper().attr(aria);
    }
  }
  _getAriaAttributes() {
    const {
      message
    } = this.option();
    const label = message || message_default.format("Loading");
    const aria = {
      role: "alert",
      "aria-label": label
    };
    return aria;
  }
  _renderContentImpl() {
    super._renderContentImpl();
    this.$content().addClass("dx-loadpanel-content");
    this._$loadPanelContentWrapper = renderer_default("<div>").addClass("dx-loadpanel-content-wrapper");
    this._$loadPanelContentWrapper.appendTo(this.$content());
    this._togglePaneVisible();
    this._cleanPreviousContent();
    this._renderLoadIndicator();
    this._renderMessage();
  }
  _show() {
    const {
      delay
    } = this.option();
    if (!delay) {
      return super._show();
    }
    const deferred = Deferred();
    const callBase = super._show.bind(this);
    this._clearShowTimeout();
    this._showTimeout = setTimeout(() => {
      callBase().done(() => {
        deferred.resolve();
      });
    }, delay);
    return deferred.promise();
  }
  _hide() {
    this._clearShowTimeout();
    return super._hide();
  }
  _clearShowTimeout() {
    clearTimeout(this._showTimeout);
  }
  _renderMessage() {
    if (!this._$loadPanelContentWrapper) {
      return;
    }
    const {
      message
    } = this.option();
    if (!message) {
      return;
    }
    const $message = renderer_default("<div>").addClass("dx-loadpanel-message").text(message);
    this._$loadPanelContentWrapper.append($message);
  }
  _renderLoadIndicator() {
    if (!this._$loadPanelContentWrapper || !this.option("showIndicator")) {
      return;
    }
    if (!this._$indicator) {
      this._$indicator = renderer_default("<div>").addClass("dx-loadpanel-indicator").appendTo(this._$loadPanelContentWrapper);
    }
    this._createComponent(this._$indicator, load_indicator_default, {
      elementAttr: this._getAriaAttributes(),
      indicatorSrc: this.option("indicatorSrc")
    });
  }
  _cleanPreviousContent() {
    this.$content().find(".dx-loadpanel-message").remove();
    this.$content().find(".dx-loadpanel-indicator").remove();
    delete this._$indicator;
  }
  _togglePaneVisible() {
    this.$content().toggleClass("dx-loadpanel-pane-hidden", !this.option("showPane"));
  }
  _optionChanged(args) {
    switch (args.name) {
      case "delay":
        break;
      case "message":
      case "showIndicator":
        this._cleanPreviousContent();
        this._renderLoadIndicator();
        this._renderMessage();
        this._updateWrapperAria();
        break;
      case "showPane":
        this._togglePaneVisible();
        break;
      case "indicatorSrc":
        this._renderLoadIndicator();
        break;
      default:
        super._optionChanged(args);
    }
  }
  _dispose() {
    this._clearShowTimeout();
    super._dispose();
  }
};
component_registrator_default("dxLoadPanel", LoadPanel);
var m_load_panel_default = LoadPanel;

// node_modules/devextreme/esm/ui/load_panel.js
var load_panel_default = m_load_panel_default;

// node_modules/devextreme/esm/ui/shared/filtering.js
var DEFAULT_DATE_INTERVAL = ["year", "month", "day"];
var DEFAULT_DATETIME_INTERVAL = ["year", "month", "day", "hour", "minute"];
var isDateType = function(dataType) {
  return "date" === dataType || "datetime" === dataType;
};
var getGroupInterval = function(column) {
  let index2;
  let result2 = [];
  const dateIntervals = ["year", "month", "day", "hour", "minute", "second"];
  const groupInterval = column.headerFilter && column.headerFilter.groupInterval;
  const interval = "quarter" === groupInterval ? "month" : groupInterval;
  if (isDateType(column.dataType) && null !== groupInterval) {
    result2 = "datetime" === column.dataType ? DEFAULT_DATETIME_INTERVAL : DEFAULT_DATE_INTERVAL;
    index2 = dateIntervals.indexOf(interval);
    if (index2 >= 0) {
      result2 = dateIntervals.slice(0, index2);
      result2.push(groupInterval);
      return result2;
    }
    return result2;
  } else if (isDefined(groupInterval)) {
    return Array.isArray(groupInterval) ? groupInterval : [groupInterval];
  }
};
var getNormalizedCalculateDisplayValue = function(column) {
  var _column$calculateDisp;
  return null !== (_column$calculateDisp = column.calculateDisplayValue) && void 0 !== _column$calculateDisp && _column$calculateDisp.context ? column.calculateDisplayValue : null;
};
var filtering_default = /* @__PURE__ */ function() {
  const getFilterSelector = function(column, target) {
    let selector = column.dataField || column.selector;
    if ("search" === target) {
      selector = column.displayField || getNormalizedCalculateDisplayValue(column) || selector;
    }
    return selector;
  };
  const getFilterExpressionByRange = function(filterValue, target) {
    const column = this;
    let endFilterValue;
    let startFilterExpression;
    let endFilterExpression;
    const selector = getFilterSelector(column, target);
    if (Array.isArray(filterValue) && isDefined(filterValue[0]) && isDefined(filterValue[1])) {
      startFilterExpression = [selector, ">=", filterValue[0]];
      endFilterExpression = [selector, "<=", filterValue[1]];
      if (isDateType(column.dataType) && (date = filterValue[1], date.getHours() + date.getMinutes() + date.getSeconds() + date.getMilliseconds() < 1)) {
        endFilterValue = new Date(filterValue[1].getTime());
        if ("date" === column.dataType) {
          endFilterValue.setDate(filterValue[1].getDate() + 1);
        }
        endFilterExpression = [selector, "<", endFilterValue];
      }
      return [startFilterExpression, "and", endFilterExpression];
    }
    var date;
  };
  const getFilterExpressionForDate = function(filterValue, selectedFilterOperation, target) {
    const column = this;
    let dateStart;
    let dateEnd;
    let dateInterval;
    const values = function(dateValue) {
      if (isDate(dateValue)) {
        return [dateValue.getFullYear(), dateValue.getMonth(), dateValue.getDate(), dateValue.getHours(), dateValue.getMinutes(), dateValue.getSeconds()];
      }
      return map(("" + dateValue).split("/"), function(value2, index2) {
        return 1 === index2 ? Number(value2) - 1 : Number(value2);
      });
    }(filterValue);
    const selector = getFilterSelector(column, target);
    if ("headerFilter" === target) {
      dateInterval = getGroupInterval(column)[values.length - 1];
    } else if ("datetime" === column.dataType) {
      dateInterval = "minute";
    }
    switch (dateInterval) {
      case "year":
        dateStart = new Date(values[0], 0, 1);
        dateEnd = new Date(values[0] + 1, 0, 1);
        break;
      case "month":
        dateStart = new Date(values[0], values[1], 1);
        dateEnd = new Date(values[0], values[1] + 1, 1);
        break;
      case "quarter":
        dateStart = new Date(values[0], 3 * values[1], 1);
        dateEnd = new Date(values[0], 3 * values[1] + 3, 1);
        break;
      case "hour":
        dateStart = new Date(values[0], values[1], values[2], values[3]);
        dateEnd = new Date(values[0], values[1], values[2], values[3] + 1);
        break;
      case "minute":
        dateStart = new Date(values[0], values[1], values[2], values[3], values[4]);
        dateEnd = new Date(values[0], values[1], values[2], values[3], values[4] + 1);
        break;
      case "second":
        dateStart = new Date(values[0], values[1], values[2], values[3], values[4], values[5]);
        dateEnd = new Date(values[0], values[1], values[2], values[3], values[4], values[5] + 1);
        break;
      default:
        dateStart = new Date(values[0], values[1], values[2]);
        dateEnd = new Date(values[0], values[1], values[2] + 1);
    }
    switch (selectedFilterOperation) {
      case "<":
        return [selector, "<", dateStart];
      case "<=":
        return [selector, "<", dateEnd];
      case ">":
        return [selector, ">=", dateEnd];
      case ">=":
        return [selector, ">=", dateStart];
      case "<>":
        return [
          [selector, "<", dateStart],
          "or",
          [selector, ">=", dateEnd]
        ];
      default:
        return [
          [selector, ">=", dateStart],
          "and",
          [selector, "<", dateEnd]
        ];
    }
  };
  const getFilterExpressionForNumber = function(filterValue, selectedFilterOperation, target) {
    const selector = getFilterSelector(this, target);
    const groupInterval = getGroupInterval(this);
    if ("headerFilter" === target && groupInterval && isDefined(filterValue)) {
      const values = ("" + filterValue).split("/");
      const value2 = Number(values[values.length - 1]);
      const interval = groupInterval[values.length - 1];
      const startFilterValue = [selector, ">=", value2];
      const endFilterValue = [selector, "<", value2 + interval];
      const condition = [startFilterValue, "and", endFilterValue];
      return condition;
    }
    return [selector, selectedFilterOperation || "=", filterValue];
  };
  return {
    defaultCalculateFilterExpression: function(filterValue, selectedFilterOperation, target) {
      const column = this;
      const selector = getFilterSelector(column, target);
      const isSearchByDisplayValue = column.calculateDisplayValue && "search" === target;
      const dataType = isSearchByDisplayValue && column.lookup && column.lookup.dataType || column.dataType;
      let filter = null;
      if (("headerFilter" === target || "filterBuilder" === target) && null === filterValue) {
        filter = [selector, selectedFilterOperation || "=", null];
        if ("string" === dataType) {
          filter = [filter, "=" === selectedFilterOperation ? "or" : "and", [selector, selectedFilterOperation || "=", ""]];
        }
      } else if ("string" === dataType && (!column.lookup || isSearchByDisplayValue)) {
        filter = [selector, selectedFilterOperation || "contains", filterValue];
      } else if ("between" === selectedFilterOperation) {
        return getFilterExpressionByRange.apply(column, [filterValue, target]);
      } else if (isDateType(dataType) && isDefined(filterValue)) {
        return getFilterExpressionForDate.apply(column, arguments);
      } else if ("number" === dataType) {
        return getFilterExpressionForNumber.apply(column, arguments);
      } else {
        filter = [selector, selectedFilterOperation || "=", filterValue];
      }
      return filter;
    },
    getGroupInterval
  };
}();

// node_modules/devextreme/esm/__internal/grids/grid_core/m_utils.js
var LEGACY_SCROLLING_MODE = "scrolling.legacyMode";
var ROW_RENDERING_MODE_OPTION = "scrolling.rowRenderingMode";
var DATE_INTERVAL_SELECTORS = {
  year: (value2) => value2 && value2.getFullYear(),
  month: (value2) => value2 && value2.getMonth() + 1,
  day: (value2) => value2 && value2.getDate(),
  quarter: (value2) => value2 && Math.floor(value2.getMonth() / 3) + 1,
  hour: (value2) => value2 && value2.getHours(),
  minute: (value2) => value2 && value2.getMinutes(),
  second: (value2) => value2 && value2.getSeconds()
};
var getIntervalSelector = function() {
  const data17 = arguments[1];
  const value2 = this.calculateCellValue(data17);
  if (!isDefined(value2)) {
    return null;
  }
  if (isDateType2(this.dataType)) {
    const nameIntervalSelector = arguments[0];
    return DATE_INTERVAL_SELECTORS[nameIntervalSelector](value2);
  }
  if ("number" === this.dataType) {
    const groupInterval = arguments[0];
    return Math.floor(Number(value2) / groupInterval) * groupInterval;
  }
};
var equalSelectors = function(selector1, selector2) {
  if (isFunction(selector1) && isFunction(selector2)) {
    if (selector1.originalCallback && selector2.originalCallback) {
      return selector1.originalCallback === selector2.originalCallback && selector1.columnIndex === selector2.columnIndex;
    }
  }
  return selector1 === selector2;
};
function isDateType2(dataType) {
  return "date" === dataType || "datetime" === dataType;
}
var setEmptyText = function($container) {
  $container.get(0).textContent = " ";
};
var normalizeSortingInfo2 = function(sort) {
  sort = sort || [];
  const result2 = normalizeSortingInfo(sort);
  for (let i = 0; i < sort.length; i++) {
    if (sort && sort[i] && void 0 !== sort[i].isExpanded) {
      result2[i].isExpanded = sort[i].isExpanded;
    }
    if (sort && sort[i] && void 0 !== sort[i].groupInterval) {
      result2[i].groupInterval = sort[i].groupInterval;
    }
  }
  return result2;
};
var formatValue2 = function(value2, options2) {
  const valueText = format_helper_default.format(value2, options2.format) || value2 && value2.toString() || "";
  const formatObject = {
    value: value2,
    valueText: options2.getDisplayFormat ? options2.getDisplayFormat(valueText) : valueText,
    target: options2.target || "row",
    groupInterval: options2.groupInterval
  };
  return options2.customizeText ? options2.customizeText.call(options2, formatObject) : formatObject.valueText;
};
var getSummaryText = function(summaryItem, summaryTexts) {
  const displayFormat = summaryItem.displayFormat || summaryItem.columnCaption && summaryTexts[`${summaryItem.summaryType}OtherColumn`] || summaryTexts[summaryItem.summaryType];
  return formatValue2(summaryItem.value, {
    format: summaryItem.valueFormat,
    getDisplayFormat: (valueText) => displayFormat ? format(displayFormat, valueText, summaryItem.columnCaption) : valueText,
    customizeText: summaryItem.customizeText
  });
};
var getWidgetInstance = function($element) {
  const editorData = $element.data && $element.data();
  const dxComponents = editorData && editorData.dxComponents;
  const widgetName = dxComponents && dxComponents[0];
  return widgetName && editorData[widgetName];
};
var equalFilterParameters = function(filter1, filter2, langParams) {
  if (Array.isArray(filter1) && Array.isArray(filter2)) {
    if (filter1.length !== filter2.length) {
      return false;
    }
    for (let i = 0; i < filter1.length; i++) {
      if (!equalFilterParameters(filter1[i], filter2[i], langParams)) {
        return false;
      }
    }
    return true;
  }
  if (isFunction(filter1) && filter1.columnIndex >= 0 && isFunction(filter2) && filter2.columnIndex >= 0) {
    return filter1.columnIndex === filter2.columnIndex && toComparable(filter1.filterValue, void 0, langParams) === toComparable(filter2.filterValue, void 0, langParams) && toComparable(filter1.selectedFilterOperation, void 0, langParams) === toComparable(filter2.selectedFilterOperation, void 0, langParams);
  }
  return toComparable(filter1, void 0, langParams) == toComparable(filter2, void 0, langParams);
};
var createPoint = (options2) => ({
  index: options2.index,
  columnIndex: options2.columnIndex,
  x: options2.x,
  y: options2.y
});
var addPointIfNeed = (points, pointProps, pointCreated) => {
  let notCreatePoint = false;
  if (pointCreated) {
    notCreatePoint = pointCreated(pointProps);
  }
  if (!notCreatePoint) {
    const point = createPoint(pointProps);
    points.push(point);
  }
};
function normalizeGroupingLoadOptions(group) {
  if (!Array.isArray(group)) {
    group = [group];
  }
  return group.map((item, i) => {
    if (isString(item)) {
      return {
        selector: item,
        isExpanded: i < group.length - 1
      };
    }
    return item;
  });
}
var m_utils_default = {
  renderNoDataText($element) {
    const that = this;
    $element = $element || this.element();
    if (!$element) {
      return;
    }
    const noDataClass = that.addWidgetPrefix("nodata");
    let noDataElement = $element.find(`.${noDataClass}`).last();
    const isVisible2 = this._dataController.isEmpty();
    const isLoading = this._dataController.isLoading();
    if (!noDataElement.length) {
      noDataElement = renderer_default("<span>").addClass(noDataClass);
    }
    if (!noDataElement.parent().is($element)) {
      noDataElement.appendTo($element);
    }
    if (isVisible2 && !isLoading) {
      noDataElement.removeClass("dx-hidden").text(that._getNoDataText());
    } else {
      noDataElement.addClass("dx-hidden");
    }
  },
  renderLoadPanel($element, $container, isLocalStore) {
    const that = this;
    let loadPanelOptions;
    that._loadPanel && that._loadPanel.$element().remove();
    loadPanelOptions = that.option("loadPanel");
    if (loadPanelOptions && ("auto" === loadPanelOptions.enabled ? !isLocalStore : loadPanelOptions.enabled)) {
      loadPanelOptions = extend({
        shading: false,
        message: loadPanelOptions.text,
        container: $container
      }, loadPanelOptions);
      that._loadPanel = that._createComponent(renderer_default("<div>").appendTo($container), load_panel_default, loadPanelOptions);
    } else {
      that._loadPanel = null;
    }
  },
  calculateLoadPanelPosition($element) {
    const $window = renderer_default(getWindow());
    if (getHeight($element) > getHeight($window)) {
      return {
        of: $window,
        boundary: $element,
        collision: "fit"
      };
    }
    return {
      of: $element
    };
  },
  getIndexByKey(key, items, keyName) {
    let index2 = -1;
    if (void 0 !== key && Array.isArray(items)) {
      keyName = arguments.length <= 2 ? "key" : keyName;
      for (let i = 0; i < items.length; i++) {
        const item = isDefined(keyName) ? items[i][keyName] : items[i];
        if (equalByValue(key, item)) {
          index2 = i;
          break;
        }
      }
    }
    return index2;
  },
  combineFilters(filters, operation) {
    let resultFilter = [];
    operation = operation || "and";
    for (let i = 0; i < filters.length; i++) {
      var _filters$i;
      if (!filters[i]) {
        continue;
      }
      if (1 === (null === (_filters$i = filters[i]) || void 0 === _filters$i ? void 0 : _filters$i.length) && "!" === filters[i][0]) {
        if ("and" === operation) {
          return ["!"];
        }
        if ("or" === operation) {
          continue;
        }
      }
      if (resultFilter.length) {
        resultFilter.push(operation);
      }
      resultFilter.push(filters[i]);
    }
    if (1 === resultFilter.length) {
      resultFilter = resultFilter[0];
    }
    if (resultFilter.length) {
      return resultFilter;
    }
    return;
  },
  checkChanges(changes, changeNames) {
    let changesWithChangeNamesCount = 0;
    for (let i = 0; i < changeNames.length; i++) {
      if (changes[changeNames[i]]) {
        changesWithChangeNamesCount++;
      }
    }
    return changes.length && changes.length === changesWithChangeNamesCount;
  },
  equalFilterParameters,
  proxyMethod(instance, methodName, defaultResult) {
    if (!instance[methodName]) {
      instance[methodName] = function() {
        const dataSource = this._dataSource;
        return dataSource ? dataSource[methodName].apply(dataSource, arguments) : defaultResult;
      };
    }
  },
  formatValue: formatValue2,
  getFormatOptionsByColumn: (column, target) => ({
    format: column.format,
    getDisplayFormat: column.getDisplayFormat,
    customizeText: column.customizeText,
    target,
    trueText: column.trueText,
    falseText: column.falseText
  }),
  getDisplayValue(column, value2, data17, rowType) {
    if (column.displayValueMap && void 0 !== column.displayValueMap[value2]) {
      return column.displayValueMap[value2];
    }
    if (column.calculateDisplayValue && data17 && "group" !== rowType) {
      return column.calculateDisplayValue(data17);
    }
    if (column.lookup && !("group" === rowType && (column.calculateGroupValue || column.calculateDisplayValue))) {
      return column.lookup.calculateCellValue(value2);
    }
    return value2;
  },
  getGroupRowSummaryText(summaryItems, summaryTexts) {
    let result2 = "(";
    for (let i = 0; i < summaryItems.length; i++) {
      const summaryItem = summaryItems[i];
      result2 += (i > 0 ? ", " : "") + getSummaryText(summaryItem, summaryTexts);
    }
    return result2 + ")";
  },
  getSummaryText,
  normalizeSortingInfo: normalizeSortingInfo2,
  getFormatByDataType(dataType) {
    switch (dataType) {
      case "date":
        return "shortDate";
      case "datetime":
        return "shortDateShortTime";
      default:
        return;
    }
  },
  getHeaderFilterGroupParameters(column, remoteGrouping) {
    let result2 = [];
    const dataField = column.dataField || column.name;
    const groupInterval = filtering_default.getGroupInterval(column);
    if (groupInterval) {
      each(groupInterval, (index2, interval) => {
        result2.push(remoteGrouping ? {
          selector: dataField,
          groupInterval: interval,
          isExpanded: index2 < groupInterval.length - 1
        } : getIntervalSelector.bind(column, interval));
      });
      return result2;
    }
    if (remoteGrouping) {
      result2 = [{
        selector: dataField,
        isExpanded: false
      }];
    } else {
      result2 = function(data17) {
        let result3 = column.calculateCellValue(data17);
        if (void 0 === result3 || "" === result3) {
          result3 = null;
        }
        return result3;
      };
      if (column.sortingMethod) {
        result2 = [{
          selector: result2,
          compare: column.sortingMethod.bind(column)
        }];
      }
    }
    return result2;
  },
  equalSortParameters(sortParameters1, sortParameters2, ignoreIsExpanded) {
    sortParameters1 = normalizeSortingInfo2(sortParameters1);
    sortParameters2 = normalizeSortingInfo2(sortParameters2);
    if (Array.isArray(sortParameters1) && Array.isArray(sortParameters2)) {
      if (sortParameters1.length !== sortParameters2.length) {
        return false;
      }
      for (let i = 0; i < sortParameters1.length; i++) {
        if (!equalSelectors(sortParameters1[i].selector, sortParameters2[i].selector) || sortParameters1[i].desc !== sortParameters2[i].desc || sortParameters1[i].groupInterval !== sortParameters2[i].groupInterval || !ignoreIsExpanded && Boolean(sortParameters1[i].isExpanded) !== Boolean(sortParameters2[i].isExpanded)) {
          return false;
        }
      }
      return true;
    }
    return (!sortParameters1 || !sortParameters1.length) === (!sortParameters2 || !sortParameters2.length);
  },
  getPointsByColumns(items, pointCreated) {
    let isVertical = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : false;
    let startColumnIndex = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0;
    let needToCheckPrevPoint = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : false;
    const result2 = [];
    const cellsLength = items.length;
    let $item;
    let offset2 = {
      left: 0,
      top: 0
    };
    let itemRect = {
      width: 0,
      height: 0
    };
    let columnIndex = startColumnIndex;
    let rtlEnabled;
    for (let i = 0; i <= cellsLength; i++) {
      var _$item;
      if (i < cellsLength) {
        $item = items.eq(i);
        offset2 = $item.offset();
        itemRect = getBoundingRect($item.get(0));
        rtlEnabled = "rtl" === $item.css("direction");
      }
      const offsetRight = offset2.left + itemRect.width;
      const offsetBottom = offset2.top + itemRect.height;
      const pointProps = {
        index: columnIndex,
        columnIndex,
        item: null === (_$item = $item) || void 0 === _$item ? void 0 : _$item.get(0),
        x: !isVertical && rtlEnabled !== (i === cellsLength) ? offsetRight : offset2.left,
        y: isVertical && i === cellsLength ? offsetBottom : offset2.top
      };
      if (!isVertical && i > 0) {
        const prevItemOffset = items.eq(i - 1).offset();
        const {
          width: prevItemWidth
        } = getBoundingRect(items[i - 1]);
        const prevItemOffsetX = rtlEnabled ? prevItemOffset.left : prevItemOffset.left + prevItemWidth;
        if (prevItemOffset.top < pointProps.y) {
          pointProps.y = prevItemOffset.top;
        }
        if (needToCheckPrevPoint && Math.round(prevItemOffsetX) !== Math.round(pointProps.x)) {
          const prevPointProps = _extends({}, pointProps, {
            item: items[i - 1],
            x: prevItemOffsetX
          });
          if (rtlEnabled) {
            pointProps.isRightBoundary = true;
            prevPointProps.isLeftBoundary = true;
          } else {
            pointProps.isLeftBoundary = true;
            prevPointProps.isRightBoundary = true;
          }
          addPointIfNeed(result2, prevPointProps, pointCreated);
        }
      }
      addPointIfNeed(result2, pointProps, pointCreated);
      columnIndex++;
    }
    return result2;
  },
  getExpandCellTemplate: () => ({
    allowRenderToDetachedContainer: true,
    render(container, options2) {
      const $container = renderer_default(container);
      if (isDefined(options2.value) && !(options2.data && options2.data.isContinuation) && !options2.row.isNewRow) {
        const rowsView18 = options2.component.getView("rowsView");
        $container.addClass("dx-datagrid-expand").addClass("dx-selection-disabled");
        renderer_default("<div>").addClass(options2.value ? "dx-datagrid-group-opened" : "dx-datagrid-group-closed").appendTo($container);
        rowsView18.setAria("label", options2.value ? rowsView18.localize("dxDataGrid-ariaCollapse") : rowsView18.localize("dxDataGrid-ariaExpand"), $container);
      } else {
        setEmptyText($container);
      }
    }
  }),
  setEmptyText,
  isDateType: isDateType2,
  getSelectionRange(focusedElement) {
    try {
      if (focusedElement) {
        return {
          selectionStart: focusedElement.selectionStart,
          selectionEnd: focusedElement.selectionEnd
        };
      }
    } catch (e) {
    }
    return {};
  },
  setSelectionRange(focusedElement, selectionRange) {
    try {
      if (focusedElement && focusedElement.setSelectionRange) {
        focusedElement.setSelectionRange(selectionRange.selectionStart, selectionRange.selectionEnd);
      }
    } catch (e) {
    }
  },
  focusAndSelectElement(component, $element) {
    const isFocused = $element.is(":focus");
    m_events_engine_default.trigger($element, "focus");
    const isSelectTextOnEditingStart = component.option("editing.selectTextOnEditStart");
    const element = $element.get(0);
    if (!isFocused && isSelectTextOnEditingStart && $element.is(".dx-texteditor-input") && !$element.is("[readonly]")) {
      const editor = getWidgetInstance($element.closest(".dx-texteditor"));
      when(editor && editor._loadItemDeferred).done(() => {
        element.select();
      });
    }
  },
  getWidgetInstance,
  getLastResizableColumnIndex(columns7, resultWidths) {
    const hasResizableColumns = columns7.some((column) => column && !column.command && !column.fixed && false !== column.allowResizing);
    let lastColumnIndex;
    for (lastColumnIndex = columns7.length - 1; columns7[lastColumnIndex]; lastColumnIndex--) {
      const column = columns7[lastColumnIndex];
      const width = resultWidths && resultWidths[lastColumnIndex];
      const allowResizing2 = !hasResizableColumns || false !== column.allowResizing;
      if (!column.command && !column.fixed && "adaptiveHidden" !== width && allowResizing2) {
        break;
      }
    }
    return lastColumnIndex;
  },
  isElementInCurrentGrid(controller, $element) {
    if ($element && $element.length) {
      const $grid = $element.closest(`.${controller.getWidgetContainerClass()}`).parent();
      return $grid.is(controller.component.$element());
    }
    return false;
  },
  isVirtualRowRendering(that) {
    const rowRenderingMode = that.option(ROW_RENDERING_MODE_OPTION);
    const isVirtualMode3 = "virtual" === that.option("scrolling.mode");
    const isAppendMode3 = "infinite" === that.option("scrolling.mode");
    if (false === that.option(LEGACY_SCROLLING_MODE) && (isVirtualMode3 || isAppendMode3)) {
      return true;
    }
    return "virtual" === rowRenderingMode;
  },
  getPixelRatio: (window31) => window31.devicePixelRatio || 1,
  getContentHeightLimit(browser2) {
    if (browser2.mozilla) {
      return 8e6;
    }
    return 15e6 / this.getPixelRatio(getWindow());
  },
  normalizeLookupDataSource(lookup) {
    let lookupDataSourceOptions;
    if (lookup.items) {
      lookupDataSourceOptions = lookup.items;
    } else {
      lookupDataSourceOptions = lookup.dataSource;
      if (isFunction(lookupDataSourceOptions) && !variable_wrapper_default.isWrapped(lookupDataSourceOptions)) {
        lookupDataSourceOptions = lookupDataSourceOptions({});
      }
    }
    return normalizeDataSourceOptions(lookupDataSourceOptions);
  },
  getWrappedLookupDataSource(column, dataSource, filter) {
    if (!dataSource) {
      return [];
    }
    const lookupDataSourceOptions = this.normalizeLookupDataSource(column.lookup);
    if (column.calculateCellValue !== column.defaultCalculateCellValue) {
      return lookupDataSourceOptions;
    }
    const hasGroupPaging = dataSource.remoteOperations().groupPaging;
    const hasLookupOptimization = column.displayField && isString(column.displayField);
    let cachedUniqueRelevantItems;
    let previousTake;
    let previousSkip;
    const sliceItems = (items, loadOptions) => {
      const start = loadOptions.skip ?? 0;
      const end = loadOptions.take ? start + loadOptions.take : items.length;
      return items.slice(start, end);
    };
    const lookupDataSource = _extends({}, lookupDataSourceOptions, {
      __dataGridSourceFilter: filter,
      load: (loadOptions) => {
        const d = new Deferred();
        ((loadOptions2) => {
          const group = normalizeGroupingLoadOptions(hasLookupOptimization ? [column.dataField, column.displayField] : column.dataField);
          const d2 = new Deferred();
          const canUseCache = cachedUniqueRelevantItems && (!hasGroupPaging || loadOptions2.skip === previousSkip && loadOptions2.take === previousTake);
          if (canUseCache) {
            d2.resolve(sliceItems(cachedUniqueRelevantItems, loadOptions2));
          } else {
            previousSkip = loadOptions2.skip;
            previousTake = loadOptions2.take;
            dataSource.load({
              filter,
              group,
              take: hasGroupPaging ? loadOptions2.take : void 0,
              skip: hasGroupPaging ? loadOptions2.skip : void 0
            }).done((items) => {
              cachedUniqueRelevantItems = items;
              d2.resolve(hasGroupPaging ? items : sliceItems(items, loadOptions2));
            }).fail(d2.fail);
          }
          return d2;
        })(loadOptions).done((items) => {
          if (0 === items.length) {
            d.resolve([]);
            return;
          }
          const filter2 = this.combineFilters(items.flatMap((data17) => data17.key).map((key) => [column.lookup.valueExpr, key]), "or");
          const newDataSource = new data_source_default(_extends({}, lookupDataSourceOptions, loadOptions, {
            filter: this.combineFilters([filter2, loadOptions.filter], "and"),
            paginate: false
          }));
          newDataSource.load().done(d.resolve).fail(d.fail);
        }).fail(d.fail);
        return d;
      },
      key: column.lookup.valueExpr,
      byKey(key) {
        const d = Deferred();
        this.load({
          filter: [column.lookup.valueExpr, "=", key]
        }).done((arr) => {
          d.resolve(arr[0]);
        });
        return d.promise();
      }
    });
    return lookupDataSource;
  },
  logHeaderFilterDeprecatedWarningIfNeed(component) {
    const logWarning = component._logDeprecatedOptionWarning.bind(component);
    if (isDefined(component.option("headerFilter.allowSearch"))) {
      logWarning("headerFilter.allowSearch", {
        since: "23.1",
        alias: "headerFilter.search.enabled"
      });
    }
    if (isDefined(component.option("headerFilter.searchTimeout"))) {
      logWarning("headerFilter.searchTimeout", {
        since: "23.1",
        alias: "headerFilter.search.timeout"
      });
    }
    const specificName = "dxPivotGrid" === component.NAME ? "dataSource.fields" : "columns";
    const columns7 = component.option(specificName);
    if (!Array.isArray(columns7)) {
      return;
    }
    const logSpecificDeprecatedWarningIfNeed = (columns8) => {
      columns8.forEach((column) => {
        var _column$columns;
        const headerFilter = column.headerFilter || {};
        if (isDefined(headerFilter.allowSearch)) {
          logWarning(`${specificName}[].headerFilter.allowSearch`, {
            since: "23.1",
            alias: `${specificName}[].headerFilter.search.enabled`
          });
        }
        if (isDefined(headerFilter.searchMode)) {
          logWarning(`${specificName}[].headerFilter.searchMode`, {
            since: "23.1",
            alias: `${specificName}[].headerFilter.search.mode`
          });
        }
        if (null !== (_column$columns = column.columns) && void 0 !== _column$columns && _column$columns.length) {
          logSpecificDeprecatedWarningIfNeed(column.columns);
        }
      });
    };
    logSpecificDeprecatedWarningIfNeed(columns7);
  },
  getComponentBorderWidth(that, $rowsViewElement) {
    const borderWidth = that.option("showBorders") ? Math.ceil(getOuterWidth($rowsViewElement) - getInnerWidth($rowsViewElement)) : 0;
    return borderWidth;
  },
  isCustomCommandColumn(columns7, commandColumn) {
    const customCommandColumns = columns7.filter((column) => column.type === commandColumn.type);
    return !!customCommandColumns.length;
  }
};

// node_modules/devextreme/esm/__internal/grids/grid_core/views/m_columns_view.js
var DETAIL_ROW_CLASS = "dx-master-detail-row";
var CELL_HINT_VISIBLE = "dxCellHintVisible";
var appendElementTemplate = {
  render(options2) {
    options2.container.append(options2.content);
  }
};
var subscribeToRowEvents = function(that, $table) {
  let touchTarget;
  let touchCurrentTarget;
  let timeoutId;
  function clearTouchTargets(timeout) {
    return setTimeout(() => {
      touchTarget = touchCurrentTarget = null;
    }, timeout);
  }
  m_events_engine_default.on($table, "touchstart touchend", ".dx-row", (e) => {
    clearTimeout(timeoutId);
    if ("touchstart" === e.type) {
      touchTarget = e.target;
      touchCurrentTarget = e.currentTarget;
      timeoutId = clearTouchTargets(1e3);
    } else {
      timeoutId = clearTouchTargets();
    }
  });
  m_events_engine_default.on($table, [CLICK_EVENT_NAME, DBLCLICK_EVENT_NAME, m_pointer_default.down].join(" "), ".dx-row", that.createAction((e) => {
    const {
      event
    } = e;
    if (touchTarget) {
      event.target = touchTarget;
      event.currentTarget = touchCurrentTarget;
    }
    if (!renderer_default(event.target).closest("a").length) {
      e.rowIndex = that.getRowIndex(event.currentTarget);
      if (e.rowIndex >= 0) {
        e.rowElement = getPublicElement(renderer_default(event.currentTarget));
        e.columns = that.getColumns();
        if (event.type === m_pointer_default.down) {
          that._rowPointerDown(e);
        } else if (event.type === CLICK_EVENT_NAME) {
          that._rowClick(e);
        } else {
          that._rowDblClick(e);
        }
      }
    }
  }));
};
var getWidthStyle = function(width) {
  if ("auto" === width) {
    return "";
  }
  return isNumeric(width) ? `${width}px` : width;
};
var setCellWidth = function(cell, column, width) {
  cell.style.width = cell.style.maxWidth = "auto" === column.width ? "" : width;
};
var copyAttributes = function(element, newElement) {
  if (!element || !newElement) {
    return;
  }
  const oldAttributes = element.attributes;
  const newAttributes = newElement.attributes;
  let i;
  for (i = 0; i < oldAttributes.length; i++) {
    const name2 = oldAttributes[i].nodeName;
    if (!newElement.hasAttribute(name2)) {
      element.removeAttribute(name2);
    }
  }
  for (i = 0; i < newAttributes.length; i++) {
    element.setAttribute(newAttributes[i].nodeName, newAttributes[i].nodeValue);
  }
};
var removeHandler = function(templateDeferred) {
  templateDeferred.resolve();
};
var normalizeWidth = (width) => {
  if ("number" === typeof width) {
    return `${width.toFixed(3)}px`;
  }
  if ("adaptiveHidden" === width) {
    return "0.0001px";
  }
  return width;
};
var ColumnsView = class extends ColumnStateMixin(m_modules_default.View) {
  init() {
    this._scrollLeft = -1;
    this._columnsController = this.getController("columns");
    this._dataController = this.getController("data");
    this._adaptiveColumnsController = this.getController("adaptiveColumns");
    this._columnChooserController = this.getController("columnChooser");
    this._editorFactoryController = this.getController("editorFactory");
    this._selectionController = this.getController("selection");
    this._columnChooserView = this.getView("columnChooserView");
    this._delayedTemplates = [];
    this._templateDeferreds = /* @__PURE__ */ new Set();
    this._templatesCache = {};
    this._templateTimeouts = /* @__PURE__ */ new Set();
    this.createAction("onCellClick");
    this.createAction("onRowClick");
    this.createAction("onCellDblClick");
    this.createAction("onRowDblClick");
    this.createAction("onCellHoverChanged", {
      excludeValidators: ["disabled", "readOnly"]
    });
    this.createAction("onCellPrepared", {
      excludeValidators: ["disabled", "readOnly"],
      category: "rendering"
    });
    this.createAction("onRowPrepared", {
      excludeValidators: ["disabled", "readOnly"],
      category: "rendering",
      afterExecute: (e) => {
        this._afterRowPrepared(e);
      }
    });
    this._columnsController.columnsChanged.add(this._columnOptionChanged.bind(this));
    this._dataController && this._dataController.changed.add(this._handleDataChanged.bind(this));
  }
  dispose() {
    if (hasWindow()) {
      var _this$_templateTimeou, _this$_templateTimeou2;
      const window31 = getWindow();
      null === (_this$_templateTimeou = this._templateTimeouts) || void 0 === _this$_templateTimeou || _this$_templateTimeou.forEach((templateTimeout) => window31.clearTimeout(templateTimeout));
      null === (_this$_templateTimeou2 = this._templateTimeouts) || void 0 === _this$_templateTimeou2 || _this$_templateTimeou2.clear();
    }
  }
  optionChanged(args) {
    super.optionChanged(args);
    switch (args.name) {
      case "cellHintEnabled":
      case "onCellPrepared":
      case "onRowPrepared":
      case "onCellHoverChanged":
        this._invalidate(true, true);
        args.handled = true;
        break;
      case "keyboardNavigation":
        if ("keyboardNavigation.enabled" === args.fullName) {
          this._invalidate(true, true);
        }
        args.handled = true;
    }
  }
  _createScrollableOptions() {
    const scrollingOptions = this.option("scrolling");
    let useNativeScrolling = this.option("scrolling.useNative");
    const options2 = extend({}, scrollingOptions, {
      direction: "both",
      bounceEnabled: false,
      useKeyboard: false
    });
    if (void 0 === useNativeScrolling) {
      useNativeScrolling = true;
    }
    if ("auto" === useNativeScrolling) {
      delete options2.useNative;
      delete options2.useSimulatedScrollbar;
    } else {
      options2.useNative = !!useNativeScrolling;
      options2.useSimulatedScrollbar = !useNativeScrolling;
    }
    return options2;
  }
  _updateCell($cell, parameters) {
    if (parameters.rowType) {
      this._cellPrepared($cell, parameters);
    }
  }
  _needToSetCellWidths() {
    return this.option("columnAutoWidth");
  }
  _createCell(options2) {
    const {
      column
    } = options2;
    const alignment = column.alignment || getDefaultAlignment(this.option("rtlEnabled"));
    const needToSetCellWidths = this._needToSetCellWidths();
    const cell = dom_adapter_default.createElement("td");
    cell.style.textAlign = alignment;
    const $cell = renderer_default(cell);
    if (column.cssClass) {
      $cell.addClass(column.cssClass);
    }
    if (Array.isArray(column.elementAttr)) {
      column.elementAttr.forEach((_ref) => {
        let {
          name: name2,
          value: value2
        } = _ref;
        $cell.attr(name2, value2);
      });
    }
    if ("expand" === column.command) {
      $cell.addClass(column.cssClass);
      $cell.addClass(this.addWidgetPrefix("group-space"));
    }
    if (column.colspan > 1) {
      $cell.attr("colSpan", column.colspan);
    } else if (!column.isBand && "auto" !== column.visibleWidth && needToSetCellWidths) {
      if (column.width || column.minWidth) {
        cell.style.minWidth = getWidthStyle(column.minWidth || column.width);
      }
      if (column.width) {
        setCellWidth(cell, column, getWidthStyle(column.width));
      }
    }
    return $cell;
  }
  _createRow(rowObject, tagName) {
    tagName = tagName || "tr";
    const $element = renderer_default(`<${tagName}>`).addClass("dx-row");
    if ("tr" === tagName) {
      this.setAria("role", "row", $element);
    }
    return $element;
  }
  _isAltRow(row) {
    return row && row.dataIndex % 2 === 1;
  }
  _createTable(columns7, isAppend) {
    const $table = renderer_default("<table>").addClass(this.addWidgetPrefix("table")).addClass(this.addWidgetPrefix("table-fixed"));
    if (columns7 && !isAppend) {
      $table.attr("id", `dx-${new guid_default2()}`).append(this._createColGroup(columns7));
      if (browser_default.safari) {
        $table.append(renderer_default("<thead>").append("<tr>"));
      }
      this.setAria("role", "presentation", $table);
    } else {
      this.setAria("hidden", true, $table);
    }
    this.setAria("role", "presentation", renderer_default("<tbody>").appendTo($table));
    if (isAppend) {
      return $table;
    }
    if (browser_default.mozilla) {
      m_events_engine_default.on($table, "mousedown", "td", (e) => {
        if (e.ctrlKey) {
          e.preventDefault();
        }
      });
    }
    if (this.option("cellHintEnabled")) {
      m_events_engine_default.on($table, "mousemove", ".dx-row > td", this.createAction((args) => {
        const e = args.event;
        const $element = renderer_default(e.target);
        const $cell = renderer_default(e.currentTarget);
        const $row = $cell.parent();
        const visibleColumns = this._columnsController.getVisibleColumns();
        const rowOptions = $row.data("options");
        const columnIndex = $cell.index();
        const cellOptions = rowOptions && rowOptions.cells && rowOptions.cells[columnIndex];
        const column = cellOptions ? cellOptions.column : visibleColumns[columnIndex];
        const isHeaderRow = $row.hasClass("dx-header-row");
        const isDataRow2 = $row.hasClass("dx-data-row");
        const isMasterDetailRow = $row.hasClass(DETAIL_ROW_CLASS);
        const isGroupRow3 = $row.hasClass("dx-group-row");
        const isFilterRow = $row.hasClass(this.addWidgetPrefix("filter-row"));
        const isDataRowWithTemplate = isDataRow2 && (!column || column.cellTemplate);
        const isEditorShown = isDataRow2 && cellOptions && (rowOptions.isEditing || cellOptions.isEditing || (null === column || void 0 === column ? void 0 : column.showEditorAlways));
        const isHeaderRowWithTemplate = isHeaderRow && (!column || column.headerCellTemplate);
        const isGroupCellWithTemplate = isGroupRow3 && (!column || column.groupIndex && column.groupCellTemplate);
        const shouldShowHint = !isMasterDetailRow && !isFilterRow && !isEditorShown && !isDataRowWithTemplate && !isHeaderRowWithTemplate && !isGroupCellWithTemplate;
        if (shouldShowHint) {
          if ($element.data(CELL_HINT_VISIBLE)) {
            $element.removeAttr("title");
            $element.data(CELL_HINT_VISIBLE, false);
          }
          const difference = $element[0].scrollWidth - $element[0].clientWidth;
          if (difference > 0 && !isDefined($element.attr("title"))) {
            $element.attr("title", $element.text());
            $element.data(CELL_HINT_VISIBLE, true);
          }
        }
      }));
    }
    const getOptions = (event) => {
      const $cell = renderer_default(event.currentTarget);
      const $fieldItemContent = renderer_default(event.target).closest(".dx-field-item-content");
      const $row = $cell.parent();
      const rowOptions = $row.data("options");
      const options2 = rowOptions && rowOptions.cells && rowOptions.cells[$cell.index()];
      if (!$cell.closest("table").is(event.delegateTarget)) {
        return;
      }
      const resultOptions = extend({}, options2, {
        cellElement: getPublicElement($cell),
        event,
        eventType: event.type
      });
      resultOptions.rowIndex = this.getRowIndex($row);
      if ($fieldItemContent.length) {
        const formItemOptions = $fieldItemContent.data("dx-form-item");
        if (formItemOptions.column) {
          resultOptions.column = formItemOptions.column;
          resultOptions.columnIndex = this._columnsController.getVisibleIndex(resultOptions.column.index);
        }
      }
      return resultOptions;
    };
    m_events_engine_default.on($table, "mouseover", ".dx-row > td", (e) => {
      const options2 = getOptions(e);
      options2 && this.executeAction("onCellHoverChanged", options2);
    });
    m_events_engine_default.on($table, "mouseout", ".dx-row > td", (e) => {
      const options2 = getOptions(e);
      options2 && this.executeAction("onCellHoverChanged", options2);
    });
    m_events_engine_default.on($table, CLICK_EVENT_NAME, ".dx-row > td", (e) => {
      const options2 = getOptions(e);
      options2 && this.executeAction("onCellClick", options2);
    });
    m_events_engine_default.on($table, DBLCLICK_EVENT_NAME, ".dx-row > td", (e) => {
      const options2 = getOptions(e);
      options2 && this.executeAction("onCellDblClick", options2);
    });
    subscribeToRowEvents(this, $table);
    return $table;
  }
  _rowPointerDown(e) {
  }
  _rowClick() {
  }
  _rowDblClick() {
  }
  _createColGroup(columns7) {
    const colgroupElement = renderer_default("<colgroup>");
    for (let i = 0; i < columns7.length; i++) {
      const colspan = columns7[i].colspan || 1;
      for (let j = 0; j < colspan; j++) {
        colgroupElement.append(this._createCol(columns7[i]));
      }
    }
    return colgroupElement;
  }
  _createCol(column) {
    let width = column.visibleWidth || column.width;
    if ("adaptiveHidden" === width) {
      width = "0.0001px";
    }
    const col = renderer_default("<col>");
    setWidth2(col, width);
    return col;
  }
  renderDelayedTemplates(change) {
    const delayedTemplates = this._delayedTemplates;
    const syncTemplates = delayedTemplates.filter((template) => !template.async);
    const asyncTemplates = delayedTemplates.filter((template) => template.async);
    this._delayedTemplates = [];
    this._renderDelayedTemplatesCore(syncTemplates, false, change);
    this._renderDelayedTemplatesCoreAsync(asyncTemplates);
  }
  _renderDelayedTemplatesCoreAsync(templates) {
    if (templates.length) {
      const templateTimeout = getWindow().setTimeout(() => {
        this._templateTimeouts.delete(templateTimeout);
        this._renderDelayedTemplatesCore(templates, true);
      });
      this._templateTimeouts.add(templateTimeout);
    }
  }
  _renderDelayedTemplatesCore(templates, isAsync, change) {
    const date = /* @__PURE__ */ new Date();
    while (templates.length) {
      const templateParameters = templates.shift();
      const {
        options: options2
      } = templateParameters;
      const doc = dom_adapter_default.getRootNode(renderer_default(options2.container).get(0));
      const needWaitAsyncTemplates = this.needWaitAsyncTemplates();
      if (!isAsync || renderer_default(options2.container).closest(doc).length || needWaitAsyncTemplates) {
        if (change) {
          options2.change = change;
        }
        templateParameters.template.render(options2);
      }
      if (isAsync && /* @__PURE__ */ new Date() - date > 30) {
        this._renderDelayedTemplatesCoreAsync(templates);
        break;
      }
    }
    if (!templates.length && this._delayedTemplates.length) {
      this.renderDelayedTemplates();
    }
  }
  _processTemplate(template, options2) {
    const that = this;
    let renderingTemplate;
    if (template && template.render && !isRenderer(template)) {
      renderingTemplate = {
        allowRenderToDetachedContainer: template.allowRenderToDetachedContainer,
        render(options3) {
          template.render(options3.container, options3.model, options3.change);
          options3.deferred && options3.deferred.resolve();
        }
      };
    } else if (isFunction(template)) {
      renderingTemplate = {
        render(options3) {
          const renderedTemplate = template(getPublicElement(options3.container), options3.model, options3.change);
          if (renderedTemplate && (renderedTemplate.nodeType || isRenderer(renderedTemplate))) {
            options3.container.append(renderedTemplate);
          }
          options3.deferred && options3.deferred.resolve();
        }
      };
    } else {
      const templateID = isString(template) ? template : renderer_default(template).attr("id");
      if (!templateID) {
        renderingTemplate = that.getTemplate(template);
      } else {
        if (!that._templatesCache[templateID]) {
          that._templatesCache[templateID] = that.getTemplate(template);
        }
        renderingTemplate = that._templatesCache[templateID];
      }
    }
    return renderingTemplate;
  }
  renderTemplate(container, template, options2, allowRenderToDetachedContainer, change) {
    const renderingTemplate = this._processTemplate(template, options2);
    const {
      column
    } = options2;
    const isDataRow2 = "data" === options2.rowType;
    const templateDeferred = new Deferred();
    const templateOptions = {
      container,
      model: options2,
      deferred: templateDeferred,
      onRendered: () => {
        if (this.isDisposed()) {
          templateDeferred.reject();
        } else {
          templateDeferred.resolve();
        }
      }
    };
    if (renderingTemplate) {
      options2.component = this.component;
      const columnAsync = column && (column.renderAsync && isDataRow2 || this.option("renderAsync") && (false !== column.renderAsync && (column.command || column.showEditorAlways) && isDataRow2 || "filter" === options2.rowType));
      const async = options2.renderAsync ?? columnAsync;
      if ((renderingTemplate.allowRenderToDetachedContainer || allowRenderToDetachedContainer) && !async) {
        renderingTemplate.render(templateOptions);
      } else {
        this._delayedTemplates.push({
          template: renderingTemplate,
          options: templateOptions,
          async
        });
      }
      this._templateDeferreds.add(templateDeferred);
      m_events_engine_default.on(container, removeEvent, removeHandler.bind(null, templateDeferred));
    } else {
      templateDeferred.reject();
    }
    return templateDeferred.promise().always(() => {
      this._templateDeferreds.delete(templateDeferred);
    });
  }
  _getBodies(tableElement) {
    return renderer_default(tableElement).children("tbody").not(".dx-header").not(".dx-footer");
  }
  _needWrapRow($tableElement) {
    var _this$_getBodies;
    const hasRowTemplate = !!this.option().rowTemplate;
    return hasRowTemplate && !!(null !== (_this$_getBodies = this._getBodies($tableElement)) && void 0 !== _this$_getBodies && _this$_getBodies.filter(".dx-row").length);
  }
  _wrapRowIfNeed($table, $row, isRefreshing) {
    const $tableElement = isRefreshing ? $table || this._tableElement : this._tableElement || $table;
    const needWrapRow = this._needWrapRow($tableElement);
    if (needWrapRow) {
      const $tbody = renderer_default("<tbody>").addClass($row.attr("class"));
      this.setAria("role", "presentation", $tbody);
      return $tbody.append($row);
    }
    return $row;
  }
  _appendRow($table, $row, appendTemplate) {
    appendTemplate = appendTemplate || appendElementTemplate;
    appendTemplate.render({
      content: $row,
      container: $table
    });
  }
  _resizeCore() {
    const scrollLeft = this._scrollLeft;
    if (scrollLeft >= 0) {
      this._scrollLeft = 0;
      this.scrollTo({
        left: scrollLeft
      });
    }
  }
  _renderCore(e) {
    const $root = this.element().parent();
    if (!$root || $root.parent().length) {
      this.renderDelayedTemplates(e);
    }
    return new Deferred().resolve();
  }
  _renderTable(options2) {
    options2 = options2 || {};
    options2.columns = this._columnsController.getVisibleColumns();
    const changeType = options2.change && options2.change.changeType;
    const $table = this._createTable(options2.columns, "append" === changeType || "prepend" === changeType || "update" === changeType);
    this._renderRows($table, options2);
    return $table;
  }
  _renderRows($table, options2) {
    const that = this;
    const rows = that._getRows(options2.change);
    const columnIndices = options2.change && options2.change.columnIndices || [];
    const changeTypes = options2.change && options2.change.changeTypes || [];
    for (let i = 0; i < rows.length; i++) {
      that._renderRow($table, extend({
        row: rows[i],
        columnIndices: columnIndices[i],
        changeType: changeTypes[i]
      }, options2));
    }
  }
  _renderRow($table, options2) {
    if (!options2.columnIndices) {
      options2.row.cells = [];
    }
    const $row = this._createRow(options2.row);
    const $wrappedRow = this._wrapRowIfNeed($table, $row);
    if ("remove" !== options2.changeType) {
      this._renderCells($row, options2);
    }
    this._appendRow($table, $wrappedRow);
    const rowOptions = extend({
      columns: options2.columns
    }, options2.row);
    this._addWatchMethod(rowOptions, options2.row);
    this._rowPrepared($wrappedRow, rowOptions, options2.row);
  }
  _needRenderCell(columnIndex, columnIndices) {
    return !columnIndices || columnIndices.indexOf(columnIndex) >= 0;
  }
  _renderCells($row, options2) {
    const that = this;
    let columnIndex = 0;
    const {
      row
    } = options2;
    const {
      columns: columns7
    } = options2;
    for (let i = 0; i < columns7.length; i++) {
      if (this._needRenderCell(i, options2.columnIndices)) {
        that._renderCell($row, extend({
          column: columns7[i],
          columnIndex,
          value: row.values && row.values[columnIndex],
          oldValue: row.oldValues && row.oldValues[columnIndex]
        }, options2));
      }
      if (columns7[i].colspan > 1) {
        columnIndex += columns7[i].colspan;
      } else {
        columnIndex++;
      }
    }
  }
  _updateCells($rowElement, $newRowElement, columnIndices, options2) {
    var _options$node;
    const that = this;
    const $cells = $rowElement.children();
    const $newCells = $newRowElement.children();
    const highlightChanges = this.option("highlightChanges");
    const cellUpdatedClass = this.addWidgetPrefix("cell-updated-animation");
    if (null !== options2 && void 0 !== options2 && null !== (_options$node = options2.node) && void 0 !== _options$node && _options$node.hasChildren) {
      $cells.each(function() {
        that.setAria("expanded", options2.isExpanded, renderer_default(this));
      });
    }
    columnIndices.forEach((columnIndex, index2) => {
      const $cell = $cells.eq(columnIndex);
      const $newCell = $newCells.eq(index2);
      $cell.replaceWith($newCell);
      if (highlightChanges && !$newCell.hasClass("dx-command-expand")) {
        $newCell.addClass(cellUpdatedClass);
      }
    });
    copyAttributes($rowElement.get(0), $newRowElement.get(0));
  }
  _setCellAriaAttributes($cell, cellOptions, options2) {
    var _row$node;
    const {
      row
    } = options2;
    const isFreeSpaceRow = "freeSpace" === cellOptions.rowType;
    const isGroupRow3 = "group" === cellOptions.rowType;
    const rowHasChildren = null === row || void 0 === row || null === (_row$node = row.node) || void 0 === _row$node ? void 0 : _row$node.hasChildren;
    if (isFreeSpaceRow) {
      return;
    }
    this.setAria("role", "gridcell", $cell);
    if (rowHasChildren) {
      this.setAria("expanded", row.isExpanded, $cell);
    }
    const columnIndexOffset = this._columnsController.getColumnIndexOffset();
    const ariaColIndex = isGroupRow3 ? cellOptions.columnIndex + 1 : cellOptions.columnIndex + columnIndexOffset + 1;
    this.setAria("colindex", ariaColIndex, $cell);
  }
  _renderCell($row, options2) {
    const cellOptions = this._getCellOptions(options2);
    if (options2.columnIndices) {
      if (options2.row.cells) {
        const cellIndex = options2.row.cells.findIndex((cell) => cell.columnIndex === cellOptions.columnIndex);
        options2.row.cells[cellIndex] = cellOptions;
      }
    } else {
      options2.row.cells.push(cellOptions);
    }
    const $cell = this._createCell(cellOptions);
    this._setCellAriaAttributes($cell, cellOptions, options2);
    this._renderCellContent($cell, cellOptions, options2);
    $row.get(0).appendChild($cell.get(0));
    return $cell;
  }
  _renderCellContent($cell, options2, renderOptions) {
    const template = this._getCellTemplate(options2);
    when(!template || this.renderTemplate($cell, template, options2, void 0, renderOptions.change)).done(() => {
      this._updateCell($cell, options2);
    });
  }
  _getCellTemplate(options2) {
  }
  _getRows(change) {
    return [];
  }
  _getCellOptions(options2) {
    const cellOptions = {
      column: options2.column,
      columnIndex: options2.columnIndex,
      rowType: options2.row.rowType,
      rowIndex: options2.row.rowIndex,
      isAltRow: this._isAltRow(options2.row)
    };
    this._addWatchMethod(cellOptions);
    return cellOptions;
  }
  _addWatchMethod(options2, source) {
    if (!this.option("repaintChangesOnly")) {
      return;
    }
    const watchers = [];
    source = source || options2;
    source.watch = source.watch || function(getter, updateValueFunc, updateRowFunc) {
      let oldValue = getter(source.data);
      const watcher = function(row) {
        if (row && updateRowFunc) {
          updateRowFunc(row);
        }
        const newValue = getter(source.data);
        if (JSON.stringify(oldValue) !== JSON.stringify(newValue)) {
          if (row) {
            updateValueFunc(newValue);
          }
          oldValue = newValue;
        }
      };
      watchers.push(watcher);
      return function() {
        const index2 = watchers.indexOf(watcher);
        if (index2 >= 0) {
          watchers.splice(index2, 1);
        }
      };
    };
    source.update = source.update || function(row, keepRow) {
      if (row) {
        this.data = options2.data = row.data;
        this.rowIndex = options2.rowIndex = row.rowIndex;
        this.dataIndex = options2.dataIndex = row.dataIndex;
        this.isExpanded = options2.isExpanded = row.isExpanded;
        if (options2.row && !keepRow) {
          options2.row = row;
        }
      }
      watchers.forEach((watcher) => {
        watcher(row);
      });
    };
    if (source !== options2) {
      options2.watch = source.watch.bind(source);
    }
    return options2;
  }
  _cellPrepared(cell, options2) {
    options2.cellElement = getPublicElement(renderer_default(cell));
    this.executeAction("onCellPrepared", options2);
  }
  _rowPrepared($row, options2, row) {
    data($row.get(0), "options", options2);
    options2.rowElement = getPublicElement($row);
    this.executeAction("onRowPrepared", options2);
  }
  _columnOptionChanged(e) {
    const {
      optionNames
    } = e;
    if (m_utils_default.checkChanges(optionNames, ["width", "visibleWidth"])) {
      const visibleColumns = this._columnsController.getVisibleColumns();
      const widths = visibleColumns.map((column) => column.visibleWidth || column.width);
      this.setColumnWidths({
        widths,
        optionNames
      });
      return;
    }
    if (!this._requireReady) {
      this.render();
    }
  }
  getCellIndex($cell, rowIndex) {
    const cellIndex = $cell.length ? $cell[0].cellIndex : -1;
    return cellIndex;
  }
  getTableElements() {
    return this._tableElement || renderer_default();
  }
  getTableElement(isFixedTableRendering) {
    return this._tableElement;
  }
  setTableElement(tableElement, isFixedTableRendering) {
    this._tableElement = tableElement;
  }
  _afterRowPrepared(e) {
  }
  _handleDataChanged(e) {
  }
  callbackNames() {
    return ["scrollChanged"];
  }
  _updateScrollLeftPosition() {
    const scrollLeft = this._scrollLeft;
    if (scrollLeft >= 0) {
      this._scrollLeft = 0;
      this.scrollTo({
        left: scrollLeft
      });
    }
  }
  scrollTo(pos) {
    const $element = this.element();
    const $scrollContainer = $element && $element.children(`.${this.addWidgetPrefix("scroll-container")}`).not(`.${this.addWidgetPrefix("content-fixed")}`);
    if (isDefined(pos) && isDefined(pos.left) && this._scrollLeft !== pos.left) {
      this._scrollLeft = pos.left;
      $scrollContainer && $scrollContainer.scrollLeft(pos.left);
    }
  }
  getContent(isFixedTableRendering) {
    var _this$_tableElement;
    return null === (_this$_tableElement = this._tableElement) || void 0 === _this$_tableElement ? void 0 : _this$_tableElement.parent();
  }
  _removeContent(isFixedTableRendering) {
    const $scrollContainer = this.getContent(isFixedTableRendering);
    if (null !== $scrollContainer && void 0 !== $scrollContainer && $scrollContainer.length) {
      $scrollContainer.remove();
    }
  }
  handleScroll(e) {
    const scrollLeft = renderer_default(e.target).scrollLeft();
    if (scrollLeft !== this._scrollLeft) {
      this.scrollChanged.fire({
        left: scrollLeft
      }, this.name);
    }
  }
  _wrapTableInScrollContainer($table, isFixedTableRendering) {
    const $scrollContainer = renderer_default("<div>");
    const useNative = this.option("scrolling.useNative");
    if (false === useNative || "auto" === useNative && !m_support_default.nativeScrolling) {
      $scrollContainer.addClass(this.addWidgetPrefix("scrollable-simulated"));
    }
    m_events_engine_default.on($scrollContainer, "scroll", this.handleScroll.bind(this));
    $scrollContainer.addClass(this.addWidgetPrefix("content")).addClass(this.addWidgetPrefix("scroll-container")).append($table).appendTo(this.element());
    this.setAria("role", "presentation", $scrollContainer);
    return $scrollContainer;
  }
  needWaitAsyncTemplates() {
    return this.option("templatesRenderAsynchronously") && false === this.option("renderAsync");
  }
  waitAsyncTemplates() {
    let forceWaiting = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : false;
    const result2 = new Deferred();
    const needWaitAsyncTemplates = forceWaiting || this.needWaitAsyncTemplates();
    if (!needWaitAsyncTemplates || !isDefined(this._templateDeferreds)) {
      return result2.resolve();
    }
    const waitTemplatesRecursion = () => when.apply(this, Array.from(this._templateDeferreds)).done(() => {
      if (this.isDisposed()) {
        result2.reject();
      } else if (this._templateDeferreds.size > 0) {
        waitTemplatesRecursion();
      } else {
        result2.resolve();
      }
    }).fail(result2.reject);
    waitTemplatesRecursion();
    return result2.promise();
  }
  _updateContent($newTableElement, change, isFixedTableRendering) {
    return this.waitAsyncTemplates().done(() => {
      this._removeContent(isFixedTableRendering);
      this.setTableElement($newTableElement, isFixedTableRendering);
      this._wrapTableInScrollContainer($newTableElement, isFixedTableRendering);
    });
  }
  _findContentElement(isFixedTableRendering) {
  }
  _getWidths($cellElements) {
    if (!$cellElements) {
      return [];
    }
    const result2 = [];
    const cellElements = $cellElements.toArray();
    cellElements.forEach((cell) => {
      let width = cell.offsetWidth;
      if (cell.getBoundingClientRect) {
        const rect = getBoundingRect(cell);
        if (rect.width > cell.offsetWidth - 1) {
          width = rect.width;
        }
      }
      result2.push(width);
    });
    return result2;
  }
  getColumnWidths($tableElement, rowIndex) {
    (this.option("forceApplyBindings") || noop2)();
    $tableElement = $tableElement ?? this.getTableElement();
    if ($tableElement) {
      const $rows = $tableElement.children("tbody:not(.dx-header)").children();
      for (let i = 0; i < $rows.length; i++) {
        const $row = $rows.eq(i);
        const isGroupRow3 = $row.hasClass("dx-group-row");
        const isDetailRow2 = $row.hasClass(DETAIL_ROW_CLASS);
        const isErrorRow = $row.hasClass("dx-error-row");
        const isRowVisible = "none" !== $row.get(0).style.display && !$row.hasClass("dx-state-invisible");
        const isRelevantRow = !isGroupRow3 && !isDetailRow2 && !isErrorRow;
        if (isRowVisible && isRelevantRow) {
          const $cells = $row.children("td");
          const result2 = this._getWidths($cells);
          return result2;
        }
      }
    }
    return [];
  }
  getVisibleColumnIndex(columnIndex, rowIndex) {
    return columnIndex;
  }
  setCellPropertiesCore(styleProps, $row, visibleCellIndex) {
    const $cell = $row.hasClass("dx-group-row") ? $row.find(`td[aria-colindex='${visibleCellIndex + 1}']:not(.dx-group-cell)`) : $row.find("td").eq(visibleCellIndex);
    for (let i = 0; i < $cell.length; i += 1) {
      const cell = $cell.get(i);
      Object.assign(cell.style, styleProps);
    }
  }
  setCellProperties(styleProps, columnIndex, rowIndex) {
    const $tableElement = this.getTableElement();
    if (!(null !== $tableElement && void 0 !== $tableElement && $tableElement.length)) {
      return;
    }
    const $rows = $tableElement.children().children(".dx-row").not(`.${DETAIL_ROW_CLASS}`);
    if (isDefined(rowIndex)) {
      this.setCellPropertiesCore(styleProps, $rows.eq(rowIndex), columnIndex);
    } else {
      for (let rowIndex2 = 0; rowIndex2 < $rows.length; rowIndex2++) {
        const visibleIndex = this.getVisibleColumnIndex(columnIndex, rowIndex2);
        if (visibleIndex >= 0) {
          this.setCellPropertiesCore(styleProps, $rows.eq(rowIndex2), visibleIndex);
        }
      }
    }
  }
  setColumnWidths(_ref2) {
    let {
      widths,
      optionNames
    } = _ref2;
    const $tableElement = this.getTableElement();
    if (!(null !== $tableElement && void 0 !== $tableElement && $tableElement.length) || !widths) {
      return;
    }
    const columns7 = this.getColumns();
    const needToSetCellWidths = this._needToSetCellWidths();
    const $cols = $tableElement.children("colgroup").children("col");
    $cols.toArray().forEach((col) => col.removeAttribute("style"));
    columns7.forEach((column, columnIndex) => {
      if (needToSetCellWidths && column.width && !column.command) {
        const styleProps = {};
        const width = getWidthStyle(column.visibleWidth || column.width);
        const minWidth = getWidthStyle(column.minWidth || width);
        styleProps.width = "auto" === column.width ? "" : width;
        styleProps.maxWidth = styleProps.width;
        styleProps.minWidth = minWidth;
        this.setCellProperties(styleProps, columnIndex);
      }
      const colWidth = normalizeWidth(widths[columnIndex]);
      if (isDefined(colWidth)) {
        setWidth2($cols.eq(columnIndex), colWidth);
      }
    });
  }
  getCellElements(rowIndex) {
    return this._getCellElementsCore(rowIndex);
  }
  _getCellElementsCore(rowIndex) {
    if (rowIndex < 0) {
      return;
    }
    const $row = this._getRowElements().eq(rowIndex);
    return $row.children();
  }
  _getCellElement(rowIndex, columnIdentifier) {
    const $cells = this.getCellElements(rowIndex);
    const columnVisibleIndex = this._getVisibleColumnIndex($cells, rowIndex, columnIdentifier);
    if (!(null !== $cells && void 0 !== $cells && $cells.length) || columnVisibleIndex < 0) {
      return;
    }
    const $cell = $cells.eq(columnVisibleIndex);
    return $cell.length > 0 ? $cell : void 0;
  }
  _getRowElement(rowIndex) {
    const that = this;
    let $rowElement = renderer_default();
    const $tableElements = that.getTableElements();
    each($tableElements, (_, tableElement) => {
      $rowElement = $rowElement.add(that._getRowElements(renderer_default(tableElement)).eq(rowIndex));
    });
    if ($rowElement.length) {
      return $rowElement;
    }
    return;
  }
  getCellElement(rowIndex, columnIdentifier) {
    const $cell = this._getCellElement(rowIndex, columnIdentifier);
    if ($cell) {
      return getPublicElement($cell);
    }
    return;
  }
  getRowElement(rowIndex) {
    const $rows = this._getRowElement(rowIndex);
    let elements = [];
    if ($rows && !getPublicElement($rows).get) {
      for (let i = 0; i < $rows.length; i++) {
        elements.push($rows[i]);
      }
    } else {
      elements = $rows;
    }
    return elements;
  }
  _getVisibleColumnIndex($cells, rowIndex, columnIdentifier) {
    if (isString(columnIdentifier)) {
      const columnIndex = this._columnsController.columnOption(columnIdentifier, "index");
      return this._columnsController.getVisibleIndex(columnIndex);
    }
    return columnIdentifier;
  }
  getColumnElements() {
  }
  getColumns(rowIndex, $tableElement) {
    return this._columnsController.getVisibleColumns(rowIndex);
  }
  getCell(cellPosition, rows, cells) {
    const $rows = rows || this._getRowElements();
    let $cells;
    if ($rows.length > 0 && cellPosition.rowIndex >= 0) {
      var _$cells;
      if ("virtual" !== this.option("scrolling.mode") && "virtual" !== this.option("scrolling.rowRenderingMode")) {
        cellPosition.rowIndex = cellPosition.rowIndex < $rows.length ? cellPosition.rowIndex : $rows.length - 1;
      }
      $cells = cells || this.getCellElements(cellPosition.rowIndex);
      if ((null === (_$cells = $cells) || void 0 === _$cells ? void 0 : _$cells.length) > 0) {
        return $cells.eq($cells.length > cellPosition.columnIndex ? cellPosition.columnIndex : $cells.length - 1);
      }
    }
  }
  getRowsCount() {
    const tableElement = this.getTableElement();
    if (tableElement && 1 === tableElement.length) {
      return tableElement[0].rows.length;
    }
    return 0;
  }
  _getRowElementsCore(tableElement) {
    tableElement = tableElement || this.getTableElement();
    if (tableElement) {
      const hasRowTemplate = this.option().rowTemplate || this.option("dataRowTemplate");
      const tBodies = hasRowTemplate && tableElement.find("> tbody.dx-row");
      return tBodies && tBodies.length ? tBodies : tableElement.find("> tbody > .dx-row, > .dx-row");
    }
    return renderer_default();
  }
  _getRowElements(tableElement) {
    return this._getRowElementsCore(tableElement);
  }
  getRowIndex($row) {
    return this._getRowElements().index($row);
  }
  getBoundingRect() {
  }
  getName() {
  }
  setScrollerSpacing(width) {
    const $element = this.element();
    const rtlEnabled = this.option("rtlEnabled");
    $element && $element.css({
      paddingLeft: rtlEnabled ? width : "",
      paddingRight: !rtlEnabled ? width : ""
    });
  }
  isScrollbarVisible(isHorizontal) {
    const $element = this.element();
    const $tableElement = this._tableElement;
    if ($element && $tableElement) {
      return isHorizontal ? getOuterWidth($tableElement) - getWidth($element) > 0 : getOuterHeight($tableElement) - getHeight($element) > 0;
    }
    return false;
  }
  isDisposed() {
    var _this$component;
    return null === (_this$component = this.component) || void 0 === _this$component ? void 0 : _this$component._disposed;
  }
};

// node_modules/devextreme/esm/__internal/grids/grid_core/column_headers/m_column_headers.js
var LINK = "dx-link";
var createCellContent = function(that, $cell, options2) {
  const $cellContent = renderer_default("<div>").addClass(that.addWidgetPrefix("text-content"));
  that.setAria("role", "presentation", $cellContent);
  addCssClassesToCellContent(that, $cell, options2.column, $cellContent);
  const showColumnLines = that.option("showColumnLines");
  const contentAlignment = that.getController("columns").getHeaderContentAlignment(options2.column.alignment);
  return $cellContent[showColumnLines || "right" === contentAlignment ? "appendTo" : "prependTo"]($cell);
};
function addCssClassesToCellContent(that, $cell, column, $cellContent) {
  const $indicatorElements = that._getIndicatorElements($cell, true);
  const $visibleIndicatorElements = that._getIndicatorElements($cell);
  const indicatorCount = null === $indicatorElements || void 0 === $indicatorElements ? void 0 : $indicatorElements.length;
  const columnAlignment = that._getColumnAlignment(column.alignment);
  const sortIndicatorClassName = `.${that._getIndicatorClassName("sort")}`;
  const sortIndexIndicatorClassName = `.${that._getIndicatorClassName("sortIndex")}`;
  const $sortIndicator = $visibleIndicatorElements.filter(sortIndicatorClassName);
  const $sortIndexIndicator = $visibleIndicatorElements.children().filter(sortIndexIndicatorClassName);
  $cellContent = $cellContent || $cell.children(`.${that.addWidgetPrefix("text-content")}`);
  $cellContent.toggleClass("dx-text-content-alignment-" + columnAlignment, indicatorCount > 0).toggleClass("dx-text-content-alignment-" + ("left" === columnAlignment ? "right" : "left"), indicatorCount > 0 && "center" === column.alignment).toggleClass("dx-sort-indicator", !!$sortIndicator.length).toggleClass("dx-sort-index-indicator", !!$sortIndexIndicator.length).toggleClass("dx-header-filter-indicator", !!$visibleIndicatorElements.filter(`.${that._getIndicatorClassName("headerFilter")}`).length);
}
var ColumnHeadersView = class extends ColumnContextMenuMixin(ColumnsView) {
  init() {
    super.init();
    this._headerPanelView = this.getView("headerPanel");
    this._headerFilterController = this.getController("headerFilter");
    this._dataController = this.getController("data");
    this._headersKeyboardNavigation = this.getController("headersKeyboardNavigation");
  }
  _createTable() {
    const $table = super._createTable.apply(this, arguments);
    m_events_engine_default.on($table, "mousedown selectstart", this.createAction((e) => {
      const {
        event
      } = e;
      if (event.shiftKey) {
        event.preventDefault();
      }
    }));
    return $table;
  }
  _isLegacyKeyboardNavigation() {
    return this.option("useLegacyKeyboardNavigation");
  }
  _getDefaultTemplate(column) {
    const that = this;
    return function($container, options2) {
      const {
        caption
      } = column;
      const needCellContent = !column.command || caption && "expand" !== column.command;
      if ("empty" === column.command) {
        that._renderEmptyMessage($container, options2);
      } else if (needCellContent) {
        const $content = createCellContent(that, $container, options2);
        $content.text(caption);
      } else if (column.command) {
        $container.html("&nbsp;");
      }
    };
  }
  _renderEmptyMessage($container, options2) {
    const textEmpty = this._getEmptyHeaderText();
    if (!textEmpty) {
      $container.html("&nbsp;");
      return;
    }
    const $cellContent = createCellContent(this, $container, options2);
    const needSplit = textEmpty.includes("{0}");
    if (needSplit) {
      const [leftPart, rightPart] = textEmpty.split("{0}");
      const columnChooserTitle = message_default.format("dxDataGrid-emptyHeaderColumnChooserText");
      const columnChooserView = this._columnChooserView;
      const $link = renderer_default("<a>").text(columnChooserTitle).addClass(LINK);
      m_events_engine_default.on($link, "click", this.createAction(() => columnChooserView.showColumnChooser()));
      $cellContent.append(dom_adapter_default.createTextNode(leftPart)).append($link).append(dom_adapter_default.createTextNode(rightPart));
    } else {
      $cellContent.text(textEmpty);
    }
  }
  _getEmptyHeaderText() {
    const hasHiddenColumns = !!this._columnChooserView.hasHiddenColumns();
    const hasGroupedColumns = !!this._headerPanelView.hasGroupedColumns();
    switch (true) {
      case (hasHiddenColumns && hasGroupedColumns):
        return message_default.format("dxDataGrid-emptyHeaderWithColumnChooserAndGroupPanelText");
      case hasGroupedColumns:
        return message_default.format("dxDataGrid-emptyHeaderWithGroupPanelText");
      case hasHiddenColumns:
        return message_default.format("dxDataGrid-emptyHeaderWithColumnChooserText");
      default:
        return "";
    }
  }
  _getHeaderTemplate(column) {
    return column.headerCellTemplate || {
      allowRenderToDetachedContainer: true,
      render: this._getDefaultTemplate(column)
    };
  }
  _processTemplate(template, options2) {
    const that = this;
    let resultTemplate;
    const {
      column
    } = options2;
    const renderingTemplate = super._processTemplate(template);
    if ("header" === options2.rowType && renderingTemplate && column.headerCellTemplate && !column.command) {
      resultTemplate = {
        render(options3) {
          const $content = createCellContent(that, options3.container, options3.model);
          renderingTemplate.render(extend({}, options3, {
            container: $content
          }));
        }
      };
    } else {
      resultTemplate = renderingTemplate;
    }
    return resultTemplate;
  }
  _handleDataChanged(e) {
    if ("refresh" !== e.changeType) {
      return;
    }
    if (this._isGroupingChanged || this._requireReady) {
      this._isGroupingChanged = false;
      this.render();
    }
  }
  _renderCell($row, options2) {
    const $cell = super._renderCell($row, options2);
    if ("header" === options2.row.rowType) {
      $cell.addClass("dx-cell-focus-disabled");
      if (!this._isLegacyKeyboardNavigation()) {
        const {
          column
        } = options2;
        const isCustomCommandColumn = this._columnsController.isCustomCommandColumn(column);
        if (column && (!column.type || isCustomCommandColumn)) {
          $cell.attr("tabindex", this.option("tabindex") || 0);
        }
      }
    }
    return $cell;
  }
  _setCellAriaAttributes($cell, cellOptions, options2) {
    super._setCellAriaAttributes($cell, cellOptions, options2);
    if ("header" === cellOptions.rowType) {
      if (!cellOptions.column.type) {
        this.setAria("role", "columnheader", $cell);
      }
      if (cellOptions.column && !cellOptions.column.command && !cellOptions.column.isBand) {
        $cell.attr("id", cellOptions.column.headerId);
        this.setAria("label", `${message_default.format("dxDataGrid-ariaColumn")} ${cellOptions.column.caption}`, $cell);
      }
    }
  }
  _createRow(row) {
    const $row = super._createRow.apply(this, arguments);
    $row.toggleClass("dx-column-lines", this.option("showColumnLines"));
    if ("header" === row.rowType) {
      $row.addClass("dx-header-row");
      if (!this._isLegacyKeyboardNavigation()) {
        registerKeyboardAction2("columnHeaders", this, $row, "td", this._handleActionKeyDown.bind(this));
      }
    }
    return $row;
  }
  _processHeaderAction(event, $row) {
  }
  _handleActionKeyDown(args) {
    const {
      event
    } = args;
    const $target = renderer_default(event.target);
    this._lastActionElement = event.target;
    if ($target.is(".dx-header-filter")) {
      const headerFilterController = this._headerFilterController;
      const $column = $target.closest("td");
      const columnIndex = this.getColumnIndexByElement($column);
      if (columnIndex >= 0) {
        headerFilterController.showHeaderFilterMenu(columnIndex, false);
      }
    } else {
      const $row = $target.closest(".dx-row");
      this._processHeaderAction(event, $row);
    }
    event.preventDefault();
  }
  _renderCore() {
    const $container = this.element();
    const change = {};
    if (this._tableElement && !this._dataController.isLoaded() && !this._hasRowElements) {
      return new Deferred().resolve();
    }
    $container.addClass(this.addWidgetPrefix("headers")).toggleClass(this.addWidgetPrefix("nowrap"), !this.option("wordWrapEnabled"));
    this.setAria("role", "presentation", $container);
    const deferred = this._updateContent(this._renderTable({
      change
    }), change);
    $container.toggleClass("dx-header-multi-row", this.getRowCount() > 1);
    super._renderCore.apply(this, arguments);
    return deferred;
  }
  _renderRows() {
    const that = this;
    if (that._dataController.isLoaded() || that._hasRowElements) {
      super._renderRows.apply(that, arguments);
      that._hasRowElements = true;
    }
  }
  _renderRow($table, options2) {
    const rowIndex = 1 === this.getRowCount() ? null : options2.row.rowIndex;
    options2.columns = this.getColumns(rowIndex);
    super._renderRow($table, options2);
  }
  _createCell(options2) {
    const {
      column
    } = options2;
    const $cellElement = super._createCell.apply(this, arguments);
    column.rowspan > 1 && "header" === options2.rowType && $cellElement.attr("rowSpan", column.rowspan);
    return $cellElement;
  }
  _getRows() {
    const result2 = [];
    const rowCount = this.getRowCount();
    if (this.option("showColumnHeaders")) {
      for (let i = 0; i < rowCount; i++) {
        result2.push({
          rowType: "header",
          rowIndex: i
        });
      }
    }
    return result2;
  }
  _getCellTemplate(options2) {
    if ("header" === options2.rowType) {
      return this._getHeaderTemplate(options2.column);
    }
  }
  _columnOptionChanged(e) {
    const {
      changeTypes
    } = e;
    const {
      optionNames
    } = e;
    if (changeTypes.grouping || changeTypes.groupExpanding) {
      if (changeTypes.grouping) {
        this._isGroupingChanged = true;
      }
      return;
    }
    super._columnOptionChanged(e);
    if (optionNames.width || optionNames.visible) {
      this.resizeCompleted.fire();
    }
  }
  _isElementVisible(elementOptions) {
    return null === elementOptions || void 0 === elementOptions ? void 0 : elementOptions.visible;
  }
  _alignCaptionByCenter($cell) {
    var _$indicatorsContainer;
    let $indicatorsContainer = this._getIndicatorContainer($cell, true);
    if (null !== (_$indicatorsContainer = $indicatorsContainer) && void 0 !== _$indicatorsContainer && _$indicatorsContainer.length) {
      $indicatorsContainer.filter(".dx-visibility-hidden").remove();
      $indicatorsContainer = this._getIndicatorContainer($cell);
      $indicatorsContainer.clone().addClass("dx-visibility-hidden").css("float", "").insertBefore($cell.children(`.${this.addWidgetPrefix("text-content")}`));
    }
  }
  _updateCell($cell, options2) {
    if ("header" === options2.rowType && "center" === options2.column.alignment) {
      this._alignCaptionByCenter($cell);
    }
    super._updateCell.apply(this, arguments);
  }
  _updateIndicator($cell, column, indicatorName) {
    const $indicatorElement = super._updateIndicator.apply(this, arguments);
    if ("center" === column.alignment) {
      this._alignCaptionByCenter($cell);
    }
    addCssClassesToCellContent(this, $cell, column);
    return $indicatorElement;
  }
  _getIndicatorContainer($cell, returnAll) {
    const $indicatorsContainer = super._getIndicatorContainer($cell);
    return returnAll ? $indicatorsContainer : $indicatorsContainer.filter(":not(.dx-visibility-hidden)");
  }
  _isSortableElement($target) {
    return true;
  }
  getHeadersRowHeight() {
    const $tableElement = this.getTableElement();
    const $headerRows = null === $tableElement || void 0 === $tableElement ? void 0 : $tableElement.find(".dx-header-row");
    return (null === $headerRows || void 0 === $headerRows ? void 0 : $headerRows.toArray().reduce((sum, headerRow) => sum + getHeight(headerRow), 0)) || 0;
  }
  getHeaderElement(index2) {
    const $columnElements = this.getColumnElements();
    return (null === $columnElements || void 0 === $columnElements ? void 0 : $columnElements.eq(index2)) ?? renderer_default("");
  }
  getColumnElements(index2, bandColumnIndex) {
    const that = this;
    let $cellElement;
    const columnsController = that._columnsController;
    const rowCount = that.getRowCount();
    if (that.option("showColumnHeaders")) {
      if (rowCount > 1 && (!isDefined(index2) || isDefined(bandColumnIndex))) {
        const result2 = [];
        const visibleColumns = isDefined(bandColumnIndex) ? columnsController.getChildrenByBandColumn(bandColumnIndex, true) : columnsController.getVisibleColumns();
        each(visibleColumns, (_, column) => {
          const rowIndex = isDefined(index2) ? index2 : columnsController.getRowIndex(column.index);
          $cellElement = that._getCellElement(rowIndex, columnsController.getVisibleIndex(column.index, rowIndex));
          $cellElement && result2.push($cellElement.get(0));
        });
        return renderer_default(result2);
      }
      if (!index2 || index2 < rowCount) {
        return that.getCellElements(index2 || 0);
      }
    }
    return;
  }
  getColumnIndexByElement($cell) {
    const cellIndex = this.getCellIndex($cell);
    const $row = $cell.closest(".dx-row");
    const {
      rowIndex
    } = $row[0];
    const column = this.getColumns(rowIndex)[cellIndex];
    return column ? column.index : -1;
  }
  getVisibleColumnIndex(columnIndex, rowIndex) {
    const column = this.getColumns()[columnIndex];
    return column ? this._columnsController.getVisibleIndex(column.index, rowIndex) : -1;
  }
  getColumnWidths($tableElement, rowIndex) {
    const $columnElements = this.getColumnElements(rowIndex);
    if (null !== $columnElements && void 0 !== $columnElements && $columnElements.length) {
      return this._getWidths($columnElements);
    }
    return super.getColumnWidths.apply(this, arguments);
  }
  isColumnReorderingEnabled(column) {
    return column.allowReordering && (this.option("allowColumnReordering") ?? this._columnsController.isColumnOptionUsed("allowReordering"));
  }
  allowDragging(column) {
    const rowIndex = column && this._columnsController.getRowIndex(column.index);
    const columns7 = this.getColumns(rowIndex);
    return this.isColumnReorderingEnabled(column) && columns7.length > 1;
  }
  getBoundingRect() {
    const that = this;
    const $columnElements = that.getColumnElements();
    if (null !== $columnElements && void 0 !== $columnElements && $columnElements.length) {
      const offset2 = that.getTableElement().offset();
      return {
        top: offset2.top
      };
    }
    return null;
  }
  getName() {
    return "headers";
  }
  getColumnCount() {
    const $columnElements = this.getColumnElements();
    return $columnElements ? $columnElements.length : 0;
  }
  isVisible() {
    return this.option("showColumnHeaders");
  }
  optionChanged(args) {
    const that = this;
    switch (args.name) {
      case "showColumnHeaders":
      case "wordWrapEnabled":
      case "showColumnLines":
        that._invalidate(true, true);
        args.handled = true;
        break;
      default:
        super.optionChanged(args);
    }
  }
  getHeight() {
    return this.getElementHeight();
  }
  getContextMenuItems(options2) {
    let items;
    const {
      column
    } = options2;
    if (options2.row && ("header" === options2.row.rowType || "detailAdaptive" === options2.row.rowType)) {
      const sortingOptions = this.option("sorting");
      if (sortingOptions && "none" !== sortingOptions.mode && null !== column && void 0 !== column && column.allowSorting) {
        const onItemClick = (params) => {
          setTimeout(() => {
            this._columnsController.changeSortOrder(column.index, params.itemData.value);
          });
        };
        items = [{
          text: sortingOptions.ascendingText,
          value: "asc",
          disabled: "asc" === column.sortOrder,
          icon: "context-menu-sort-asc",
          onItemClick
        }, {
          text: sortingOptions.descendingText,
          value: "desc",
          disabled: "desc" === column.sortOrder,
          icon: "context-menu-sort-desc",
          onItemClick
        }, {
          name: "clearSorting",
          text: sortingOptions.clearText,
          value: "none",
          disabled: !column.sortOrder,
          icon: "context-menu-sort-none",
          onItemClick
        }];
      }
      if ("header" === options2.row.rowType) {
        const moveColumnItems = this.getMoveColumnContextMenuItems(options2);
        if (null !== moveColumnItems && void 0 !== moveColumnItems && moveColumnItems.length) {
          items = items ?? [];
          items.push(...moveColumnItems);
        }
      }
    }
    return items;
  }
  getRowCount() {
    var _this$_columnsControl;
    return null === (_this$_columnsControl = this._columnsController) || void 0 === _this$_columnsControl ? void 0 : _this$_columnsControl.getRowCount();
  }
  toggleDraggableColumnClass(columnIndex, value2, rowIndex) {
    let i;
    let columnElements;
    const rowCount = this.getRowCount();
    const columns7 = this._columnsController.getColumns();
    const column = null === columns7 || void 0 === columns7 ? void 0 : columns7[columnIndex];
    const columnID = (null === column || void 0 === column ? void 0 : column.isBand) && column.index;
    const setColumnClass = (column2, index2) => {
      if (column2.ownerBand === columnID) {
        columnElements.eq(index2).toggleClass(this.addWidgetPrefix(CLASSES.draggableColumn), value2);
        if (column2.isBand) {
          this.toggleDraggableColumnClass(column2.index, value2, i + 1);
        }
      }
    };
    if (isDefined(columnID)) {
      rowIndex = rowIndex || 0;
      for (i = rowIndex; i < rowCount; i++) {
        columnElements = this.getCellElements(i);
        if (columnElements) {
          const rowColumns = this.getColumns(i);
          rowColumns.forEach(setColumnClass);
        }
      }
    }
  }
  isFilterRowCell($cell) {
    return false;
  }
  getKeyboardNavigationController() {
    return this._headersKeyboardNavigation;
  }
};
var columnHeadersModule = {
  defaultOptions: () => ({
    showColumnHeaders: true,
    cellHintEnabled: true
  }),
  views: {
    columnHeadersView: ColumnHeadersView
  }
};

// node_modules/devextreme/esm/__internal/grids/data_grid/m_core.js
var m_core_default = _extends({}, m_modules_default, m_utils_default, {
  modules: []
});

// node_modules/devextreme/esm/__internal/grids/data_grid/module_not_extended/column_headers.js
var ColumnHeadersView2 = columnHeadersModule.views.columnHeadersView;
m_core_default.registerModule("columnHeaders", columnHeadersModule);

// node_modules/devextreme/esm/__internal/grids/grid_core/sticky_columns/const.js
var STICKY_BORDER_WIDTH = 2;
var StickyPosition;
!function(StickyPosition2) {
  StickyPosition2.Left = "left";
  StickyPosition2.Right = "right";
  StickyPosition2.Sticky = "sticky";
}(StickyPosition || (StickyPosition = {}));
var CLASSES3 = {
  stickyColumn: "sticky-column",
  stickyColumnLeft: "sticky-column-left",
  stickyColumnRight: "sticky-column-right",
  stickyColumnBorderRight: "sticky-column-border-right",
  stickyColumnBorderLeft: "sticky-column-border-left",
  stickyColumns: "sticky-columns",
  firstHeader: "first-header",
  columnNoBorder: "column-no-border",
  groupRowContainer: "group-row-container",
  focusedFixedElement: "dx-focused-fixed-element",
  focused: "dx-focused",
  hidden: "dx-hidden"
};

// node_modules/devextreme/esm/__internal/grids/grid_core/columns_controller/const.js
var USER_STATE_FIELD_NAMES_15_1 = ["filterValues", "filterType", "fixed", "fixedPosition"];
var USER_STATE_FIELD_NAMES = ["visibleIndex", "dataField", "name", "dataType", "width", "visible", "sortOrder", "lastSortOrder", "sortIndex", "groupIndex", "filterValue", "bufferedFilterValue", "selectedFilterOperation", "bufferedSelectedFilterOperation", "added"].concat(USER_STATE_FIELD_NAMES_15_1);
var IGNORE_COLUMN_OPTION_NAMES = {
  visibleWidth: true,
  bestFitWidth: true,
  bufferedFilterValue: true
};
var COMMAND_EXPAND_CLASS2 = "dx-command-expand";
var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
var GROUP_COMMAND_COLUMN_NAME = "groupExpand";
var DETAIL_COMMAND_COLUMN_NAME = "detailExpand";
var COLUMN_OPTION_REGEXP = /columns\[(\d+)\]\.?/gi;
var DEFAULT_COLUMN_OPTIONS = {
  visible: true,
  showInColumnChooser: true
};
var DATATYPE_OPERATIONS = {
  number: ["=", "<>", "<", ">", "<=", ">=", "between"],
  string: ["contains", "notcontains", "startswith", "endswith", "=", "<>"],
  date: ["=", "<>", "<", ">", "<=", ">=", "between"],
  datetime: ["=", "<>", "<", ">", "<=", ">=", "between"]
};
var COLUMN_INDEX_OPTIONS = {
  visibleIndex: true,
  groupIndex: true,
  grouped: true,
  sortIndex: true,
  sortOrder: true
};
var GROUP_LOCATION = "group";
var COLUMN_CHOOSER_LOCATION = "columnChooser";

// node_modules/devextreme/esm/__internal/grids/grid_core/adaptivity/const.js
var HIDDEN_COLUMNS_WIDTH = "adaptiveHidden";

// node_modules/devextreme/esm/__internal/grids/grid_core/sticky_columns/utils.js
var getColumnFixedPosition = (that, column) => {
  const {
    fixedPosition
  } = column;
  const rtlEnabled = that.option("rtlEnabled");
  const isExceptionCommandColumn = column.command && "expand" === column.command;
  const isDefaultCommandColumn = column.command && !m_utils_default.isCustomCommandColumn(that._columns, column);
  if (isDefaultCommandColumn && rtlEnabled && !isExceptionCommandColumn) {
    return fixedPosition === StickyPosition.Right ? StickyPosition.Left : StickyPosition.Right;
  }
  return fixedPosition ?? StickyPosition.Left;
};
var needToDisableStickyColumn = function(that, column) {
  return that.isVirtualMode() && !!column.fixed && column.fixedPosition === StickyPosition.Sticky;
};
var processFixedColumns = function(that, columns7) {
  return columns7.map((column) => {
    if (needToDisableStickyColumn(that, column)) {
      return _extends({}, column, {
        fixed: false,
        fixedPosition: ""
      });
    }
    return column;
  });
};
var isVisibleColumn = function(that, column) {
  return column.visibleWidth !== HIDDEN_COLUMNS_WIDTH && (!column.isBand || !!that.getVisibleDataColumnsByBandColumn(column.index).length);
};
var areNextOnlyFixedOrHiddenColumns = function(that, columns7) {
  return !columns7.some((column) => !column.fixed && isVisibleColumn(that, column));
};
var getStickyOffsetCore = function(that, columns7, widths, columnIndex, fixedPosition, offsets) {
  const column = columns7[columnIndex];
  const isChildColumn = isDefined(column.ownerBand);
  const targetColumnIsRight = fixedPosition === StickyPosition.Right;
  const targetColumnIsSticky = column.fixedPosition === StickyPosition.Sticky;
  const nextOrPrevColumns = targetColumnIsRight ? columns7.slice(columnIndex + 1) : columns7.slice(0, columnIndex).reverse();
  const nextOrPrevColumnWidths = targetColumnIsRight ? widths.slice(columnIndex + 1) : widths.slice(0, columnIndex).reverse();
  let offset2 = 0;
  let adjacentStickyColumnIndex = 0;
  let nonSiblingStickyColumnCount = !areNextOnlyFixedOrHiddenColumns(that, nextOrPrevColumns) && targetColumnIsSticky && nextOrPrevColumns.length ? 1 : 0;
  nextOrPrevColumns.forEach((col, colIndex) => {
    if (col.fixed && (!isDefined(offsets) || column.ownerBand === col.ownerBand)) {
      const columnIsSticky = col.fixedPosition === StickyPosition.Sticky;
      offset2 += nextOrPrevColumnWidths[colIndex] ?? col.visibleWidth;
      if (targetColumnIsSticky && columnIsSticky && !areNextOnlyFixedOrHiddenColumns(that, nextOrPrevColumns.slice(colIndex + 1))) {
        if (colIndex !== adjacentStickyColumnIndex) {
          nonSiblingStickyColumnCount += 1;
          adjacentStickyColumnIndex = colIndex + 1;
        } else {
          adjacentStickyColumnIndex += 1;
        }
      }
    } else if (!isVisibleColumn(that, col)) {
      adjacentStickyColumnIndex += 1;
    }
  });
  if (isChildColumn && isDefined(offsets)) {
    var _offsets$column$owner;
    offset2 += (null === offsets || void 0 === offsets || null === (_offsets$column$owner = offsets[column.ownerBand]) || void 0 === _offsets$column$owner ? void 0 : _offsets$column$owner[fixedPosition]) ?? 0;
    return offset2;
  }
  return offset2 - nonSiblingStickyColumnCount * STICKY_BORDER_WIDTH;
};
var isFirstOrLastColumn = function(that, column, rowIndex) {
  let onlyWithinBandColumn = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : false;
  let isLast = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : false;
  let fixedPosition = arguments.length > 5 ? arguments[5] : void 0;
  const rtlEnabled = that.option("rtlEnabled");
  const methodName = rtlEnabled !== isLast ? "isLastColumn" : "isFirstColumn";
  if (column.fixedPosition === StickyPosition.Sticky) {
    const parentColumn = that.getParentColumn(column) ?? column;
    if (that[methodName](parentColumn, 0)) {
      return false;
    }
  }
  return that[methodName](column, rowIndex, onlyWithinBandColumn, fixedPosition);
};
var getPrevColumn = function(that, column, visibleColumns, rowIndex) {
  const visibleColumnIndex = that.getVisibleIndex(column.index, rowIndex);
  return null === visibleColumns || void 0 === visibleColumns ? void 0 : visibleColumns.slice(0, visibleColumnIndex).reverse().find((col) => isVisibleColumn(that, col));
};
var getStickyOffset = function(that, columns7, widths, columnIndex, offsets) {
  const result2 = {};
  const column = columns7[columnIndex];
  if (column) {
    const fixedPosition = getColumnFixedPosition(that, column);
    switch (fixedPosition) {
      case StickyPosition.Sticky: {
        const offsetLeft = getStickyOffsetCore(that, columns7, widths, columnIndex, StickyPosition.Left, offsets);
        const offsetRight = getStickyOffsetCore(that, columns7, widths, columnIndex, StickyPosition.Right, offsets);
        result2.left = offsetLeft;
        result2.right = offsetRight;
        break;
      }
      case StickyPosition.Right: {
        const offsetRight = getStickyOffsetCore(that, columns7, widths, columnIndex, StickyPosition.Right, offsets);
        result2.right = offsetRight;
        break;
      }
      default: {
        const offsetLeft = getStickyOffsetCore(that, columns7, widths, columnIndex, StickyPosition.Left, offsets);
        result2.left = offsetLeft;
      }
    }
  }
  return result2;
};
var needToRemoveColumnBorderCore = function(that, column, visibleColumns, rowIndex) {
  const prevColumn = getPrevColumn(that, column, visibleColumns, rowIndex);
  const columnFixedPosition = getColumnFixedPosition(that, column);
  const prevColumnFixedPosition = prevColumn && getColumnFixedPosition(that, prevColumn);
  return !!(null !== prevColumn && void 0 !== prevColumn && prevColumn.fixed) && !needToDisableStickyColumn(that, prevColumn) && (!column.fixed || columnFixedPosition === StickyPosition.Sticky || prevColumnFixedPosition === StickyPosition.Sticky);
};
var needToRemoveColumnBorder = function(that, column, rowIndex) {
  let isDataColumn = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : false;
  const visibleColumns = that.getVisibleColumns(isDataColumn ? null : rowIndex);
  const parentColumn = that.getParentColumn(column);
  if (parentColumn) {
    const isFirstColumn = that.isFirstColumn(column, rowIndex, true);
    return isFirstColumn && needToRemoveColumnBorderCore(that, parentColumn, that.getVisibleColumns(0), 0);
  }
  return needToRemoveColumnBorderCore(that, column, visibleColumns, rowIndex);
};
var normalizeOffset2 = function(offset2) {
  const styleProps = {};
  if (isDefined(offset2.left)) {
    styleProps.left = `${offset2.left}px`;
  }
  if (isDefined(offset2.right)) {
    styleProps.right = `${offset2.right}px`;
  }
  return styleProps;
};
var isFirstFixedColumn = function(that, column, rowIndex) {
  let onlyWithinBandColumn = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : false;
  let fixedPosition = arguments.length > 4 ? arguments[4] : void 0;
  return isFirstOrLastColumn(that, column, rowIndex, onlyWithinBandColumn, false, fixedPosition);
};
var isLastFixedColumn = function(that, column, rowIndex) {
  let onlyWithinBandColumn = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : false;
  let fixedPosition = arguments.length > 4 ? arguments[4] : void 0;
  return isFirstOrLastColumn(that, column, rowIndex, onlyWithinBandColumn, true, fixedPosition);
};
var isFixedEdge = function(point, column, nextColumn) {
  const isSplitPoint = isDefined(point.isLeftBoundary) || isDefined(point.isRightBoundary);
  return !isSplitPoint && !!column && !!nextColumn && column.fixed !== nextColumn.fixed;
};

// node_modules/devextreme/esm/__internal/grids/grid_core/columns_controller/m_columns_controller_utils.js
var setFilterOperationsAsDefaultValues = function(column) {
  column.filterOperations = column.defaultFilterOperations;
};
var globalColumnId = 1;
var createColumn = function(that, columnOptions, userStateColumnOptions, bandColumn) {
  let commonColumnOptions = {};
  if (columnOptions) {
    if (isString(columnOptions)) {
      columnOptions = {
        dataField: columnOptions
      };
    }
    that.setName(columnOptions);
    let result2 = {};
    if (columnOptions.command) {
      result2 = deepExtendArraySafe(commonColumnOptions, columnOptions);
    } else {
      commonColumnOptions = that.getCommonSettings(columnOptions);
      if (userStateColumnOptions && userStateColumnOptions.name && userStateColumnOptions.dataField) {
        columnOptions = extend({}, columnOptions, {
          dataField: userStateColumnOptions.dataField
        });
      }
      const calculatedColumnOptions = that._createCalculatedColumnOptions(columnOptions, bandColumn);
      if (!columnOptions.type) {
        result2 = {
          headerId: "dx-col-" + globalColumnId++
        };
      }
      result2 = deepExtendArraySafe(result2, DEFAULT_COLUMN_OPTIONS, false, true);
      deepExtendArraySafe(result2, commonColumnOptions, false, true);
      deepExtendArraySafe(result2, calculatedColumnOptions, false, true);
      deepExtendArraySafe(result2, columnOptions, false, true);
      deepExtendArraySafe(result2, {
        selector: null
      }, false, true);
    }
    if (columnOptions.filterOperations === columnOptions.defaultFilterOperations) {
      setFilterOperationsAsDefaultValues(result2);
    }
    return result2;
  }
};
var createColumnsFromOptions = function(that, columnsOptions, bandColumn, createdColumnCount) {
  let result2 = [];
  if (columnsOptions) {
    each(columnsOptions, (index2, columnOptions) => {
      const currentIndex = (createdColumnCount ?? 0) + result2.length;
      const userStateColumnOptions = that._columnsUserState && checkUserStateColumn(columnOptions, that._columnsUserState[currentIndex]) && that._columnsUserState[currentIndex];
      const column = createColumn(that, columnOptions, userStateColumnOptions, bandColumn);
      if (column) {
        if (bandColumn) {
          column.ownerBand = bandColumn;
        }
        result2.push(column);
        if (column.columns) {
          result2 = result2.concat(createColumnsFromOptions(that, column.columns, column, result2.length));
          delete column.columns;
          column.hasColumns = true;
        }
      }
    });
  }
  return result2;
};
var getParentBandColumns = function(columnIndex, columnParentByIndex) {
  const result2 = [];
  let parent = columnParentByIndex[columnIndex];
  while (parent) {
    result2.unshift(parent);
    columnIndex = parent.index;
    parent = columnParentByIndex[columnIndex];
  }
  return result2;
};
var getChildrenByBandColumn = function(columnIndex, columnChildrenByIndex, recursive) {
  let result2 = [];
  const children = columnChildrenByIndex[columnIndex];
  if (children) {
    for (let i = 0; i < children.length; i++) {
      const column = children[i];
      if (!isDefined(column.groupIndex) || column.showWhenGrouped) {
        result2.push(column);
        if (recursive && column.isBand) {
          result2 = result2.concat(getChildrenByBandColumn(column.index, columnChildrenByIndex, recursive));
        }
      }
    }
  }
  return result2;
};
var getColumnByIndexes = function(that, columnIndexes) {
  let result2;
  let columns7;
  const bandColumnsCache = that.getBandColumnsCache();
  const callbackFilter = function(column) {
    const ownerBand = result2 ? result2.index : void 0;
    return column.ownerBand === ownerBand;
  };
  if (bandColumnsCache.isPlain) {
    result2 = that._columns[columnIndexes[0]];
  } else {
    columns7 = that._columns.filter(callbackFilter);
    for (let i = 0; i < columnIndexes.length; i++) {
      result2 = columns7[columnIndexes[i]];
      if (result2) {
        columns7 = that._columns.filter(callbackFilter);
      }
    }
  }
  return result2;
};
var getColumnFullPath = function(that, column) {
  let result2 = [];
  let columns7;
  const bandColumnsCache = that.getBandColumnsCache();
  const callbackFilter = function(item) {
    return item.ownerBand === column.ownerBand;
  };
  if (bandColumnsCache.isPlain) {
    const columnIndex = that._columns.indexOf(column);
    if (columnIndex >= 0) {
      result2 = [`columns[${columnIndex}]`];
    }
  } else {
    columns7 = that._columns.filter(callbackFilter);
    while (columns7.length && -1 !== columns7.indexOf(column)) {
      result2.unshift(`columns[${columns7.indexOf(column)}]`);
      column = bandColumnsCache.columnParentByIndex[column.index];
      columns7 = column ? that._columns.filter(callbackFilter) : [];
    }
  }
  return result2.join(".");
};
var calculateColspan = function(that, columnID) {
  let colspan = 0;
  const columns7 = that.getChildrenByBandColumn(columnID, true);
  each(columns7, (_, column) => {
    if (column.isBand) {
      column.colspan = column.colspan || calculateColspan(that, column.index);
      colspan += column.colspan || 1;
    } else {
      colspan += 1;
    }
  });
  return colspan;
};
var processBandColumns = function(that, columns7, bandColumnsCache) {
  let rowspan;
  for (let i = 0; i < columns7.length; i++) {
    const column = columns7[i];
    if (column.visible || column.command) {
      if (column.isBand) {
        column.colspan = column.colspan || calculateColspan(that, column.index);
      }
      if (!column.isBand || !column.colspan) {
        rowspan = that.getRowCount();
        if (!column.command && (!isDefined(column.groupIndex) || column.showWhenGrouped)) {
          rowspan -= getParentBandColumns(column.index, bandColumnsCache.columnParentByIndex).length;
        }
        if (rowspan > 1) {
          column.rowspan = rowspan;
        }
      }
    }
  }
};
var getValueDataType = function(value2) {
  let dataType = type(value2);
  if ("string" !== dataType && "boolean" !== dataType && "number" !== dataType && "date" !== dataType && "object" !== dataType) {
    dataType = void 0;
  }
  return dataType;
};
var getSerializationFormat = function(dataType, value2) {
  switch (dataType) {
    case "date":
    case "datetime":
      return date_serialization_default.getDateSerializationFormat(value2);
    case "number":
      if (isString(value2)) {
        return "string";
      }
      if (isNumeric(value2)) {
        return null;
      }
  }
};
var updateSerializers = function(options2, dataType) {
  if (!options2.deserializeValue) {
    if (m_utils_default.isDateType(dataType)) {
      options2.deserializeValue = function(value2) {
        return date_serialization_default.deserializeDate(value2);
      };
      options2.serializeValue = function(value2) {
        return isString(value2) ? value2 : date_serialization_default.serializeDate(value2, this.serializationFormat);
      };
    }
    if ("number" === dataType) {
      options2.deserializeValue = function(value2) {
        const parsedValue = parseFloat(value2);
        return isNaN(parsedValue) ? value2 : parsedValue;
      };
      options2.serializeValue = function(value2, target) {
        if ("filter" === target) {
          return value2;
        }
        return isDefined(value2) && "string" === this.serializationFormat ? value2.toString() : value2;
      };
    }
  }
};
var getAlignmentByDataType = function(dataType, isRTL) {
  switch (dataType) {
    case "number":
      return "right";
    case "boolean":
      return "center";
    default:
      return getDefaultAlignment(isRTL);
  }
};
var customizeTextForBooleanDataType = function(e) {
  if (true === e.value) {
    return this.trueText || "true";
  }
  if (false === e.value) {
    return this.falseText || "false";
  }
  return e.valueText || "";
};
var getCustomizeTextByDataType = function(dataType) {
  if ("boolean" === dataType) {
    return customizeTextForBooleanDataType;
  }
};
var createColumnsFromDataSource = function(that, dataSource) {
  const firstItems = that._getFirstItems(dataSource);
  let fieldName;
  const processedFields = {};
  const result2 = [];
  for (let i = 0; i < firstItems.length; i++) {
    if (firstItems[i]) {
      for (fieldName in firstItems[i]) {
        if (!isFunction(firstItems[i][fieldName]) || variable_wrapper_default.isWrapped(firstItems[i][fieldName])) {
          processedFields[fieldName] = true;
        }
      }
    }
  }
  for (fieldName in processedFields) {
    if (0 !== fieldName.indexOf("__")) {
      const column = createColumn(that, fieldName);
      result2.push(column);
    }
  }
  return result2;
};
var updateColumnIndexes = function(that) {
  each(that._columns, (index2, column) => {
    column.index = index2;
  });
  each(that._columns, (index2, column) => {
    if (isObject(column.ownerBand)) {
      column.ownerBand = column.ownerBand.index;
    }
  });
  each(that._commandColumns, (index2, column) => {
    column.index = -(index2 + 1);
  });
};
var updateColumnGroupIndexes = function(that, currentColumn) {
  normalizeIndexes(that._columns, "groupIndex", currentColumn, (column) => {
    const {
      grouped
    } = column;
    delete column.grouped;
    return grouped;
  });
};
var updateColumnSortIndexes = function(that, currentColumn) {
  each(that._columns, (index2, column) => {
    if (isDefined(column.sortIndex) && !isSortOrderValid(column.sortOrder)) {
      delete column.sortIndex;
    }
  });
  normalizeIndexes(that._columns, "sortIndex", currentColumn, (column) => !isDefined(column.groupIndex) && isSortOrderValid(column.sortOrder));
};
var updateColumnVisibleIndexes = function(that, currentColumn) {
  let column;
  const result2 = [];
  const bandColumnsCache = that.getBandColumnsCache();
  const bandedColumns = [];
  const columns7 = that._columns.filter((column2) => !column2.command);
  for (let i = 0; i < columns7.length; i++) {
    column = columns7[i];
    const parentBandColumns = getParentBandColumns(i, bandColumnsCache.columnParentByIndex);
    if (parentBandColumns.length) {
      bandedColumns.push(column);
    } else {
      result2.push(column);
    }
  }
  normalizeIndexes(bandedColumns, "visibleIndex", currentColumn);
  normalizeIndexes(result2, "visibleIndex", currentColumn);
};
var getColumnIndexByVisibleIndex = function(that, visibleIndex, location) {
  const rowIndex = isObject(visibleIndex) ? visibleIndex.rowIndex : null;
  const columns7 = location === GROUP_LOCATION ? that.getGroupColumns() : location === COLUMN_CHOOSER_LOCATION ? that.getChooserColumns() : that.getVisibleColumns(rowIndex, true);
  let column;
  visibleIndex = isObject(visibleIndex) ? visibleIndex.columnIndex : visibleIndex;
  column = columns7[visibleIndex];
  if (column && column.type === GROUP_COMMAND_COLUMN_NAME) {
    column = that._columns.filter((col) => column.type === col.type)[0] || column;
  }
  return column && isDefined(column.index) ? column.index : -1;
};
var moveColumnToGroup = function(that, column, groupIndex) {
  const groupColumns = that.getGroupColumns();
  let i;
  if (groupIndex >= 0) {
    for (i = 0; i < groupColumns.length; i++) {
      if (groupColumns[i].groupIndex >= groupIndex) {
        groupColumns[i].groupIndex++;
      }
    }
  } else {
    groupIndex = 0;
    for (i = 0; i < groupColumns.length; i++) {
      groupIndex = Math.max(groupIndex, groupColumns[i].groupIndex + 1);
    }
  }
  return groupIndex;
};
function checkUserStateColumn(column, userStateColumn) {
  return column && userStateColumn && userStateColumn.name === (column.name || column.dataField) && (userStateColumn.dataField === column.dataField || column.name);
}
var applyUserState = function(that) {
  const columnsUserState = that._columnsUserState;
  const ignoreColumnOptionNames = that._ignoreColumnOptionNames || [];
  const columns7 = that._columns;
  const columnCountById = {};
  let resultColumns = [];
  let allColumnsHaveState = true;
  const userStateColumnIndexes = [];
  let column;
  let userStateColumnIndex;
  let i;
  function applyFieldsState(column2, userStateColumn) {
    if (!userStateColumn) {
      return;
    }
    for (let index2 = 0; index2 < USER_STATE_FIELD_NAMES.length; index2++) {
      const fieldName = USER_STATE_FIELD_NAMES[index2];
      if (ignoreColumnOptionNames.includes(fieldName)) {
        continue;
      }
      if ("dataType" === fieldName) {
        column2[fieldName] = column2[fieldName] || userStateColumn[fieldName];
      } else if (USER_STATE_FIELD_NAMES_15_1.includes(fieldName)) {
        if (fieldName in userStateColumn) {
          column2[fieldName] = userStateColumn[fieldName];
        }
      } else {
        if ("selectedFilterOperation" === fieldName && userStateColumn[fieldName]) {
          column2.defaultSelectedFilterOperation = column2[fieldName] || null;
        }
        column2[fieldName] = userStateColumn[fieldName];
      }
    }
  }
  function findUserStateColumn(columnsUserState2, column2) {
    const id = column2.name || column2.dataField;
    let count = columnCountById[id] || 0;
    for (let j = 0; j < columnsUserState2.length; j++) {
      if (checkUserStateColumn(column2, columnsUserState2[j])) {
        if (count) {
          count--;
        } else {
          columnCountById[id] = columnCountById[id] || 0;
          columnCountById[id]++;
          return j;
        }
      }
    }
    return -1;
  }
  if (columnsUserState) {
    for (i = 0; i < columns7.length; i++) {
      userStateColumnIndex = findUserStateColumn(columnsUserState, columns7[i]);
      allColumnsHaveState = allColumnsHaveState && userStateColumnIndex >= 0;
      userStateColumnIndexes.push(userStateColumnIndex);
    }
    for (i = 0; i < columns7.length; i++) {
      column = columns7[i];
      userStateColumnIndex = userStateColumnIndexes[i];
      if (that._hasUserState || allColumnsHaveState) {
        applyFieldsState(column, columnsUserState[userStateColumnIndex]);
      }
      if (userStateColumnIndex >= 0 && isDefined(columnsUserState[userStateColumnIndex].initialIndex)) {
        resultColumns[userStateColumnIndex] = column;
      } else {
        resultColumns.push(column);
      }
    }
    let hasAddedBands = false;
    for (i = 0; i < columnsUserState.length; i++) {
      const columnUserState = columnsUserState[i];
      if (columnUserState.added && findUserStateColumn(columns7, columnUserState) < 0) {
        column = createColumn(that, columnUserState.added);
        applyFieldsState(column, columnUserState);
        resultColumns.push(column);
        if (columnUserState.added.columns) {
          hasAddedBands = true;
        }
      }
    }
    if (hasAddedBands) {
      updateColumnIndexes(that);
      resultColumns = createColumnsFromOptions(that, resultColumns);
    }
    assignColumns(that, resultColumns);
  }
};
var updateIndexes = function(that, column) {
  updateColumnIndexes(that);
  updateColumnGroupIndexes(that, column);
  updateColumnSortIndexes(that, column);
  resetBandColumnsCache(that);
  updateColumnVisibleIndexes(that, column);
};
var resetColumnsCache = function(that) {
  that.resetColumnsCache();
};
function assignColumns(that, columns7) {
  that._previousColumns = that._columns;
  that._columns = columns7;
  resetColumnsCache(that);
  that.updateColumnDataTypes();
}
var updateColumnChanges = function(that, changeType, optionName, columnIndex) {
  const columnChanges = that._columnChanges || {
    optionNames: {
      length: 0
    },
    changeTypes: {
      length: 0
    },
    columnIndex
  };
  optionName = optionName || "all";
  optionName = optionName.split(".")[0];
  const {
    changeTypes
  } = columnChanges;
  if (changeType && !changeTypes[changeType]) {
    changeTypes[changeType] = true;
    changeTypes.length++;
  }
  const {
    optionNames
  } = columnChanges;
  if (optionName && !optionNames[optionName]) {
    optionNames[optionName] = true;
    optionNames.length++;
  }
  if (void 0 === columnIndex || columnIndex !== columnChanges.columnIndex) {
    if (isDefined(columnIndex)) {
      columnChanges.columnIndices ?? (columnChanges.columnIndices = []);
      if (isDefined(columnChanges.columnIndex)) {
        columnChanges.columnIndices.push(columnChanges.columnIndex);
      }
      columnChanges.columnIndices.push(columnIndex);
    }
    delete columnChanges.columnIndex;
  }
  that._columnChanges = columnChanges;
  resetColumnsCache(that);
};
var fireColumnsChanged = function(that) {
  const onColumnsChanging = that.option("onColumnsChanging");
  const columnChanges = that._columnChanges;
  const reinitOptionNames = ["dataField", "lookup", "dataType", "columns"];
  if (that.isInitialized() && !that._updateLockCount && columnChanges) {
    if (onColumnsChanging) {
      that._updateLockCount++;
      onColumnsChanging(extend({
        component: that.component
      }, columnChanges));
      that._updateLockCount--;
    }
    that._columnChanges = void 0;
    if (options2 = columnChanges.optionNames, options2 && reinitOptionNames.some((name2) => options2[name2])) {
      that._reinitAfterLookupChanges = null === columnChanges || void 0 === columnChanges ? void 0 : columnChanges.optionNames.lookup;
      that.reinit();
      that._reinitAfterLookupChanges = void 0;
    } else {
      that.columnsChanged.fire(columnChanges);
    }
  }
  var options2;
};
var updateSortOrderWhenGrouping = function(that, column, groupIndex, prevGroupIndex) {
  const columnWasGrouped = prevGroupIndex >= 0;
  if (groupIndex >= 0) {
    if (!columnWasGrouped) {
      column.lastSortOrder = column.sortOrder;
    }
  } else {
    const sortMode = that.option("sorting.mode");
    let sortOrder = column.lastSortOrder;
    if ("single" === sortMode) {
      const sortedByAnotherColumn = that._columns.some((col) => col !== column && isDefined(col.sortIndex));
      if (sortedByAnotherColumn) {
        sortOrder = void 0;
      }
    }
    column.sortOrder = sortOrder;
  }
};
var fireOptionChanged = function(that, options2) {
  const {
    value: value2
  } = options2;
  const {
    optionName
  } = options2;
  const {
    prevValue
  } = options2;
  const {
    fullOptionName
  } = options2;
  const fullOptionPath = `${fullOptionName}.${optionName}`;
  if (!IGNORE_COLUMN_OPTION_NAMES[optionName] && that._skipProcessingColumnsChange !== fullOptionPath) {
    that._skipProcessingColumnsChange = fullOptionPath;
    that.component._notifyOptionChanged(fullOptionPath, value2, prevValue);
    that._skipProcessingColumnsChange = false;
  }
};
var columnOptionCore = function(that, column, optionName, value2, notFireEvent) {
  const optionGetter = compileGetter(optionName);
  const columnIndex = column.index;
  let columns7;
  let changeType;
  let initialColumn;
  if (3 === arguments.length) {
    return optionGetter(column, {
      functionsAsIs: true
    });
  }
  const prevValue = optionGetter(column, {
    functionsAsIs: true
  });
  if (!equalByValue(prevValue, value2, {
    maxDepth: 5
  })) {
    if ("groupIndex" === optionName || "calculateGroupValue" === optionName) {
      changeType = "grouping";
      updateSortOrderWhenGrouping(that, column, value2, prevValue);
    } else if ("sortIndex" === optionName || "sortOrder" === optionName || "calculateSortValue" === optionName) {
      changeType = "sorting";
    } else {
      changeType = "columns";
    }
    const optionSetter = compileSetter(optionName);
    optionSetter(column, value2, {
      functionsAsIs: true
    });
    const fullOptionName = getColumnFullPath(that, column);
    if (COLUMN_INDEX_OPTIONS[optionName]) {
      updateIndexes(that, column);
      value2 = optionGetter(column);
    }
    if ("name" === optionName || "allowEditing" === optionName) {
      that._checkColumns();
    }
    if (!isDefined(prevValue) && !isDefined(value2) && 0 !== optionName.indexOf("buffer") && false !== notFireEvent) {
      notFireEvent = true;
    }
    if (!notFireEvent) {
      if (!USER_STATE_FIELD_NAMES.includes(optionName) && "visibleWidth" !== optionName) {
        columns7 = that.option("columns");
        initialColumn = that.getColumnByPath(fullOptionName, columns7);
        if (isString(initialColumn)) {
          initialColumn = columns7[columnIndex] = {
            dataField: initialColumn
          };
        }
        if (initialColumn && checkUserStateColumn(initialColumn, column)) {
          optionSetter(initialColumn, value2, {
            functionsAsIs: true
          });
        }
      }
      updateColumnChanges(that, changeType, optionName, columnIndex);
    } else {
      resetColumnsCache(that);
    }
    fullOptionName && fireOptionChanged(that, {
      fullOptionName,
      optionName,
      value: value2,
      prevValue
    });
  }
};
function isSortOrderValid(sortOrder) {
  return "asc" === sortOrder || "desc" === sortOrder;
}
var addExpandColumn = function(that) {
  const options2 = that._getExpandColumnOptions();
  that.addCommandColumn(options2);
};
var defaultSetCellValue = function(data17, value2) {
  if (!this.dataField) {
    return;
  }
  const path = this.dataField.split(".");
  const dotCount = path.length - 1;
  if (this.serializeValue) {
    value2 = this.serializeValue(value2);
  }
  for (let i = 0; i < dotCount; i++) {
    const name2 = path[i];
    data17 = data17[name2] = data17[name2] || {};
  }
  data17[path[dotCount]] = value2;
};
var getDataColumns = function(columns7, rowIndex, bandColumnID) {
  const result2 = [];
  rowIndex = rowIndex || 0;
  columns7[rowIndex] && each(columns7[rowIndex], (_, column) => {
    if (column.ownerBand === bandColumnID || column.type === GROUP_COMMAND_COLUMN_NAME) {
      if (!column.isBand || !column.colspan) {
        if (!column.command || rowIndex < 1) {
          result2.push(column);
        }
      } else {
        result2.push.apply(result2, getDataColumns(columns7, rowIndex + 1, column.index));
      }
    }
  });
  return result2;
};
var getRowCount = function(that) {
  let rowCount = 1;
  const bandColumnsCache = that.getBandColumnsCache();
  const {
    columnParentByIndex
  } = bandColumnsCache;
  that._columns.forEach((column) => {
    const parents = getParentBandColumns(column.index, columnParentByIndex);
    const invisibleParents = parents.filter((column2) => !column2.visible);
    if (column.visible && !invisibleParents.length) {
      rowCount = Math.max(rowCount, parents.length + 1);
    }
  });
  return rowCount;
};
var getFixedPosition = function(that, column) {
  const rtlEnabled = that.option("rtlEnabled");
  if (column.command && !m_utils_default.isCustomCommandColumn(that._columns, column) || !column.fixedPosition) {
    return rtlEnabled ? "right" : "left";
  }
  return column.fixedPosition;
};
var processExpandColumns = function(columns7, expandColumns, type2, columnIndex) {
  let customColumnIndex;
  const rowCount = this.getRowCount();
  let rowspan = columns7[columnIndex] && columns7[columnIndex].rowspan;
  let expandColumnsByType = expandColumns.filter((column) => column.type === type2);
  columns7.forEach((column, index2) => {
    if (column.type === type2) {
      customColumnIndex = index2;
      rowspan = columns7[index2 + 1] ? columns7[index2 + 1].rowspan : rowCount;
    }
  });
  if (rowspan > 1) {
    expandColumnsByType = map(expandColumnsByType, (expandColumn) => extend({}, expandColumn, {
      rowspan
    }));
  }
  expandColumnsByType.unshift.apply(expandColumnsByType, isDefined(customColumnIndex) ? [customColumnIndex, 1] : [columnIndex, 0]);
  columns7.splice.apply(columns7, expandColumnsByType);
  return rowspan || 1;
};
var digitsCount = function(number) {
  let i;
  for (i = 0; number > 1; i++) {
    number /= 10;
  }
  return i;
};
var numberToString = function(number, digitsCount2) {
  let str = number ? number.toString() : "0";
  while (str.length < digitsCount2) {
    str = `0${str}`;
  }
  return str;
};
var mergeColumns = (that, columns7, commandColumns, needToExtend) => {
  let column;
  let commandColumnIndex;
  let result2 = columns7.slice().map((column2) => extend({}, column2));
  const isColumnFixing = that._isColumnFixing();
  let defaultCommandColumns = commandColumns.slice().map((column2) => extend({
    fixed: isColumnFixing
  }, column2));
  const getCommandColumnIndex = (column2) => commandColumns.reduce((result3, commandColumn, index2) => {
    const columnType = needToExtend && column2.type === GROUP_COMMAND_COLUMN_NAME ? "expand" : column2.type;
    return commandColumn.type === columnType || commandColumn.command === column2.command ? index2 : result3;
  }, -1);
  const callbackFilter = (commandColumn) => commandColumn.command !== commandColumns[commandColumnIndex].command;
  for (let i = 0; i < columns7.length; i++) {
    column = columns7[i];
    commandColumnIndex = column && (column.type || column.command) ? getCommandColumnIndex(column) : -1;
    if (commandColumnIndex >= 0) {
      if (needToExtend) {
        result2[i] = extend({
          fixed: isColumnFixing
        }, commandColumns[commandColumnIndex], column);
        if (column.type !== GROUP_COMMAND_COLUMN_NAME) {
          defaultCommandColumns = defaultCommandColumns.filter(callbackFilter);
        }
      } else {
        const columnOptions = {
          visibleIndex: column.visibleIndex,
          index: column.index,
          headerId: column.headerId,
          allowFixing: 0 === column.groupIndex,
          allowReordering: 0 === column.groupIndex,
          groupIndex: column.groupIndex
        };
        result2[i] = extend({}, column, commandColumns[commandColumnIndex], column.type === GROUP_COMMAND_COLUMN_NAME && columnOptions);
      }
    }
  }
  if (columns7.length && needToExtend && defaultCommandColumns.length) {
    result2 = result2.concat(defaultCommandColumns);
  }
  return result2;
};
var isColumnFixed = (that, column) => isDefined(column.fixed) || !column.type ? column.fixed && column.fixedPosition !== StickyPosition.Sticky : that._isColumnFixing();
var convertOwnerBandToColumnReference = (columns7) => {
  columns7.forEach((column) => {
    if (isDefined(column.ownerBand)) {
      column.ownerBand = columns7[column.ownerBand];
    }
  });
};
var resetBandColumnsCache = (that) => {
  that._bandColumnsCache = void 0;
};
var findColumn = (columns7, identifier) => {
  const identifierOptionName = isString(identifier) && identifier.substr(0, identifier.indexOf(":"));
  let column;
  if (void 0 === identifier) {
    return;
  }
  if (identifierOptionName) {
    identifier = identifier.substr(identifierOptionName.length + 1);
  }
  if (identifierOptionName) {
    column = columns7.filter((column2) => `${column2[identifierOptionName]}` === identifier)[0];
  } else {
    ["index", "name", "dataField", "caption"].some((optionName) => {
      column = columns7.filter((column2) => column2[optionName] === identifier)[0];
      return !!column;
    });
  }
  return column;
};
var sortColumns = (columns7, sortOrder) => {
  if ("asc" !== sortOrder && "desc" !== sortOrder) {
    return columns7;
  }
  const sign2 = "asc" === sortOrder ? 1 : -1;
  columns7.sort((column1, column2) => {
    const caption1 = column1.caption || "";
    const caption2 = column2.caption || "";
    return sign2 * caption1.localeCompare(caption2);
  });
  return columns7;
};
var strictParseNumber = function(text, format2) {
  const parsedValue = number_default2.parse(text);
  if (isNumeric(parsedValue)) {
    const formattedValue = number_default2.format(parsedValue, format2);
    const formattedValueWithDefaultFormat = number_default2.format(parsedValue, "decimal");
    if (formattedValue === text || formattedValueWithDefaultFormat === text) {
      return parsedValue;
    }
  }
};
var isFirstOrLastBandColumn = function(that, bandColumns) {
  let onlyWithinBandColumn = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : false;
  let isLast = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : false;
  let fixedPosition = arguments.length > 4 ? arguments[4] : void 0;
  return bandColumns.every((column, index2) => onlyWithinBandColumn && 0 === index2 || isFirstOrLastColumnCore(that, column, index2, onlyWithinBandColumn, isLast, fixedPosition));
};
var isFirstOrLastColumnCore = function(that, column, rowIndex) {
  var _columns, _columns$;
  let onlyWithinBandColumn = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : false;
  let isLast = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : false;
  let fixedPosition = arguments.length > 5 ? arguments[5] : void 0;
  const columnIndex = column.index;
  const columns7 = (index2 = rowIndex, that.getVisibleColumns(index2).filter((col) => {
    let res = true;
    if (col.visibleWidth === HIDDEN_COLUMNS_WIDTH) {
      return false;
    }
    if (onlyWithinBandColumn && column) {
      res && (res = col.ownerBand === column.ownerBand);
    } else if (fixedPosition) {
      res && (res = col.fixed && getColumnFixedPosition(that, col) === fixedPosition);
    }
    return res;
  }));
  var index2;
  const visibleColumnIndex = that.getVisibleIndex(columnIndex, rowIndex);
  return isLast ? visibleColumnIndex === that.getVisibleIndex(null === (_columns = columns7[columns7.length - 1]) || void 0 === _columns ? void 0 : _columns.index, rowIndex) : visibleColumnIndex === that.getVisibleIndex(null === (_columns$ = columns7[0]) || void 0 === _columns$ ? void 0 : _columns$.index, rowIndex);
};
var isFirstOrLastColumn2 = function(that, targetColumn, rowIndex) {
  let onlyWithinBandColumn = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : false;
  let isLast = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : false;
  let fixedPosition = arguments.length > 5 ? arguments[5] : void 0;
  const targetColumnIndex = targetColumn.index;
  const bandColumnsCache = that.getBandColumnsCache();
  const parentBandColumns = getParentBandColumns(targetColumnIndex, bandColumnsCache.columnParentByIndex);
  if (null !== parentBandColumns && void 0 !== parentBandColumns && parentBandColumns.length) {
    return isFirstOrLastBandColumn(that, parentBandColumns.concat([targetColumn]), onlyWithinBandColumn, isLast, fixedPosition);
  }
  return onlyWithinBandColumn || isFirstOrLastColumnCore(that, targetColumn, rowIndex, onlyWithinBandColumn, isLast, fixedPosition);
};

// node_modules/devextreme/esm/__internal/grids/grid_core/columns_controller/m_columns_controller.js
var ColumnsController = class extends m_modules_default.Controller {
  init(isApplyingUserState) {
    this._dataController = this.getController("data");
    this._focusController = this.getController("focus");
    this._stateStoringController = this.getController("stateStoring");
    const columns7 = this.option("columns");
    this._commandColumns = this._commandColumns || [];
    this._columns = this._columns || [];
    this._isColumnsFromOptions = !!columns7;
    if (this._isColumnsFromOptions) {
      assignColumns(this, columns7 ? createColumnsFromOptions(this, columns7) : []);
      applyUserState(this);
    } else {
      assignColumns(this, this._columnsUserState ? createColumnsFromOptions(this, this._columnsUserState) : this._columns);
    }
    addExpandColumn(this);
    if (this._dataSourceApplied) {
      this.applyDataSource(this._dataSource, true, isApplyingUserState);
    } else {
      updateIndexes(this);
    }
    this._checkColumns();
  }
  _getExpandColumnOptions() {
    return {
      type: "expand",
      command: "expand",
      width: "auto",
      cssClass: COMMAND_EXPAND_CLASS2,
      allowEditing: false,
      allowGrouping: false,
      allowSorting: false,
      allowResizing: false,
      allowReordering: false,
      allowHiding: false
    };
  }
  _getFirstItems(dataSource) {
    let groupsCount;
    let items = [];
    const getFirstItemsCore = function(items2, groupsCount2) {
      if (!items2 || !groupsCount2) {
        return items2;
      }
      for (let i = 0; i < items2.length; i++) {
        const childItems = getFirstItemsCore(items2[i].items || items2[i].collapsedItems, groupsCount2 - 1);
        if (childItems && childItems.length) {
          return childItems;
        }
      }
    };
    if (dataSource && dataSource.items().length > 0) {
      groupsCount = m_utils_default.normalizeSortingInfo(dataSource.group()).length;
      items = getFirstItemsCore(dataSource.items(), groupsCount) || [];
    }
    return items;
  }
  _endUpdateCore() {
    !this._skipProcessingColumnsChange && fireColumnsChanged(this);
  }
  callbackNames() {
    return ["columnsChanged"];
  }
  getColumnByPath(path, columns7) {
    const that = this;
    let column;
    const columnIndexes = [];
    path.replace(COLUMN_OPTION_REGEXP, (_, columnIndex) => {
      columnIndexes.push(parseInt(columnIndex));
      return "";
    });
    if (columnIndexes.length) {
      if (columns7) {
        column = columnIndexes.reduce((column2, index2) => column2 && column2.columns && column2.columns[index2], {
          columns: columns7
        });
      } else {
        column = getColumnByIndexes(that, columnIndexes);
      }
    }
    return column;
  }
  optionChanged(args) {
    let needUpdateRequireResize;
    switch (args.name) {
      case "adaptColumnWidthByRatio":
        args.handled = true;
        break;
      case "dataSource":
        if (args.value !== args.previousValue && !this.option("columns") && (!Array.isArray(args.value) || !Array.isArray(args.previousValue))) {
          this._columns = [];
        }
        break;
      case "columns":
        needUpdateRequireResize = this._skipProcessingColumnsChange;
        args.handled = true;
        if (!this._skipProcessingColumnsChange) {
          if (args.name === args.fullName) {
            this._columnsUserState = null;
            this._ignoreColumnOptionNames = null;
            this.init();
          } else {
            this._columnOptionChanged(args);
            needUpdateRequireResize = true;
          }
        }
        if (needUpdateRequireResize) {
          this._updateRequireResize(args);
        }
        break;
      case "commonColumnSettings":
      case "columnAutoWidth":
      case "allowColumnResizing":
      case "allowColumnReordering":
      case "columnFixing":
      case "grouping":
      case "groupPanel":
      case "regenerateColumnsByVisibleItems":
      case "customizeColumns":
      case "columnHidingEnabled":
      case "dateSerializationFormat":
      case "columnResizingMode":
      case "columnMinWidth":
      case "columnWidth": {
        args.handled = true;
        const ignoreColumnOptionNames = "columnWidth" === args.fullName && ["width"];
        this.reinit(ignoreColumnOptionNames);
        break;
      }
      case "rtlEnabled":
        this.reinit();
        break;
      default:
        super.optionChanged(args);
    }
  }
  _columnOptionChanged(args) {
    let columnOptionValue = {};
    const column = this.getColumnByPath(args.fullName);
    const columnOptionName = args.fullName.replace(COLUMN_OPTION_REGEXP, "");
    if (column) {
      if (columnOptionName) {
        columnOptionValue[columnOptionName] = args.value;
      } else {
        columnOptionValue = args.value;
      }
      this._skipProcessingColumnsChange = args.fullName;
      this.columnOption(column.index, columnOptionValue);
      this._skipProcessingColumnsChange = false;
    }
  }
  _updateRequireResize(args) {
    const {
      component
    } = this;
    if ("width" === args.fullName.replace(COLUMN_OPTION_REGEXP, "") && component._updateLockCount) {
      component._requireResize = true;
    }
  }
  publicMethods() {
    return ["addColumn", "deleteColumn", "columnOption", "columnCount", "clearSorting", "clearGrouping", "getVisibleColumns", "getVisibleColumnIndex", "getColumns"];
  }
  applyDataSource(dataSource, forceApplying, isApplyingUserState) {
    const that = this;
    const isDataSourceLoaded = dataSource && dataSource.isLoaded();
    that._dataSource = dataSource;
    if (!that._dataSourceApplied || 0 === that._dataSourceColumnsCount || forceApplying || that.option("regenerateColumnsByVisibleItems")) {
      if (isDataSourceLoaded) {
        if (!that._isColumnsFromOptions) {
          const columnsFromDataSource = createColumnsFromDataSource(that, dataSource);
          if (columnsFromDataSource.length) {
            assignColumns(that, columnsFromDataSource);
            that._dataSourceColumnsCount = that._columns.length;
            applyUserState(that);
          }
        }
        return that.updateColumns(dataSource, forceApplying, isApplyingUserState);
      }
      that._dataSourceApplied = false;
      updateIndexes(that);
    } else if (isDataSourceLoaded && !that.isAllDataTypesDefined(true) && that.updateColumnDataTypes(dataSource)) {
      updateColumnChanges(that, "columns");
      fireColumnsChanged(that);
      return new Deferred().reject().promise();
    }
  }
  reset() {
    this._dataSource = null;
    this._dataSourceApplied = false;
    this._dataSourceColumnsCount = void 0;
    this.reinit();
  }
  resetColumnsCache() {
    this._visibleColumns = void 0;
    this._fixedColumns = void 0;
    this._rowCount = void 0;
    resetBandColumnsCache(this);
  }
  reinit(ignoreColumnOptionNames) {
    this._columnsUserState = this.getUserState();
    this._ignoreColumnOptionNames = ignoreColumnOptionNames || null;
    this.init();
    if (ignoreColumnOptionNames) {
      this._ignoreColumnOptionNames = null;
    }
  }
  isInitialized() {
    return !!this._columns.length || !!this.option("columns");
  }
  isDataSourceApplied() {
    return this._dataSourceApplied;
  }
  getCommonSettings(column) {
    const commonColumnSettings = (!column || !column.type) && this.option("commonColumnSettings") || {};
    const groupingOptions = this.option("grouping") ?? {};
    const groupPanelOptions = this.option("groupPanel") ?? {};
    return extend({
      allowFixing: this.option("columnFixing.enabled"),
      allowResizing: this.option("allowColumnResizing") || void 0,
      allowReordering: this.option("allowColumnReordering"),
      minWidth: this.option("columnMinWidth"),
      width: this.option("columnWidth"),
      autoExpandGroup: groupingOptions.autoExpandAll,
      allowCollapsing: groupingOptions.allowCollapsing,
      allowGrouping: groupPanelOptions.allowColumnDragging && groupPanelOptions.visible || groupingOptions.contextMenuEnabled
    }, commonColumnSettings);
  }
  isColumnOptionUsed(optionName) {
    for (let i = 0; i < this._columns.length; i++) {
      if (this._columns[i][optionName]) {
        return true;
      }
    }
  }
  isAllDataTypesDefined(checkSerializers) {
    const columns7 = this._columns;
    if (!columns7.length) {
      return false;
    }
    for (let i = 0; i < columns7.length; i++) {
      if (!columns7[i].dataField && columns7[i].calculateCellValue === columns7[i].defaultCalculateCellValue) {
        continue;
      }
      if (!columns7[i].dataType || checkSerializers && columns7[i].deserializeValue && void 0 === columns7[i].serializationFormat) {
        return false;
      }
    }
    return true;
  }
  getColumns() {
    return this._columns;
  }
  isBandColumnsUsed() {
    return this.getColumns().some((column) => column.isBand);
  }
  getGroupColumns() {
    const result2 = [];
    each(this._columns, function() {
      const column = this;
      if (isDefined(column.groupIndex)) {
        result2[column.groupIndex] = column;
      }
    });
    return result2;
  }
  _shouldReturnVisibleColumns() {
    return true;
  }
  _compileVisibleColumns(rowIndex) {
    this._visibleColumns = this._visibleColumns || this._compileVisibleColumnsCore();
    rowIndex = isDefined(rowIndex) ? rowIndex : this._visibleColumns.length - 1;
    return this._visibleColumns[rowIndex] || [];
  }
  getVisibleColumns(rowIndex, isBase) {
    if (!this._shouldReturnVisibleColumns()) {
      return [];
    }
    return this._compileVisibleColumns.apply(this, arguments);
  }
  getFixedColumns(rowIndex) {
    this._fixedColumns = this._fixedColumns || this._getFixedColumnsCore();
    rowIndex = isDefined(rowIndex) ? rowIndex : this._fixedColumns.length - 1;
    return this._fixedColumns[rowIndex] || [];
  }
  getFilteringColumns() {
    return this.getColumns().filter((item) => (item.dataField || item.name) && (item.allowFiltering || item.allowHeaderFiltering)).map((item) => {
      const field = extend(true, {}, item);
      if (!isDefined(field.dataField)) {
        field.dataField = field.name;
      }
      field.filterOperations = item.filterOperations !== item.defaultFilterOperations ? field.filterOperations : null;
      return field;
    });
  }
  getColumnIndexOffset() {
    return 0;
  }
  getStickyColumns(rowIndex) {
    const visibleColumns = this.getVisibleColumns(rowIndex, true);
    return visibleColumns.filter((column) => column.fixed);
  }
  _getFixedColumnsCore() {
    const that = this;
    const result2 = [];
    const rowCount = that.getRowCount();
    const isColumnFixing = that._isColumnFixing();
    const transparentColumn = {
      command: "transparent"
    };
    let transparentColspan = 0;
    let notFixedColumnCount;
    let transparentColumnIndex;
    let lastFixedPosition;
    if (isColumnFixing) {
      for (let i = 0; i <= rowCount; i++) {
        notFixedColumnCount = 0;
        lastFixedPosition = null;
        transparentColumnIndex = null;
        const visibleColumns = that.getVisibleColumns(i, true);
        for (let j = 0; j < visibleColumns.length; j++) {
          const prevColumn = visibleColumns[j - 1];
          const column = visibleColumns[j];
          if (!column.fixed || column.fixedPosition === StickyPosition.Sticky) {
            if (0 === i) {
              if (column.isBand && column.colspan) {
                transparentColspan += column.colspan;
              } else {
                transparentColspan++;
              }
            }
            notFixedColumnCount++;
            if (!isDefined(transparentColumnIndex)) {
              transparentColumnIndex = j;
            }
          } else if (prevColumn && prevColumn.fixed && getFixedPosition(that, prevColumn) !== getFixedPosition(that, column)) {
            if (!isDefined(transparentColumnIndex)) {
              transparentColumnIndex = j;
            }
          } else {
            lastFixedPosition = column.fixedPosition;
          }
        }
        if (0 === i && (0 === notFixedColumnCount || notFixedColumnCount >= visibleColumns.length)) {
          return [];
        }
        if (!isDefined(transparentColumnIndex)) {
          transparentColumnIndex = "right" === lastFixedPosition ? 0 : visibleColumns.length;
        }
        result2[i] = visibleColumns.slice(0);
        if (!transparentColumn.colspan) {
          transparentColumn.colspan = transparentColspan;
        }
        result2[i].splice(transparentColumnIndex, notFixedColumnCount, transparentColumn);
      }
    }
    return result2.map((columns7) => columns7.map((column) => {
      const newColumn = _extends({}, column);
      if (newColumn.headerId) {
        newColumn.headerId += "-fixed";
      }
      return newColumn;
    }));
  }
  _isColumnFixing() {
    let isColumnFixing = this.option("columnFixing.enabled");
    !isColumnFixing && each(this._columns, (_, column) => {
      if (column.fixed) {
        isColumnFixing = true;
        return false;
      }
    });
    return isColumnFixing;
  }
  _getExpandColumnsCore() {
    return this.getGroupColumns();
  }
  getExpandColumns() {
    let expandColumns = this._getExpandColumnsCore();
    let expandColumn;
    const firstGroupColumn = expandColumns.filter((column) => 0 === column.groupIndex)[0];
    const isFixedFirstGroupColumn = firstGroupColumn && firstGroupColumn.fixed;
    const isColumnFixing = this._isColumnFixing();
    const rtlEnabled = this.option("rtlEnabled");
    if (expandColumns.length) {
      expandColumn = this.columnOption("command:expand");
    }
    expandColumns = map(expandColumns, (column) => extend({}, column, {
      visibleWidth: null,
      minWidth: null,
      cellTemplate: !isDefined(column.groupIndex) ? column.cellTemplate : null,
      headerCellTemplate: null,
      fixed: !isDefined(column.groupIndex) || !isFixedFirstGroupColumn ? isColumnFixing : true,
      fixedPosition: rtlEnabled ? "right" : "left"
    }, expandColumn, {
      index: column.index,
      type: column.type || GROUP_COMMAND_COLUMN_NAME
    }));
    return expandColumns;
  }
  getBandColumnsCache() {
    if (!this._bandColumnsCache) {
      const columns7 = this._columns;
      const columnChildrenByIndex = {};
      const columnParentByIndex = {};
      let isPlain = true;
      columns7.forEach((column) => {
        const {
          ownerBand
        } = column;
        let parentIndex = isObject(ownerBand) ? ownerBand.index : ownerBand;
        const parent = columns7[parentIndex];
        if (column.hasColumns) {
          isPlain = false;
        }
        if (column.colspan) {
          column.colspan = void 0;
        }
        if (column.rowspan) {
          column.rowspan = void 0;
        }
        if (parent) {
          columnParentByIndex[column.index] = parent;
        } else {
          parentIndex = -1;
        }
        columnChildrenByIndex[parentIndex] = columnChildrenByIndex[parentIndex] || [];
        columnChildrenByIndex[parentIndex].push(column);
      });
      this._bandColumnsCache = {
        isPlain,
        columnChildrenByIndex,
        columnParentByIndex
      };
    }
    return this._bandColumnsCache;
  }
  _isColumnVisible(column) {
    return column.visible && this.isParentColumnVisible(column.index);
  }
  _isColumnInGroupPanel(column) {
    return isDefined(column.groupIndex) && !column.showWhenGrouped;
  }
  hasVisibleDataColumns() {
    const columns7 = this._columns;
    return columns7.some((column) => {
      const isVisible2 = this._isColumnVisible(column);
      const isInGroupPanel = this._isColumnInGroupPanel(column);
      const isCommand = !!column.command;
      return isVisible2 && !isInGroupPanel && !isCommand;
    });
  }
  _compileVisibleColumnsCore() {
    const bandColumnsCache = this.getBandColumnsCache();
    const columns7 = mergeColumns(this, this._columns, this._commandColumns, true);
    processBandColumns(this, columns7, bandColumnsCache);
    const indexedColumns = this._getIndexedColumns(columns7);
    const visibleColumns = this._getVisibleColumnsFromIndexed(indexedColumns);
    const isDataColumnsInvisible = !this.hasVisibleDataColumns();
    if (isDataColumnsInvisible && this._columns.length) {
      visibleColumns[visibleColumns.length - 1].push({
        command: "empty",
        type: "empty"
      });
    }
    return visibleColumns;
  }
  _getIndexedColumns(columns7) {
    const rtlEnabled = this.option("rtlEnabled");
    const rowCount = this.getRowCount();
    const columnDigitsCount = digitsCount(columns7.length);
    const bandColumnsCache = this.getBandColumnsCache();
    const positiveIndexedColumns = [];
    const negativeIndexedColumns = [];
    for (let i = 0; i < rowCount; i += 1) {
      negativeIndexedColumns[i] = [{}];
      positiveIndexedColumns[i] = [{}, {}, {}];
    }
    columns7.forEach((column) => {
      let {
        visibleIndex
      } = column;
      let indexedColumns;
      const parentBandColumns = getParentBandColumns(column.index, bandColumnsCache.columnParentByIndex);
      const isVisible2 = this._isColumnVisible(column);
      const isInGroupPanel = this._isColumnInGroupPanel(column);
      if (isVisible2 && !isInGroupPanel) {
        const rowIndex = parentBandColumns.length;
        if (visibleIndex < 0) {
          visibleIndex = -visibleIndex;
          indexedColumns = negativeIndexedColumns[rowIndex];
        } else {
          var _parentBandColumns$, _parentBandColumns$2;
          column.fixed = (null === (_parentBandColumns$ = parentBandColumns[0]) || void 0 === _parentBandColumns$ ? void 0 : _parentBandColumns$.fixed) ?? column.fixed;
          column.fixedPosition = (null === (_parentBandColumns$2 = parentBandColumns[0]) || void 0 === _parentBandColumns$2 ? void 0 : _parentBandColumns$2.fixedPosition) ?? column.fixedPosition;
          if (column.fixed && column.fixedPosition !== StickyPosition.Sticky) {
            const isDefaultCommandColumn = !!column.command && !m_utils_default.isCustomCommandColumn(this._columns, column);
            let isFixedToEnd = "right" === column.fixedPosition;
            if (rtlEnabled && !isDefaultCommandColumn) {
              isFixedToEnd = !isFixedToEnd;
            }
            indexedColumns = isFixedToEnd ? positiveIndexedColumns[rowIndex][2] : positiveIndexedColumns[rowIndex][0];
          } else {
            indexedColumns = positiveIndexedColumns[rowIndex][1];
          }
        }
        if (parentBandColumns.length) {
          visibleIndex = numberToString(visibleIndex, columnDigitsCount);
          for (let i = parentBandColumns.length - 1; i >= 0; i -= 1) {
            visibleIndex = numberToString(parentBandColumns[i].visibleIndex, columnDigitsCount) + visibleIndex;
          }
        }
        indexedColumns[visibleIndex] = indexedColumns[visibleIndex] || [];
        indexedColumns[visibleIndex].push(column);
      }
    });
    return {
      positiveIndexedColumns,
      negativeIndexedColumns
    };
  }
  _getVisibleColumnsFromIndexed(_ref) {
    let {
      positiveIndexedColumns,
      negativeIndexedColumns
    } = _ref;
    const result2 = [];
    const rowCount = this.getRowCount();
    const expandColumns = mergeColumns(this, this.getExpandColumns(), this._columns);
    let rowspanGroupColumns = 0;
    let rowspanExpandColumns = 0;
    for (let rowIndex = 0; rowIndex < rowCount; rowIndex += 1) {
      result2.push([]);
      orderEach(negativeIndexedColumns[rowIndex], (_, columns7) => {
        result2[rowIndex].unshift.apply(result2[rowIndex], columns7);
      });
      const firstPositiveIndexColumn = result2[rowIndex].length;
      const positiveIndexedRowColumns = positiveIndexedColumns[rowIndex];
      positiveIndexedRowColumns.forEach((columnsByFixing) => {
        orderEach(columnsByFixing, (_, columnsByVisibleIndex) => {
          result2[rowIndex].push.apply(result2[rowIndex], columnsByVisibleIndex);
        });
      });
      if (rowspanExpandColumns <= rowIndex) {
        rowspanExpandColumns += processExpandColumns.call(this, result2[rowIndex], expandColumns, DETAIL_COMMAND_COLUMN_NAME, firstPositiveIndexColumn);
      }
      if (rowspanGroupColumns <= rowIndex) {
        rowspanGroupColumns += processExpandColumns.call(this, result2[rowIndex], expandColumns, GROUP_COMMAND_COLUMN_NAME, firstPositiveIndexColumn);
      }
    }
    result2.push(getDataColumns(result2));
    return result2;
  }
  getInvisibleColumns(columns7, bandColumnIndex) {
    const that = this;
    let result2 = [];
    let hiddenColumnsByBand;
    columns7 = columns7 || that._columns;
    each(columns7, (_, column) => {
      if (column.ownerBand !== bandColumnIndex) {
        return;
      }
      if (column.isBand) {
        if (!column.visible) {
          hiddenColumnsByBand = that.getChildrenByBandColumn(column.index);
        } else {
          hiddenColumnsByBand = that.getInvisibleColumns(that.getChildrenByBandColumn(column.index), column.index);
        }
        if (hiddenColumnsByBand.length) {
          result2.push(column);
          result2 = result2.concat(hiddenColumnsByBand);
        }
        return;
      }
      if (!column.visible) {
        result2.push(column);
      }
    });
    return result2;
  }
  getChooserColumns(getAllColumns) {
    const columns7 = getAllColumns ? this.getColumns() : this.getInvisibleColumns();
    const columnChooserColumns = columns7.filter((column) => column.showInColumnChooser);
    const sortOrder = this.option("columnChooser.sortOrder");
    return sortColumns(columnChooserColumns, sortOrder);
  }
  allowMoveColumn(fromVisibleIndex, toVisibleIndex, sourceLocation, targetLocation) {
    const columnIndex = getColumnIndexByVisibleIndex(this, fromVisibleIndex, sourceLocation);
    const sourceColumn = this._columns[columnIndex];
    if (sourceColumn && (sourceColumn.allowReordering || sourceColumn.allowGrouping || sourceColumn.allowHiding)) {
      if (sourceLocation === targetLocation) {
        if (sourceLocation === COLUMN_CHOOSER_LOCATION) {
          return false;
        }
        fromVisibleIndex = isObject(fromVisibleIndex) ? fromVisibleIndex.columnIndex : fromVisibleIndex;
        toVisibleIndex = isObject(toVisibleIndex) ? toVisibleIndex.columnIndex : toVisibleIndex;
        return fromVisibleIndex !== toVisibleIndex && fromVisibleIndex + 1 !== toVisibleIndex;
      }
      if (sourceLocation === GROUP_LOCATION && targetLocation !== COLUMN_CHOOSER_LOCATION || targetLocation === GROUP_LOCATION) {
        return sourceColumn && sourceColumn.allowGrouping;
      }
      if (sourceLocation === COLUMN_CHOOSER_LOCATION || targetLocation === COLUMN_CHOOSER_LOCATION) {
        return sourceColumn && sourceColumn.allowHiding;
      }
      return true;
    }
    return false;
  }
  moveColumn(fromVisibleIndex, toVisibleIndex, sourceLocation, targetLocation) {
    const that = this;
    const options2 = {};
    let prevGroupIndex;
    const fromIndex = getColumnIndexByVisibleIndex(that, fromVisibleIndex, sourceLocation);
    const toIndex = getColumnIndexByVisibleIndex(that, toVisibleIndex, targetLocation);
    let targetGroupIndex;
    if (fromIndex >= 0) {
      const column = that._columns[fromIndex];
      toVisibleIndex = isObject(toVisibleIndex) ? toVisibleIndex.columnIndex : toVisibleIndex;
      targetGroupIndex = toIndex >= 0 ? that._columns[toIndex].groupIndex : -1;
      if (isDefined(column.groupIndex) && sourceLocation === GROUP_LOCATION) {
        if (targetGroupIndex > column.groupIndex) {
          targetGroupIndex--;
        }
        if (targetLocation !== GROUP_LOCATION) {
          options2.groupIndex = void 0;
        } else {
          prevGroupIndex = column.groupIndex;
          delete column.groupIndex;
          updateColumnGroupIndexes(that);
        }
      }
      if (targetLocation === GROUP_LOCATION) {
        options2.groupIndex = moveColumnToGroup(that, column, targetGroupIndex);
        column.groupIndex = prevGroupIndex;
      } else if (toVisibleIndex >= 0) {
        const targetColumn = that._columns[toIndex];
        if (!targetColumn || column.ownerBand !== targetColumn.ownerBand) {
          options2.visibleIndex = MAX_SAFE_INTEGER;
        } else if (isColumnFixed(that, column) ^ isColumnFixed(that, targetColumn)) {
          options2.visibleIndex = MAX_SAFE_INTEGER;
        } else {
          options2.visibleIndex = targetColumn.visibleIndex;
        }
      }
      const isVisible2 = targetLocation !== COLUMN_CHOOSER_LOCATION;
      if (column.visible !== isVisible2) {
        options2.visible = isVisible2;
      }
      that.columnOption(column.index, options2);
    }
  }
  allowColumnSorting(column) {
    const sortingOptions = this.option("sorting");
    const allowSorting = "single" === (null === sortingOptions || void 0 === sortingOptions ? void 0 : sortingOptions.mode) || "multiple" === (null === sortingOptions || void 0 === sortingOptions ? void 0 : sortingOptions.mode);
    return allowSorting && (null === column || void 0 === column ? void 0 : column.allowSorting);
  }
  changeSortOrder(columnIndex, sortOrder) {
    const that = this;
    const options2 = {};
    const sortingOptions = that.option("sorting");
    const sortingMode = null === sortingOptions || void 0 === sortingOptions ? void 0 : sortingOptions.mode;
    const needResetSorting = "single" === sortingMode || !sortOrder;
    const column = that._columns[columnIndex];
    if (this.allowColumnSorting(column)) {
      if (needResetSorting && !isDefined(column.groupIndex)) {
        each(that._columns, function(index2) {
          if (index2 !== columnIndex && this.sortOrder) {
            if (!isDefined(this.groupIndex)) {
              delete this.sortOrder;
            }
            delete this.sortIndex;
          }
        });
      }
      if (isSortOrderValid(sortOrder)) {
        if (column.sortOrder !== sortOrder) {
          options2.sortOrder = sortOrder;
        }
      } else if ("none" === sortOrder) {
        if (column.sortOrder) {
          options2.sortIndex = void 0;
          options2.sortOrder = void 0;
        }
      } else {
        !function(column2) {
          if ("ctrl" === sortOrder) {
            if (!("sortOrder" in column2 && "sortIndex" in column2)) {
              return false;
            }
            options2.sortOrder = void 0;
            options2.sortIndex = void 0;
          } else if (isDefined(column2.groupIndex) || isDefined(column2.sortIndex)) {
            options2.sortOrder = "desc" === column2.sortOrder ? "asc" : "desc";
          } else {
            options2.sortOrder = "asc";
          }
          return true;
        }(column);
      }
    }
    that.columnOption(column.index, options2);
  }
  getSortDataSourceParameters(useLocalSelector) {
    const sortColumns2 = [];
    const sort = [];
    each(this._columns, function() {
      if ((this.dataField || this.selector || this.calculateCellValue) && isDefined(this.sortIndex) && !isDefined(this.groupIndex)) {
        sortColumns2[this.sortIndex] = this;
      }
    });
    each(sortColumns2, function() {
      const sortOrder = this && this.sortOrder;
      if (isSortOrderValid(sortOrder)) {
        const sortItem = {
          selector: this.calculateSortValue || this.displayField || this.calculateDisplayValue || useLocalSelector && this.selector || this.dataField || this.calculateCellValue,
          desc: "desc" === this.sortOrder
        };
        if (this.sortingMethod) {
          sortItem.compare = this.sortingMethod.bind(this);
        }
        sort.push(sortItem);
      }
    });
    return sort.length > 0 ? sort : null;
  }
  getGroupDataSourceParameters(useLocalSelector) {
    const group = [];
    each(this.getGroupColumns(), function() {
      const selector = this.calculateGroupValue || this.displayField || this.calculateDisplayValue || useLocalSelector && this.selector || this.dataField || this.calculateCellValue;
      if (selector) {
        const groupItem = {
          selector,
          desc: "desc" === this.sortOrder,
          isExpanded: !!this.autoExpandGroup
        };
        if (this.sortingMethod) {
          groupItem.compare = this.sortingMethod.bind(this);
        }
        group.push(groupItem);
      }
    });
    return group.length > 0 ? group : null;
  }
  refresh(updateNewLookupsOnly) {
    const deferreds = [];
    each(this._columns, function() {
      const {
        lookup
      } = this;
      if (lookup && !this.calculateDisplayValue) {
        if (updateNewLookupsOnly && lookup.valueMap) {
          return;
        }
        if (lookup.update) {
          deferreds.push(lookup.update());
        }
      }
    });
    return when.apply(renderer_default, deferreds).done(resetColumnsCache.bind(null, this));
  }
  _updateColumnOptions(column, columnIndex) {
    var _this$_previousColumn, _this$_previousColumn2;
    const shouldTakeOriginalCallbackFromPrevious = this._reinitAfterLookupChanges && (null === (_this$_previousColumn = this._previousColumns) || void 0 === _this$_previousColumn ? void 0 : _this$_previousColumn[columnIndex]);
    column.selector = column.selector ?? ((data17) => column.calculateCellValue(data17));
    column.selector.columnIndex = columnIndex;
    column.selector.originalCallback = shouldTakeOriginalCallbackFromPrevious ? (null === (_this$_previousColumn2 = this._previousColumns[columnIndex].selector) || void 0 === _this$_previousColumn2 ? void 0 : _this$_previousColumn2.originalCallback) ?? column.selector : column.selector;
    each(["calculateSortValue", "calculateGroupValue", "calculateDisplayValue"], (_, calculateCallbackName) => {
      const calculateCallback = column[calculateCallbackName];
      if (isFunction(calculateCallback)) {
        if (!calculateCallback.originalCallback) {
          const context2 = {
            column
          };
          column[calculateCallbackName] = function(data17) {
            return calculateCallback.call(context2.column, data17);
          };
          column[calculateCallbackName].originalCallback = calculateCallback;
          column[calculateCallbackName].columnIndex = columnIndex;
          column[calculateCallbackName].context = context2;
        } else {
          column[calculateCallbackName].context.column = column;
        }
      }
    });
    if (isString(column.calculateDisplayValue)) {
      column.displayField = column.calculateDisplayValue;
      column.calculateDisplayValue = compileGetter(column.displayField);
    }
    if (column.calculateDisplayValue) {
      column.displayValueMap = column.displayValueMap || {};
    }
    updateSerializers(column, column.dataType);
    const {
      lookup
    } = column;
    if (lookup) {
      updateSerializers(lookup, lookup.dataType);
    }
    const dataType = lookup ? lookup.dataType : column.dataType;
    if (dataType) {
      column.alignment = column.alignment || getAlignmentByDataType(dataType, this.option("rtlEnabled"));
      column.format = column.format || m_utils_default.getFormatByDataType(dataType);
      column.customizeText = column.customizeText || getCustomizeTextByDataType(dataType);
      column.defaultFilterOperations = column.defaultFilterOperations || !lookup && DATATYPE_OPERATIONS[dataType] || [];
      if (!isDefined(column.filterOperations)) {
        setFilterOperationsAsDefaultValues(column);
      }
      column.defaultFilterOperation = column.filterOperations && column.filterOperations[0] || "=";
      column.showEditorAlways = isDefined(column.showEditorAlways) ? column.showEditorAlways : "boolean" === dataType && !column.cellTemplate && !column.lookup;
    }
  }
  updateColumnDataTypes(dataSource) {
    const that = this;
    const dateSerializationFormat = that.option("dateSerializationFormat");
    const firstItems = that._getFirstItems(dataSource);
    let isColumnDataTypesUpdated = false;
    each(that._columns, (index2, column) => {
      let i;
      let value2;
      let dataType;
      let lookupDataType;
      let valueDataType;
      const {
        lookup
      } = column;
      if (m_utils_default.isDateType(column.dataType) && void 0 === column.serializationFormat) {
        column.serializationFormat = dateSerializationFormat;
      }
      if (lookup && m_utils_default.isDateType(lookup.dataType) && void 0 === column.serializationFormat) {
        lookup.serializationFormat = dateSerializationFormat;
      }
      if (column.calculateCellValue && firstItems.length) {
        if (!column.dataType || lookup && !lookup.dataType) {
          for (i = 0; i < firstItems.length; i++) {
            value2 = column.calculateCellValue(firstItems[i]);
            if (!column.dataType) {
              valueDataType = getValueDataType(value2);
              dataType = dataType || valueDataType;
              if (dataType && valueDataType && dataType !== valueDataType) {
                dataType = "string";
              }
            }
            if (lookup && !lookup.dataType) {
              valueDataType = getValueDataType(m_utils_default.getDisplayValue(column, value2, firstItems[i]));
              lookupDataType = lookupDataType || valueDataType;
              if (lookupDataType && valueDataType && lookupDataType !== valueDataType) {
                lookupDataType = "string";
              }
            }
          }
          if (dataType || lookupDataType) {
            if (dataType) {
              column.dataType = dataType;
            }
            if (lookup && lookupDataType) {
              lookup.dataType = lookupDataType;
            }
            isColumnDataTypesUpdated = true;
          }
        }
        if (void 0 === column.serializationFormat || lookup && void 0 === lookup.serializationFormat) {
          for (i = 0; i < firstItems.length; i++) {
            value2 = column.calculateCellValue(firstItems[i], true);
            if (void 0 === column.serializationFormat) {
              column.serializationFormat = getSerializationFormat(column.dataType, value2);
            }
            if (lookup && void 0 === lookup.serializationFormat) {
              lookup.serializationFormat = getSerializationFormat(lookup.dataType, lookup.calculateCellValue(value2, true));
            }
          }
        }
      }
      that._updateColumnOptions(column, index2);
    });
    return isColumnDataTypesUpdated;
  }
  _customizeColumns(columns7) {
    const that = this;
    const customizeColumns = that.option("customizeColumns");
    if (customizeColumns) {
      const hasOwnerBand = columns7.some((column) => isObject(column.ownerBand));
      if (hasOwnerBand) {
        updateIndexes(that);
      }
      customizeColumns(columns7);
      assignColumns(that, createColumnsFromOptions(that, columns7));
    }
  }
  updateColumns(dataSource, forceApplying, isApplyingUserState) {
    if (!forceApplying) {
      this.updateSortingGrouping(dataSource);
    }
    if (!dataSource || dataSource.isLoaded()) {
      const sortParameters = dataSource ? dataSource.sort() || [] : this.getSortDataSourceParameters();
      const groupParameters = dataSource ? dataSource.group() || [] : this.getGroupDataSourceParameters();
      const filterParameters = null === dataSource || void 0 === dataSource ? void 0 : dataSource.lastLoadOptions().filter;
      if (!isApplyingUserState) {
        this._customizeColumns(this._columns);
      }
      updateIndexes(this);
      const columns7 = this._columns;
      return when(this.refresh(true)).always(() => {
        if (this._columns !== columns7) {
          return;
        }
        this._updateChanges(dataSource, {
          sorting: sortParameters,
          grouping: groupParameters,
          filtering: filterParameters
        });
        fireColumnsChanged(this);
      });
    }
  }
  _updateChanges(dataSource, parameters) {
    var _dataSource$loadOptio;
    const langParams = null === dataSource || void 0 === dataSource || null === (_dataSource$loadOptio = dataSource.loadOptions) || void 0 === _dataSource$loadOptio || null === (_dataSource$loadOptio = _dataSource$loadOptio.call(dataSource)) || void 0 === _dataSource$loadOptio ? void 0 : _dataSource$loadOptio.langParams;
    if (dataSource) {
      this.updateColumnDataTypes(dataSource);
      this._dataSourceApplied = true;
    }
    if (!m_utils_default.equalSortParameters(parameters.sorting, this.getSortDataSourceParameters())) {
      updateColumnChanges(this, "sorting");
    }
    if (!m_utils_default.equalSortParameters(parameters.grouping, this.getGroupDataSourceParameters())) {
      updateColumnChanges(this, "grouping");
    }
    if (this._dataController && !m_utils_default.equalFilterParameters(parameters.filtering, this._dataController.getCombinedFilter(), langParams)) {
      updateColumnChanges(this, "filtering");
    }
    updateColumnChanges(this, "columns");
  }
  updateSortingGrouping(dataSource, fromDataSource) {
    const that = this;
    let isColumnsChanged;
    const updateSortGroupParameterIndexes = function(columns7, sortParameters, indexParameterName) {
      each(columns7, (index2, column) => {
        delete column[indexParameterName];
        if (sortParameters) {
          for (let i = 0; i < sortParameters.length; i++) {
            const {
              selector
            } = sortParameters[i];
            const {
              isExpanded
            } = sortParameters[i];
            if (selector === column.dataField || selector === column.name || selector === column.displayField || selector === column.selector || selector === column.calculateCellValue || selector === column.calculateGroupValue || selector === column.calculateDisplayValue) {
              if (fromDataSource) {
                column.sortOrder = "sortOrder" in column ? column.sortOrder : sortParameters[i].desc ? "desc" : "asc";
              } else {
                column.sortOrder = column.sortOrder || (sortParameters[i].desc ? "desc" : "asc");
              }
              if (void 0 !== isExpanded) {
                column.autoExpandGroup = isExpanded;
              }
              column[indexParameterName] = i;
              break;
            }
          }
        }
      });
    };
    if (dataSource) {
      var _this$_columnChanges;
      const sortParameters = m_utils_default.normalizeSortingInfo(dataSource.sort());
      const groupParameters = m_utils_default.normalizeSortingInfo(dataSource.group());
      const columnsGroupParameters = that.getGroupDataSourceParameters();
      const columnsSortParameters = that.getSortDataSourceParameters();
      const changeTypes = null === (_this$_columnChanges = this._columnChanges) || void 0 === _this$_columnChanges ? void 0 : _this$_columnChanges.changeTypes;
      const sortingChanged = !m_utils_default.equalSortParameters(sortParameters, columnsSortParameters);
      const needToApplySortingFromDataSource = fromDataSource && !(null !== changeTypes && void 0 !== changeTypes && changeTypes.sorting);
      const needToApplyGroupingFromDataSource = fromDataSource && !(null !== changeTypes && void 0 !== changeTypes && changeTypes.grouping);
      const groupingChanged = !m_utils_default.equalSortParameters(groupParameters, columnsGroupParameters, true);
      const groupExpandingChanged = !groupingChanged && !m_utils_default.equalSortParameters(groupParameters, columnsGroupParameters);
      if (!that._columns.length) {
        each(groupParameters, (index2, group) => {
          that._columns.push(group.selector);
        });
        each(sortParameters, (index2, sort) => {
          if (!isFunction(sort.selector)) {
            that._columns.push(sort.selector);
          }
        });
        assignColumns(that, createColumnsFromOptions(that, that._columns));
      }
      if ((needToApplyGroupingFromDataSource || !columnsGroupParameters && !that._hasUserState) && (groupingChanged || groupExpandingChanged)) {
        updateSortGroupParameterIndexes(that._columns, groupParameters, "groupIndex");
        if (fromDataSource) {
          groupingChanged && updateColumnChanges(that, "grouping");
          groupExpandingChanged && updateColumnChanges(that, "groupExpanding");
          isColumnsChanged = true;
        }
      }
      if ((needToApplySortingFromDataSource || !columnsSortParameters && !that._hasUserState) && sortingChanged) {
        updateSortGroupParameterIndexes(that._columns, sortParameters, "sortIndex");
        if (fromDataSource) {
          updateColumnChanges(that, "sorting");
          isColumnsChanged = true;
        }
      }
      if (isColumnsChanged) {
        fireColumnsChanged(that);
      }
    }
  }
  updateFilter(filter, remoteFiltering, columnIndex, filterValue) {
    const that = this;
    if (!Array.isArray(filter)) {
      return filter;
    }
    filter = extend([], filter);
    columnIndex = void 0 !== filter.columnIndex ? filter.columnIndex : columnIndex;
    filterValue = void 0 !== filter.filterValue ? filter.filterValue : filterValue;
    if (isString(filter[0]) && "!" !== filter[0]) {
      const column = that.columnOption(filter[0]);
      if (remoteFiltering) {
        if (config_default2().forceIsoDateParsing && column && column.serializeValue && filter.length > 1) {
          filter[filter.length - 1] = column.serializeValue(filter[filter.length - 1], "filter");
        }
      } else if (column && column.selector) {
        filter[0] = column.selector;
        filter[0].columnIndex = column.index;
      }
    } else if (isFunction(filter[0])) {
      filter[0].columnIndex = columnIndex;
      filter[0].filterValue = filterValue;
      filter[0].selectedFilterOperation = filter.selectedFilterOperation;
    }
    for (let i = 0; i < filter.length; i++) {
      filter[i] = that.updateFilter(filter[i], remoteFiltering, columnIndex, filterValue);
    }
    return filter;
  }
  columnCount() {
    return this._columns ? this._columns.length : 0;
  }
  columnOption(identifier, option, value2, notFireEvent) {
    const that = this;
    const columns7 = that._columns.concat(that._commandColumns);
    const column = findColumn(columns7, identifier);
    if (column) {
      if (1 === arguments.length) {
        return extend({}, column);
      }
      if (isString(option)) {
        if (2 === arguments.length) {
          return columnOptionCore(that, column, option);
        }
        columnOptionCore(that, column, option, value2, notFireEvent);
      } else if (isObject(option)) {
        each(option, (optionName, value3) => {
          columnOptionCore(that, column, optionName, value3, notFireEvent);
        });
      }
      fireColumnsChanged(that);
    }
  }
  clearSorting() {
    const that = this;
    const columnCount = this.columnCount();
    that.beginUpdate();
    for (let i = 0; i < columnCount; i++) {
      that.columnOption(i, "sortOrder", void 0);
      delete findColumn(that._columns, i).sortOrder;
    }
    that.endUpdate();
  }
  clearGrouping() {
    const that = this;
    const columnCount = this.columnCount();
    that.beginUpdate();
    for (let i = 0; i < columnCount; i++) {
      that.columnOption(i, "groupIndex", void 0);
    }
    that.endUpdate();
  }
  getVisibleIndex(index2, rowIndex) {
    const columns7 = this.getVisibleColumns(rowIndex);
    for (let i = columns7.length - 1; i >= 0; i--) {
      if (columns7[i].index === index2) {
        return i;
      }
    }
    return -1;
  }
  getVisibleIndexByColumn(column, rowIndex) {
    const visibleColumns = this.getVisibleColumns(rowIndex);
    const visibleColumn = visibleColumns.filter((col) => col.index === column.index && col.command === column.command)[0];
    return visibleColumns.indexOf(visibleColumn);
  }
  getVisibleColumnIndex(id, rowIndex) {
    const index2 = this.columnOption(id, "index");
    return this.getVisibleIndex(index2, rowIndex);
  }
  addColumn(options2) {
    const that = this;
    let column = createColumn(that, options2);
    const index2 = that._columns.length;
    that._columns.push(column);
    if (column.isBand) {
      that._columns = createColumnsFromOptions(that, that._columns);
      column = that._columns[index2];
    }
    column.added = options2;
    updateIndexes(that, column);
    that.updateColumns(that._dataSource);
    that._checkColumns();
  }
  deleteColumn(id) {
    const that = this;
    const column = that.columnOption(id);
    if (column && column.index >= 0) {
      convertOwnerBandToColumnReference(that._columns);
      that._columns.splice(column.index, 1);
      if (column.isBand) {
        const childIndexes = that.getChildrenByBandColumn(column.index).map((column2) => column2.index);
        that._columns = that._columns.filter((column2) => childIndexes.indexOf(column2.index) < 0);
      }
      updateIndexes(that);
      that.updateColumns(that._dataSource);
    }
  }
  addCommandColumn(options2) {
    let commandColumn = this._commandColumns.filter((column) => column.command === options2.command)[0];
    if (!commandColumn) {
      commandColumn = options2;
      this._commandColumns.push(commandColumn);
    }
  }
  getUserState() {
    const columns7 = this._columns;
    const result2 = [];
    let i;
    function handleStateField(index2, value2) {
      if (void 0 !== columns7[i][value2]) {
        result2[i][value2] = columns7[i][value2];
      }
    }
    for (i = 0; i < columns7.length; i++) {
      result2[i] = {};
      each(USER_STATE_FIELD_NAMES, handleStateField);
    }
    return result2;
  }
  setName(column) {
    column.name = column.name || column.dataField || column.type;
  }
  setUserState(state) {
    const that = this;
    const dataSource = that._dataSource;
    let ignoreColumnOptionNames = that.option("stateStoring.ignoreColumnOptionNames");
    null === state || void 0 === state || state.forEach(this.setName);
    if (!ignoreColumnOptionNames) {
      ignoreColumnOptionNames = [];
      const commonColumnSettings = that.getCommonSettings();
      if (!that.option("columnChooser.enabled")) {
        ignoreColumnOptionNames.push("visible");
      }
      if ("none" === that.option("sorting.mode")) {
        ignoreColumnOptionNames.push("sortIndex", "sortOrder");
      }
      if (!commonColumnSettings.allowGrouping) {
        ignoreColumnOptionNames.push("groupIndex");
      }
      if (!commonColumnSettings.allowFixing) {
        ignoreColumnOptionNames.push("fixed", "fixedPosition");
      }
      if (!commonColumnSettings.allowResizing) {
        ignoreColumnOptionNames.push("width", "visibleWidth");
      }
      const isFilterPanelHidden = !that.option("filterPanel.visible");
      if (!that.option("filterRow.visible") && isFilterPanelHidden) {
        ignoreColumnOptionNames.push("filterValue", "selectedFilterOperation");
      }
      if (!that.option("headerFilter.visible") && isFilterPanelHidden) {
        ignoreColumnOptionNames.push("filterValues", "filterType");
      }
    }
    that._columnsUserState = state;
    that._ignoreColumnOptionNames = ignoreColumnOptionNames;
    that._hasUserState = !!state;
    updateColumnChanges(that, "filtering");
    that.init(true);
    if (dataSource) {
      dataSource.sort(that.getSortDataSourceParameters());
      dataSource.group(that.getGroupDataSourceParameters());
    }
  }
  _checkColumns() {
    const usedNames = {};
    let hasEditableColumnWithoutName = false;
    const duplicatedNames = [];
    this._columns.forEach((column) => {
      var _column$columns;
      const {
        name: name2
      } = column;
      const isBand = null === (_column$columns = column.columns) || void 0 === _column$columns ? void 0 : _column$columns.length;
      const isEditable2 = column.allowEditing && (column.dataField || column.setCellValue) && !isBand;
      if (name2) {
        if (usedNames[name2]) {
          duplicatedNames.push(`"${name2}"`);
        }
        usedNames[name2] = true;
      } else if (isEditable2) {
        hasEditableColumnWithoutName = true;
      }
    });
    if (duplicatedNames.length) {
      ui_errors_default.log("E1059", duplicatedNames.join(", "));
    }
    if (hasEditableColumnWithoutName) {
      ui_errors_default.log("E1060");
    }
  }
  _createCalculatedColumnOptions(columnOptions, bandColumn) {
    let calculatedColumnOptions = {};
    let {
      dataField
    } = columnOptions;
    if (Array.isArray(columnOptions.columns) && columnOptions.columns.length || columnOptions.isBand) {
      calculatedColumnOptions.isBand = true;
      dataField = null;
    }
    if (dataField) {
      if (isString(dataField)) {
        const getter = compileGetter(dataField);
        calculatedColumnOptions = {
          caption: m_inflector_default.captionize(dataField),
          calculateCellValue(data17, skipDeserialization) {
            const value2 = getter(data17);
            return this.deserializeValue && !skipDeserialization ? this.deserializeValue(value2) : value2;
          },
          setCellValue: defaultSetCellValue,
          parseValue(text) {
            const column = this;
            let result2;
            let parsedValue;
            if ("number" === column.dataType) {
              if (isString(text) && column.format) {
                result2 = strictParseNumber(text.trim(), column.format);
              } else if (isDefined(text) && isNumeric(text)) {
                result2 = Number(text);
              }
            } else if ("boolean" === column.dataType) {
              if (text === column.trueText) {
                result2 = true;
              } else if (text === column.falseText) {
                result2 = false;
              }
            } else if (m_utils_default.isDateType(column.dataType)) {
              parsedValue = date_default3.parse(text, column.format);
              if (parsedValue) {
                result2 = parsedValue;
              }
            } else {
              result2 = text;
            }
            return result2;
          }
        };
      }
      calculatedColumnOptions.allowFiltering = true;
    } else {
      calculatedColumnOptions.allowFiltering = !!columnOptions.calculateFilterExpression;
    }
    calculatedColumnOptions.calculateFilterExpression = function() {
      return filtering_default.defaultCalculateFilterExpression.apply(this, arguments);
    };
    calculatedColumnOptions.defaultFilterOperation = "=";
    calculatedColumnOptions.createFilterExpression = function(filterValue, selectedFilterOperation) {
      let result2;
      if (this.calculateFilterExpression) {
        result2 = this.calculateFilterExpression.apply(this, arguments);
      }
      if (isFunction(result2)) {
        result2 = [result2, "=", true];
      }
      if (result2) {
        result2.columnIndex = this.index;
        result2.filterValue = filterValue;
        result2.selectedFilterOperation = selectedFilterOperation;
      }
      return result2;
    };
    if (!dataField || !isString(dataField)) {
      extend(true, calculatedColumnOptions, {
        allowSorting: false,
        allowGrouping: false,
        calculateCellValue: () => null
      });
    }
    if (bandColumn) {
      calculatedColumnOptions.allowFixing = false;
    }
    if (columnOptions.dataType) {
      calculatedColumnOptions.userDataType = columnOptions.dataType;
    }
    if (columnOptions.selectedFilterOperation && !("defaultSelectedFilterOperation" in calculatedColumnOptions)) {
      calculatedColumnOptions.defaultSelectedFilterOperation = columnOptions.selectedFilterOperation;
    }
    if (columnOptions.lookup) {
      calculatedColumnOptions.lookup = {
        calculateCellValue(value2, skipDeserialization) {
          if (this.valueExpr) {
            value2 = this.valueMap && this.valueMap[value2];
          }
          return this.deserializeValue && !skipDeserialization ? this.deserializeValue(value2) : value2;
        },
        updateValueMap() {
          this.valueMap = {};
          if (this.items) {
            const calculateValue = compileGetter(this.valueExpr);
            const calculateDisplayValue = compileGetter(this.displayExpr);
            for (let i = 0; i < this.items.length; i++) {
              const item = this.items[i];
              const displayValue = calculateDisplayValue(item);
              this.valueMap[calculateValue(item)] = displayValue;
              this.dataType = this.dataType || getValueDataType(displayValue);
            }
          }
        },
        update() {
          const that = this;
          let {
            dataSource
          } = that;
          if (dataSource) {
            if (isFunction(dataSource) && !variable_wrapper_default.isWrapped(dataSource)) {
              dataSource = dataSource({});
            }
            if (isPlainObject(dataSource) || dataSource instanceof m_abstract_store_default || Array.isArray(dataSource)) {
              if (that.valueExpr) {
                const dataSourceOptions = normalizeDataSourceOptions(dataSource);
                dataSourceOptions.paginate = false;
                dataSource = new DataSource(dataSourceOptions);
                return dataSource.load().done((data17) => {
                  that.items = data17;
                  that.updateValueMap && that.updateValueMap();
                });
              }
            } else {
              ui_errors_default.log("E1016");
            }
          } else {
            that.updateValueMap && that.updateValueMap();
          }
        }
      };
    }
    calculatedColumnOptions.resizedCallbacks = callbacks_default();
    if (columnOptions.resized) {
      calculatedColumnOptions.resizedCallbacks.add(columnOptions.resized.bind(columnOptions));
    }
    each(calculatedColumnOptions, (optionName) => {
      if (isFunction(calculatedColumnOptions[optionName]) && 0 !== optionName.indexOf("default")) {
        const defaultOptionName = `default${optionName.charAt(0).toUpperCase()}${optionName.substr(1)}`;
        calculatedColumnOptions[defaultOptionName] = calculatedColumnOptions[optionName];
      }
    });
    return calculatedColumnOptions;
  }
  getRowCount() {
    this._rowCount = this._rowCount || getRowCount(this);
    return this._rowCount;
  }
  getRowIndex(columnIndex, alwaysGetRowIndex) {
    const column = this._columns[columnIndex];
    const bandColumnsCache = this.getBandColumnsCache();
    return column && (alwaysGetRowIndex || column.visible && !(column.command || isDefined(column.groupIndex))) ? getParentBandColumns(columnIndex, bandColumnsCache.columnParentByIndex).length : 0;
  }
  getChildrenByBandColumn(bandColumnIndex, onlyVisibleDirectChildren) {
    const bandColumnsCache = this.getBandColumnsCache();
    const result2 = getChildrenByBandColumn(bandColumnIndex, bandColumnsCache.columnChildrenByIndex, !onlyVisibleDirectChildren);
    if (onlyVisibleDirectChildren) {
      return result2.filter((column) => column.visible && !column.command).sort((column1, column2) => column1.visibleIndex - column2.visibleIndex);
    }
    return result2;
  }
  getVisibleDataColumnsByBandColumn(bandColumnIndex) {
    const bandColumnsCache = this.getBandColumnsCache();
    const result2 = this.getChildrenByBandColumn(bandColumnIndex, bandColumnsCache.columnChildrenByIndex);
    return result2.filter((column) => !column.isBand && column.visible);
  }
  isParentBandColumn(columnIndex, bandColumnIndex) {
    let result2 = false;
    const column = this._columns[columnIndex];
    const bandColumnsCache = this.getBandColumnsCache();
    const parentBandColumns = column && getParentBandColumns(columnIndex, bandColumnsCache.columnParentByIndex);
    if (parentBandColumns) {
      each(parentBandColumns, (_, bandColumn) => {
        if (bandColumn.index === bandColumnIndex) {
          result2 = true;
          return false;
        }
      });
    }
    return result2;
  }
  isParentColumnVisible(columnIndex) {
    let result2 = true;
    const bandColumnsCache = this.getBandColumnsCache();
    const bandColumns = columnIndex >= 0 && getParentBandColumns(columnIndex, bandColumnsCache.columnParentByIndex);
    bandColumns && each(bandColumns, (_, bandColumn) => {
      result2 = result2 && bandColumn.visible;
      return result2;
    });
    return result2;
  }
  getParentColumn(column) {
    let needDirectParent = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : false;
    const bandColumnsCache = this.getBandColumnsCache();
    const parentColumns = getParentBandColumns(column.index, bandColumnsCache.columnParentByIndex);
    const parentColumnIndex = needDirectParent ? -1 : 0;
    return parentColumns.at(parentColumnIndex);
  }
  isFirstColumn(column, rowIndex) {
    let onlyWithinBandColumn = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : false;
    let fixedPosition = arguments.length > 3 ? arguments[3] : void 0;
    return isFirstOrLastColumn2(this, column, rowIndex, onlyWithinBandColumn, false, fixedPosition);
  }
  isLastColumn(column, rowIndex) {
    let onlyWithinBandColumn = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : false;
    let fixedPosition = arguments.length > 3 ? arguments[3] : void 0;
    return isFirstOrLastColumn2(this, column, rowIndex, onlyWithinBandColumn, true, fixedPosition);
  }
  isCustomCommandColumn(commandColumn) {
    return m_utils_default.isCustomCommandColumn(this._columns, commandColumn);
  }
  getColumnId(column) {
    if (column.command && column.type === GROUP_COMMAND_COLUMN_NAME) {
      if (m_utils_default.isCustomCommandColumn(this._columns, column)) {
        return `type:${column.type}`;
      }
      return `command:${column.command}`;
    }
    return column.index;
  }
  getCustomizeTextByDataType(dataType) {
    return getCustomizeTextByDataType(dataType);
  }
  getHeaderContentAlignment(columnAlignment) {
    const rtlEnabled = this.option("rtlEnabled");
    if (rtlEnabled) {
      return "left" === columnAlignment ? "right" : "left";
    }
    return columnAlignment;
  }
  isVirtualMode() {
    return false;
  }
  isNeedToRenderVirtualColumns(scrollPosition) {
    return false;
  }
};
var columnsControllerModule = {
  defaultOptions: () => ({
    commonColumnSettings: {
      allowFiltering: true,
      allowHiding: true,
      allowSorting: true,
      allowEditing: true,
      encodeHtml: true,
      trueText: message_default.format("dxDataGrid-trueText"),
      falseText: message_default.format("dxDataGrid-falseText")
    },
    allowColumnReordering: false,
    allowColumnResizing: false,
    columnResizingMode: "nextColumn",
    columnMinWidth: void 0,
    columnWidth: void 0,
    adaptColumnWidthByRatio: true,
    columns: void 0,
    regenerateColumnsByVisibleItems: false,
    customizeColumns: null,
    dateSerializationFormat: void 0
  }),
  controllers: {
    columns: ColumnsController
  }
};

// node_modules/devextreme/esm/__internal/grids/data_grid/m_columns_controller.js
m_core_default.registerModule("columns", {
  defaultOptions: () => extend(true, {}, columnsControllerModule.defaultOptions(), {
    commonColumnSettings: {
      allowExporting: true
    }
  }),
  controllers: columnsControllerModule.controllers
});

// node_modules/devextreme/esm/__internal/core/utils/m_array_compare.js
var getKeyWrapper = function(item, getKey) {
  const key = getKey(item);
  if (isObject(key)) {
    try {
      return JSON.stringify(key);
    } catch (e) {
      return key;
    }
  }
  return key;
};
var getSameNewByOld = function(oldItem, newItems, newIndexByKey, getKey) {
  const key = getKeyWrapper(oldItem, getKey);
  return newItems[newIndexByKey[key]];
};
var isKeysEqual = function(oldKeys, newKeys) {
  if (oldKeys.length !== newKeys.length) {
    return false;
  }
  for (let i = 0; i < newKeys.length; i++) {
    if (oldKeys[i] !== newKeys[i]) {
      return false;
    }
  }
  return true;
};
var findChanges = function(oldItems, newItems, getKey, isItemEquals) {
  const oldIndexByKey = {};
  const newIndexByKey = {};
  let addedCount = 0;
  let removeCount = 0;
  const result2 = [];
  oldItems.forEach(function(item, index2) {
    const key = getKeyWrapper(item, getKey);
    oldIndexByKey[key] = index2;
  });
  newItems.forEach(function(item, index2) {
    const key = getKeyWrapper(item, getKey);
    newIndexByKey[key] = index2;
  });
  const itemCount = Math.max(oldItems.length, newItems.length);
  for (let index2 = 0; index2 < itemCount + addedCount; index2++) {
    const newItem = newItems[index2];
    const oldNextIndex = index2 - addedCount + removeCount;
    const nextOldItem = oldItems[oldNextIndex];
    const isRemoved = !newItem || nextOldItem && !getSameNewByOld(nextOldItem, newItems, newIndexByKey, getKey);
    if (isRemoved) {
      if (nextOldItem) {
        result2.push({
          type: "remove",
          key: getKey(nextOldItem),
          index: index2,
          oldItem: nextOldItem
        });
        removeCount++;
        index2--;
      }
    } else {
      const key = getKeyWrapper(newItem, getKey);
      const oldIndex = oldIndexByKey[key];
      const oldItem = oldItems[oldIndex];
      if (!oldItem) {
        addedCount++;
        result2.push({
          type: "insert",
          data: newItem,
          index: index2
        });
      } else if (oldIndex === oldNextIndex) {
        if (!isItemEquals(oldItem, newItem)) {
          result2.push({
            type: "update",
            data: newItem,
            key: getKey(newItem),
            index: index2,
            oldItem
          });
        }
      } else {
        return;
      }
    }
  }
  return result2;
};

// node_modules/devextreme/esm/__internal/ui/collection/m_data_controller.js
var DataControllerMock = {
  load: () => Deferred().reject(),
  loadSingle: () => Deferred().reject(),
  loadFromStore: () => Deferred().reject(),
  loadNextPage: () => Deferred().reject(),
  loadOptions: noop2,
  userData: noop2,
  cancel: noop2,
  cancelAll: noop2,
  filter: noop2,
  addSearchFilter: noop2,
  group: noop2,
  paginate: noop2,
  pageSize: noop2,
  pageIndex: noop2,
  resetDataSourcePageIndex: noop2,
  totalCount: noop2,
  isLastPage: noop2,
  isLoading: noop2,
  isLoaded: noop2,
  searchValue: noop2,
  searchOperation: noop2,
  searchExpr: noop2,
  select: noop2,
  key: noop2,
  keyOf: noop2,
  store: noop2,
  items: noop2,
  applyMapFunction: noop2,
  getDataSource: noop2,
  reload: noop2,
  on: noop2,
  off: noop2
};
var DataController = class {
  constructor(dataSource) {
    if (!dataSource) {
      return DataControllerMock;
    }
    this._dataSource = dataSource;
  }
  load() {
    return this._dataSource.load();
  }
  loadSingle(propName, propValue) {
    if (arguments.length < 2) {
      propValue = propName;
      propName = this.key();
    }
    return this._dataSource.loadSingle(propName, propValue);
  }
  loadFromStore(loadOptions) {
    return this.store().load(loadOptions);
  }
  loadNextPage() {
    this.pageIndex(1 + this.pageIndex());
    return this.load();
  }
  loadOptions() {
    return this._dataSource.loadOptions();
  }
  userData() {
    return this._dataSource._userData;
  }
  cancel(operationId) {
    this._dataSource.cancel(operationId);
  }
  cancelAll() {
    this._dataSource.cancelAll();
  }
  filter(filter) {
    return this._dataSource.filter(filter);
  }
  addSearchFilter(storeLoadOptions) {
    this._dataSource._addSearchFilter(storeLoadOptions);
  }
  group(group) {
    return this._dataSource.group(group);
  }
  paginate() {
    return this._dataSource.paginate();
  }
  pageSize() {
    return this._dataSource._pageSize;
  }
  pageIndex(pageIndex) {
    return this._dataSource.pageIndex(pageIndex);
  }
  resetDataSourcePageIndex() {
    if (this.pageIndex()) {
      this.pageIndex(0);
      this.load();
    }
  }
  totalCount() {
    return this._dataSource.totalCount();
  }
  isLastPage() {
    return this._dataSource.isLastPage() || !this._dataSource._pageSize;
  }
  isLoading() {
    return this._dataSource.isLoading();
  }
  isLoaded() {
    return this._dataSource.isLoaded();
  }
  searchValue(value2) {
    if (!arguments.length) {
      return this._dataSource.searchValue();
    }
    return this._dataSource.searchValue(value2);
  }
  searchOperation(operation) {
    return this._dataSource.searchOperation(operation);
  }
  searchExpr(expr) {
    if (!arguments.length) {
      return this._dataSource.searchExpr();
    }
    return this._dataSource.searchExpr(expr);
  }
  select() {
    return this._dataSource.select(...arguments);
  }
  key() {
    return this._dataSource.key();
  }
  keyOf(item) {
    return this.store().keyOf(item);
  }
  store() {
    return this._dataSource.store();
  }
  items() {
    return this._dataSource.items();
  }
  applyMapFunction(data17) {
    return this._dataSource._applyMapFunction(data17);
  }
  getDataSource() {
    return this._dataSource || null;
  }
  reload() {
    return this._dataSource.reload();
  }
  on(event, handler) {
    this._dataSource.on(event, handler);
  }
  off(event, handler) {
    this._dataSource.off(event, handler);
  }
};
var m_data_controller_default = DataController;

// node_modules/devextreme/esm/__internal/grids/grid_core/data_controller/m_data_helper_mixin.js
var DATA_SOURCE_CHANGED_METHOD = "_dataSourceChangedHandler";
var SPECIFIC_DATA_SOURCE_OPTION = "_getSpecificDataSourceOption";
var NORMALIZE_DATA_SOURCE = "_normalizeDataSource";
var DataHelperMixin = (Base) => class extends Base {
  postCtor() {
    this.on("disposing", () => {
      this._disposeDataSource();
    });
  }
  _refreshDataSource() {
    this._initDataSource();
    this._loadDataSource();
  }
  _initDataSource() {
    let dataSourceOptions = SPECIFIC_DATA_SOURCE_OPTION in this ? this[SPECIFIC_DATA_SOURCE_OPTION]() : this.option("dataSource");
    let widgetDataSourceOptions;
    let dataSourceType;
    this._disposeDataSource();
    if (dataSourceOptions) {
      if (dataSourceOptions instanceof DataSource) {
        this._isSharedDataSource = true;
        this._dataSource = dataSourceOptions;
      } else {
        widgetDataSourceOptions = "_dataSourceOptions" in this ? this._dataSourceOptions() : {};
        dataSourceType = this._dataSourceType ? this._dataSourceType() : DataSource;
        dataSourceOptions = normalizeDataSourceOptions(dataSourceOptions, {
          fromUrlLoadMode: "_dataSourceFromUrlLoadMode" in this && this._dataSourceFromUrlLoadMode()
        });
        this._dataSource = new dataSourceType(extend(true, {}, widgetDataSourceOptions, dataSourceOptions));
      }
      if (NORMALIZE_DATA_SOURCE in this) {
        this._dataSource = this[NORMALIZE_DATA_SOURCE](this._dataSource);
      }
      this._addDataSourceHandlers();
      this._initDataController();
    }
  }
  _initDataController() {
    var _this$option;
    const dataController2 = null === (_this$option = this.option) || void 0 === _this$option ? void 0 : _this$option.call(this, "_dataController");
    const dataSource = this._dataSource;
    if (dataController2) {
      this._dataController = dataController2;
    } else {
      this._dataController = new m_data_controller_default(dataSource);
    }
  }
  _addDataSourceHandlers() {
    if (DATA_SOURCE_CHANGED_METHOD in this) {
      this._addDataSourceChangeHandler();
    }
    if ("_dataSourceLoadErrorHandler" in this) {
      this._addDataSourceLoadErrorHandler();
    }
    if ("_dataSourceLoadingChangedHandler" in this) {
      this._addDataSourceLoadingChangedHandler();
    }
    this._addReadyWatcher();
  }
  _addReadyWatcher() {
    this.readyWatcher = function(isLoading) {
      this._ready && this._ready(!isLoading);
    }.bind(this);
    this._dataSource.on("loadingChanged", this.readyWatcher);
  }
  _addDataSourceChangeHandler() {
    const dataSource = this._dataSource;
    this._proxiedDataSourceChangedHandler = function(e) {
      this[DATA_SOURCE_CHANGED_METHOD](dataSource.items(), e);
    }.bind(this);
    dataSource.on("changed", this._proxiedDataSourceChangedHandler);
  }
  _addDataSourceLoadErrorHandler() {
    this._proxiedDataSourceLoadErrorHandler = this._dataSourceLoadErrorHandler.bind(this);
    this._dataSource.on("loadError", this._proxiedDataSourceLoadErrorHandler);
  }
  _addDataSourceLoadingChangedHandler() {
    this._proxiedDataSourceLoadingChangedHandler = this._dataSourceLoadingChangedHandler.bind(this);
    this._dataSource.on("loadingChanged", this._proxiedDataSourceLoadingChangedHandler);
  }
  _loadDataSource() {
    const dataSource = this._dataSource;
    if (dataSource) {
      if (dataSource.isLoaded()) {
        this._proxiedDataSourceChangedHandler && this._proxiedDataSourceChangedHandler();
      } else {
        dataSource.load();
      }
    }
  }
  _loadSingle(key, value2) {
    key = "this" === key ? this._dataSource.key() || "this" : key;
    return this._dataSource.loadSingle(key, value2);
  }
  _isLastPage() {
    return !this._dataSource || this._dataSource.isLastPage() || !this._dataSource._pageSize;
  }
  _isDataSourceLoading() {
    return this._dataSource && this._dataSource.isLoading();
  }
  _disposeDataSource() {
    if (this._dataSource) {
      if (this._isSharedDataSource) {
        delete this._isSharedDataSource;
        this._proxiedDataSourceChangedHandler && this._dataSource.off("changed", this._proxiedDataSourceChangedHandler);
        this._proxiedDataSourceLoadErrorHandler && this._dataSource.off("loadError", this._proxiedDataSourceLoadErrorHandler);
        this._proxiedDataSourceLoadingChangedHandler && this._dataSource.off("loadingChanged", this._proxiedDataSourceLoadingChangedHandler);
        if (this._dataSource._eventsStrategy) {
          this._dataSource._eventsStrategy.off("loadingChanged", this.readyWatcher);
        }
      } else {
        this._dataSource.dispose();
      }
      delete this._dataSource;
      delete this._proxiedDataSourceChangedHandler;
      delete this._proxiedDataSourceLoadErrorHandler;
      delete this._proxiedDataSourceLoadingChangedHandler;
    }
  }
  getDataSource() {
    return this._dataSource || null;
  }
};

// node_modules/devextreme/esm/__internal/grids/grid_core/data_controller/m_data_controller.js
var changePaging = function(that, optionName, value2) {
  const dataSource = that._dataSource;
  if (dataSource) {
    if (void 0 !== value2) {
      const oldValue = that._getPagingOptionValue(optionName);
      if (oldValue !== value2) {
        if ("pageSize" === optionName) {
          dataSource.pageIndex(0);
        }
        dataSource[optionName](value2);
        that._skipProcessingPagingChange = true;
        that.option(`paging.${optionName}`, value2);
        that._skipProcessingPagingChange = false;
        const pageIndex = dataSource.pageIndex();
        that._isPaging = "pageIndex" === optionName;
        return dataSource["pageIndex" === optionName ? "load" : "reload"]().done(() => {
          that._isPaging = false;
          that.pageChanged.fire(pageIndex);
        });
      }
      return Deferred().resolve().promise();
    }
    return dataSource[optionName]();
  }
  if ("pageIndex" === optionName && void 0 !== value2) {
    return Deferred().resolve().promise();
  }
  return 0;
};
var DataController2 = class extends DataHelperMixin(m_modules_default.Controller) {
  init() {
    this._items = [];
    this._cachedProcessedItems = null;
    this._columnsController = this.getController("columns");
    this._adaptiveColumnsController = this.getController("adaptiveColumns");
    this._editingController = this.getController("editing");
    this._editorFactoryController = this.getController("editorFactory");
    this._errorHandlingController = this.getController("errorHandling");
    this._filterSyncController = this.getController("filterSync");
    this._applyFilterController = this.getController("applyFilter");
    this._keyboardNavigationController = this.getController("keyboardNavigation");
    this._focusController = this.getController("focus");
    this._headerFilterController = this.getController("headerFilter");
    this._selectionController = this.getController("selection");
    this._stateStoringController = this.getController("stateStoring");
    this._validatingController = this.getController("validating");
    this._isPaging = false;
    this._currentOperationTypes = null;
    this._dataChangedHandler = (e) => {
      this._currentOperationTypes = this._dataSource.operationTypes();
      this._handleDataChanged(e);
      this._currentOperationTypes = null;
    };
    this._columnsChangedHandler = this._handleColumnsChanged.bind(this);
    this._loadingChangedHandler = this._handleLoadingChanged.bind(this);
    this._loadErrorHandler = this._handleLoadError.bind(this);
    this._customizeStoreLoadOptionsHandler = this._handleCustomizeStoreLoadOptions.bind(this);
    this._changingHandler = this._handleChanging.bind(this);
    this._dataPushedHandler = this._handleDataPushed.bind(this);
    this._columnsController.columnsChanged.add(this._columnsChangedHandler);
    this._isLoading = false;
    this._isCustomLoading = false;
    this._repaintChangesOnly = void 0;
    this._changes = [];
    this.createAction("onDataErrorOccurred");
    this.dataErrorOccurred.add((error2) => this.executeAction("onDataErrorOccurred", {
      error: error2
    }));
    this._refreshDataSource();
    this.postCtor();
  }
  _getPagingOptionValue(optionName) {
    return this._dataSource[optionName]();
  }
  callbackNames() {
    return ["changed", "loadingChanged", "dataErrorOccurred", "pageChanged", "dataSourceChanged", "pushed"];
  }
  callbackFlags(name2) {
    if ("dataErrorOccurred" === name2) {
      return {
        stopOnFalse: true
      };
    }
    return;
  }
  publicMethods() {
    return ["_disposeDataSource", "beginCustomLoading", "byKey", "clearFilter", "endCustomLoading", "filter", "getCombinedFilter", "getDataByKeys", "getDataSource", "getKeyByRowIndex", "getRowIndexByKey", "getVisibleRows", "keyOf", "pageCount", "pageIndex", "pageSize", "refresh", "repaintRows", "totalCount"];
  }
  reset() {
    this._columnsController.reset();
    this._items = [];
    this._refreshDataSource();
  }
  _handleDataSourceChange(args) {
    if (args.value === args.previousValue || this.option("columns") && Array.isArray(args.value) && Array.isArray(args.previousValue)) {
      const isValueChanged = args.value !== args.previousValue;
      if (isValueChanged) {
        const store = this.store();
        if (store) {
          store._array = args.value;
        }
      }
      if (this.needToRefreshOnDataSourceChange(args)) {
        this.refresh(this.option("repaintChangesOnly"));
      }
      return true;
    }
    return false;
  }
  needToRefreshOnDataSourceChange(args) {
    return true;
  }
  optionChanged(args) {
    const that = this;
    let dataSource;
    let changedPagingOptions;
    function handled() {
      args.handled = true;
    }
    if ("dataSource" === args.name && args.name === args.fullName && this._handleDataSourceChange(args)) {
      handled();
      return;
    }
    switch (args.name) {
      case "cacheEnabled":
      case "repaintChangesOnly":
      case "highlightChanges":
      case "loadingTimeout":
        handled();
        break;
      case "remoteOperations":
      case "keyExpr":
      case "dataSource":
      case "scrolling":
        handled();
        that.reset();
        break;
      case "paging":
        dataSource = that.dataSource();
        if (dataSource) {
          changedPagingOptions = that._setPagingOptions(dataSource);
          if (changedPagingOptions) {
            const pageIndex = dataSource.pageIndex();
            this._isPaging = changedPagingOptions.isPageIndexChanged;
            dataSource.load().done(() => {
              this._isPaging = false;
              that.pageChanged.fire(pageIndex);
            });
          }
        }
        handled();
        break;
      case "rtlEnabled":
        that.reset();
        break;
      case "columns":
        dataSource = that.dataSource();
        if (dataSource && dataSource.isLoading() && args.name === args.fullName) {
          this._useSortingGroupingFromColumns = true;
          dataSource.load();
        }
        break;
      default:
        super.optionChanged(args);
    }
  }
  isReady() {
    return !this._isLoading;
  }
  getDataSource() {
    return this._dataSource && this._dataSource._dataSource;
  }
  getCombinedFilter(returnDataField) {
    return this.combinedFilter(void 0, returnDataField);
  }
  combinedFilter(filter, returnDataField) {
    if (!this._dataSource) {
      return filter;
    }
    let combined = filter ?? this._dataSource.filter();
    const isColumnsTypesDefined = this._columnsController.isDataSourceApplied() || this._columnsController.isAllDataTypesDefined();
    if (isColumnsTypesDefined) {
      const additionalFilter = this._calculateAdditionalFilter();
      combined = additionalFilter ? m_utils_default.combineFilters([additionalFilter, combined]) : combined;
    }
    const isRemoteFiltering = this._dataSource.remoteOperations().filtering || returnDataField;
    combined = this._columnsController.updateFilter(combined, isRemoteFiltering);
    return combined;
  }
  waitReady() {
    if (this._updateLockCount) {
      this._readyDeferred = new Deferred();
      return this._readyDeferred;
    }
    return when();
  }
  _endUpdateCore() {
    const changes = this._changes;
    if (changes.length) {
      this._changes = [];
      const repaintChangesOnly = changes.every((change) => change.repaintChangesOnly);
      this.updateItems(1 === changes.length ? changes[0] : {
        repaintChangesOnly
      });
    }
    if (this._readyDeferred) {
      this._readyDeferred.resolve();
      this._readyDeferred = null;
    }
  }
  _handleCustomizeStoreLoadOptions(e) {
    var _storeLoadOptions$fil;
    const columnsController = this._columnsController;
    const dataSource = this._dataSource;
    const {
      storeLoadOptions
    } = e;
    if (e.isCustomLoading && !storeLoadOptions.isLoadingAll) {
      return;
    }
    storeLoadOptions.filter = this.combinedFilter(storeLoadOptions.filter);
    if (1 === (null === (_storeLoadOptions$fil = storeLoadOptions.filter) || void 0 === _storeLoadOptions$fil ? void 0 : _storeLoadOptions$fil.length) && "!" === storeLoadOptions.filter[0]) {
      e.data = [];
      e.extra = e.extra || {};
      e.extra.totalCount = 0;
    }
    if (!columnsController.isDataSourceApplied()) {
      columnsController.updateColumnDataTypes(dataSource);
    }
    this._columnsUpdating = true;
    columnsController.updateSortingGrouping(dataSource, !this._useSortingGroupingFromColumns);
    this._columnsUpdating = false;
    storeLoadOptions.sort = columnsController.getSortDataSourceParameters();
    storeLoadOptions.group = columnsController.getGroupDataSourceParameters();
    dataSource.sort(storeLoadOptions.sort);
    dataSource.group(storeLoadOptions.group);
    storeLoadOptions.sort = columnsController.getSortDataSourceParameters(!dataSource.remoteOperations().sorting);
    e.group = columnsController.getGroupDataSourceParameters(!dataSource.remoteOperations().grouping);
  }
  _handleColumnsChanged(e) {
    const that = this;
    const {
      changeTypes
    } = e;
    const {
      optionNames
    } = e;
    let filterValue;
    let filterValues;
    let filterApplied;
    const updateItemsHandler = function(change) {
      var _change$changeTypes, _change$changeTypes2;
      that._columnsController.columnsChanged.remove(updateItemsHandler);
      that.updateItems({
        repaintChangesOnly: false,
        event: null === change || void 0 === change || null === (_change$changeTypes = change.changeTypes) || void 0 === _change$changeTypes ? void 0 : _change$changeTypes.event,
        virtualColumnsScrolling: null === change || void 0 === change || null === (_change$changeTypes2 = change.changeTypes) || void 0 === _change$changeTypes2 ? void 0 : _change$changeTypes2.virtualColumnsScrolling
      });
    };
    if (changeTypes.sorting || changeTypes.grouping) {
      if (that._dataSource && !that._columnsUpdating) {
        that._dataSource.group(that._columnsController.getGroupDataSourceParameters());
        that._dataSource.sort(that._columnsController.getSortDataSourceParameters());
        that.reload();
      }
    } else if (changeTypes.columns) {
      filterValues = that._columnsController.columnOption(e.columnIndex, "filterValues");
      if (optionNames.filterValues || optionNames.filterType && Array.isArray(filterValues) || optionNames.filterValue || optionNames.selectedFilterOperation || optionNames.allowFiltering) {
        filterValue = that._columnsController.columnOption(e.columnIndex, "filterValue");
        if (Array.isArray(filterValues) || void 0 === e.columnIndex || isDefined(filterValue) || !optionNames.selectedFilterOperation || optionNames.filterValue) {
          that._applyFilter();
          filterApplied = true;
        }
      }
      if (!that._needApplyFilter && !m_utils_default.checkChanges(optionNames, ["width", "visibleWidth", "filterValue", "bufferedFilterValue", "selectedFilterOperation", "filterValues", "filterType"])) {
        that._columnsController.columnsChanged.add(updateItemsHandler);
      }
      if (isDefined(optionNames.visible)) {
        const column = that._columnsController.columnOption(e.columnIndex);
        if (column && (isDefined(column.filterValue) || isDefined(column.filterValues))) {
          that._applyFilter();
          filterApplied = true;
        }
      }
    }
    if (!filterApplied && changeTypes.filtering && !this._needApplyFilter) {
      that.reload();
    }
  }
  _handleDataChanged(e) {
    const that = this;
    const dataSource = that._dataSource;
    const columnsController = that._columnsController;
    let isAsyncDataSourceApplying = false;
    this._useSortingGroupingFromColumns = false;
    if (dataSource && !that._isDataSourceApplying) {
      that._isDataSourceApplying = true;
      when(that._columnsController.applyDataSource(dataSource)).done(() => {
        if (that._isLoading) {
          that._handleLoadingChanged(false);
        }
        if (isAsyncDataSourceApplying && e && e.isDelayed) {
          e.isDelayed = false;
        }
        that._isDataSourceApplying = false;
        const needApplyFilter = that._needApplyFilter;
        that._needApplyFilter = false;
        if (needApplyFilter && !that._isAllDataTypesDefined && (() => {
          const additionalFilter = that._calculateAdditionalFilter();
          return additionalFilter && additionalFilter.length;
        })()) {
          ui_errors_default.log("W1005", that.component.NAME);
          that._applyFilter();
        } else {
          that.updateItems(e, true);
        }
      }).fail(() => {
        that._isDataSourceApplying = false;
      });
      if (that._isDataSourceApplying) {
        isAsyncDataSourceApplying = true;
        that._handleLoadingChanged(true);
      }
      that._needApplyFilter = !that._columnsController.isDataSourceApplied();
      that._isAllDataTypesDefined = columnsController.isAllDataTypesDefined();
    }
  }
  _handleLoadingChanged(isLoading) {
    this._isLoading = isLoading;
    this._fireLoadingChanged();
  }
  _handleLoadError(e) {
    this.dataErrorOccurred.fire(e);
  }
  _handleDataPushed(changes) {
    this.pushed.fire(changes);
  }
  fireError() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    this.dataErrorOccurred.fire(ui_errors_default.Error.apply(ui_errors_default, args));
  }
  _setPagingOptions(dataSource) {
    const pageIndex = this.option("paging.pageIndex");
    const pageSize = this.option("paging.pageSize");
    const pagingEnabled = this.option("paging.enabled");
    const scrollingMode = this.option("scrolling.mode");
    const appendMode = "infinite" === scrollingMode;
    const virtualMode = "virtual" === scrollingMode;
    const paginate = pagingEnabled || virtualMode || appendMode;
    let isPaginateChanged = false;
    let isPageSizeChanged = false;
    let isPageIndexChanged = false;
    dataSource.requireTotalCount(!appendMode);
    if (void 0 !== pagingEnabled && dataSource.paginate() !== paginate) {
      dataSource.paginate(paginate);
      isPaginateChanged = true;
    }
    if (void 0 !== pageSize && dataSource.pageSize() !== pageSize) {
      dataSource.pageSize(pageSize);
      isPageSizeChanged = true;
    }
    if (void 0 !== pageIndex && dataSource.pageIndex() !== pageIndex) {
      dataSource.pageIndex(pageIndex);
      isPageIndexChanged = true;
    }
    if (isPaginateChanged || isPageSizeChanged || isPageIndexChanged) {
      return {
        isPaginateChanged,
        isPageSizeChanged,
        isPageIndexChanged
      };
    }
    return false;
  }
  _getSpecificDataSourceOption() {
    const dataSource = this.option("dataSource");
    if (Array.isArray(dataSource)) {
      return {
        store: {
          type: "array",
          data: dataSource,
          key: this.option("keyExpr")
        }
      };
    }
    return dataSource;
  }
  _initDataSource() {
    const that = this;
    const oldDataSource = this._dataSource;
    super._initDataSource();
    const dataSource = that._dataSource;
    that._useSortingGroupingFromColumns = true;
    that._cachedProcessedItems = null;
    if (dataSource) {
      const changedPagingOptions = that._setPagingOptions(dataSource);
      this._isPaging = null === changedPagingOptions || void 0 === changedPagingOptions ? void 0 : changedPagingOptions.isPageIndexChanged;
      that.setDataSource(dataSource);
    } else if (oldDataSource) {
      that.updateItems();
    }
  }
  _loadDataSource() {
    const that = this;
    const dataSource = that._dataSource;
    const result2 = new Deferred();
    when(this._columnsController.refresh(true)).always(() => {
      if (dataSource) {
        dataSource.load().done(function() {
          that._isPaging = false;
          result2.resolve.apply(result2, arguments);
        }).fail(result2.reject);
      } else {
        result2.resolve();
      }
    });
    return result2.promise();
  }
  _beforeProcessItems(items) {
    return items.slice(0);
  }
  getRowIndexDelta() {
    return 0;
  }
  getDataIndex(change) {
    const visibleItems = this._items;
    const lastVisibleItem = "append" === change.changeType && visibleItems.length > 0 ? visibleItems[visibleItems.length - 1] : null;
    return isDefined(null === lastVisibleItem || void 0 === lastVisibleItem ? void 0 : lastVisibleItem.dataIndex) ? lastVisibleItem.dataIndex + 1 : 0;
  }
  _processItems(items, change) {
    const that = this;
    const rowIndexDelta = that.getRowIndexDelta();
    const {
      changeType
    } = change;
    const visibleColumns = that._columnsController.getVisibleColumns(null, "loadingAll" === changeType);
    const dataIndex = this.getDataIndex(change);
    const options2 = {
      visibleColumns,
      dataIndex
    };
    const result2 = [];
    each(items, (index2, item) => {
      if (isDefined(item)) {
        options2.rowIndex = index2 - rowIndexDelta;
        item = that._processItem(item, options2);
        result2.push(item);
      }
    });
    return result2;
  }
  _processItem(item, options2) {
    item = this._generateDataItem(item, options2);
    item = this._processDataItem(item, options2);
    item.dataIndex = options2.dataIndex++;
    return item;
  }
  _generateDataItem(data17, options2) {
    return {
      rowType: "data",
      data: data17,
      key: this.keyOf(data17)
    };
  }
  _processDataItem(dataItem, options2) {
    dataItem.values = this.generateDataValues(dataItem.data, options2.visibleColumns);
    return dataItem;
  }
  generateDataValues(data17, columns7, isModified) {
    const values = [];
    let value2;
    for (let i = 0; i < columns7.length; i++) {
      const column = columns7[i];
      value2 = isModified ? void 0 : null;
      if (!column.command) {
        if (column.calculateCellValue) {
          value2 = column.calculateCellValue(data17);
        } else if (column.dataField) {
          value2 = data17[column.dataField];
        }
      }
      values.push(value2);
    }
    return values;
  }
  _applyChange(change) {
    const that = this;
    if ("update" === change.changeType) {
      that._applyChangeUpdate(change);
    } else if (that.items().length && change.repaintChangesOnly && "refresh" === change.changeType) {
      that._applyChangesOnly(change);
    } else if ("refresh" === change.changeType) {
      that._applyChangeFull(change);
    }
  }
  _applyChangeFull(change) {
    this._items = change.items.slice(0);
  }
  _getRowIndices(change) {
    const rowIndices = change.rowIndices.slice(0);
    const rowIndexDelta = this.getRowIndexDelta();
    rowIndices.sort((a, b) => a - b);
    for (let i = 0; i < rowIndices.length; i++) {
      let correctedRowIndex = rowIndices[i];
      if (change.allowInvisibleRowIndices) {
        correctedRowIndex += rowIndexDelta;
      }
      if (correctedRowIndex < 0) {
        rowIndices.splice(i, 1);
        i--;
      }
    }
    return rowIndices;
  }
  _applyChangeUpdate(change) {
    const that = this;
    const {
      items
    } = change;
    const rowIndices = that._getRowIndices(change);
    const rowIndexDelta = that.getRowIndexDelta();
    const repaintChangesOnly = that.option("repaintChangesOnly");
    let prevIndex = -1;
    let rowIndexCorrection = 0;
    let changeType;
    change.items = [];
    change.rowIndices = [];
    change.columnIndices = [];
    change.changeTypes = [];
    const equalItems = function(item1, item2, strict) {
      let result2 = item1 && item2 && equalByValue(item1.key, item2.key);
      if (result2 && strict) {
        result2 = item1.rowType === item2.rowType && ("detail" !== item2.rowType || item1.isEditing === item2.isEditing);
      }
      return result2;
    };
    each(rowIndices, (index2, rowIndex) => {
      let columnIndices;
      rowIndex += rowIndexCorrection + rowIndexDelta;
      if (prevIndex === rowIndex) {
        return;
      }
      prevIndex = rowIndex;
      const oldItem = that._items[rowIndex];
      const oldNextItem = that._items[rowIndex + 1];
      const newItem = items[rowIndex];
      const newNextItem = items[rowIndex + 1];
      const strict = equalItems(oldItem, oldNextItem) || equalItems(newItem, newNextItem);
      if (newItem) {
        newItem.rowIndex = rowIndex;
        change.items.push(newItem);
      }
      if (oldItem && newItem && equalItems(oldItem, newItem, strict)) {
        changeType = "update";
        that._items[rowIndex] = newItem;
        if (oldItem.visible !== newItem.visible) {
          change.items.splice(-1, 1, {
            visible: newItem.visible
          });
        } else if (repaintChangesOnly && !change.isFullUpdate) {
          columnIndices = that._partialUpdateRow(oldItem, newItem, rowIndex - rowIndexDelta);
        }
      } else if (newItem && !oldItem || newNextItem && equalItems(oldItem, newNextItem, strict)) {
        changeType = "insert";
        that._items.splice(rowIndex, 0, newItem);
        rowIndexCorrection++;
      } else if (oldItem && !newItem || oldNextItem && equalItems(newItem, oldNextItem, strict)) {
        changeType = "remove";
        that._items.splice(rowIndex, 1);
        rowIndexCorrection--;
        prevIndex = -1;
      } else if (newItem) {
        changeType = "update";
        that._items[rowIndex] = newItem;
      } else {
        return;
      }
      change.rowIndices.push(rowIndex - rowIndexDelta);
      change.changeTypes.push(changeType);
      change.columnIndices.push(columnIndices);
    });
  }
  _isCellChanged(oldRow, newRow, visibleRowIndex, columnIndex, isLiveUpdate) {
    if (JSON.stringify(oldRow.values[columnIndex]) !== JSON.stringify(newRow.values[columnIndex])) {
      return true;
    }
    function isCellModified(row, columnIndex2) {
      return row.modifiedValues ? void 0 !== row.modifiedValues[columnIndex2] : false;
    }
    if (isCellModified(oldRow, columnIndex) !== isCellModified(newRow, columnIndex)) {
      return true;
    }
    return false;
  }
  _getChangedColumnIndices(oldItem, newItem, visibleRowIndex, isLiveUpdate) {
    let columnIndices;
    if (oldItem.rowType === newItem.rowType) {
      if ("group" !== newItem.rowType && "groupFooter" !== newItem.rowType) {
        columnIndices = [];
        if ("detail" !== newItem.rowType) {
          for (let columnIndex = 0; columnIndex < oldItem.values.length; columnIndex++) {
            if (this._isCellChanged(oldItem, newItem, visibleRowIndex, columnIndex, isLiveUpdate)) {
              columnIndices.push(columnIndex);
            }
          }
        }
      }
      if ("group" === newItem.rowType && oldItem.cells) {
        const isRowStateEquals = newItem.isExpanded === oldItem.isExpanded && newItem.data.isContinuation === oldItem.data.isContinuation && newItem.data.isContinuationOnNextPage === oldItem.data.isContinuationOnNextPage;
        if (isRowStateEquals) {
          columnIndices = oldItem.cells.map((cell, index2) => {
            var _cell$column;
            return "groupExpand" !== (null === (_cell$column = cell.column) || void 0 === _cell$column ? void 0 : _cell$column.type) ? index2 : -1;
          }).filter((index2) => index2 >= 0);
        }
      }
    }
    return columnIndices;
  }
  _partialUpdateRow(oldItem, newItem, visibleRowIndex, isLiveUpdate) {
    var _changedColumnIndices;
    let changedColumnIndices = this._getChangedColumnIndices(oldItem, newItem, visibleRowIndex, isLiveUpdate);
    if (null !== (_changedColumnIndices = changedColumnIndices) && void 0 !== _changedColumnIndices && _changedColumnIndices.length && this.option("dataRowTemplate")) {
      changedColumnIndices = void 0;
    }
    if (changedColumnIndices) {
      oldItem.cells && oldItem.cells.forEach((cell, columnIndex) => {
        const isCellChanged = changedColumnIndices.indexOf(columnIndex) >= 0;
        if (!isCellChanged && cell && cell.update) {
          cell.update(newItem);
        }
      });
      newItem.update = oldItem.update;
      newItem.watch = oldItem.watch;
      newItem.cells = oldItem.cells;
      if (isLiveUpdate) {
        newItem.oldValues = oldItem.values;
      }
      oldItem.update && oldItem.update(newItem);
    }
    return changedColumnIndices;
  }
  _isItemEquals(item1, item2) {
    if (JSON.stringify(item1.values) !== JSON.stringify(item2.values)) {
      return false;
    }
    if (["modified", "isNewRow", "removed", "isEditing"].some((field) => item1[field] !== item2[field])) {
      return false;
    }
    if ("group" === item1.rowType || "groupFooter" === item1.rowType) {
      var _item1$data, _item2$data, _item1$data2, _item2$data2;
      const expandedMatch = item1.isExpanded === item2.isExpanded;
      const summaryCellsMatch = JSON.stringify(item1.summaryCells) === JSON.stringify(item2.summaryCells);
      const continuationMatch = (null === (_item1$data = item1.data) || void 0 === _item1$data ? void 0 : _item1$data.isContinuation) === (null === (_item2$data = item2.data) || void 0 === _item2$data ? void 0 : _item2$data.isContinuation) && (null === (_item1$data2 = item1.data) || void 0 === _item1$data2 ? void 0 : _item1$data2.isContinuationOnNextPage) === (null === (_item2$data2 = item2.data) || void 0 === _item2$data2 ? void 0 : _item2$data2.isContinuationOnNextPage);
      if (!expandedMatch || !summaryCellsMatch || !continuationMatch) {
        return false;
      }
    }
    return true;
  }
  _applyChangesOnly(change) {
    const rowIndices = [];
    const columnIndices = [];
    const changeTypes = [];
    const items = [];
    const newIndexByKey = {};
    const isLiveUpdate = (null === change || void 0 === change ? void 0 : change.isLiveUpdate) ?? true;
    function getRowKey(row) {
      if (row) {
        return `${row.rowType},${JSON.stringify(row.key)}`;
      }
      return;
    }
    const currentItems = this._items;
    const oldItems = currentItems.slice();
    change.items.forEach((item, index2) => {
      const key = getRowKey(item);
      newIndexByKey[key] = index2;
      item.rowIndex = index2;
    });
    const result2 = findChanges(oldItems, change.items, getRowKey, (item1, item2) => {
      if (!this._isItemEquals(item1, item2)) {
        return false;
      }
      if (item1.cells) {
        item1.update && item1.update(item2);
        item1.cells.forEach((cell) => {
          if (cell && cell.update) {
            cell.update(item2, true);
          }
        });
      }
      return true;
    });
    if (!result2) {
      this._applyChangeFull(change);
      return;
    }
    result2.forEach((change2) => {
      switch (change2.type) {
        case "update": {
          const {
            index: index2
          } = change2;
          const newItem = change2.data;
          const {
            oldItem
          } = change2;
          const changedColumnIndices = this._partialUpdateRow(oldItem, newItem, index2, isLiveUpdate);
          rowIndices.push(index2);
          changeTypes.push("update");
          items.push(newItem);
          currentItems[index2] = newItem;
          columnIndices.push(changedColumnIndices);
          break;
        }
        case "insert":
          rowIndices.push(change2.index);
          changeTypes.push("insert");
          items.push(change2.data);
          columnIndices.push(void 0);
          currentItems.splice(change2.index, 0, change2.data);
          break;
        case "remove":
          rowIndices.push(change2.index);
          changeTypes.push("remove");
          currentItems.splice(change2.index, 1);
          items.push(change2.oldItem);
          columnIndices.push(void 0);
      }
    });
    change.repaintChangesOnly = true;
    change.changeType = "update";
    change.rowIndices = rowIndices;
    change.columnIndices = columnIndices;
    change.changeTypes = changeTypes;
    change.items = items;
    if (oldItems.length) {
      change.isLiveUpdate = true;
    }
    this._correctRowIndices((rowIndex) => {
      const oldRowIndexOffset = this._rowIndexOffset || 0;
      const rowIndexOffset = this.getRowIndexOffset();
      const oldItem = oldItems[rowIndex - oldRowIndexOffset];
      const key = getRowKey(oldItem);
      const newVisibleRowIndex = newIndexByKey[key];
      return newVisibleRowIndex >= 0 ? newVisibleRowIndex + rowIndexOffset - rowIndex : 0;
    });
  }
  _correctRowIndices(rowIndex) {
  }
  _afterProcessItems(items, change) {
    return items;
  }
  _updateItemsCore(change) {
    let items;
    const dataSource = this._dataSource;
    const changeType = change.changeType || "refresh";
    change.changeType = changeType;
    if (dataSource) {
      const cachedProcessedItems = this._cachedProcessedItems;
      if (change.useProcessedItemsCache && cachedProcessedItems) {
        items = cachedProcessedItems;
      } else {
        items = change.items || dataSource.items();
        items = this._beforeProcessItems(items);
        items = this._processItems(items, change);
        this._cachedProcessedItems = items;
      }
      items = this._afterProcessItems(items, change);
      change.items = items;
      const oldItems = this._items.length === items.length && this._items;
      this._applyChange(change);
      const rowIndexDelta = this.getRowIndexDelta();
      each(this._items, (index2, item) => {
        item.rowIndex = index2 - rowIndexDelta;
        if (oldItems) {
          item.cells = oldItems[index2].cells ?? [];
        }
        const newItem = items[index2];
        if (newItem) {
          item.loadIndex = newItem.loadIndex;
        }
      });
      this._rowIndexOffset = this.getRowIndexOffset();
    } else {
      this._items = [];
    }
  }
  _handleChanging(e) {
    const rows = this.getVisibleRows();
    const dataSource = this.dataSource();
    if (dataSource) {
      e.changes.forEach((change) => {
        if ("insert" === change.type && change.index >= 0) {
          let dataIndex = 0;
          for (let i = 0; i < change.index; i++) {
            const row = rows[i];
            if (row && ("data" === row.rowType || "group" === row.rowType)) {
              dataIndex++;
            }
          }
          change.index = dataIndex;
        }
      });
    }
  }
  updateItems(change, isDataChanged) {
    change = change || {};
    const that = this;
    change.isFirstRender = !that.changed.fired();
    if (void 0 !== that._repaintChangesOnly) {
      change.repaintChangesOnly = change.repaintChangesOnly ?? that._repaintChangesOnly;
      change.needUpdateDimensions = change.needUpdateDimensions || that._needUpdateDimensions;
    } else if (change.changes) {
      change.repaintChangesOnly = that.option("repaintChangesOnly");
    } else if (isDataChanged) {
      const operationTypes = that.dataSource().operationTypes();
      change.repaintChangesOnly = operationTypes && !operationTypes.grouping && !operationTypes.filtering && that.option("repaintChangesOnly");
      change.isDataChanged = true;
      if (operationTypes && (operationTypes.reload || operationTypes.paging || operationTypes.groupExpanding)) {
        change.needUpdateDimensions = true;
      }
    }
    if (that._updateLockCount && !change.cancel) {
      that._changes.push(change);
      return;
    }
    that._updateItemsCore(change);
    if (change.cancel) {
      return;
    }
    that._fireChanged(change);
  }
  loadingOperationTypes() {
    const dataSource = this.dataSource();
    return dataSource && dataSource.loadingOperationTypes() || {};
  }
  _fireChanged(change) {
    if (this._currentOperationTypes) {
      change.operationTypes = this._currentOperationTypes;
      this._currentOperationTypes = null;
    }
    deferRender(() => {
      this.changed.fire(change);
    });
  }
  isLoading() {
    return this._isLoading || this._isCustomLoading;
  }
  _fireLoadingChanged() {
    this.loadingChanged.fire(this.isLoading(), this._loadingText);
  }
  _calculateAdditionalFilter() {
    return null;
  }
  _applyFilter() {
    const dataSource = this._dataSource;
    if (dataSource) {
      dataSource.pageIndex(0);
      this._isFilterApplying = true;
      return this.reload().done(() => {
        if (this._isFilterApplying) {
          this.pageChanged.fire();
        }
      });
    }
    return new Deferred().resolve();
  }
  resetFilterApplying() {
    this._isFilterApplying = false;
  }
  filter(filterExpr) {
    var _dataSource$loadOptio;
    const dataSource = this._dataSource;
    const filter = null === dataSource || void 0 === dataSource ? void 0 : dataSource.filter();
    const langParams = null === dataSource || void 0 === dataSource || null === (_dataSource$loadOptio = dataSource.loadOptions) || void 0 === _dataSource$loadOptio || null === (_dataSource$loadOptio = _dataSource$loadOptio.call(dataSource)) || void 0 === _dataSource$loadOptio ? void 0 : _dataSource$loadOptio.langParams;
    if (0 === arguments.length) {
      return filter;
    }
    filterExpr = arguments.length > 1 ? Array.prototype.slice.call(arguments, 0) : filterExpr;
    if (m_utils_default.equalFilterParameters(filter, filterExpr, langParams)) {
      return;
    }
    if (dataSource) {
      dataSource.filter(filterExpr);
    }
    this._applyFilter();
  }
  clearFilter(filterName) {
    const that = this;
    const columnsController = that._columnsController;
    const clearColumnOption = function(optionName) {
      const columnCount = columnsController.columnCount();
      for (let index2 = 0; index2 < columnCount; index2++) {
        columnsController.columnOption(index2, optionName, void 0);
      }
    };
    that.component.beginUpdate();
    if (arguments.length > 0) {
      switch (filterName) {
        case "dataSource":
          that.filter(null);
          break;
        case "search":
          that.searchByText("");
          break;
        case "header":
          clearColumnOption("filterValues");
          break;
        case "row":
          clearColumnOption("filterValue");
      }
    } else {
      that.filter(null);
      that.searchByText("");
      clearColumnOption("filterValue");
      clearColumnOption("bufferedFilterValue");
      clearColumnOption("filterValues");
    }
    that.component.endUpdate();
  }
  _fireDataSourceChanged() {
    const that = this;
    const changedHandler = function() {
      that.changed.remove(changedHandler);
      that.dataSourceChanged.fire();
    };
    that.changed.add(changedHandler);
  }
  _getDataSourceAdapter() {
  }
  _createDataSourceAdapterCore(dataSource, remoteOperations) {
    const dataSourceAdapterProvider = this._getDataSourceAdapter();
    const dataSourceAdapter = dataSourceAdapterProvider.create(this.component);
    dataSourceAdapter.init(dataSource, remoteOperations);
    return dataSourceAdapter;
  }
  isLocalStore() {
    let store = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.store();
    return store instanceof m_array_store_default;
  }
  isCustomStore(store) {
    store = store || this.store();
    return store instanceof m_custom_store_default;
  }
  _createDataSourceAdapter(dataSource) {
    let remoteOperations = this.option("remoteOperations");
    const store = dataSource.store();
    const enabledRemoteOperations = {
      filtering: true,
      sorting: true,
      paging: true,
      grouping: true,
      summary: true
    };
    if (isObject(remoteOperations) && remoteOperations.groupPaging) {
      remoteOperations = extend({}, enabledRemoteOperations, remoteOperations);
    }
    if ("auto" === remoteOperations) {
      remoteOperations = this.isLocalStore(store) || this.isCustomStore(store) ? {} : {
        filtering: true,
        sorting: true,
        paging: true
      };
    }
    if (true === remoteOperations) {
      remoteOperations = enabledRemoteOperations;
    }
    return this._createDataSourceAdapterCore(dataSource, remoteOperations);
  }
  setDataSource(dataSource) {
    const that = this;
    const oldDataSource = that._dataSource;
    if (!dataSource && oldDataSource) {
      oldDataSource.cancelAll();
      oldDataSource.changed.remove(that._dataChangedHandler);
      oldDataSource.loadingChanged.remove(that._loadingChangedHandler);
      oldDataSource.loadError.remove(that._loadErrorHandler);
      oldDataSource.customizeStoreLoadOptions.remove(that._customizeStoreLoadOptionsHandler);
      oldDataSource.changing.remove(that._changingHandler);
      oldDataSource.pushed.remove(that._dataPushedHandler);
      oldDataSource.dispose(that._isSharedDataSource);
    }
    if (dataSource) {
      dataSource = that._createDataSourceAdapter(dataSource);
    }
    that._dataSource = dataSource;
    if (dataSource) {
      that._fireDataSourceChanged();
      that._isLoading = !dataSource.isLoaded();
      that._needApplyFilter = true;
      that._isAllDataTypesDefined = that._columnsController.isAllDataTypesDefined();
      dataSource.changed.add(that._dataChangedHandler);
      dataSource.loadingChanged.add(that._loadingChangedHandler);
      dataSource.loadError.add(that._loadErrorHandler);
      dataSource.customizeStoreLoadOptions.add(that._customizeStoreLoadOptionsHandler);
      dataSource.changing.add(that._changingHandler);
      dataSource.pushed.add(that._dataPushedHandler);
    }
  }
  items(byLoaded) {
    return this._items;
  }
  isEmpty() {
    return !this.items().length;
  }
  pageCount() {
    return this._dataSource ? this._dataSource.pageCount() : 1;
  }
  dataSource() {
    return this._dataSource;
  }
  store() {
    const dataSource = this._dataSource;
    return dataSource && dataSource.store();
  }
  loadAll(data17) {
    let skipFilter = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : false;
    const that = this;
    const d = new Deferred();
    const dataSource = that._dataSource;
    if (dataSource) {
      if (data17) {
        const options2 = {
          data: data17,
          isCustomLoading: true,
          storeLoadOptions: {
            isLoadingAll: true
          },
          loadOptions: {
            filter: skipFilter ? null : that.getCombinedFilter(),
            group: dataSource.group(),
            sort: dataSource.sort()
          }
        };
        dataSource._handleDataLoaded(options2);
        when(options2.data).done((data18) => {
          var _options$extra;
          data18 = that._beforeProcessItems(data18);
          d.resolve(that._processItems(data18, {
            changeType: "loadingAll"
          }), null === (_options$extra = options2.extra) || void 0 === _options$extra ? void 0 : _options$extra.summary);
        }).fail(d.reject);
      } else if (!dataSource.isLoading()) {
        const loadOptions = extend({}, dataSource.loadOptions(), {
          isLoadingAll: true,
          requireTotalCount: false
        });
        dataSource.load(loadOptions).done((items, extra) => {
          items = that._beforeProcessItems(items);
          items = that._processItems(items, {
            changeType: "loadingAll"
          });
          d.resolve(items, extra && extra.summary);
        }).fail(d.reject);
      } else {
        d.reject();
      }
    } else {
      d.resolve([]);
    }
    return d;
  }
  getKeyByRowIndex(rowIndex, byLoaded) {
    const item = this.items(byLoaded)[rowIndex];
    if (item) {
      return item.key;
    }
  }
  getRowIndexByKey(key, byLoaded) {
    return m_utils_default.getIndexByKey(key, this.items(byLoaded));
  }
  keyOf(data17) {
    const store = this.store();
    if (store) {
      return store.keyOf(data17);
    }
  }
  byKey(key) {
    const store = this.store();
    const rowIndex = this.getRowIndexByKey(key);
    let result2;
    if (!store) {
      return;
    }
    if (rowIndex >= 0) {
      result2 = new Deferred().resolve(this.items()[rowIndex].data);
    }
    return result2 || store.byKey(key);
  }
  key() {
    const store = this.store();
    if (store) {
      return store.key();
    }
  }
  getRowIndexOffset(byLoadedRows) {
    return 0;
  }
  getDataByKeys(rowKeys) {
    const that = this;
    const result2 = new Deferred();
    const deferreds = [];
    const data17 = [];
    each(rowKeys, (index2, key) => {
      deferreds.push(that.byKey(key).done((keyData) => {
        data17[index2] = keyData;
      }));
    });
    when.apply(renderer_default, deferreds).always(() => {
      result2.resolve(data17);
    });
    return result2;
  }
  pageIndex(value2) {
    return changePaging(this, "pageIndex", value2);
  }
  pageSize(value2) {
    return changePaging(this, "pageSize", value2);
  }
  beginCustomLoading(messageText) {
    this._isCustomLoading = true;
    this._loadingText = messageText || "";
    this._fireLoadingChanged();
  }
  endCustomLoading() {
    this._isCustomLoading = false;
    this._loadingText = void 0;
    this._fireLoadingChanged();
  }
  refresh(options2) {
    if (true === options2) {
      options2 = {
        reload: true,
        changesOnly: true
      };
    } else if (!options2) {
      options2 = {
        lookup: true,
        selection: true,
        reload: true
      };
    }
    const that = this;
    const dataSource = that.getDataSource();
    const {
      changesOnly
    } = options2;
    const d = new Deferred();
    const customizeLoadResult = function() {
      that._repaintChangesOnly = !!changesOnly;
    };
    when(!options2.lookup || that._columnsController.refresh()).always(() => {
      if (options2.load || options2.reload) {
        dataSource && dataSource.on("customizeLoadResult", customizeLoadResult);
        when(that.reload(options2.reload, changesOnly)).always(() => {
          dataSource && dataSource.off("customizeLoadResult", customizeLoadResult);
          that._repaintChangesOnly = void 0;
        }).done(d.resolve).fail(d.reject);
      } else {
        that.updateItems({
          repaintChangesOnly: options2.changesOnly
        });
        d.resolve();
      }
    });
    return d.promise();
  }
  getVisibleRows() {
    return this.items();
  }
  _disposeDataSource() {
    if (this._dataSource && this._dataSource._eventsStrategy) {
      this._dataSource._eventsStrategy.off("loadingChanged", this.readyWatcher);
    }
    this.setDataSource(null);
  }
  dispose() {
    this._disposeDataSource();
    super.dispose();
  }
  repaintRows(rowIndexes, changesOnly) {
    rowIndexes = Array.isArray(rowIndexes) ? rowIndexes : [rowIndexes];
    if (rowIndexes.length > 1 || isDefined(rowIndexes[0])) {
      this.updateItems({
        changeType: "update",
        rowIndices: rowIndexes,
        isFullUpdate: !changesOnly
      });
    }
  }
  skipProcessingPagingChange(fullName) {
    return this._skipProcessingPagingChange && ("paging.pageIndex" === fullName || "paging.pageSize" === fullName);
  }
  getUserState() {
    return {
      searchText: this.option("searchPanel.text"),
      pageIndex: this.pageIndex(),
      pageSize: this.pageSize()
    };
  }
  getCachedStoreData() {
    return this._dataSource && this._dataSource.getCachedStoreData();
  }
  isLastPageLoaded() {
    const pageIndex = this.pageIndex();
    const pageCount = this.pageCount();
    return pageIndex === pageCount - 1;
  }
  load() {
    var _this$_dataSource;
    return null === (_this$_dataSource = this._dataSource) || void 0 === _this$_dataSource ? void 0 : _this$_dataSource.load();
  }
  reload(reload, changesOnly) {
    var _this$_dataSource2;
    return null === (_this$_dataSource2 = this._dataSource) || void 0 === _this$_dataSource2 ? void 0 : _this$_dataSource2.reload(reload, changesOnly);
  }
  push() {
    var _this$_dataSource3;
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    return null === (_this$_dataSource3 = this._dataSource) || void 0 === _this$_dataSource3 ? void 0 : _this$_dataSource3.push(...args);
  }
  itemsCount() {
    var _this$_dataSource4;
    return this._dataSource ? null === (_this$_dataSource4 = this._dataSource) || void 0 === _this$_dataSource4 ? void 0 : _this$_dataSource4.itemsCount() : 0;
  }
  totalItemsCount() {
    var _this$_dataSource5;
    return this._dataSource ? null === (_this$_dataSource5 = this._dataSource) || void 0 === _this$_dataSource5 ? void 0 : _this$_dataSource5.totalItemsCount() : 0;
  }
  hasKnownLastPage() {
    var _this$_dataSource6;
    return this._dataSource ? null === (_this$_dataSource6 = this._dataSource) || void 0 === _this$_dataSource6 ? void 0 : _this$_dataSource6.hasKnownLastPage() : true;
  }
  isLoaded() {
    var _this$_dataSource7;
    return this._dataSource ? null === (_this$_dataSource7 = this._dataSource) || void 0 === _this$_dataSource7 ? void 0 : _this$_dataSource7.isLoaded() : true;
  }
  totalCount() {
    var _this$_dataSource8;
    return this._dataSource ? null === (_this$_dataSource8 = this._dataSource) || void 0 === _this$_dataSource8 ? void 0 : _this$_dataSource8.totalCount() : 0;
  }
  hasLoadOperation() {
    var _this$_dataSource9;
    const operationTypes = (null === (_this$_dataSource9 = this._dataSource) || void 0 === _this$_dataSource9 ? void 0 : _this$_dataSource9.operationTypes()) ?? {};
    return Object.keys(operationTypes).some((type2) => operationTypes[type2]);
  }
};
var dataControllerModule = {
  defaultOptions: () => ({
    loadingTimeout: 0,
    dataSource: null,
    cacheEnabled: true,
    repaintChangesOnly: false,
    highlightChanges: false,
    onDataErrorOccurred: null,
    remoteOperations: "auto",
    paging: {
      enabled: true,
      pageSize: void 0,
      pageIndex: void 0
    }
  }),
  controllers: {
    data: DataController2
  }
};

// node_modules/devextreme/esm/__internal/grids/grid_core/data_source_adapter/m_data_source_adapter_utils.js
var cloneItems = function(items, groupCount) {
  if (items) {
    items = items.slice(0);
    if (groupCount) {
      for (let i = 0; i < items.length; i++) {
        items[i] = extend({
          key: items[i].key
        }, items[i]);
        items[i].items = cloneItems(items[i].items, groupCount - 1);
      }
    }
  }
  return items;
};
var calculateOperationTypes = function(loadOptions, lastLoadOptions, isFullReload) {
  let operationTypes = {
    reload: true,
    fullReload: true
  };
  if (lastLoadOptions) {
    operationTypes = {
      sorting: !m_utils_default.equalSortParameters(loadOptions.sort, lastLoadOptions.sort),
      grouping: !m_utils_default.equalSortParameters(loadOptions.group, lastLoadOptions.group, true),
      groupExpanding: !m_utils_default.equalSortParameters(loadOptions.group, lastLoadOptions.group) || lastLoadOptions.groupExpand,
      filtering: !m_utils_default.equalFilterParameters(loadOptions.filter, lastLoadOptions.filter, loadOptions.langParams),
      pageIndex: loadOptions.pageIndex !== lastLoadOptions.pageIndex,
      skip: loadOptions.skip !== lastLoadOptions.skip,
      take: loadOptions.take !== lastLoadOptions.take,
      pageSize: loadOptions.pageSize !== lastLoadOptions.pageSize,
      fullReload: isFullReload,
      reload: false,
      paging: false
    };
    operationTypes.reload = isFullReload || operationTypes.sorting || operationTypes.grouping || operationTypes.filtering;
    operationTypes.paging = operationTypes.pageIndex || operationTypes.pageSize || operationTypes.take;
  }
  return operationTypes;
};
var executeTask = function(action, timeout) {
  if (isDefined(timeout)) {
    m_common_default.executeAsync(action, timeout);
  } else {
    action();
  }
};
var createEmptyCachedData = function() {
  return {
    items: {}
  };
};
var getPageDataFromCache = function(options2, updatePaging) {
  const groupCount = m_utils_default.normalizeSortingInfo(options2.group || options2.storeLoadOptions.group || options2.loadOptions.group).length;
  const items = [];
  if (fillItemsFromCache(items, options2, groupCount)) {
    return items;
  }
  if (updatePaging) {
    updatePagingOptionsByCache(items, options2, groupCount);
  }
};
var fillItemsFromCache = function(items, options2, groupCount, fromEnd) {
  var _options$cachedData;
  const {
    storeLoadOptions
  } = options2;
  const take = options2.take ?? storeLoadOptions.take ?? 0;
  const cachedItems = null === (_options$cachedData = options2.cachedData) || void 0 === _options$cachedData ? void 0 : _options$cachedData.items;
  if (take && cachedItems) {
    const skip = options2.skip ?? storeLoadOptions.skip ?? 0;
    for (let i = 0; i < take; i += 1) {
      const localIndex = fromEnd ? take - 1 - i : i;
      const cacheItemIndex = localIndex + skip;
      const cacheItem = cachedItems[cacheItemIndex];
      if (void 0 === cacheItem && cacheItemIndex in cachedItems) {
        return true;
      }
      const item = getItemFromCache(options2, cacheItem, groupCount, localIndex, take);
      if (item) {
        items.push(item);
      } else {
        return false;
      }
    }
    return true;
  }
  return false;
};
var getItemFromCache = function(options2, cacheItem, groupCount, index2, take) {
  if (groupCount && cacheItem) {
    const skips = 0 === index2 && options2.skips || [];
    const takes = index2 === take - 1 && options2.takes || [];
    return getGroupItemFromCache(cacheItem, groupCount, skips, takes);
  }
  return cacheItem;
};
var getGroupItemFromCache = function(cacheItem, groupCount, skips, takes) {
  if (groupCount && cacheItem) {
    const result2 = _extends({}, cacheItem);
    const skip = skips[0] || 0;
    const take = takes[0];
    const {
      items
    } = cacheItem;
    if (items) {
      if (void 0 === take && !items[skip]) {
        return;
      }
      result2.items = [];
      if (skips.length) {
        result2.isContinuation = true;
      }
      if (take) {
        result2.isContinuationOnNextPage = cacheItem.count > take;
      }
      for (let i = 0; void 0 === take ? items[i + skip] : i < take; i += 1) {
        const childCacheItem = items[i + skip];
        const isLast = i + 1 === take;
        const item = getGroupItemFromCache(childCacheItem, groupCount - 1, 0 === i ? skips.slice(1) : [], isLast ? takes.slice(1) : []);
        if (void 0 !== item) {
          result2.items.push(item);
        } else {
          return;
        }
      }
    }
    return result2;
  }
  return cacheItem;
};
var updatePagingOptionsByCache = function(cacheItemsFromBegin, options2, groupCount) {
  const cacheItemBeginCount = cacheItemsFromBegin.length;
  const {
    storeLoadOptions
  } = options2;
  if (void 0 !== storeLoadOptions.skip && storeLoadOptions.take && !groupCount) {
    const cacheItemsFromEnd = [];
    fillItemsFromCache(cacheItemsFromEnd, options2, groupCount, true);
    const cacheItemEndCount = cacheItemsFromEnd.length;
    if (cacheItemBeginCount || cacheItemEndCount) {
      options2.skip = options2.skip ?? storeLoadOptions.skip;
      options2.take = options2.take ?? storeLoadOptions.take;
    }
    if (cacheItemBeginCount) {
      storeLoadOptions.skip += cacheItemBeginCount;
      storeLoadOptions.take -= cacheItemBeginCount;
      options2.cachedDataPartBegin = cacheItemsFromBegin;
    }
    if (cacheItemEndCount) {
      storeLoadOptions.take -= cacheItemEndCount;
      options2.cachedDataPartEnd = cacheItemsFromEnd.reverse();
    }
  }
};
var setPageDataToCache = function(options2, data17, groupCount) {
  const {
    storeLoadOptions
  } = options2;
  const skip = options2.skip ?? storeLoadOptions.skip ?? 0;
  const take = options2.take ?? storeLoadOptions.take ?? 0;
  for (let i = 0; i < take; i += 1) {
    const globalIndex = i + skip;
    const cacheItems = options2.cachedData.items;
    const skips = 0 === i && options2.skips || [];
    cacheItems[globalIndex] = getCacheItem(cacheItems[globalIndex], data17[i], groupCount, skips);
  }
};
var getCacheItem = function(cacheItem, loadedItem, groupCount, skips) {
  if (groupCount && loadedItem) {
    const result2 = _extends({}, loadedItem);
    delete result2.isContinuation;
    delete result2.isContinuationOnNextPage;
    const skip = skips[0] || 0;
    if (loadedItem.items) {
      result2.items = (null === cacheItem || void 0 === cacheItem ? void 0 : cacheItem.items) || {};
      loadedItem.items.forEach((item, index2) => {
        const globalIndex = index2 + skip;
        const childSkips = 0 === index2 ? skips.slice(1) : [];
        result2.items[globalIndex] = getCacheItem(result2.items[globalIndex], item, groupCount - 1, childSkips);
      });
    }
    return result2;
  }
  return loadedItem;
};

// node_modules/devextreme/esm/__internal/grids/grid_core/data_source_adapter/m_data_source_adapter.js
var DataSourceAdapter = class extends m_modules_default.Controller {
  init(dataSource, remoteOperations) {
    const that = this;
    that._dataSource = dataSource;
    that._remoteOperations = remoteOperations || {};
    that._isLastPage = !dataSource.isLastPage();
    that._hasLastPage = false;
    that._currentTotalCount = 0;
    that._cachedData = createEmptyCachedData();
    that._lastOperationTypes = {};
    that._eventsStrategy = dataSource._eventsStrategy;
    that._totalCountCorrection = 0;
    that._isLoadingAll = false;
    that.changed = callbacks_default();
    that.loadingChanged = callbacks_default();
    that.loadError = callbacks_default();
    that.customizeStoreLoadOptions = callbacks_default();
    that.changing = callbacks_default();
    that.pushed = callbacks_default();
    that._dataChangedHandler = that._handleDataChanged.bind(that);
    that._customizeStoreLoadOptionsHandler = that._handleCustomizeStoreLoadOptions.bind(that);
    that._dataLoadedHandler = that._handleDataLoaded.bind(that);
    that._loadingChangedHandler = that._handleLoadingChanged.bind(that);
    that._loadErrorHandler = that._handleLoadError.bind(that);
    that._pushHandler = that._handlePush.bind(that);
    that._changingHandler = that._handleChanging.bind(that);
    dataSource.on("changed", that._dataChangedHandler);
    dataSource.on("customizeStoreLoadOptions", that._customizeStoreLoadOptionsHandler);
    dataSource.on("customizeLoadResult", that._dataLoadedHandler);
    dataSource.on("loadingChanged", that._loadingChangedHandler);
    dataSource.on("loadError", that._loadErrorHandler);
    dataSource.on("changing", that._changingHandler);
    dataSource.store().on("beforePush", that._pushHandler);
    each(dataSource, (memberName, member) => {
      if (!that[memberName] && isFunction(member)) {
        that[memberName] = function() {
          return this._dataSource[memberName].apply(this._dataSource, arguments);
        };
      }
    });
  }
  dispose(isSharedDataSource) {
    const dataSource = this._dataSource;
    const store = dataSource.store();
    dataSource.off("changed", this._dataChangedHandler);
    dataSource.off("customizeStoreLoadOptions", this._customizeStoreLoadOptionsHandler);
    dataSource.off("customizeLoadResult", this._dataLoadedHandler);
    dataSource.off("loadingChanged", this._loadingChangedHandler);
    dataSource.off("loadError", this._loadErrorHandler);
    dataSource.off("changing", this._changingHandler);
    store && store.off("beforePush", this._pushHandler);
    if (!isSharedDataSource) {
      dataSource.dispose();
    }
  }
  remoteOperations() {
    return this._remoteOperations;
  }
  refresh(options2, operationTypes) {
    const that = this;
    const dataSource = that._dataSource;
    if (operationTypes.reload) {
      that.resetCurrentTotalCount();
      that._isLastPage = !dataSource.paginate();
      that._hasLastPage = that._isLastPage;
    }
  }
  resetCurrentTotalCount() {
    this._currentTotalCount = 0;
    this._totalCountCorrection = 0;
  }
  resetCache() {
    this._cachedStoreData = void 0;
    this._cachedPagingData = void 0;
  }
  resetPagesCache(isLiveUpdate) {
    this._cachedData = createEmptyCachedData();
  }
  _needClearStoreDataCache() {
    const remoteOperations = this.remoteOperations();
    const operationTypes = calculateOperationTypes(this._lastLoadOptions || {}, {});
    const isLocalOperations = Object.keys(remoteOperations).every((operationName) => !operationTypes[operationName] || !remoteOperations[operationName]);
    return !isLocalOperations;
  }
  push(changes, fromStore) {
    const store = this.store();
    if (this._needClearStoreDataCache()) {
      this._cachedStoreData = void 0;
    }
    this._cachedPagingData = void 0;
    this.resetPagesCache(true);
    if (this._cachedStoreData) {
      applyBatch({
        keyInfo: store,
        data: this._cachedStoreData,
        changes
      });
    }
    if (!fromStore) {
      this._applyBatch(changes);
    }
    this.pushed.fire(changes);
  }
  getDataIndexGetter() {
    if (!this._dataIndexGetter) {
      let indexByKey2;
      let storeData;
      const store = this.store();
      this._dataIndexGetter = (data17) => {
        const isCacheUpdated = storeData && storeData !== this._cachedStoreData;
        if (!indexByKey2 || isCacheUpdated) {
          storeData = this._cachedStoreData || [];
          indexByKey2 = {};
          for (let i = 0; i < storeData.length; i++) {
            indexByKey2[getKeyHash(store.keyOf(storeData[i]))] = i;
          }
        }
        return indexByKey2[getKeyHash(store.keyOf(data17))];
      };
    }
    return this._dataIndexGetter;
  }
  _getKeyInfo() {
    return this.store();
  }
  _needToCopyDataObject() {
    return true;
  }
  _applyBatch(changes, fromStore) {
    const keyInfo = this._getKeyInfo();
    const dataSource = this._dataSource;
    const groupCount = m_utils_default.normalizeSortingInfo(this.group()).length;
    const isReshapeMode = "reshape" === this.option("editing.refreshMode");
    const isVirtualMode3 = "virtual" === this.option("scrolling.mode");
    changes = changes.filter((change) => !dataSource.paginate() || "insert" !== change.type || void 0 !== change.index);
    const getItemCount2 = () => groupCount ? this.itemsCount() : this.items().length;
    const oldItemCount = getItemCount2();
    applyBatch({
      keyInfo,
      data: this._items,
      changes,
      groupCount,
      useInsertIndex: true,
      skipCopying: !this._needToCopyDataObject()
    });
    applyBatch({
      keyInfo,
      data: dataSource.items(),
      changes,
      groupCount,
      useInsertIndex: true,
      skipCopying: !this._needToCopyDataObject()
    });
    const needUpdateTotalCountCorrection = this._currentTotalCount > 0 || (fromStore || !isReshapeMode) && isVirtualMode3;
    if (needUpdateTotalCountCorrection) {
      this._totalCountCorrection += getItemCount2() - oldItemCount;
    }
    changes.splice(0, changes.length);
  }
  _handlePush(_ref) {
    let {
      changes
    } = _ref;
    this.push(changes, true);
  }
  _handleChanging(e) {
    this.changing.fire(e);
    this._applyBatch(e.changes, true);
  }
  _needCleanCacheByOperation(operationType, remoteOperations) {
    const operationTypesByOrder = ["filtering", "sorting", "paging"];
    const operationTypeIndex = operationTypesByOrder.indexOf(operationType);
    const currentOperationTypes = operationTypeIndex >= 0 ? operationTypesByOrder.slice(operationTypeIndex) : [operationType];
    return currentOperationTypes.some((operationType2) => remoteOperations[operationType2]);
  }
  _customizeRemoteOperations(options2, operationTypes) {
    let cachedStoreData = this._cachedStoreData;
    let cachedPagingData = this._cachedPagingData;
    let cachedData = this._cachedData;
    if (options2.storeLoadOptions.filter && !options2.remoteOperations.filtering || options2.storeLoadOptions.sort && !options2.remoteOperations.sorting) {
      options2.remoteOperations = {
        filtering: options2.remoteOperations.filtering,
        summary: options2.remoteOperations.summary
      };
    }
    if (operationTypes.fullReload) {
      cachedStoreData = void 0;
      cachedPagingData = void 0;
      cachedData = createEmptyCachedData();
    } else {
      if (operationTypes.reload) {
        cachedPagingData = void 0;
        cachedData = createEmptyCachedData();
      } else if (operationTypes.groupExpanding) {
        cachedData = createEmptyCachedData();
      }
      each(operationTypes, (operationType, value2) => {
        if (value2 && this._needCleanCacheByOperation(operationType, options2.remoteOperations)) {
          cachedStoreData = void 0;
          cachedPagingData = void 0;
        }
      });
    }
    if (cachedPagingData) {
      options2.remoteOperations.paging = false;
    }
    options2.cachedStoreData = cachedStoreData;
    options2.cachedPagingData = cachedPagingData;
    options2.cachedData = cachedData;
    if (!options2.isCustomLoading) {
      this._cachedStoreData = cachedStoreData;
      this._cachedPagingData = cachedPagingData;
      this._cachedData = cachedData;
    }
  }
  _handleCustomizeStoreLoadOptions(options2) {
    var _options$data;
    this._handleDataLoading(options2);
    if (!(0 === (null === (_options$data = options2.data) || void 0 === _options$data ? void 0 : _options$data.length))) {
      options2.data = getPageDataFromCache(options2, true) || options2.cachedStoreData;
    }
  }
  _handleDataLoading(options2) {
    const dataSource = this._dataSource;
    const lastLoadOptions = this._lastLoadOptions;
    this.customizeStoreLoadOptions.fire(options2);
    options2.delay = this.option("loadingTimeout");
    options2.originalStoreLoadOptions = options2.storeLoadOptions;
    options2.remoteOperations = extend({}, this.remoteOperations());
    const isFullReload = !this.isLoaded() && !this._isRefreshing;
    if (this.option("integrationOptions.renderedOnServer") && !this.isLoaded()) {
      options2.delay = void 0;
    }
    const loadOptions = extend({
      pageIndex: this.pageIndex(),
      pageSize: this.pageSize()
    }, options2.storeLoadOptions);
    const operationTypes = calculateOperationTypes(loadOptions, lastLoadOptions, isFullReload);
    this._customizeRemoteOperations(options2, operationTypes);
    if (!options2.isCustomLoading) {
      const isRefreshing = this._isRefreshing;
      options2.pageIndex = dataSource.pageIndex();
      options2.lastLoadOptions = loadOptions;
      options2.operationTypes = operationTypes;
      this._loadingOperationTypes = operationTypes;
      this._isRefreshing = true;
      when(isRefreshing || this._isRefreshed || this.refresh(options2, operationTypes)).done(() => {
        if (this._lastOperationId === options2.operationId) {
          this._isRefreshed = true;
          this.load().always(() => {
            this._isRefreshed = false;
          });
        }
      }).fail(() => {
        dataSource.cancel(options2.operationId);
      }).always(() => {
        this._isRefreshing = false;
      });
      dataSource.cancel(this._lastOperationId);
      this._lastOperationId = options2.operationId;
      if (this._isRefreshing) {
        dataSource.cancel(this._lastOperationId);
      }
    }
    this._handleDataLoadingCore(options2);
  }
  _handleDataLoadingCore(options2) {
    const {
      remoteOperations
    } = options2;
    options2.loadOptions = {};
    const cachedExtra = options2.cachedData.extra;
    const localLoadOptionNames = {
      filter: !remoteOperations.filtering,
      sort: !remoteOperations.sorting,
      group: !remoteOperations.grouping,
      summary: !remoteOperations.summary,
      skip: !remoteOperations.paging,
      take: !remoteOperations.paging,
      requireTotalCount: cachedExtra && "totalCount" in cachedExtra || !remoteOperations.paging,
      langParams: !remoteOperations.filtering || !remoteOperations.sorting
    };
    each(options2.storeLoadOptions, (optionName, optionValue) => {
      if (localLoadOptionNames[optionName]) {
        options2.loadOptions[optionName] = optionValue;
        delete options2.storeLoadOptions[optionName];
      }
    });
    if (cachedExtra) {
      options2.extra = cachedExtra;
    }
  }
  _handleDataLoaded(options2) {
    const {
      loadOptions
    } = options2;
    const localPaging = options2.remoteOperations && !options2.remoteOperations.paging;
    const {
      cachedData
    } = options2;
    const {
      storeLoadOptions
    } = options2;
    const needCache = false !== this.option("cacheEnabled") && storeLoadOptions;
    const needPageCache = needCache && !options2.isCustomLoading && cachedData && (!localPaging || storeLoadOptions.group);
    const needPagingCache = needCache && localPaging;
    const needStoreCache = needPagingCache && !options2.isCustomLoading;
    if (!loadOptions) {
      this._dataSource.cancel(options2.operationId);
      return;
    }
    if (localPaging) {
      options2.skip = loadOptions.skip;
      options2.take = loadOptions.take;
      delete loadOptions.skip;
      delete loadOptions.take;
    }
    if (loadOptions.group) {
      loadOptions.group = options2.group || loadOptions.group;
    }
    const groupCount = m_utils_default.normalizeSortingInfo(options2.group || storeLoadOptions.group || loadOptions.group).length;
    if (options2.cachedDataPartBegin) {
      options2.data = options2.cachedDataPartBegin.concat(options2.data);
    }
    if (options2.cachedDataPartEnd) {
      options2.data = options2.data.concat(options2.cachedDataPartEnd);
    }
    if (!needPageCache || !getPageDataFromCache(options2)) {
      var _options$extra;
      if (needPagingCache && options2.cachedPagingData) {
        options2.data = cloneItems(options2.cachedPagingData, groupCount);
      } else {
        if (needStoreCache) {
          if (!this._cachedStoreData) {
            this._cachedStoreData = cloneItems(options2.data, m_utils_default.normalizeSortingInfo(storeLoadOptions.group).length);
          } else if (options2.mergeStoreLoadData) {
            options2.data = this._cachedStoreData = this._cachedStoreData.concat(options2.data);
          }
        }
        new m_array_store_default(options2.data).load(loadOptions).done((data17) => {
          options2.data = data17;
          if (needStoreCache) {
            this._cachedPagingData = cloneItems(options2.data, groupCount);
          }
        }).fail((error2) => {
          options2.data = new Deferred().reject(error2);
        });
      }
      if (loadOptions.requireTotalCount && localPaging) {
        options2.extra = isPlainObject(options2.extra) ? options2.extra : {};
        options2.extra.totalCount = options2.data.length;
      }
      if (options2.extra && options2.extra.totalCount >= 0 && (false === storeLoadOptions.requireTotalCount || false === loadOptions.requireTotalCount)) {
        options2.extra.totalCount = -1;
      }
      if (!loadOptions.data && (storeLoadOptions.requireTotalCount || ((null === (_options$extra = options2.extra) || void 0 === _options$extra ? void 0 : _options$extra.totalCount) ?? -1) >= 0)) {
        this._totalCountCorrection = 0;
      }
      this._handleDataLoadedCore(options2);
      if (needPageCache) {
        cachedData.extra = cachedData.extra || extend({}, options2.extra);
        when(options2.data).done((data17) => {
          setPageDataToCache(options2, data17, groupCount);
        });
      }
    }
    when(options2.data).done(() => {
      if (options2.lastLoadOptions) {
        this._lastLoadOptions = options2.lastLoadOptions;
        Object.keys(options2.operationTypes).forEach((operationType) => {
          this._lastOperationTypes[operationType] = this._lastOperationTypes[operationType] || options2.operationTypes[operationType];
        });
      }
    });
    options2.storeLoadOptions = options2.originalStoreLoadOptions;
  }
  _handleDataLoadedCore(options2) {
    if (options2.remoteOperations && !options2.remoteOperations.paging && Array.isArray(options2.data)) {
      if (void 0 !== options2.skip) {
        options2.data = options2.data.slice(options2.skip);
      }
      if (void 0 !== options2.take) {
        options2.data = options2.data.slice(0, options2.take);
      }
    }
  }
  _handleLoadingChanged(isLoading) {
    this.loadingChanged.fire(isLoading);
  }
  _handleLoadError(error2) {
    this.loadError.fire(error2);
    this.changed.fire({
      changeType: "loadError",
      error: error2
    });
  }
  _loadPageSize() {
    return this.pageSize();
  }
  _handleDataChanged(args) {
    let currentTotalCount;
    const dataSource = this._dataSource;
    let isLoading = false;
    const isDataLoading = !args || isDefined(args.changeType);
    const itemsCount = this.itemsCount();
    if (isDataLoading) {
      this._isLastPage = !itemsCount || !this._loadPageSize() || itemsCount < this._loadPageSize();
      if (this._isLastPage) {
        this._hasLastPage = true;
      }
    }
    if (dataSource.totalCount() >= 0) {
      if (dataSource.pageIndex() >= this.pageCount()) {
        dataSource.pageIndex(this.pageCount() - 1);
        this.pageIndex(dataSource.pageIndex());
        this.resetPagesCache();
        dataSource.load();
        isLoading = true;
      }
    } else if (isDataLoading) {
      currentTotalCount = dataSource.pageIndex() * this.pageSize() + itemsCount;
      if (currentTotalCount > this._currentTotalCount) {
        this._currentTotalCount = currentTotalCount;
        if (0 === dataSource.pageIndex() || !this.option("scrolling.legacyMode")) {
          this._totalCountCorrection = 0;
        }
      }
      if (0 === itemsCount && dataSource.pageIndex() >= this.pageCount()) {
        dataSource.pageIndex(this.pageCount() - 1);
        if ("infinite" !== this.option("scrolling.mode")) {
          dataSource.load();
          isLoading = true;
        }
      }
    }
    if (!isLoading) {
      this._operationTypes = this._lastOperationTypes;
      this._lastOperationTypes = {};
      this.component._optionCache = {};
      this.changed.fire(args);
      this.component._optionCache = void 0;
    }
  }
  _scheduleCustomLoadCallbacks(deferred) {
    const that = this;
    that._isCustomLoading = true;
    deferred.always(() => {
      that._isCustomLoading = false;
    });
  }
  loadingOperationTypes() {
    return this._loadingOperationTypes;
  }
  operationTypes() {
    return this._operationTypes;
  }
  lastLoadOptions() {
    return this._lastLoadOptions || {};
  }
  isLastPage() {
    return this._isLastPage;
  }
  _dataSourceTotalCount() {
    return this._dataSource.totalCount();
  }
  _changeRowExpandCore(path) {
  }
  changeRowExpand(path) {
  }
  totalCount() {
    return parseInt((this._currentTotalCount || this._dataSourceTotalCount()) + this._totalCountCorrection);
  }
  totalCountCorrection() {
    return this._totalCountCorrection;
  }
  items() {
  }
  itemsCount() {
    return this._dataSource.items().length;
  }
  totalItemsCount() {
    return this.totalCount();
  }
  pageSize() {
    const dataSource = this._dataSource;
    if (!arguments.length && !dataSource.paginate()) {
      return 0;
    }
    return dataSource.pageSize.apply(dataSource, arguments);
  }
  pageCount() {
    const count = this.totalItemsCount() - this._totalCountCorrection;
    const pageSize = this.pageSize();
    if (pageSize && count > 0) {
      return Math.max(1, Math.ceil(count / pageSize));
    }
    return 1;
  }
  hasKnownLastPage() {
    return this._hasLastPage || this._dataSource.totalCount() >= 0;
  }
  loadFromStore(loadOptions, store) {
    const dataSource = this._dataSource;
    const d = new Deferred();
    if (!dataSource) {
      return;
    }
    store = store || dataSource.store();
    store.load(loadOptions).done((data17, extra) => {
      if (data17 && !Array.isArray(data17) && Array.isArray(data17.data)) {
        extra = data17;
        data17 = data17.data;
      }
      d.resolve(data17, extra);
    }).fail(d.reject);
    return d;
  }
  isCustomLoading() {
    return !!this._isCustomLoading;
  }
  load(options2) {
    const that = this;
    const dataSource = that._dataSource;
    const d = new Deferred();
    if (options2) {
      const store = dataSource.store();
      const dataSourceLoadOptions = dataSource.loadOptions();
      const loadResult = {
        storeLoadOptions: extend({}, options2, {
          langParams: null === dataSourceLoadOptions || void 0 === dataSourceLoadOptions ? void 0 : dataSourceLoadOptions.langParams
        }),
        isCustomLoading: true
      };
      each(store._customLoadOptions() || [], (_, optionName) => {
        if (!(optionName in loadResult.storeLoadOptions)) {
          loadResult.storeLoadOptions[optionName] = dataSourceLoadOptions[optionName];
        }
      });
      this._isLoadingAll = options2.isLoadingAll;
      that._scheduleCustomLoadCallbacks(d);
      dataSource._scheduleLoadCallbacks(d);
      that._handleCustomizeStoreLoadOptions(loadResult);
      executeTask(() => {
        if (!dataSource.store()) {
          return d.reject("canceled");
        }
        when(loadResult.data || that.loadFromStore(loadResult.storeLoadOptions)).done((data17, extra) => {
          loadResult.data = data17;
          loadResult.extra = extra || {};
          that._handleDataLoaded(loadResult);
          if (options2.requireTotalCount && void 0 === loadResult.extra.totalCount) {
            loadResult.extra.totalCount = store.totalCount(loadResult.storeLoadOptions);
          }
          when(loadResult.data, loadResult.extra.totalCount).done((data18, totalCount) => {
            loadResult.extra.totalCount = totalCount;
            d.resolve(data18, loadResult.extra);
          }).fail(d.reject);
        }).fail(d.reject);
      }, that.option("loadingTimeout"));
      return d.fail(function() {
        that._eventsStrategy.fireEvent("loadError", arguments);
      }).always(() => {
        this._isLoadingAll = false;
      }).promise();
    }
    return dataSource.load();
  }
  reload(full) {
    return full ? this._dataSource.reload() : this._dataSource.load();
  }
  getCachedStoreData() {
    return this._cachedStoreData;
  }
  isLoaded() {
  }
  pageIndex(pageIndex) {
  }
};

// node_modules/devextreme/esm/__internal/grids/data_grid/m_data_source_adapter.js
var DataSourceAdapterType = DataSourceAdapter;
var m_data_source_adapter_default = {
  extend(extender) {
    DataSourceAdapterType = extender(DataSourceAdapterType);
  },
  create: (component) => new DataSourceAdapterType(component)
};

// node_modules/devextreme/esm/__internal/grids/data_grid/m_data_controller.js
var DataGridDataController = class extends DataController2 {
  _getDataSourceAdapter() {
    return m_data_source_adapter_default;
  }
  _getSpecificDataSourceOption() {
    const dataSource = this.option("dataSource");
    if (dataSource && !Array.isArray(dataSource) && this.option("keyExpr")) {
      ui_errors_default.log("W1011");
    }
    return super._getSpecificDataSourceOption();
  }
};
m_core_default.registerModule("data", {
  defaultOptions: dataControllerModule.defaultOptions,
  controllers: {
    data: DataGridDataController
  }
});

// node_modules/devextreme/esm/__internal/grids/grid_core/sorting/m_sorting_mixin.js
var sortingMixin = (Base) => class extends Base {
  _applyColumnState(options2) {
    const that = this;
    let ariaSortState;
    let $sortIndicator;
    const sortingMode = that.option("sorting.mode");
    const {
      rootElement
    } = options2;
    const {
      column
    } = options2;
    const $indicatorsContainer = that._getIndicatorContainer(rootElement);
    if ("sort" === options2.name) {
      rootElement.find(".dx-sort").remove();
      !$indicatorsContainer.children().length && $indicatorsContainer.remove();
      const isSortingAllowed = "none" !== sortingMode && column.allowSorting;
      const hasSeveralSortIndexes = that.getController && !!that.getController("columns").columnOption("sortIndex:1");
      if (!isDefined(column.groupIndex) && (isSortingAllowed || isDefined(column.sortOrder))) {
        ariaSortState = "asc" === column.sortOrder ? "ascending" : "descending";
        $sortIndicator = super._applyColumnState(options2).toggleClass("dx-sort-up", "asc" === column.sortOrder).toggleClass("dx-sort-down", "desc" === column.sortOrder);
        if (hasSeveralSortIndexes && that.option("sorting.showSortIndexes") && column.sortIndex >= 0) {
          renderer_default("<span>").addClass("dx-sort-index-icon").text(column.sortIndex + 1).appendTo($sortIndicator);
          $sortIndicator.addClass("dx-sort-index");
        }
        if (isSortingAllowed) {
          options2.rootElement.addClass(that.addWidgetPrefix("action"));
        }
      }
      this._setAriaSortAttribute(column, ariaSortState, rootElement, hasSeveralSortIndexes);
      return $sortIndicator;
    }
    return super._applyColumnState(options2);
  }
  _setAriaSortAttribute(column, ariaSortState, $rootElement, hasSeveralSortIndexes) {
    $rootElement.removeAttr("aria-roledescription");
    if (column.isGrouped) {
      let description = this.localize("dxDataGrid-ariaNotSortedColumn");
      if (isDefined(column.sortOrder)) {
        description = "asc" === column.sortOrder ? this.localize("dxDataGrid-ariaSortedAscendingColumn") : this.localize("dxDataGrid-ariaSortedDescendingColumn");
      }
      this.setAria("roledescription", description, $rootElement);
    } else if (!isDefined(column.sortOrder)) {
      this.setAria("sort", "none", $rootElement);
    } else {
      this.setAria("sort", ariaSortState, $rootElement);
      if (hasSeveralSortIndexes && column.sortIndex >= 0) {
        const ariaColumnHeader = message_default.format("dxDataGrid-ariaColumnHeader");
        const ariaSortIndex = message_default.format("dxDataGrid-ariaSortIndex", column.sortIndex + 1);
        const description = `${ariaColumnHeader}, ${ariaSortIndex}`;
        this.setAria("roledescription", description, $rootElement);
      }
    }
  }
  _getIndicatorClassName(name2) {
    if ("sort" === name2) {
      return "dx-sort";
    }
    if ("sortIndex" === name2) {
      return "dx-sort-index-icon";
    }
    return super._getIndicatorClassName(name2);
  }
  _renderIndicator(options2) {
    const {
      column
    } = options2;
    const $container = options2.container;
    const $indicator = options2.indicator;
    if ("sort" === options2.name) {
      const rtlEnabled = this.option("rtlEnabled");
      if (!isDefined(column.sortOrder)) {
        $indicator && $indicator.addClass("dx-sort-none");
      }
      if ($container.children().length && (!rtlEnabled && "left" === options2.columnAlignment || rtlEnabled && "right" === options2.columnAlignment)) {
        $container.prepend($indicator);
        return;
      }
    }
    super._renderIndicator(options2);
  }
  _updateIndicator($cell, column, indicatorName) {
    if ("sort" === indicatorName && isDefined(column.groupIndex)) {
      return;
    }
    return super._updateIndicator.apply(this, arguments);
  }
  _getIndicatorElements($cell, returnAll) {
    const $indicatorElements = super._getIndicatorElements($cell);
    return returnAll ? $indicatorElements : $indicatorElements && $indicatorElements.not(".dx-sort-none");
  }
};
var m_sorting_mixin_default = sortingMixin;

// node_modules/devextreme/esm/__internal/grids/grid_core/sorting/m_sorting.js
var columnHeadersView = (Base) => class extends m_sorting_mixin_default(Base) {
  optionChanged(args) {
    const that = this;
    if ("sorting" === args.name) {
      that._invalidate();
      args.handled = true;
    } else {
      super.optionChanged(args);
    }
  }
  _createRow(row) {
    const $row = super._createRow(row);
    if ("header" === row.rowType) {
      m_events_engine_default.on($row, addNamespace2(CLICK_EVENT_NAME, "dxDataGridColumnHeadersView"), "td", this.createAction((e) => {
        this._processHeaderAction(e.event, $row);
      }));
    }
    return $row;
  }
  _processHeaderAction(event, $row) {
    if (renderer_default(event.currentTarget).parent().get(0) !== $row.get(0)) {
      return;
    }
    const that = this;
    let keyName = null;
    const $cellElementFromEvent = renderer_default(event.currentTarget);
    const rowIndex = $cellElementFromEvent.parent().index();
    let columnIndex = -1;
    [].slice.call(that.getCellElements(rowIndex)).some(($cellElement, index2) => {
      if ($cellElement === $cellElementFromEvent.get(0)) {
        columnIndex = index2;
        return true;
      }
      return;
    });
    const visibleColumns = that._columnsController.getVisibleColumns(rowIndex);
    const column = visibleColumns[columnIndex];
    const editingController = that.getController("editing");
    const editingMode = that.option("editing.mode");
    const isCellEditing = editingController && editingController.isEditing() && ("batch" === editingMode || "cell" === editingMode);
    if (isCellEditing || !that._isSortableElement(renderer_default(event.target))) {
      return;
    }
    if (column && !isDefined(column.groupIndex) && !column.command) {
      if (event.shiftKey) {
        keyName = "shift";
      } else if (isCommandKeyPressed(event)) {
        keyName = "ctrl";
      }
      setTimeout(() => {
        that._columnsController.changeSortOrder(column.index, keyName);
      });
    }
  }
  _renderCellContent($cell, options2) {
    const that = this;
    const {
      column
    } = options2;
    if (!column.command && "header" === options2.rowType) {
      that._applyColumnState({
        name: "sort",
        rootElement: $cell,
        column,
        showColumnLines: that.option("showColumnLines")
      });
    }
    super._renderCellContent.apply(this, arguments);
  }
  _columnOptionChanged(e) {
    const {
      changeTypes
    } = e;
    if (1 === changeTypes.length && changeTypes.sorting) {
      this._updateIndicators("sort");
      return;
    }
    super._columnOptionChanged(e);
  }
};
var headerPanel = (Base) => class extends m_sorting_mixin_default(Base) {
  optionChanged(args) {
    const that = this;
    if ("sorting" === args.name) {
      that._invalidate();
      args.handled = true;
    } else {
      super.optionChanged(args);
    }
  }
  _createGroupPanelItem($rootElement, groupColumn) {
    const that = this;
    const $item = super._createGroupPanelItem(...arguments);
    m_events_engine_default.on($item, addNamespace2(CLICK_EVENT_NAME, "dxDataGridHeaderPanel"), that.createAction(() => {
      that._processGroupItemAction(groupColumn.index);
    }));
    that._applyColumnState({
      name: "sort",
      rootElement: $item,
      column: {
        alignment: that.option("rtlEnabled") ? "right" : "left",
        allowSorting: groupColumn.allowSorting,
        sortOrder: "desc" === groupColumn.sortOrder ? "desc" : "asc",
        isGrouped: true
      },
      showColumnLines: true
    });
    return $item;
  }
  _processGroupItemAction(groupColumnIndex) {
    setTimeout(() => this.getController("columns").changeSortOrder(groupColumnIndex));
  }
};
var sortingModule = {
  defaultOptions: () => ({
    sorting: {
      mode: "single",
      ascendingText: message_default.format("dxDataGrid-sortingAscendingText"),
      descendingText: message_default.format("dxDataGrid-sortingDescendingText"),
      clearText: message_default.format("dxDataGrid-sortingClearText"),
      showSortIndexes: true
    }
  }),
  extenders: {
    views: {
      columnHeadersView,
      headerPanel
    }
  }
};

// node_modules/devextreme/esm/__internal/grids/data_grid/module_not_extended/sorting.js
m_core_default.registerModule("sorting", sortingModule);

// node_modules/devextreme/esm/__internal/events/gesture/m_emitter.gesture.scroll.js
var {
  abstract: abstract3
} = class_default;
var realDevice = m_devices_default.real();
var Locker = class_default.inherit(function() {
  const NAMESPACED_SCROLL_EVENT = addNamespace2("scroll", "dxScrollEmitter");
  return {
    ctor(element) {
      this._element = element;
      this._locked = false;
      this._proxiedScroll = (e) => {
        if (!this._disposed) {
          this._scroll(e);
        }
      };
      m_events_engine_default.on(this._element, NAMESPACED_SCROLL_EVENT, this._proxiedScroll);
    },
    _scroll: abstract3,
    check(e, callback) {
      if (this._locked) {
        callback();
      }
    },
    dispose() {
      this._disposed = true;
      m_events_engine_default.off(this._element, NAMESPACED_SCROLL_EVENT, this._proxiedScroll);
    }
  };
}());
var TimeoutLocker = Locker.inherit({
  ctor(element, timeout) {
    this.callBase(element);
    this._timeout = timeout;
  },
  _scroll() {
    this._prepare();
    this._forget();
  },
  _prepare() {
    if (this._timer) {
      this._clearTimer();
    }
    this._locked = true;
  },
  _clearTimer() {
    clearTimeout(this._timer);
    this._locked = false;
    this._timer = null;
  },
  _forget() {
    const that = this;
    this._timer = setTimeout(() => {
      that._clearTimer();
    }, this._timeout);
  },
  dispose() {
    this.callBase();
    this._clearTimer();
  }
});
var WheelLocker = TimeoutLocker.inherit({
  ctor(element) {
    this.callBase(element, 400);
    this._lastWheelDirection = null;
  },
  check(e, callback) {
    this._checkDirectionChanged(e);
    this.callBase(e, callback);
  },
  _checkDirectionChanged(e) {
    if (!isDxMouseWheelEvent(e)) {
      this._lastWheelDirection = null;
      return;
    }
    const direction = e.shiftKey || false;
    const directionChange = null !== this._lastWheelDirection && direction !== this._lastWheelDirection;
    this._lastWheelDirection = direction;
    this._locked = this._locked && !directionChange;
  }
});
var PointerLocker = TimeoutLocker.inherit({
  ctor(element) {
    this.callBase(element, 400);
  }
});
!function() {
  const {
    ios: isIos,
    android: isAndroid
  } = realDevice;
  if (!(isIos || isAndroid)) {
    return;
  }
  PointerLocker = Locker.inherit({
    _scroll() {
      this._locked = true;
      const that = this;
      cancelAnimationFrame(this._scrollFrame);
      this._scrollFrame = requestAnimationFrame(() => {
        that._locked = false;
      });
    },
    check(e, callback) {
      cancelAnimationFrame(this._scrollFrame);
      cancelAnimationFrame(this._checkFrame);
      const that = this;
      const {
        callBase
      } = this;
      this._checkFrame = requestAnimationFrame(() => {
        callBase.call(that, e, callback);
        that._locked = false;
      });
    },
    dispose() {
      this.callBase();
      cancelAnimationFrame(this._scrollFrame);
      cancelAnimationFrame(this._checkFrame);
    }
  });
}();
var ScrollEmitter = m_emitter_gesture_default.inherit(function() {
  const FRAME_DURATION2 = Math.round(1e3 / 60);
  return {
    ctor(element) {
      this.callBase.apply(this, arguments);
      this.direction = "both";
      this._pointerLocker = new PointerLocker(element);
      this._wheelLocker = new WheelLocker(element);
    },
    validate: () => true,
    configure(data17) {
      if (data17.scrollTarget) {
        this._pointerLocker.dispose();
        this._wheelLocker.dispose();
        this._pointerLocker = new PointerLocker(data17.scrollTarget);
        this._wheelLocker = new WheelLocker(data17.scrollTarget);
      }
      this.callBase(data17);
    },
    _init(e) {
      this._wheelLocker.check(e, () => {
        if (isDxMouseWheelEvent(e)) {
          this._accept(e);
        }
      });
      this._pointerLocker.check(e, () => {
        const skipCheck = this.isNative && isMouseEvent(e);
        if (!isDxMouseWheelEvent(e) && !skipCheck) {
          this._accept(e);
        }
      });
      this._fireEvent("dxscrollinit", e);
      this._prevEventData = eventData(e);
    },
    move(e) {
      this.callBase.apply(this, arguments);
      e.isScrollingEvent = this.isNative || e.isScrollingEvent;
    },
    _start(e) {
      this._savedEventData = eventData(e);
      this._fireEvent("dxscrollstart", e);
      this._prevEventData = eventData(e);
    },
    _move(e) {
      const currentEventData = eventData(e);
      this._fireEvent("dxscroll", e, {
        delta: eventDelta(this._prevEventData, currentEventData)
      });
      const delta = eventDelta(this._savedEventData, currentEventData);
      if (delta.time > 200) {
        this._savedEventData = this._prevEventData;
      }
      this._prevEventData = eventData(e);
    },
    _end(e) {
      const endEventDelta = eventDelta(this._prevEventData, eventData(e));
      let velocity = {
        x: 0,
        y: 0
      };
      if (!isDxMouseWheelEvent(e) && endEventDelta.time < 100) {
        const delta = eventDelta(this._savedEventData, this._prevEventData);
        const velocityMultiplier = FRAME_DURATION2 / delta.time;
        velocity = {
          x: delta.x * velocityMultiplier,
          y: delta.y * velocityMultiplier
        };
      }
      this._fireEvent("dxscrollend", e, {
        velocity
      });
    },
    _stop(e) {
      this._fireEvent("dxscrollstop", e);
    },
    cancel(e) {
      this.callBase.apply(this, arguments);
      this._fireEvent("dxscrollcancel", e);
    },
    dispose() {
      this.callBase.apply(this, arguments);
      this._pointerLocker.dispose();
      this._wheelLocker.dispose();
    },
    _clearSelection() {
      if (this.isNative) {
        return;
      }
      return this.callBase.apply(this, arguments);
    },
    _toggleGestureCover() {
      if (this.isNative) {
        return;
      }
      return this.callBase.apply(this, arguments);
    }
  };
}());
m_emitter_registrator_default({
  emitter: ScrollEmitter,
  events: ["dxscrollinit", "dxscrollstart", "dxscroll", "dxscrollend", "dxscrollstop", "dxscrollcancel"]
});
var m_emitter_gesture_scroll_default = {
  init: "dxscrollinit",
  start: "dxscrollstart",
  move: "dxscroll",
  end: "dxscrollend",
  stop: "dxscrollstop",
  cancel: "dxscrollcancel",
  scroll: "scroll"
};

// node_modules/devextreme/esm/__internal/ui/scroll_view/consts.js
var DIRECTION_VERTICAL = "vertical";
var DIRECTION_HORIZONTAL = "horizontal";
var DIRECTION_BOTH = "both";
var SCROLLABLE_CONTENT_CLASS = "dx-scrollable-content";

// node_modules/devextreme/esm/__internal/ui/scroll_view/utils/get_relative_offset.js
function getRelativeOffset(targetElementClass, sourceElement) {
  const offset2 = {
    left: 0,
    top: 0
  };
  let element = sourceElement;
  while (null !== (_element = element) && void 0 !== _element && _element.offsetParent && !element.classList.contains(targetElementClass)) {
    var _element;
    const parentElement = element.offsetParent;
    const elementRect = element.getBoundingClientRect();
    const parentElementRect = parentElement.getBoundingClientRect();
    offset2.left += elementRect.left - parentElementRect.left;
    offset2.top += elementRect.top - parentElementRect.top;
    element = element.offsetParent;
  }
  return offset2;
}

// node_modules/devextreme/esm/__internal/ui/scroll_view/utils/get_element_location_internal.js
function getElementLocationInternal(targetElement, direction, containerElement, scrollOffset, offset2) {
  let scrollableContentClass = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : SCROLLABLE_CONTENT_CLASS;
  const additionalOffset = _extends({
    top: 0,
    left: 0,
    right: 0,
    bottom: 0
  }, offset2);
  const isVertical = direction === DIRECTION_VERTICAL;
  const prop = isVertical ? "top" : "left";
  const inverseProp = isVertical ? "bottom" : "right";
  const dimension = isVertical ? "height" : "width";
  const containerOffsetSize = containerElement[`offset${titleize(dimension)}`];
  const containerClientSize = containerElement[`client${titleize(dimension)}`];
  const containerSize = containerElement.getBoundingClientRect()[dimension];
  const elementSize2 = targetElement.getBoundingClientRect()[dimension];
  let scale = 1;
  if (Math.abs(containerSize - containerOffsetSize) > 1) {
    scale = containerSize / containerOffsetSize;
  }
  const relativeElementOffset = getRelativeOffset(scrollableContentClass, targetElement)[prop] / scale;
  const containerScrollOffset = scrollOffset[prop];
  const relativeStartOffset = containerScrollOffset - relativeElementOffset + additionalOffset[prop];
  const relativeEndOffset = containerScrollOffset - relativeElementOffset - elementSize2 / scale + containerClientSize - additionalOffset[inverseProp];
  if (relativeStartOffset <= 0 && relativeEndOffset >= 0) {
    return containerScrollOffset;
  }
  return containerScrollOffset - (Math.abs(relativeStartOffset) > Math.abs(relativeEndOffset) ? relativeEndOffset : relativeStartOffset);
}

// node_modules/devextreme/esm/__internal/ui/scroll_view/m_scrollable.device.js
var deviceDependentOptions = function() {
  return [{
    device: () => !m_support_default.nativeScrolling,
    options: {
      useNative: false
    }
  }, {
    device: (device) => !devices_default.isSimulator() && "desktop" === devices_default.real().deviceType && "generic" === device.platform,
    options: {
      bounceEnabled: false,
      scrollByThumb: true,
      scrollByContent: m_support_default.touch,
      showScrollbar: "onHover"
    }
  }];
};

// node_modules/devextreme/esm/__internal/ui/scroll_view/m_scrollbar.js
var SCROLLBAR = "dxScrollbar";
var HOVER_ENABLED_STATE = "dx-scrollbar-hoverable";
var HORIZONTAL = "horizontal";
var SCROLLBAR_VISIBLE = {
  onScroll: "onScroll",
  onHover: "onHover",
  always: "always",
  never: "never"
};
var activeScrollbar = null;
var Scrollbar = class extends widget_default {
  _getDefaultOptions() {
    return _extends({}, super._getDefaultOptions(), {
      direction: null,
      visible: false,
      activeStateEnabled: false,
      visibilityMode: SCROLLBAR_VISIBLE.onScroll,
      containerSize: 0,
      contentSize: 0,
      expandable: true,
      scaleRatio: 1
    });
  }
  _init() {
    super._init();
    this._isHovered = false;
  }
  _initMarkup() {
    this._renderThumb();
    super._initMarkup();
  }
  _render() {
    super._render();
    this._renderDirection();
    this._update();
    this._attachPointerDownHandler();
    this.option("hoverStateEnabled", this._isHoverMode());
    const {
      hoverStateEnabled
    } = this.option();
    this.$element().toggleClass(HOVER_ENABLED_STATE, hoverStateEnabled);
  }
  _renderThumb() {
    this._$thumb = renderer_default("<div>").addClass("dx-scrollable-scroll");
    renderer_default("<div>").addClass("dx-scrollable-scroll-content").appendTo(this._$thumb);
    this.$element().addClass("dx-scrollable-scrollbar").append(this._$thumb);
  }
  isThumb($element) {
    return !!this.$element().find($element).length;
  }
  _isHoverMode() {
    const {
      visibilityMode,
      expandable
    } = this.option();
    return (visibilityMode === SCROLLBAR_VISIBLE.onHover || visibilityMode === SCROLLBAR_VISIBLE.always) && expandable;
  }
  _renderDirection() {
    const {
      direction
    } = this.option();
    this.$element().addClass(`dx-scrollbar-${direction}`);
    this._dimension = direction === HORIZONTAL ? "width" : "height";
    this._prop = direction === HORIZONTAL ? "left" : "top";
  }
  _attachPointerDownHandler() {
    m_events_engine_default.on(this._$thumb, addNamespace2(m_pointer_default.down, SCROLLBAR), this.feedbackOn.bind(this));
  }
  feedbackOn(e) {
    null === e || void 0 === e || e.preventDefault();
    this.$element().addClass("dx-scrollable-scrollbar-active");
    activeScrollbar = this;
  }
  feedbackOff() {
    this.$element().removeClass("dx-scrollable-scrollbar-active");
    activeScrollbar = null;
  }
  cursorEnter() {
    this._isHovered = true;
    if (this._needScrollbar()) {
      this.option("visible", true);
    }
  }
  cursorLeave() {
    this._isHovered = false;
    this.option("visible", false);
  }
  _renderDimensions() {
    this._$thumb.css({
      width: this.option("width"),
      height: this.option("height")
    });
  }
  _toggleVisibility(visible2) {
    const {
      visibilityMode
    } = this.option();
    if (visibilityMode === SCROLLBAR_VISIBLE.onScroll) {
      this._$thumb.css("opacity");
    }
    visible2 = this._adjustVisibility(visible2);
    this.option().visible = visible2;
    this._$thumb.toggleClass("dx-state-invisible", !visible2);
  }
  _adjustVisibility(visible2) {
    if (this._baseContainerToContentRatio && !this._needScrollbar()) {
      return false;
    }
    const {
      visibilityMode
    } = this.option();
    switch (visibilityMode) {
      case SCROLLBAR_VISIBLE.onScroll:
        break;
      case SCROLLBAR_VISIBLE.onHover:
        visible2 = visible2 || !!this._isHovered;
        break;
      case SCROLLBAR_VISIBLE.never:
        visible2 = false;
        break;
      case SCROLLBAR_VISIBLE.always:
        visible2 = true;
    }
    return visible2;
  }
  moveTo(location) {
    if (this._isHidden()) {
      return;
    }
    if (isPlainObject(location)) {
      location = location[this._prop] || 0;
    }
    const scrollBarLocation = {};
    scrollBarLocation[this._prop] = this._calculateScrollBarPosition(location);
    move(this._$thumb, scrollBarLocation);
  }
  _calculateScrollBarPosition(location) {
    return -location * this._thumbRatio;
  }
  _update() {
    const containerSize = Math.round(this.option("containerSize"));
    const contentSize = Math.round(this.option("contentSize"));
    let baseContainerSize = Math.round(this.option("baseContainerSize"));
    let baseContentSize = Math.round(this.option("baseContentSize"));
    if (isNaN(baseContainerSize)) {
      baseContainerSize = containerSize;
      baseContentSize = contentSize;
    }
    const {
      scaleRatio
    } = this.option();
    this._baseContainerToContentRatio = baseContentSize ? baseContainerSize / baseContentSize : baseContainerSize;
    this._realContainerToContentRatio = contentSize ? containerSize / contentSize : containerSize;
    const thumbSize = Math.round(Math.max(Math.round(containerSize * this._realContainerToContentRatio), 15));
    this._thumbRatio = (containerSize - thumbSize) / (scaleRatio * (contentSize - containerSize));
    this.option(this._dimension, thumbSize / scaleRatio);
    this.$element().css("display", this._needScrollbar() ? "" : "none");
  }
  _isHidden() {
    const {
      visibilityMode
    } = this.option();
    return visibilityMode === SCROLLBAR_VISIBLE.never;
  }
  _needScrollbar() {
    return !this._isHidden() && this._baseContainerToContentRatio < 1;
  }
  containerToContentRatio() {
    return this._realContainerToContentRatio;
  }
  _normalizeSize(size) {
    return isPlainObject(size) ? size[this._dimension] || 0 : size;
  }
  _clean() {
    super._clean();
    if (this === activeScrollbar) {
      activeScrollbar = null;
    }
    m_events_engine_default.off(this._$thumb, `.${SCROLLBAR}`);
  }
  _optionChanged(args) {
    if (this._isHidden()) {
      return;
    }
    switch (args.name) {
      case "containerSize":
      case "contentSize":
        this.option()[args.name] = this._normalizeSize(args.value);
        this._update();
        break;
      case "baseContentSize":
      case "baseContainerSize":
      case "scaleRatio":
        this._update();
        break;
      case "visibilityMode":
      case "direction":
        this._invalidate();
        break;
      default:
        super._optionChanged.apply(this, arguments);
    }
  }
  update() {
    deferRenderer(() => {
      this._adjustVisibility() && this.option("visible", true);
    })();
  }
};
ready_callbacks_default.add(() => {
  m_events_engine_default.subscribeGlobal(dom_adapter_default.getDocument(), addNamespace2(m_pointer_default.up, SCROLLBAR), () => {
    if (activeScrollbar) {
      activeScrollbar.feedbackOff();
    }
  });
});
var m_scrollbar_default = Scrollbar;

// node_modules/devextreme/esm/__internal/ui/scroll_view/m_scrollable.native.js
var SCROLLABLE_NATIVE = "dxNativeScrollable";
var SCROLLABLE_SCROLLBAR_SIMULATED = "dx-scrollable-scrollbar-simulated";
var SCROLLABLE_SCROLLBARS_HIDDEN = "dx-scrollable-scrollbars-hidden";
var VERTICAL = "vertical";
var HORIZONTAL2 = "horizontal";
var NativeStrategy = class extends class_default.inherit({}) {
  ctor(scrollable) {
    this._init(scrollable);
  }
  _init(scrollable) {
    this._component = scrollable;
    this._$element = scrollable.$element();
    this._$container = renderer_default(scrollable.container());
    this._$content = scrollable.$content();
    const {
      direction,
      useSimulatedScrollbar
    } = scrollable.option();
    this._direction = direction;
    this._useSimulatedScrollbar = useSimulatedScrollbar;
    this.option = scrollable.option.bind(scrollable);
    this._createActionByOption = scrollable._createActionByOption.bind(scrollable);
    this._isLocked = scrollable._isLocked.bind(scrollable);
    this._isDirection = scrollable._isDirection.bind(scrollable);
    this._allowedDirection = scrollable._allowedDirection.bind(scrollable);
    this._getMaxOffset = scrollable._getMaxOffset.bind(scrollable);
    this._isRtlNativeStrategy = scrollable._isRtlNativeStrategy.bind(scrollable);
  }
  render() {
    const device = devices_default.real();
    const deviceType = device.platform;
    this._$element.addClass("dx-scrollable-native").addClass(`dx-scrollable-native-${deviceType}`).toggleClass(SCROLLABLE_SCROLLBARS_HIDDEN, !this._isScrollbarVisible());
    if (this._isScrollbarVisible() && this._useSimulatedScrollbar) {
      this._renderScrollbars();
    }
  }
  updateRtlPosition(isFirstRender) {
    if (isFirstRender && this.option("rtlEnabled")) {
      if (this._isScrollbarVisible() && this._useSimulatedScrollbar) {
        this._moveScrollbars();
      }
    }
  }
  _renderScrollbars() {
    this._scrollbars = {};
    this._hideScrollbarTimeout = 0;
    this._$element.addClass(SCROLLABLE_SCROLLBAR_SIMULATED);
    this._renderScrollbar(VERTICAL);
    this._renderScrollbar(HORIZONTAL2);
  }
  _renderScrollbar(direction) {
    if (!this._isDirection(direction)) {
      return;
    }
    this._scrollbars[direction] = new m_scrollbar_default(renderer_default("<div>").appendTo(this._$element), {
      direction,
      expandable: this._component.option("scrollByThumb")
    });
  }
  handleInit(e) {
  }
  handleStart() {
  }
  handleMove(e) {
    if (this._isLocked()) {
      e.cancel = true;
      return;
    }
    if (this._allowedDirection()) {
      e.originalEvent.isScrollingEvent = true;
    }
  }
  handleEnd() {
  }
  handleCancel() {
  }
  handleStop() {
  }
  _eachScrollbar(callback) {
    callback = callback.bind(this);
    each(this._scrollbars || {}, (direction, scrollbar) => {
      callback(scrollbar, direction);
    });
  }
  createActions() {
    this._scrollAction = this._createActionByOption("onScroll");
    this._updateAction = this._createActionByOption("onUpdated");
  }
  _createActionArgs() {
    const {
      left,
      top
    } = this.location();
    return {
      event: this._eventForUserAction,
      scrollOffset: this._getScrollOffset(),
      reachedLeft: this._isRtlNativeStrategy() ? this._isReachedRight(-left) : this._isReachedLeft(left),
      reachedRight: this._isRtlNativeStrategy() ? this._isReachedLeft(-Math.abs(left)) : this._isReachedRight(left),
      reachedTop: this._isDirection(VERTICAL) ? Math.round(top) >= 0 : void 0,
      reachedBottom: this._isDirection(VERTICAL) ? Math.round(Math.abs(top) - this._getMaxOffset().top) >= 0 : void 0
    };
  }
  _getScrollOffset() {
    const {
      top,
      left
    } = this.location();
    return {
      top: -top,
      left: this._normalizeOffsetLeft(-left)
    };
  }
  _normalizeOffsetLeft(scrollLeft) {
    if (this._isRtlNativeStrategy()) {
      return this._getMaxOffset().left + scrollLeft;
    }
    return scrollLeft;
  }
  _isReachedLeft(left) {
    return this._isDirection(HORIZONTAL2) ? Math.round(left) >= 0 : void 0;
  }
  _isReachedRight(left) {
    return this._isDirection(HORIZONTAL2) ? Math.round(Math.abs(left) - this._getMaxOffset().left) >= 0 : void 0;
  }
  _isScrollbarVisible() {
    const {
      showScrollbar
    } = this.option();
    return "never" !== showScrollbar && false !== showScrollbar;
  }
  handleScroll(e) {
    var _this$_scrollAction;
    this._eventForUserAction = e;
    this._moveScrollbars();
    null === (_this$_scrollAction = this._scrollAction) || void 0 === _this$_scrollAction || _this$_scrollAction.call(this, this._createActionArgs());
  }
  _moveScrollbars() {
    const {
      top,
      left
    } = this._getScrollOffset();
    this._eachScrollbar((scrollbar) => {
      scrollbar.moveTo({
        top: -top,
        left: -left
      });
      scrollbar.option("visible", true);
    });
    this._hideScrollbars();
  }
  _hideScrollbars() {
    clearTimeout(this._hideScrollbarTimeout);
    this._hideScrollbarTimeout = setTimeout(() => {
      this._eachScrollbar((scrollbar) => {
        scrollbar.option("visible", false);
      });
    }, 500);
  }
  location() {
    return {
      left: -this._$container.scrollLeft(),
      top: -this._$container.scrollTop()
    };
  }
  disabledChanged() {
  }
  update() {
    this._update();
    this._updateAction(this._createActionArgs());
  }
  _update() {
    this._updateDimensions();
    this._updateScrollbars();
  }
  _updateDimensions() {
    this._containerSize = {
      height: getHeight(this._$container),
      width: getWidth(this._$container)
    };
    this._componentContentSize = {
      height: getHeight(this._component.$content()),
      width: getWidth(this._component.$content())
    };
    this._contentSize = {
      height: getHeight(this._$content),
      width: getWidth(this._$content)
    };
  }
  _updateScrollbars() {
    this._eachScrollbar(function(scrollbar, direction) {
      const dimension = direction === VERTICAL ? "height" : "width";
      scrollbar.option({
        containerSize: this._containerSize[dimension],
        contentSize: this._componentContentSize[dimension]
      });
      scrollbar.update();
    });
  }
  _allowedDirections() {
    return {
      vertical: this._isDirection(VERTICAL) && this._contentSize.height > this._containerSize.height,
      horizontal: this._isDirection(HORIZONTAL2) && this._contentSize.width > this._containerSize.width
    };
  }
  dispose() {
    const {
      className
    } = this._$element.get(0);
    const scrollableNativeRegexp = new RegExp("dx-scrollable-native\\S*", "g");
    if (scrollableNativeRegexp.test(className)) {
      this._$element.removeClass(className.match(scrollableNativeRegexp).join(" "));
    }
    m_events_engine_default.off(this._$element, `.${SCROLLABLE_NATIVE}`);
    m_events_engine_default.off(this._$container, `.${SCROLLABLE_NATIVE}`);
    this._removeScrollbars();
    clearTimeout(this._hideScrollbarTimeout);
  }
  _removeScrollbars() {
    this._eachScrollbar((scrollbar) => {
      scrollbar.$element().remove();
    });
  }
  scrollBy(distance) {
    const location = this.location();
    this._$container.scrollTop(Math.round(-location.top - distance.top));
    this._$container.scrollLeft(Math.round(-location.left - distance.left));
  }
  validate(e) {
    const {
      disabled
    } = this.option();
    if (disabled) {
      return false;
    }
    if (isDxMouseWheelEvent(e) && this._isScrolledInMaxDirection(e)) {
      return false;
    }
    return !!this._allowedDirection();
  }
  _isScrolledInMaxDirection(e) {
    const container = this._$container.get(0);
    let result2;
    if (e.delta > 0) {
      result2 = e.shiftKey ? !container.scrollLeft : !container.scrollTop;
    } else if (e.shiftKey) {
      result2 = container.scrollLeft >= this._getMaxOffset().left;
    } else {
      result2 = container.scrollTop >= this._getMaxOffset().top;
    }
    return result2;
  }
  getDirection() {
    return this._allowedDirection();
  }
};
var m_scrollable_native_default = NativeStrategy;

// node_modules/devextreme/esm/__internal/ui/scroll_view/m_animator.js
var Animator = class extends class_default.inherit({}) {
  ctor(strategy3) {
    this._finished = true;
    this._stopped = false;
    this._proxiedStepCore = this._stepCore.bind(this);
  }
  start() {
    this._stopped = false;
    this._finished = false;
    this._stepCore();
  }
  stop() {
    this._stopped = true;
    cancelAnimationFrame(this._stepAnimationFrame);
  }
  _stepCore() {
    if (this._isStopped()) {
      this._stop();
      return;
    }
    if (this._isFinished()) {
      this._finished = true;
      this._complete();
      return;
    }
    this._step();
    this._stepAnimationFrame = requestAnimationFrame(this._proxiedStepCore);
  }
  _step() {
    class_default.abstract();
  }
  _isFinished() {
  }
  _stop() {
  }
  _complete() {
  }
  _isStopped() {
    return this._stopped;
  }
  inProgress() {
    return !(this._stopped || this._finished);
  }
};
var m_animator_default = Animator;

// node_modules/devextreme/esm/__internal/ui/scroll_view/m_scrollable.simulated.js
var SCROLLABLE_SIMULATED = "dxSimulatedScrollable";
var SCROLLABLE_STRATEGY = "dxScrollableStrategy";
var SCROLLABLE_SIMULATED_CURSOR = `${SCROLLABLE_SIMULATED}Cursor`;
var SCROLLABLE_SIMULATED_KEYBOARD = `${SCROLLABLE_SIMULATED}Keyboard`;
var SCROLLABLE_SCROLLBARS_ALWAYSVISIBLE = "dx-scrollable-scrollbars-alwaysvisible";
var VERTICAL2 = "vertical";
var HORIZONTAL3 = "horizontal";
var FRAME_DURATION = Math.round(1e3 / 60);
var BOUNCE_FRAMES = 400 / FRAME_DURATION;
var BOUNCE_ACCELERATION_SUM = (1 - 0.92 ** BOUNCE_FRAMES) / (1 - 0.92);
var KEY_CODES2 = {
  PAGE_UP: "pageUp",
  PAGE_DOWN: "pageDown",
  END: "end",
  HOME: "home",
  LEFT: "leftArrow",
  UP: "upArrow",
  RIGHT: "rightArrow",
  DOWN: "downArrow",
  TAB: "tab"
};
var InertiaAnimator = class extends m_animator_default {
  constructor() {
    super(...arguments);
    this.VELOCITY_LIMIT = 1;
  }
  ctor(scroller) {
    super.ctor();
    this.scroller = scroller;
  }
  _isFinished() {
    return Math.abs(this.scroller._velocity) <= this.VELOCITY_LIMIT;
  }
  _step() {
    this.scroller._scrollStep(this.scroller._velocity);
    this.scroller._velocity *= this._acceleration();
  }
  _acceleration() {
    return this.scroller._inBounds() ? 0.92 : 0.5;
  }
  _complete() {
    this.scroller._scrollComplete();
  }
};
var BounceAnimator = class extends InertiaAnimator {
  constructor() {
    super(...arguments);
    this.VELOCITY_LIMIT = 0.2;
  }
  _isFinished() {
    return this.scroller._crossBoundOnNextStep() || super._isFinished();
  }
  _acceleration() {
    return 0.92;
  }
  _complete() {
    this.scroller._move(this.scroller._bounceLocation);
    super._complete();
  }
};
var Scroller = class extends class_default.inherit({}) {
  ctor(options2) {
    this._initOptions(options2);
    this._initAnimators();
    this._initScrollbar();
  }
  _initOptions(options2) {
    this._location = 0;
    this._topReached = false;
    this._bottomReached = false;
    this._axis = options2.direction === HORIZONTAL3 ? "x" : "y";
    this._prop = options2.direction === HORIZONTAL3 ? "left" : "top";
    this._dimension = options2.direction === HORIZONTAL3 ? "width" : "height";
    this._scrollProp = options2.direction === HORIZONTAL3 ? "scrollLeft" : "scrollTop";
    each(options2, (optionName, optionValue) => {
      this[`_${optionName}`] = optionValue;
    });
  }
  _initAnimators() {
    this._inertiaAnimator = new InertiaAnimator(this);
    this._bounceAnimator = new BounceAnimator(this);
  }
  _initScrollbar() {
    this._scrollbar = new m_scrollbar_default(renderer_default("<div>").appendTo(this._$container), {
      direction: this._direction,
      visible: this._scrollByThumb,
      visibilityMode: this._visibilityModeNormalize(this._scrollbarVisible),
      expandable: this._scrollByThumb
    });
    this._$scrollbar = this._scrollbar.$element();
  }
  _visibilityModeNormalize(mode) {
    return true === mode ? "onScroll" : false === mode ? "never" : mode;
  }
  _scrollStep(delta) {
    const prevLocation = this._location;
    this._location += delta;
    this._suppressBounce();
    this._move();
    if (Math.abs(prevLocation - this._location) < 1) {
      return;
    }
    m_events_engine_default.triggerHandler(this._$container, {
      type: "scroll"
    });
  }
  _suppressBounce() {
    if (this._bounceEnabled || this._inBounds(this._location)) {
      return;
    }
    this._velocity = 0;
    this._location = this._boundLocation();
  }
  _boundLocation(location) {
    location = void 0 !== location ? location : this._location;
    return Math.max(Math.min(location, this._maxOffset), this._minOffset);
  }
  _move(location) {
    this._location = void 0 !== location ? location * this._getScaleRatio() : this._location;
    this._moveContent();
    this._moveScrollbar();
  }
  _moveContent() {
    const location = this._location;
    this._$container[this._scrollProp](-location / this._getScaleRatio());
    this._moveContentByTranslator(location);
  }
  _getScaleRatio() {
    if (hasWindow() && !this._scaleRatio) {
      const element = this._$element.get(0);
      const realDimension = this._getRealDimension(element, this._dimension);
      const baseDimension = this._getBaseDimension(element, this._dimension);
      this._scaleRatio = Math.round(realDimension / baseDimension * 100) / 100;
    }
    return this._scaleRatio || 1;
  }
  _getRealDimension(element, dimension) {
    return Math.round(getBoundingRect(element)[dimension]);
  }
  _getBaseDimension(element, dimension) {
    const dimensionName = `offset${titleize(dimension)}`;
    return element[dimensionName];
  }
  _moveContentByTranslator(location) {
    let translateOffset;
    const minOffset = -this._maxScrollPropValue;
    if (location > 0) {
      translateOffset = location;
    }
    if (location <= minOffset) {
      translateOffset = location - minOffset;
    }
    if (this._translateOffset === translateOffset) {
      return;
    }
    const targetLocation = {};
    targetLocation[this._prop] = translateOffset;
    this._translateOffset = translateOffset;
    if (!translateOffset) {
      resetPosition(this._$content);
      return;
    }
    move(this._$content, targetLocation);
  }
  _moveScrollbar() {
    this._scrollbar.moveTo(this._location);
  }
  _scrollComplete() {
    if (this._inBounds()) {
      this._hideScrollbar();
      if (this._completeDeferred) {
        this._completeDeferred.resolve();
      }
    }
    this._scrollToBounds();
  }
  _scrollToBounds() {
    var _this$_bounceAction;
    if (this._inBounds()) {
      return;
    }
    null === (_this$_bounceAction = this._bounceAction) || void 0 === _this$_bounceAction || _this$_bounceAction.call(this);
    this._setupBounce();
    this._bounceAnimator.start();
  }
  _setupBounce() {
    const boundLocation = this._bounceLocation = this._boundLocation();
    const bounceDistance = boundLocation - this._location;
    this._velocity = bounceDistance / BOUNCE_ACCELERATION_SUM;
  }
  _inBounds(location) {
    location = void 0 !== location ? location : this._location;
    return this._boundLocation(location) === location;
  }
  _crossBoundOnNextStep() {
    const location = this._location;
    const nextLocation = location + this._velocity;
    return location < this._minOffset && nextLocation >= this._minOffset || location > this._maxOffset && nextLocation <= this._maxOffset;
  }
  _initHandler(e) {
    this._stopScrolling();
    this._prepareThumbScrolling(e);
  }
  _stopScrolling() {
    deferRenderer(() => {
      this._hideScrollbar();
      this._inertiaAnimator.stop();
      this._bounceAnimator.stop();
    })();
  }
  _prepareThumbScrolling(e) {
    if (isDxMouseWheelEvent(e.originalEvent)) {
      return;
    }
    const $target = renderer_default(e.originalEvent.target);
    const scrollbarClicked = this._isScrollbar($target);
    if (scrollbarClicked) {
      this._moveToMouseLocation(e);
    }
    this._thumbScrolling = scrollbarClicked || this._isThumb($target);
    this._crossThumbScrolling = !this._thumbScrolling && this._isAnyThumbScrolling($target);
    if (this._thumbScrolling) {
      this._scrollbar.feedbackOn();
    }
  }
  _isThumbScrollingHandler($target) {
    return this._isThumb($target);
  }
  _moveToMouseLocation(e) {
    const mouseLocation = e[`page${this._axis.toUpperCase()}`] - this._$element.offset()[this._prop];
    const location = this._location + mouseLocation / this._containerToContentRatio() - getHeight(this._$container) / 2;
    this._scrollStep(-Math.round(location));
  }
  _startHandler() {
    this._showScrollbar();
  }
  _moveHandler(delta) {
    if (this._crossThumbScrolling) {
      return;
    }
    if (this._thumbScrolling) {
      delta[this._axis] = -Math.round(delta[this._axis] / this._containerToContentRatio());
    }
    this._scrollBy(delta);
  }
  _scrollBy(delta) {
    delta = delta[this._axis];
    if (!this._inBounds()) {
      delta *= 0.5;
    }
    this._scrollStep(delta);
  }
  _scrollByHandler(delta) {
    if (!delta.x && !delta.y) {
      return;
    }
    this._scrollBy(delta);
    this._scrollComplete();
  }
  _containerToContentRatio() {
    return this._scrollbar.containerToContentRatio();
  }
  _endHandler(velocity) {
    this._completeDeferred = Deferred();
    this._velocity = velocity[this._axis];
    this._inertiaHandler();
    this._resetThumbScrolling();
    return this._completeDeferred.promise();
  }
  _inertiaHandler() {
    this._suppressInertia();
    this._inertiaAnimator.start();
  }
  _suppressInertia() {
    if (!this._inertiaEnabled || this._thumbScrolling) {
      this._velocity = 0;
    }
  }
  _resetThumbScrolling() {
    this._thumbScrolling = false;
    this._crossThumbScrolling = false;
  }
  _stopHandler() {
    if (this._thumbScrolling) {
      this._scrollComplete();
    }
    this._resetThumbScrolling();
    this._scrollToBounds();
  }
  _disposeHandler() {
    this._stopScrolling();
    this._$scrollbar.remove();
  }
  _updateHandler() {
    this._update();
    this._moveToBounds();
  }
  _update() {
    this._stopScrolling();
    return deferUpdate(() => {
      this._resetScaleRatio();
      this._updateLocation();
      this._updateBounds();
      this._updateScrollbar();
      deferRender(() => {
        this._moveScrollbar();
        this._scrollbar.update();
      });
    });
  }
  _resetScaleRatio() {
    this._scaleRatio = null;
  }
  _updateLocation() {
    this._location = (locate(this._$content)[this._prop] - this._$container[this._scrollProp]()) * this._getScaleRatio();
  }
  _updateBounds() {
    this._maxOffset = this._getMaxOffset();
    this._minOffset = this._getMinOffset();
  }
  _getMaxOffset() {
    return 0;
  }
  _getMinOffset() {
    this._maxScrollPropValue = Math.max(this._contentSize() - this._containerSize(), 0);
    return -this._maxScrollPropValue;
  }
  _updateScrollbar() {
    deferUpdater(() => {
      const containerSize = this._containerSize();
      const contentSize = this._contentSize();
      const baseContainerSize = this._getBaseDimension(this._$container.get(0), this._dimension);
      const baseContentSize = this._getBaseDimension(this._$content.get(0), this._dimension);
      deferRender(() => {
        this._scrollbar.option({
          containerSize,
          contentSize,
          baseContainerSize,
          baseContentSize,
          scaleRatio: this._getScaleRatio()
        });
      });
    })();
  }
  _moveToBounds() {
    deferRenderer(deferUpdater(deferRenderer(() => {
      const location = this._boundLocation();
      const locationChanged = location !== this._location;
      this._location = location;
      this._move();
      if (locationChanged) {
        var _this$_scrollAction;
        null === (_this$_scrollAction = this._scrollAction) || void 0 === _this$_scrollAction || _this$_scrollAction.call(this);
      }
    })))();
  }
  _createActionsHandler(actions) {
    this._scrollAction = actions.scroll;
    this._bounceAction = actions.bounce;
  }
  _showScrollbar() {
    this._scrollbar.option("visible", true);
  }
  _hideScrollbar() {
    this._scrollbar.option("visible", false);
  }
  _containerSize() {
    return this._getRealDimension(this._$container.get(0), this._dimension);
  }
  _contentSize() {
    const isOverflowHidden = "hidden" === this._$content.css(`overflow${this._axis.toUpperCase()}`);
    let contentSize = this._getRealDimension(this._$content.get(0), this._dimension);
    if (!isOverflowHidden) {
      const containerScrollSize = this._$content[0][`scroll${titleize(this._dimension)}`] * this._getScaleRatio();
      contentSize = Math.max(containerScrollSize, contentSize);
    }
    return contentSize;
  }
  _validateEvent(e) {
    const $target = renderer_default(e.originalEvent.target);
    return this._isThumb($target) || this._isScrollbar($target);
  }
  _isThumb($element) {
    return this._scrollByThumb && this._scrollbar.isThumb($element);
  }
  _isScrollbar($element) {
    return this._scrollByThumb && (null === $element || void 0 === $element ? void 0 : $element.is(this._$scrollbar));
  }
  _reachedMin() {
    return Math.round(this._location - this._minOffset) <= 0;
  }
  _reachedMax() {
    return Math.round(this._location - this._maxOffset) >= 0;
  }
  _cursorEnterHandler() {
    this._resetScaleRatio();
    this._updateScrollbar();
    this._scrollbar.cursorEnter();
  }
  _cursorLeaveHandler() {
    this._scrollbar.cursorLeave();
  }
  dispose() {
  }
};
var hoveredScrollable;
var activeScrollable;
var SimulatedStrategy = class extends class_default.inherit({}) {
  ctor(scrollable) {
    this._init(scrollable);
  }
  _init(scrollable) {
    this._component = scrollable;
    this._$element = scrollable.$element();
    this._$container = renderer_default(scrollable.container());
    this._$wrapper = scrollable._$wrapper;
    this._$content = scrollable.$content();
    this.option = scrollable.option.bind(scrollable);
    this._createActionByOption = scrollable._createActionByOption.bind(scrollable);
    this._isLocked = scrollable._isLocked.bind(scrollable);
    this._isDirection = scrollable._isDirection.bind(scrollable);
    this._allowedDirection = scrollable._allowedDirection.bind(scrollable);
    this._getMaxOffset = scrollable._getMaxOffset.bind(scrollable);
  }
  render() {
    this._$element.addClass("dx-scrollable-simulated");
    this._createScrollers();
    if (this.option("useKeyboard")) {
      this._$container.prop("tabIndex", 0);
    }
    this._attachKeyboardHandler();
    this._attachCursorHandlers();
  }
  _createScrollers() {
    this._scrollers = {};
    if (this._isDirection(HORIZONTAL3)) {
      this._createScroller(HORIZONTAL3);
    }
    if (this._isDirection(VERTICAL2)) {
      this._createScroller(VERTICAL2);
    }
    this._$element.toggleClass(SCROLLABLE_SCROLLBARS_ALWAYSVISIBLE, "always" === this.option("showScrollbar"));
  }
  _createScroller(direction) {
    this._scrollers[direction] = new Scroller(this._scrollerOptions(direction));
  }
  _scrollerOptions(direction) {
    return {
      direction,
      $content: this._$content,
      $container: this._$container,
      $wrapper: this._$wrapper,
      $element: this._$element,
      scrollByThumb: this.option("scrollByThumb"),
      scrollbarVisible: this.option("showScrollbar"),
      bounceEnabled: this.option("bounceEnabled"),
      inertiaEnabled: this.option("inertiaEnabled"),
      isAnyThumbScrolling: this._isAnyThumbScrolling.bind(this)
    };
  }
  _applyScaleRatio(targetLocation) {
    for (const direction in this._scrollers) {
      const prop = this._getPropByDirection(direction);
      if (isDefined(targetLocation[prop])) {
        const scroller = this._scrollers[direction];
        targetLocation[prop] *= scroller._getScaleRatio();
      }
    }
    return targetLocation;
  }
  _isAnyThumbScrolling($target) {
    let result2 = false;
    this._eventHandler("isThumbScrolling", $target).done((isThumbScrollingVertical, isThumbScrollingHorizontal) => {
      result2 = isThumbScrollingVertical || isThumbScrollingHorizontal;
    });
    return result2;
  }
  handleInit(e) {
    this._suppressDirections(e);
    this._eventForUserAction = e;
    this._eventHandler("init", e);
  }
  _suppressDirections(e) {
    if (isDxMouseWheelEvent(e.originalEvent)) {
      this._prepareDirections(true);
      return;
    }
    this._prepareDirections();
    this._eachScroller(function(scroller, direction) {
      const $target = renderer_default(e.originalEvent.target);
      const isValid = scroller._validateEvent(e) || this.option("scrollByContent") && this._isContent($target);
      this._validDirections[direction] = isValid;
    });
  }
  _isContent($element) {
    return !!$element.closest(this._$element).length;
  }
  _prepareDirections(value2) {
    value2 = value2 || false;
    this._validDirections = {};
    this._validDirections[HORIZONTAL3] = value2;
    this._validDirections[VERTICAL2] = value2;
  }
  _eachScroller(callback) {
    callback = callback.bind(this);
    each(this._scrollers, (direction, scroller) => {
      callback(scroller, direction);
    });
  }
  handleStart(e) {
    this._eventForUserAction = e;
    this._eventHandler("start").done(this._startAction);
  }
  _saveActive() {
    activeScrollable = this;
  }
  _resetActive() {
    if (activeScrollable === this) {
      activeScrollable = null;
    }
  }
  handleMove(e) {
    var _e$preventDefault;
    if (this._isLocked()) {
      e.cancel = true;
      this._resetActive();
      return;
    }
    this._saveActive();
    null === (_e$preventDefault = e.preventDefault) || void 0 === _e$preventDefault || _e$preventDefault.call(e);
    this._adjustDistance(e, e.delta);
    this._eventForUserAction = e;
    this._eventHandler("move", e.delta);
  }
  _adjustDistance(e, distance) {
    distance.x *= this._validDirections[HORIZONTAL3];
    distance.y *= this._validDirections[VERTICAL2];
    const devicePixelRatio = this._tryGetDevicePixelRatio();
    if (devicePixelRatio && isDxMouseWheelEvent(e.originalEvent)) {
      distance.x = Math.round(distance.x / devicePixelRatio * 100) / 100;
      distance.y = Math.round(distance.y / devicePixelRatio * 100) / 100;
    }
  }
  _tryGetDevicePixelRatio() {
    if (hasWindow()) {
      return getWindow().devicePixelRatio;
    }
  }
  handleEnd(e) {
    var _e$originalEvent;
    this._resetActive();
    this._refreshCursorState(null === (_e$originalEvent = e.originalEvent) || void 0 === _e$originalEvent ? void 0 : _e$originalEvent.target);
    this._adjustDistance(e, e.velocity);
    this._eventForUserAction = e;
    return this._eventHandler("end", e.velocity).done(this._endAction);
  }
  handleCancel(e) {
    this._resetActive();
    this._eventForUserAction = e;
    return this._eventHandler("end", {
      x: 0,
      y: 0
    });
  }
  handleStop() {
    this._resetActive();
    this._eventHandler("stop");
  }
  handleScroll() {
    var _this$_scrollAction2;
    this._updateRtlConfig();
    null === (_this$_scrollAction2 = this._scrollAction) || void 0 === _this$_scrollAction2 || _this$_scrollAction2.call(this);
  }
  _attachKeyboardHandler() {
    m_events_engine_default.off(this._$element, `.${SCROLLABLE_SIMULATED_KEYBOARD}`);
    if (!this.option("disabled") && this.option("useKeyboard")) {
      m_events_engine_default.on(this._$element, addNamespace2("keydown", SCROLLABLE_SIMULATED_KEYBOARD), this._keyDownHandler.bind(this));
    }
  }
  _keyDownHandler(e) {
    clearTimeout(this._updateHandlerTimeout);
    this._updateHandlerTimeout = setTimeout(() => {
      if (normalizeKeyName(e) === KEY_CODES2.TAB) {
        this._eachScroller((scroller) => {
          scroller._updateHandler();
        });
      }
    });
    if (!this._$container.is(dom_adapter_default.getActiveElement(this._$container.get(0)))) {
      return;
    }
    let handled = true;
    switch (normalizeKeyName(e)) {
      case KEY_CODES2.DOWN:
        this._scrollByLine({
          y: 1
        });
        break;
      case KEY_CODES2.UP:
        this._scrollByLine({
          y: -1
        });
        break;
      case KEY_CODES2.RIGHT:
        this._scrollByLine({
          x: 1
        });
        break;
      case KEY_CODES2.LEFT:
        this._scrollByLine({
          x: -1
        });
        break;
      case KEY_CODES2.PAGE_DOWN:
        this._scrollByPage(1);
        break;
      case KEY_CODES2.PAGE_UP:
        this._scrollByPage(-1);
        break;
      case KEY_CODES2.HOME:
        this._scrollToHome();
        break;
      case KEY_CODES2.END:
        this._scrollToEnd();
        break;
      default:
        handled = false;
    }
    if (handled) {
      e.stopPropagation();
      e.preventDefault();
    }
  }
  _scrollByLine(lines) {
    const devicePixelRatio = this._tryGetDevicePixelRatio();
    let scrollOffset = 40;
    if (devicePixelRatio) {
      scrollOffset = Math.abs(scrollOffset / devicePixelRatio * 100) / 100;
    }
    this.scrollBy({
      top: (lines.y || 0) * -scrollOffset,
      left: (lines.x || 0) * -scrollOffset
    });
  }
  _scrollByPage(page) {
    const prop = this._wheelProp();
    const dimension = this._dimensionByProp(prop);
    const distance = {};
    const getter = "width" === dimension ? getWidth : getHeight;
    distance[prop] = page * -getter(this._$container);
    this.scrollBy(distance);
  }
  _dimensionByProp(prop) {
    return "left" === prop ? "width" : "height";
  }
  _getPropByDirection(direction) {
    return direction === HORIZONTAL3 ? "left" : "top";
  }
  _scrollToHome() {
    const prop = this._wheelProp();
    const distance = {};
    distance[prop] = 0;
    this._component.scrollTo(distance);
  }
  _scrollToEnd() {
    const prop = this._wheelProp();
    const dimension = this._dimensionByProp(prop);
    const distance = {};
    const getter = "width" === dimension ? getWidth : getHeight;
    distance[prop] = getter(this._$content) - getter(this._$container);
    this._component.scrollTo(distance);
  }
  createActions() {
    this._startAction = this._createActionHandler("onStart");
    this._endAction = this._createActionHandler("onEnd");
    this._updateAction = this._createActionHandler("onUpdated");
    this._createScrollerActions();
  }
  _createScrollerActions() {
    this._scrollAction = this._createActionHandler("onScroll");
    this._bounceAction = this._createActionHandler("onBounce");
    this._eventHandler("createActions", {
      scroll: this._scrollAction,
      bounce: this._bounceAction
    });
  }
  _createActionHandler(optionName) {
    const actionHandler = this._createActionByOption(optionName);
    return () => {
      actionHandler(extend(this._createActionArgs(), arguments));
    };
  }
  _createActionArgs() {
    const {
      horizontal: scrollerX,
      vertical: scrollerY
    } = this._scrollers;
    const offset2 = this._getScrollOffset();
    this._scrollOffset = {
      top: scrollerY && offset2.top,
      left: scrollerX && offset2.left
    };
    return {
      event: this._eventForUserAction,
      scrollOffset: this._scrollOffset,
      reachedLeft: null === scrollerX || void 0 === scrollerX ? void 0 : scrollerX._reachedMax(),
      reachedRight: null === scrollerX || void 0 === scrollerX ? void 0 : scrollerX._reachedMin(),
      reachedTop: null === scrollerY || void 0 === scrollerY ? void 0 : scrollerY._reachedMax(),
      reachedBottom: null === scrollerY || void 0 === scrollerY ? void 0 : scrollerY._reachedMin()
    };
  }
  _getScrollOffset() {
    return {
      top: -this.location().top,
      left: -this.location().left
    };
  }
  _eventHandler(eventName, location) {
    const args = [].slice.call(arguments).slice(1);
    const deferreds = map(this._scrollers, (scroller) => scroller[`_${eventName}Handler`].apply(scroller, args));
    return when.apply(renderer_default, deferreds).promise();
  }
  location() {
    const location = locate(this._$content);
    location.top -= this._$container.scrollTop();
    location.left -= this._$container.scrollLeft();
    return location;
  }
  disabledChanged() {
    this._attachCursorHandlers();
  }
  _attachCursorHandlers() {
    m_events_engine_default.off(this._$element, `.${SCROLLABLE_SIMULATED_CURSOR}`);
    if (!this.option("disabled") && this._isHoverMode()) {
      m_events_engine_default.on(this._$element, addNamespace2("mouseenter", SCROLLABLE_SIMULATED_CURSOR), this._cursorEnterHandler.bind(this));
      m_events_engine_default.on(this._$element, addNamespace2("mouseleave", SCROLLABLE_SIMULATED_CURSOR), this._cursorLeaveHandler.bind(this));
    }
  }
  _isHoverMode() {
    return "onHover" === this.option("showScrollbar");
  }
  _cursorEnterHandler(e) {
    e = e || {};
    e.originalEvent = e.originalEvent || {};
    if (activeScrollable || e.originalEvent._hoverHandled) {
      return;
    }
    if (hoveredScrollable) {
      hoveredScrollable._cursorLeaveHandler();
    }
    hoveredScrollable = this;
    this._eventHandler("cursorEnter");
    e.originalEvent._hoverHandled = true;
  }
  _cursorLeaveHandler(e) {
    if (hoveredScrollable !== this || activeScrollable === hoveredScrollable) {
      return;
    }
    this._eventHandler("cursorLeave");
    hoveredScrollable = null;
    this._refreshCursorState(null === e || void 0 === e ? void 0 : e.relatedTarget);
  }
  _refreshCursorState(target) {
    if (!this._isHoverMode() && (!target || activeScrollable)) {
      return;
    }
    const $target = renderer_default(target);
    const $scrollable = $target.closest(".dx-scrollable-simulated:not(.dx-state-disabled)");
    const targetScrollable = $scrollable.length && $scrollable.data(SCROLLABLE_STRATEGY);
    if (hoveredScrollable && hoveredScrollable !== targetScrollable) {
      hoveredScrollable._cursorLeaveHandler();
    }
    if (targetScrollable) {
      targetScrollable._cursorEnterHandler();
    }
  }
  update() {
    const result2 = this._eventHandler("update").done(this._updateAction);
    return when(result2, deferUpdate(() => {
      const allowedDirections = this._allowedDirections();
      deferRender(() => {
        let touchDirection = allowedDirections.vertical ? "pan-x" : "";
        touchDirection = allowedDirections.horizontal ? "pan-y" : touchDirection;
        touchDirection = allowedDirections.vertical && allowedDirections.horizontal ? "none" : touchDirection;
        this._$container.css("touchAction", touchDirection);
      });
      return when().promise();
    }));
  }
  _allowedDirections() {
    const bounceEnabled = this.option("bounceEnabled");
    const verticalScroller = this._scrollers[VERTICAL2];
    const horizontalScroller = this._scrollers[HORIZONTAL3];
    return {
      vertical: verticalScroller && (verticalScroller._minOffset < 0 || bounceEnabled),
      horizontal: horizontalScroller && (horizontalScroller._minOffset < 0 || bounceEnabled)
    };
  }
  _updateBounds() {
    var _this$_scrollers$HORI;
    null === (_this$_scrollers$HORI = this._scrollers[HORIZONTAL3]) || void 0 === _this$_scrollers$HORI || _this$_scrollers$HORI._updateBounds();
  }
  _isHorizontalAndRtlEnabled() {
    return this.option("rtlEnabled") && this.option("direction") !== VERTICAL2;
  }
  updateRtlPosition(needInitializeRtlConfig) {
    if (needInitializeRtlConfig) {
      this._rtlConfig = {
        scrollRight: 0,
        clientWidth: this._$container.get(0).clientWidth,
        windowPixelRatio: this._getWindowDevicePixelRatio()
      };
    }
    this._updateBounds();
    if (this._isHorizontalAndRtlEnabled()) {
      let scrollLeft = this._getMaxOffset().left - this._rtlConfig.scrollRight;
      if (scrollLeft <= 0) {
        scrollLeft = 0;
        this._rtlConfig.scrollRight = this._getMaxOffset().left;
      }
      if (this._getScrollOffset().left !== scrollLeft) {
        this._rtlConfig.skipUpdating = true;
        this._component.scrollTo({
          left: scrollLeft
        });
        this._rtlConfig.skipUpdating = false;
      }
    }
  }
  _updateRtlConfig() {
    if (this._isHorizontalAndRtlEnabled() && !this._rtlConfig.skipUpdating) {
      const {
        clientWidth,
        scrollLeft
      } = this._$container.get(0);
      const windowPixelRatio = this._getWindowDevicePixelRatio();
      if (this._rtlConfig.windowPixelRatio === windowPixelRatio && this._rtlConfig.clientWidth === clientWidth) {
        this._rtlConfig.scrollRight = this._getMaxOffset().left - scrollLeft;
      }
      this._rtlConfig.clientWidth = clientWidth;
      this._rtlConfig.windowPixelRatio = windowPixelRatio;
    }
  }
  _getWindowDevicePixelRatio() {
    return hasWindow() ? getWindow().devicePixelRatio : 1;
  }
  scrollBy(distance) {
    var _this$_startAction, _this$_endAction;
    const verticalScroller = this._scrollers[VERTICAL2];
    const horizontalScroller = this._scrollers[HORIZONTAL3];
    if (verticalScroller) {
      distance.top = verticalScroller._boundLocation(distance.top + verticalScroller._location) - verticalScroller._location;
    }
    if (horizontalScroller) {
      distance.left = horizontalScroller._boundLocation(distance.left + horizontalScroller._location) - horizontalScroller._location;
    }
    this._prepareDirections(true);
    null === (_this$_startAction = this._startAction) || void 0 === _this$_startAction || _this$_startAction.call(this);
    this._eventHandler("scrollBy", {
      x: distance.left,
      y: distance.top
    });
    null === (_this$_endAction = this._endAction) || void 0 === _this$_endAction || _this$_endAction.call(this);
    this._updateRtlConfig();
  }
  validate(e) {
    if (isDxMouseWheelEvent(e) && isCommandKeyPressed(e)) {
      return false;
    }
    if (this.option("disabled")) {
      return false;
    }
    if (this.option("bounceEnabled")) {
      return true;
    }
    return isDxMouseWheelEvent(e) ? this._validateWheel(e) : this._validateMove(e);
  }
  _validateWheel(e) {
    const scroller = this._scrollers[this._wheelDirection(e)];
    const reachedMin = scroller._reachedMin();
    const reachedMax = scroller._reachedMax();
    const contentGreaterThanContainer = !reachedMin || !reachedMax;
    const locatedNotAtBound = !reachedMin && !reachedMax;
    const scrollFromMin = reachedMin && e.delta > 0;
    const scrollFromMax = reachedMax && e.delta < 0;
    let validated = contentGreaterThanContainer && (locatedNotAtBound || scrollFromMin || scrollFromMax);
    validated = validated || void 0 !== this._validateWheelTimer;
    if (validated) {
      clearTimeout(this._validateWheelTimer);
      this._validateWheelTimer = setTimeout(() => {
        this._validateWheelTimer = void 0;
      }, 500);
    }
    return validated;
  }
  _validateMove(e) {
    if (!this.option("scrollByContent") && !renderer_default(e.target).closest(".dx-scrollable-scrollbar").length) {
      return false;
    }
    return this._allowedDirection();
  }
  getDirection(e) {
    return isDxMouseWheelEvent(e) ? this._wheelDirection(e) : this._allowedDirection();
  }
  _wheelProp() {
    return this._wheelDirection() === HORIZONTAL3 ? "left" : "top";
  }
  _wheelDirection(e) {
    switch (this.option("direction")) {
      case HORIZONTAL3:
        return HORIZONTAL3;
      case VERTICAL2:
        return VERTICAL2;
      default:
        return null !== e && void 0 !== e && e.shiftKey ? HORIZONTAL3 : VERTICAL2;
    }
  }
  dispose() {
    this._resetActive();
    if (hoveredScrollable === this) {
      hoveredScrollable = null;
    }
    this._eventHandler("dispose");
    this._detachEventHandlers();
    this._$element.removeClass("dx-scrollable-simulated");
    this._eventForUserAction = null;
    clearTimeout(this._validateWheelTimer);
    clearTimeout(this._updateHandlerTimeout);
  }
  _detachEventHandlers() {
    m_events_engine_default.off(this._$element, `.${SCROLLABLE_SIMULATED_CURSOR}`);
    m_events_engine_default.off(this._$container, `.${SCROLLABLE_SIMULATED_KEYBOARD}`);
  }
};

// node_modules/devextreme/esm/__internal/ui/scroll_view/m_scrollable.js
var SCROLLABLE = "dxScrollable";
var SCROLLABLE_STRATEGY2 = "dxScrollableStrategy";
var VERTICAL3 = "vertical";
var HORIZONTAL4 = "horizontal";
var BOTH = "both";
var Scrollable = class _Scrollable extends dom_component_default {
  _getDefaultOptions() {
    return _extends({}, super._getDefaultOptions(), {
      disabled: false,
      onScroll: null,
      direction: VERTICAL3,
      showScrollbar: "onScroll",
      useNative: true,
      bounceEnabled: true,
      scrollByContent: true,
      scrollByThumb: false,
      onUpdated: null,
      onStart: null,
      onEnd: null,
      onBounce: null,
      useSimulatedScrollbar: false,
      useKeyboard: true,
      inertiaEnabled: true,
      updateManually: false,
      _onVisibilityChanged: noop2
    });
  }
  _defaultOptionsRules() {
    return super._defaultOptionsRules().concat(deviceDependentOptions(), [{
      device: () => m_support_default.nativeScrolling && "android" === devices_default.real().platform && !browser_default.mozilla,
      options: {
        useSimulatedScrollbar: true
      }
    }]);
  }
  _initOptions(options2) {
    super._initOptions(options2);
    if (!("useSimulatedScrollbar" in options2)) {
      this._setUseSimulatedScrollbar();
    }
  }
  _setUseSimulatedScrollbar() {
    if (!this.initialOption("useSimulatedScrollbar")) {
      this.option("useSimulatedScrollbar", !this.option("useNative"));
    }
  }
  _init() {
    super._init();
    this._initScrollableMarkup();
    this._locked = false;
  }
  _visibilityChanged(visible2) {
    if (visible2) {
      this.update();
      this._updateRtlPosition();
      this._savedScrollOffset && this.scrollTo(this._savedScrollOffset);
      delete this._savedScrollOffset;
      const {
        _onVisibilityChanged: onVisibilityChanged
      } = this.option();
      null === onVisibilityChanged || void 0 === onVisibilityChanged || onVisibilityChanged(this);
    } else {
      this._savedScrollOffset = this.scrollOffset();
    }
  }
  _initScrollableMarkup() {
    const $element = this.$element().addClass("dx-scrollable");
    const $container = renderer_default("<div>").addClass("dx-scrollable-container");
    const $wrapper = renderer_default("<div>").addClass("dx-scrollable-wrapper");
    const $content = renderer_default("<div>").addClass("dx-scrollable-content");
    this._$container = $container;
    this._$wrapper = $wrapper;
    this._$content = $content;
    $content.append($element.contents()).appendTo($container);
    $container.appendTo($wrapper);
    $wrapper.appendTo($element);
  }
  _dimensionChanged() {
    this.update();
    this._updateRtlPosition();
  }
  _initMarkup() {
    super._initMarkup();
    this._renderDirection();
  }
  _render() {
    this._renderStrategy();
    this._attachEventHandlers();
    this._renderDisabledState();
    this._createActions();
    this.update();
    super._render();
    this._updateRtlPosition(true);
  }
  _updateRtlPosition(needInitializeRtlConfig) {
    this._strategy.updateRtlPosition(needInitializeRtlConfig);
  }
  _getMaxOffset() {
    const {
      scrollWidth,
      clientWidth,
      scrollHeight,
      clientHeight
    } = renderer_default(this.container()).get(0);
    return {
      left: scrollWidth - clientWidth,
      top: scrollHeight - clientHeight
    };
  }
  _attachEventHandlers() {
    const strategy3 = this._strategy;
    const initEventData = {
      getDirection: strategy3.getDirection.bind(strategy3),
      validate: this._validate.bind(this),
      isNative: this.option("useNative"),
      scrollTarget: this._$container
    };
    m_events_engine_default.off(this._$wrapper, `.${SCROLLABLE}`);
    m_events_engine_default.on(this._$wrapper, addNamespace2(m_emitter_gesture_scroll_default.init, SCROLLABLE), initEventData, this._initHandler.bind(this));
    m_events_engine_default.on(this._$wrapper, addNamespace2(m_emitter_gesture_scroll_default.start, SCROLLABLE), strategy3.handleStart.bind(strategy3));
    m_events_engine_default.on(this._$wrapper, addNamespace2(m_emitter_gesture_scroll_default.move, SCROLLABLE), strategy3.handleMove.bind(strategy3));
    m_events_engine_default.on(this._$wrapper, addNamespace2(m_emitter_gesture_scroll_default.end, SCROLLABLE), strategy3.handleEnd.bind(strategy3));
    m_events_engine_default.on(this._$wrapper, addNamespace2(m_emitter_gesture_scroll_default.cancel, SCROLLABLE), strategy3.handleCancel.bind(strategy3));
    m_events_engine_default.on(this._$wrapper, addNamespace2(m_emitter_gesture_scroll_default.stop, SCROLLABLE), strategy3.handleStop.bind(strategy3));
    m_events_engine_default.off(this._$container, `.${SCROLLABLE}`);
    m_events_engine_default.on(this._$container, addNamespace2("scroll", SCROLLABLE), strategy3.handleScroll.bind(strategy3));
  }
  _validate(e) {
    if (this._isLocked()) {
      return false;
    }
    this._updateIfNeed();
    return this._moveIsAllowed(e);
  }
  _moveIsAllowed(e) {
    return this._strategy.validate(e);
  }
  handleMove(e) {
    this._strategy.handleMove(e);
  }
  _prepareDirections(value2) {
    this._strategy._prepareDirections(value2);
  }
  _initHandler() {
    const strategy3 = this._strategy;
    strategy3.handleInit.apply(strategy3, arguments);
  }
  _renderDisabledState() {
    const {
      disabled
    } = this.option();
    this.$element().toggleClass("dx-scrollable-disabled", disabled);
    if (this.option("disabled")) {
      this._lock();
    } else {
      this._unlock();
    }
  }
  _renderDirection() {
    const {
      direction
    } = this.option();
    this.$element().removeClass(`dx-scrollable-${HORIZONTAL4}`).removeClass(`dx-scrollable-${VERTICAL3}`).removeClass(`dx-scrollable-${BOTH}`).addClass(`dx-scrollable-${direction}`);
  }
  _renderStrategy() {
    this._createStrategy();
    this._strategy.render();
    this.$element().data(SCROLLABLE_STRATEGY2, this._strategy);
  }
  _createStrategy() {
    this._strategy = this.option("useNative") ? new m_scrollable_native_default(this) : new SimulatedStrategy(this);
  }
  _createActions() {
    var _this$_strategy;
    null === (_this$_strategy = this._strategy) || void 0 === _this$_strategy || _this$_strategy.createActions();
  }
  _clean() {
    var _this$_strategy2;
    null === (_this$_strategy2 = this._strategy) || void 0 === _this$_strategy2 || _this$_strategy2.dispose();
  }
  _optionChanged(args) {
    var _this$_strategy3;
    switch (args.name) {
      case "onStart":
      case "onEnd":
      case "onUpdated":
      case "onScroll":
      case "onBounce":
        this._createActions();
        break;
      case "direction":
        this._resetInactiveDirection();
        this._invalidate();
        break;
      case "useNative":
        this._setUseSimulatedScrollbar();
        this._invalidate();
        break;
      case "inertiaEnabled":
      case "scrollByThumb":
      case "bounceEnabled":
      case "useKeyboard":
      case "showScrollbar":
      case "useSimulatedScrollbar":
        this._invalidate();
        break;
      case "disabled":
        this._renderDisabledState();
        null === (_this$_strategy3 = this._strategy) || void 0 === _this$_strategy3 || _this$_strategy3.disabledChanged();
        break;
      case "updateManually":
      case "scrollByContent":
      case "_onVisibilityChanged":
        break;
      case "width":
        super._optionChanged(args);
        this._updateRtlPosition();
        break;
      default:
        super._optionChanged(args);
    }
  }
  _resetInactiveDirection() {
    const inactiveProp = this._getInactiveProp();
    if (!inactiveProp || !hasWindow()) {
      return;
    }
    const scrollOffset = this.scrollOffset();
    scrollOffset[inactiveProp] = 0;
    this.scrollTo(scrollOffset);
  }
  _getInactiveProp() {
    const {
      direction
    } = this.option();
    if (direction === VERTICAL3) {
      return "left";
    }
    if (direction === HORIZONTAL4) {
      return "top";
    }
  }
  _location() {
    return this._strategy.location();
  }
  _normalizeLocation(location) {
    if (isPlainObject(location)) {
      const left = ensureDefined(location.left, location.x);
      const top = ensureDefined(location.top, location.y);
      return {
        left: isDefined(left) ? -left : void 0,
        top: isDefined(top) ? -top : void 0
      };
    }
    const {
      direction
    } = this.option();
    return {
      left: direction !== VERTICAL3 ? -location : void 0,
      top: direction !== HORIZONTAL4 ? -location : void 0
    };
  }
  _isLocked() {
    return this._locked;
  }
  _lock() {
    this._locked = true;
  }
  _unlock() {
    if (!this.option("disabled")) {
      this._locked = false;
    }
  }
  _isDirection(direction) {
    const {
      direction: current2
    } = this.option();
    if (direction === VERTICAL3) {
      return current2 !== HORIZONTAL4;
    }
    if (direction === HORIZONTAL4) {
      return current2 !== VERTICAL3;
    }
    return current2 === direction;
  }
  _updateAllowedDirection() {
    const allowedDirections = this._strategy._allowedDirections();
    if (this._isDirection(BOTH) && allowedDirections.vertical && allowedDirections.horizontal) {
      this._allowedDirectionValue = BOTH;
    } else if (this._isDirection(HORIZONTAL4) && allowedDirections.horizontal) {
      this._allowedDirectionValue = HORIZONTAL4;
    } else if (this._isDirection(VERTICAL3) && allowedDirections.vertical) {
      this._allowedDirectionValue = VERTICAL3;
    } else {
      this._allowedDirectionValue = null;
    }
  }
  _allowedDirection() {
    return this._allowedDirectionValue;
  }
  $content() {
    return this._$content;
  }
  content() {
    return getPublicElement(this._$content);
  }
  container() {
    return getPublicElement(this._$container);
  }
  scrollOffset() {
    return this._strategy._getScrollOffset();
  }
  _isRtlNativeStrategy() {
    const {
      useNative,
      rtlEnabled
    } = this.option();
    return useNative && rtlEnabled;
  }
  scrollTop() {
    return this.scrollOffset().top;
  }
  scrollLeft() {
    return this.scrollOffset().left;
  }
  clientHeight() {
    return getHeight(this._$container);
  }
  scrollHeight() {
    return getOuterHeight(this.$content());
  }
  clientWidth() {
    return getWidth(this._$container);
  }
  scrollWidth() {
    return getOuterWidth(this.$content());
  }
  update() {
    if (!this._strategy) {
      return;
    }
    return when(this._strategy.update()).done(() => {
      this._updateAllowedDirection();
    });
  }
  scrollBy(distance) {
    distance = this._normalizeLocation(distance);
    if (!distance.top && !distance.left) {
      return;
    }
    this._updateIfNeed();
    this._strategy.scrollBy(distance);
  }
  scrollTo(targetLocation) {
    if (!hasWindow()) {
      return;
    }
    targetLocation = this._normalizeLocation(targetLocation);
    this._updateIfNeed();
    let location = this._location();
    const {
      useNative
    } = this.option();
    if (!useNative) {
      const strategy3 = this._strategy;
      targetLocation = strategy3._applyScaleRatio(targetLocation);
      location = strategy3._applyScaleRatio(location);
    }
    if (this._isRtlNativeStrategy()) {
      location.left -= this._getMaxOffset().left;
    }
    const distance = this._normalizeLocation({
      left: location.left - ensureDefined(targetLocation.left, location.left),
      top: location.top - ensureDefined(targetLocation.top, location.top)
    });
    if (!distance.top && !distance.left) {
      return;
    }
    this._strategy.scrollBy(distance);
  }
  scrollToElement(element, offset2) {
    const $element = renderer_default(element);
    const elementInsideContent = this.$content().find(element).length;
    const elementIsInsideContent = $element.parents(".dx-scrollable").length - $element.parents(".dx-scrollable-content").length === 0;
    if (!elementInsideContent || !elementIsInsideContent) {
      return;
    }
    const scrollPosition = {
      top: 0,
      left: 0
    };
    const {
      direction
    } = this.option();
    if (direction !== VERTICAL3) {
      scrollPosition.left = this.getScrollElementPosition($element, HORIZONTAL4, offset2);
    }
    if (direction !== HORIZONTAL4) {
      scrollPosition.top = this.getScrollElementPosition($element, VERTICAL3, offset2);
    }
    this.scrollTo(scrollPosition);
  }
  getScrollElementPosition($element, direction, offset2) {
    const scrollOffset = this.scrollOffset();
    return getElementLocationInternal($element.get(0), direction, renderer_default(this.container()).get(0), scrollOffset, offset2);
  }
  _updateIfNeed() {
    if (!this.option("updateManually")) {
      this.update();
    }
  }
  _useTemplates() {
    return false;
  }
  isRenovated() {
    return !!_Scrollable.IS_RENOVATED_WIDGET;
  }
};
component_registrator_default(SCROLLABLE, Scrollable);
var m_scrollable_default = Scrollable;

// node_modules/devextreme/esm/ui/scroll_view/ui.scrollable.js
var ui_scrollable_default = m_scrollable_default;

// node_modules/devextreme/esm/__internal/grids/grid_core/views/m_rows_view.js
var FREE_SPACE_CLASS = "dx-freespace-row";
var LAST_ROW_BORDER = "dx-last-row-border";
function getMaxHorizontalScrollOffset(scrollable) {
  return scrollable ? Math.round(scrollable.scrollWidth() - scrollable.clientWidth()) : 0;
}
function isGroupRow(_ref) {
  let {
    rowType,
    column
  } = _ref;
  return "group" === rowType && isDefined(column.groupIndex) && !column.showWhenGrouped && !column.command;
}
function setWatcher(_ref2) {
  let {
    element,
    watch,
    getter,
    callBack
  } = _ref2;
  if (watch) {
    const dispose2 = watch(getter, callBack);
    m_events_engine_default.on(element, removeEvent, dispose2);
  }
}
var defaultCellTemplate = function($container, options2) {
  const isDataTextEmpty = isEmpty(options2.text) && "data" === options2.rowType;
  const {
    text
  } = options2;
  const container = $container.get(0);
  if (isDataTextEmpty) {
    m_utils_default.setEmptyText($container);
  } else if (options2.column.encodeHtml) {
    container.textContent = text;
  } else {
    container.innerHTML = text;
  }
};
var getScrollableBottomPadding = function(that) {
  const scrollable = that.getScrollable();
  return scrollable ? Math.ceil(parseFloat(renderer_default(scrollable.content()).css("paddingBottom"))) : 0;
};
var RowsView = class extends ColumnsView {
  init() {
    super.init();
    this._editingController = this.getController("editing");
    this._resizingController = this.getController("resizing");
    this._columnsResizerController = this.getController("columnsResizer");
    this._focusController = this.getController("focus");
    this._keyboardNavigationController = this.getController("keyboardNavigation");
    this._validatingController = this.getController("validating");
    this._errorHandlingController = this.getController("errorHandling");
    this._columnHeadersView = this.getView("columnHeadersView");
    this._rowHeight = 0;
    this._scrollTop = 0;
    this._scrollLeft = -1;
    this._scrollRight = 0;
    this._hasHeight = void 0;
    this._contentChanges = [];
    this._dataController.loadingChanged.add((isLoading, messageText) => {
      this.setLoading(isLoading, messageText);
    });
    this._dataController.dataSourceChanged.add(() => {
      if (this._scrollLeft >= 0 && !this._dataController.isLoading()) {
        this._handleScroll({
          component: this.getScrollable(),
          forceUpdateScrollPosition: true,
          scrollOffset: {
            top: this._scrollTop,
            left: this._scrollLeft
          }
        });
      }
    });
  }
  _getDefaultTemplate(column) {
    if ("empty" === column.command) {
      return function(container) {
        container.html("&nbsp;");
      };
    } else {
      return defaultCellTemplate;
    }
  }
  renderFocusState(params) {
  }
  _getDefaultGroupTemplate(column) {
    const summaryTexts = this.option("summary.texts");
    return function($container, options2) {
      const {
        data: data17
      } = options2;
      let text = `${options2.column.caption}: ${options2.text}`;
      const container = $container.get(0);
      if (options2.summaryItems && options2.summaryItems.length) {
        text += ` ${m_utils_default.getGroupRowSummaryText(options2.summaryItems, summaryTexts)}`;
      }
      if (data17) {
        if (options2.groupContinuedMessage && options2.groupContinuesMessage) {
          text += ` (${options2.groupContinuedMessage}. ${options2.groupContinuesMessage})`;
        } else if (options2.groupContinuesMessage) {
          text += ` (${options2.groupContinuesMessage})`;
        } else if (options2.groupContinuedMessage) {
          text += ` (${options2.groupContinuedMessage})`;
        }
      }
      if (column.encodeHtml) {
        container.textContent = text;
      } else {
        container.innerHTML = text;
      }
    };
  }
  _update(change) {
  }
  _updateCell($cell, options2) {
    if (isGroupRow(options2)) {
      const isGroupContainer = $cell.is(`.${this.addWidgetPrefix(CLASSES3.groupRowContainer)}`);
      const $groupCell = isGroupContainer ? $cell.parent() : $cell;
      $groupCell.addClass("dx-group-cell");
    }
    super._updateCell.apply(this, arguments);
  }
  _getCellTemplate(options2) {
    const that = this;
    const {
      column
    } = options2;
    let template;
    if (isGroupRow(options2)) {
      template = column.groupCellTemplate || {
        allowRenderToDetachedContainer: true,
        render: that._getDefaultGroupTemplate(column)
      };
    } else if (("data" === options2.rowType || column.command) && column.cellTemplate) {
      template = column.cellTemplate;
    } else {
      template = {
        allowRenderToDetachedContainer: true,
        render: that._getDefaultTemplate(column)
      };
    }
    return template;
  }
  _createRow(row, tag) {
    const $row = super._createRow.apply(this, arguments);
    if (row) {
      const isGroup2 = "group" === row.rowType;
      const isDataRow2 = "data" === row.rowType;
      isDataRow2 && $row.addClass("dx-data-row");
      isDataRow2 && this.option("showRowLines") && $row.addClass("dx-row-lines");
      this.option("showColumnLines") && $row.addClass("dx-column-lines");
      if (false === row.visible) {
        $row.hide();
      }
      if (isGroup2) {
        $row.addClass("dx-group-row");
        this.setAriaExpandedAttribute($row, row);
      }
    }
    return $row;
  }
  _rowPrepared($row, rowOptions, row) {
    if ("data" === rowOptions.rowType) {
      if (this.option("rowAlternationEnabled")) {
        this._isAltRow(row) && $row.addClass("dx-row-alt");
        setWatcher({
          element: $row.get(0),
          watch: rowOptions.watch,
          getter: () => this._isAltRow(row),
          callBack: (value2) => {
            $row.toggleClass("dx-row-alt", value2);
          }
        });
      }
      this._setAriaRowIndex(rowOptions, $row);
      setWatcher({
        element: $row.get(0),
        watch: rowOptions.watch,
        getter: () => rowOptions.rowIndex,
        callBack: () => this._setAriaRowIndex(rowOptions, $row)
      });
    }
    super._rowPrepared.apply(this, arguments);
  }
  _setAriaRowIndex(row, $row) {
    if (!$row.is("tr")) {
      return;
    }
    const {
      component
    } = this;
    const isPagerMode = "standard" === component.option("scrolling.mode") && !m_utils_default.isVirtualRowRendering(component);
    let rowIndex = row.rowIndex + 1;
    if (isPagerMode) {
      rowIndex = component.pageIndex() * component.pageSize() + rowIndex;
    } else {
      rowIndex += this._dataController.getRowIndexOffset();
    }
    this.setAria("rowindex", rowIndex, $row);
  }
  setAriaExpandedAttribute($row, row) {
    const description = row.isExpanded ? this.localize("dxDataGrid-ariaExpandedRow") : this.localize("dxDataGrid-ariaCollapsedRow");
    this.setAria("roledescription", description, $row);
  }
  _afterRowPrepared(e) {
    const arg = e.args[0];
    const dataController2 = this._dataController;
    const row = dataController2.getVisibleRows()[arg.rowIndex];
    const watch = this.option("integrationOptions.watchMethod");
    if (!arg.data || "data" !== arg.rowType || arg.isNewRow || !this.option("twoWayBindingEnabled") || !watch || !row) {
      return;
    }
    const dispose2 = watch(() => dataController2.generateDataValues(arg.data, arg.columns), () => {
      dataController2.repaintRows([row.rowIndex], this.option("repaintChangesOnly"));
    }, {
      deep: true,
      skipImmediate: true
    });
    m_events_engine_default.on(arg.rowElement, removeEvent, dispose2);
  }
  _renderScrollable(force) {
    const that = this;
    const $element = that.element();
    if (!$element.children().length) {
      $element.append("<div>");
    }
    if (force || !that._loadPanel) {
      that._renderLoadPanel($element, $element.parent(), that._dataController.isLocalStore());
    }
    if ((force || !that.getScrollable()) && that._dataController.isLoaded()) {
      const columns7 = that.getColumns();
      let allColumnsHasWidth = true;
      for (let i = 0; i < columns7.length; i++) {
        if (!columns7[i].width && !columns7[i].minWidth) {
          allColumnsHasWidth = false;
          break;
        }
      }
      if (that.option("columnAutoWidth") || that._hasHeight || allColumnsHasWidth || that._columnsController._isColumnFixing()) {
        that._renderScrollableCore($element);
      }
    }
  }
  _handleScroll(e) {
    const rtlEnabled = this.option("rtlEnabled");
    const isNativeScrolling = e.component.option("useNative");
    this._scrollTop = e.scrollOffset.top;
    this._scrollLeft = e.scrollOffset.left;
    let scrollLeft = e.scrollOffset.left;
    if (rtlEnabled) {
      this._scrollRight = getMaxHorizontalScrollOffset(e.component) - this._scrollLeft;
      if (isNativeScrolling) {
        scrollLeft = -this._scrollRight;
      }
      if (!this.isScrollbarVisible(true)) {
        this._scrollLeft = -1;
      }
    }
    this.scrollChanged.fire(_extends({}, e.scrollOffset, {
      left: scrollLeft
    }), this.name);
  }
  _renderScrollableCore($element) {
    const dxScrollableOptions = this._createScrollableOptions();
    const scrollHandler = this._handleScroll.bind(this);
    dxScrollableOptions.onScroll = scrollHandler;
    this._scrollable = this._createComponent($element, ui_scrollable_default, dxScrollableOptions);
    this._scrollableContainer = this._scrollable && renderer_default(this._scrollable.container());
  }
  _renderLoadPanel() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return m_utils_default.renderLoadPanel.apply(this, arguments);
  }
  _renderContent(contentElement, tableElement, isFixedTableRendering) {
    contentElement.empty().append(tableElement);
    return this._findContentElement();
  }
  _updateContent(newTableElement, change, isFixedTableRendering) {
    this._contentChanges.push({
      newTableElement,
      change,
      isFixedTableRendering
    });
    return this.waitAsyncTemplates().done(() => {
      const contentChanges = this._contentChanges;
      this._contentChanges = [];
      contentChanges.forEach((_ref3) => {
        let {
          newTableElement: newTableElement2,
          change: change2,
          isFixedTableRendering: isFixedTableRendering2
        } = _ref3;
        const tableElement = this.getTableElement(isFixedTableRendering2);
        const contentElement = this._findContentElement(isFixedTableRendering2);
        const changeType = null === change2 || void 0 === change2 ? void 0 : change2.changeType;
        const executors = [];
        const highlightChanges = this.option("highlightChanges");
        const rowInsertedClass = this.addWidgetPrefix("row-inserted-animation");
        if ("update" === changeType) {
          each(change2.rowIndices, (index2, rowIndex) => {
            var _change$changeTypes;
            const $newRowElement = this._getRowElements(newTableElement2).eq(index2);
            const dataChangeType = null === (_change$changeTypes = change2.changeTypes) || void 0 === _change$changeTypes ? void 0 : _change$changeTypes[index2];
            const item = change2.items && change2.items[index2];
            executors.push(() => {
              const $rowElements = this._getRowElements(tableElement);
              const $rowElement = $rowElements.eq(rowIndex);
              switch (dataChangeType) {
                case "update":
                  if (item) {
                    var _change$columnIndices;
                    const columnIndices = null === (_change$columnIndices = change2.columnIndices) || void 0 === _change$columnIndices ? void 0 : _change$columnIndices[index2];
                    if (isDefined(item.visible) && item.visible !== $rowElement.is(":visible")) {
                      $rowElement.toggle(item.visible);
                    } else if (columnIndices) {
                      this._updateCells($rowElement, $newRowElement, columnIndices, item);
                    } else {
                      $rowElement.replaceWith($newRowElement);
                    }
                  }
                  break;
                case "insert":
                  if (!$rowElements.length) {
                    if (tableElement) {
                      const target = $newRowElement.is("tbody") ? tableElement : tableElement.children("tbody");
                      $newRowElement.prependTo(target);
                    }
                  } else if ($rowElement.length) {
                    $newRowElement.insertBefore($rowElement);
                  } else {
                    $newRowElement.insertAfter($rowElements.last());
                  }
                  if (highlightChanges && change2.isLiveUpdate) {
                    $newRowElement.addClass(rowInsertedClass);
                  }
                  break;
                case "remove":
                  $rowElement.remove();
              }
            });
          });
          each(executors, function() {
            this();
          });
          newTableElement2.remove();
        } else {
          this.setTableElement(newTableElement2, isFixedTableRendering2);
          contentElement.addClass(this.addWidgetPrefix("content"));
          this._setGridRole(contentElement);
          this._renderContent(contentElement, newTableElement2, isFixedTableRendering2);
        }
      });
    }).fail(() => {
      this._contentChanges = [];
    });
  }
  _getGridRoleName() {
    return "grid";
  }
  _setGridRole($element) {
    var _this$_dataController;
    const hasData = !(null !== (_this$_dataController = this._dataController) && void 0 !== _this$_dataController && _this$_dataController.isEmpty());
    const gridRoleName = this._getGridRoleName();
    if (null !== $element && void 0 !== $element && $element.length && hasData) {
      this.setAria("role", gridRoleName, $element);
    }
  }
  _createEmptyRow(className, isFixed, height) {
    const that = this;
    let $cell;
    const $row = that._createRow();
    const columns7 = isFixed ? this.getFixedColumns() : this.getColumns();
    $row.addClass(className).toggleClass("dx-column-lines", that.option("showColumnLines"));
    for (let i = 0; i < columns7.length; i++) {
      $cell = that._createCell({
        column: columns7[i],
        rowType: "freeSpace",
        columnIndex: i,
        columns: columns7
      });
      isNumeric(height) && $cell.css("height", height);
      $row.append($cell);
    }
    that.setAria("role", "presentation", $row);
    return $row;
  }
  getFixedColumns() {
    throw new Error("Method not implemented.");
  }
  _appendEmptyRow($table, $emptyRow, location) {
    const $tBodies = this._getBodies($table);
    const isTableContainer = !$tBodies.length || $emptyRow.is("tbody");
    const $container = isTableContainer ? $table : $tBodies;
    if ("top" === location) {
      $container.first().prepend($emptyRow);
      if (isTableContainer) {
        const $colgroup = $container.children("colgroup");
        $container.prepend($colgroup);
      }
    } else {
      $container.last().append($emptyRow);
    }
  }
  _renderFreeSpaceRow($tableElement, change) {
    let $freeSpaceRowElement = this._createEmptyRow(FREE_SPACE_CLASS);
    $freeSpaceRowElement = this._wrapRowIfNeed($tableElement, $freeSpaceRowElement, "refresh" === (null === change || void 0 === change ? void 0 : change.changeType));
    this._appendEmptyRow($tableElement, $freeSpaceRowElement);
  }
  _checkRowKeys(options2) {
    const that = this;
    const rows = that._getRows(options2);
    const keyExpr = that._dataController.store() && that._dataController.store().key();
    keyExpr && rows.some((row) => {
      if ("data" === row.rowType && void 0 === row.key) {
        that._dataController.fireError("E1046", keyExpr);
        return true;
      }
      return;
    });
  }
  _needUpdateRowHeight(itemsCount) {
    return itemsCount > 0 && !this._rowHeight;
  }
  _getRowsHeight($tableElement) {
    $tableElement = $tableElement || this._tableElement;
    const $rowElements = $tableElement.children("tbody").children().not(".dx-virtual-row").not(`.${FREE_SPACE_CLASS}`);
    return $rowElements.toArray().reduce((sum, row) => sum + getBoundingRect(row).height, 0);
  }
  _updateRowHeight() {
    const that = this;
    const $tableElement = that.getTableElement();
    const itemsCount = that._dataController.items().length;
    if ($tableElement && that._needUpdateRowHeight(itemsCount)) {
      const rowsHeight = that._getRowsHeight($tableElement);
      that._rowHeight = rowsHeight / itemsCount;
    }
  }
  _findContentElement(isFixedTableRendering) {
    let $content = this.element();
    const scrollable = this.getScrollable();
    if ($content) {
      if (scrollable) {
        $content = renderer_default(scrollable.content());
      }
      return $content.children().first();
    }
  }
  _getRowElements(tableElement) {
    const $rows = super._getRowElements(tableElement);
    return $rows && $rows.not(`.${FREE_SPACE_CLASS}`);
  }
  _getFreeSpaceRowElements($table) {
    const tableElements = $table || this.getTableElements();
    return tableElements && tableElements.children("tbody").children(`.${FREE_SPACE_CLASS}`);
  }
  _getNoDataText() {
    return this.option("noDataText");
  }
  _rowClick(e) {
    const item = this._dataController.items()[e.rowIndex] || {};
    this.executeAction("onRowClick", extend({
      evaluate(expr) {
        const getter = compileGetter(expr);
        return getter(item.data);
      }
    }, e, item));
  }
  _rowDblClick(e) {
    const item = this._dataController.items()[e.rowIndex] || {};
    this.executeAction("onRowDblClick", extend({}, e, item));
  }
  _getColumnsCountBeforeGroups(columns7) {
    for (let i = 0; i < columns7.length; i++) {
      if ("groupExpand" === columns7[i].type) {
        return i;
      }
    }
    return 0;
  }
  _getGroupCellOptions(options2) {
    const columnsCountBeforeGroups = this._getColumnsCountBeforeGroups(options2.columns);
    const columnIndex = (options2.row.groupIndex || 0) + columnsCountBeforeGroups;
    return {
      columnIndex,
      colspan: options2.columns.length - columnIndex - 1
    };
  }
  _needWrapRow() {
    return super._needWrapRow.apply(this, arguments) || !!this.option("dataRowTemplate");
  }
  _renderCells($row, options2) {
    if ("group" === options2.row.rowType) {
      this._renderGroupedCells($row, options2);
    } else if (options2.row.values) {
      super._renderCells($row, options2);
    }
  }
  _renderGroupedCells($row, options2) {
    const {
      row
    } = options2;
    let expandColumn;
    const {
      columns: columns7
    } = options2;
    const {
      rowIndex
    } = row;
    let isExpanded;
    const groupCellOptions = this._getGroupCellOptions(options2);
    for (let i = 0; i <= groupCellOptions.columnIndex; i++) {
      if (i === groupCellOptions.columnIndex && columns7[i].allowCollapsing && "infinite" !== options2.scrollingMode) {
        isExpanded = !!row.isExpanded;
        expandColumn = columns7[i];
      } else {
        isExpanded = null;
        expandColumn = {
          command: "expand",
          cssClass: columns7[i].cssClass,
          fixed: columns7[i].fixed
        };
      }
      if (this._needRenderCell(i, options2.columnIndices)) {
        this._renderCell($row, {
          value: isExpanded,
          row,
          rowIndex,
          column: expandColumn,
          columnIndex: i,
          columnIndices: options2.columnIndices,
          change: options2.change
        });
      }
    }
    const groupColumnAlignment = getDefaultAlignment(this.option("rtlEnabled"));
    const groupColumn = extend({}, columns7[groupCellOptions.columnIndex], {
      command: null,
      type: null,
      cssClass: null,
      width: null,
      showWhenGrouped: false,
      alignment: groupColumnAlignment
    });
    if (groupCellOptions.colspan > 1) {
      groupColumn.colspan = groupCellOptions.colspan;
    }
    if (this._needRenderCell(groupCellOptions.columnIndex + 1, options2.columnIndices)) {
      this._renderCell($row, {
        value: row.values[row.groupIndex],
        row,
        rowIndex,
        column: groupColumn,
        columnIndex: groupCellOptions.columnIndex + 1,
        columnIndices: options2.columnIndices,
        change: options2.change
      });
    }
  }
  _renderRows($table, options2) {
    const that = this;
    const scrollingMode = that.option("scrolling.mode");
    super._renderRows($table, extend({
      scrollingMode
    }, options2));
    that._checkRowKeys(options2.change);
    that._renderFreeSpaceRow($table, options2.change);
    if (!that._hasHeight) {
      that.updateFreeSpaceRowHeight($table);
    }
  }
  _renderDataRowByTemplate($table, options2, dataRowTemplate) {
    const {
      row
    } = options2;
    const rowOptions = extend({
      columns: options2.columns
    }, row);
    const $tbody = this._createRow(row, "tbody");
    $tbody.appendTo($table);
    this.renderTemplate($tbody, dataRowTemplate, rowOptions, true, options2.change);
    this._rowPrepared($tbody, rowOptions, options2.row);
  }
  _renderRow($table, options2) {
    const {
      row
    } = options2;
    const {
      rowTemplate
    } = this.option();
    const dataRowTemplate = this.option("dataRowTemplate");
    if ("data" === row.rowType && dataRowTemplate) {
      this._renderDataRowByTemplate($table, options2, dataRowTemplate);
    } else if (("data" === row.rowType || "group" === row.rowType) && !isDefined(row.groupIndex) && rowTemplate) {
      this.renderTemplate($table, rowTemplate, extend({
        columns: options2.columns
      }, row), true);
    } else {
      super._renderRow($table, options2);
    }
  }
  _renderTable(options2) {
    const that = this;
    const $table = super._renderTable(options2);
    const resizeCompletedHandler = function() {
      const scrollableInstance = that.getScrollable();
      if (scrollableInstance && that.element().closest(getWindow().document).length) {
        that.resizeCompleted.remove(resizeCompletedHandler);
        scrollableInstance._visibilityChanged(true);
      }
    };
    if (!isDefined(that.getTableElement())) {
      that.setTableElement($table);
      that._renderScrollable(true);
      that.resizeCompleted.add(resizeCompletedHandler);
    } else {
      that._renderScrollable();
    }
    return $table;
  }
  _createTable() {
    const $table = super._createTable.apply(this, arguments);
    if (this.option().rowTemplate || this.option().dataRowTemplate) {
      $table.appendTo(this.component.$element());
    }
    return $table;
  }
  _renderCore(change) {
    const $element = this.element();
    $element.addClass(this.addWidgetPrefix("rowsview")).toggleClass(this.addWidgetPrefix("nowrap"), !this.option("wordWrapEnabled"));
    $element.toggleClass("dx-empty", this._dataController.isEmpty());
    this.setAria("role", "presentation", $element);
    const $table = this._renderTable({
      change
    });
    const deferred = this._updateContent($table, change);
    super._renderCore(change);
    this._lastColumnWidths = null;
    return deferred;
  }
  _getRows(change) {
    return change && change.items || this._dataController.items();
  }
  _getCellOptions(options2) {
    const that = this;
    const {
      column
    } = options2;
    const {
      row
    } = options2;
    const {
      data: data17
    } = row;
    const summaryCells = row && row.summaryCells;
    const {
      value: value2
    } = options2;
    const displayValue = m_utils_default.getDisplayValue(column, value2, data17, row.rowType);
    const parameters = super._getCellOptions(options2);
    parameters.value = value2;
    parameters.oldValue = options2.oldValue;
    parameters.displayValue = displayValue;
    parameters.row = row;
    parameters.key = row.key;
    parameters.data = data17;
    parameters.rowType = row.rowType;
    parameters.values = row.values;
    parameters.text = !column.command ? m_utils_default.formatValue(displayValue, column) : "";
    parameters.rowIndex = row.rowIndex;
    parameters.summaryItems = summaryCells && summaryCells[options2.columnIndex];
    parameters.resized = column.resizedCallbacks;
    if (isDefined(column.groupIndex) && !column.command) {
      const groupingTextsOptions = that.option("grouping.texts");
      const scrollingMode = that.option("scrolling.mode");
      if ("virtual" !== scrollingMode && "infinite" !== scrollingMode) {
        parameters.groupContinuesMessage = data17 && data17.isContinuationOnNextPage && groupingTextsOptions && groupingTextsOptions.groupContinuesMessage;
        parameters.groupContinuedMessage = data17 && data17.isContinuation && groupingTextsOptions && groupingTextsOptions.groupContinuedMessage;
      }
    }
    return parameters;
  }
  _toggleDraggableSourceColumnClass($rows, visibleColumns, columnIndex, value2) {
    const columnsController = this._columnsController;
    const columns7 = columnsController.getColumns();
    const column = columns7 && columns7[columnIndex];
    const columnID = column && column.isBand && column.index;
    each($rows, (rowIndex, row) => {
      if (!renderer_default(row).hasClass("dx-group-row")) {
        for (let i = 0; i < visibleColumns.length; i++) {
          if (isNumeric(columnID) && columnsController.isParentBandColumn(visibleColumns[i].index, columnID) || visibleColumns[i].index === columnIndex) {
            $rows.eq(rowIndex).children().eq(i).toggleClass(this.addWidgetPrefix(CLASSES.draggableColumn), value2);
            if (!isNumeric(columnID)) {
              break;
            }
          }
        }
      }
    });
  }
  _getDevicePixelRatio() {
    return getWindow().devicePixelRatio;
  }
  renderNoDataText() {
    return m_utils_default.renderNoDataText.apply(this, arguments);
  }
  getCellOptions(rowIndex, columnIdentifier) {
    const rowOptions = this._dataController.items()[rowIndex];
    let cellOptions;
    let column;
    if (rowOptions) {
      if (isString(columnIdentifier)) {
        column = this._columnsController.columnOption(columnIdentifier);
      } else {
        column = this._columnsController.getVisibleColumns()[columnIdentifier];
      }
      if (column) {
        cellOptions = this._getCellOptions({
          value: column.calculateCellValue(rowOptions.data),
          rowIndex: rowOptions.rowIndex,
          row: rowOptions,
          column
        });
      }
    }
    return cellOptions;
  }
  getRow(index2) {
    if (index2 >= 0) {
      const rows = this._getRowElements();
      if (rows.length > index2) {
        return renderer_default(rows[index2]);
      }
    }
    return;
  }
  updateFreeSpaceRowHeight($table) {
    const dataController2 = this._dataController;
    const itemCount = dataController2.items(true).length;
    const contentElement = this._findContentElement();
    const freeSpaceRowElements = this._getFreeSpaceRowElements($table);
    if (freeSpaceRowElements && contentElement && dataController2.totalCount() >= 0) {
      let isFreeSpaceRowVisible = false;
      if (itemCount > 0) {
        if (!this._hasHeight) {
          const freeSpaceRowCount = dataController2.pageSize() - itemCount;
          const scrollingMode = this.option("scrolling.mode");
          if (freeSpaceRowCount > 0 && dataController2.pageCount() > 1 && "virtual" !== scrollingMode && "infinite" !== scrollingMode) {
            setHeight2(freeSpaceRowElements, freeSpaceRowCount * this._rowHeight);
            isFreeSpaceRowVisible = true;
          }
          if (!isFreeSpaceRowVisible && $table) {
            setHeight2(freeSpaceRowElements, 0);
          } else {
            freeSpaceRowElements.toggle(isFreeSpaceRowVisible);
          }
          this._updateLastRowBorder(isFreeSpaceRowVisible);
        } else {
          freeSpaceRowElements.hide();
          deferUpdate(() => {
            const scrollbarWidth2 = this.getScrollbarWidth(true);
            const elementHeightWithoutScrollbar = getHeight(this.element()) - scrollbarWidth2;
            const contentHeight = getOuterHeight(contentElement);
            const showFreeSpaceRow = elementHeightWithoutScrollbar - contentHeight > 0;
            const rowsHeight = this._getRowsHeight(contentElement.children().first());
            const $tableElement = $table || this.getTableElements();
            const borderTopWidth = Math.ceil(parseFloat($tableElement.css("borderTopWidth")));
            const heightCorrection = this._getHeightCorrection();
            const resultHeight = elementHeightWithoutScrollbar - rowsHeight - borderTopWidth - heightCorrection;
            if (showFreeSpaceRow) {
              deferRender(() => {
                freeSpaceRowElements.css("height", resultHeight);
                isFreeSpaceRowVisible = true;
                freeSpaceRowElements.show();
              });
            }
            deferRender(() => this._updateLastRowBorder(isFreeSpaceRowVisible));
          });
        }
      } else {
        freeSpaceRowElements.css("height", 0);
        freeSpaceRowElements.show();
        this._updateLastRowBorder(true);
      }
    }
  }
  _getHeightCorrection() {
    const isZoomedWebkit = browser_default.webkit && this._getDevicePixelRatio() >= 2;
    const isChromeLatest = browser_default.chrome && browser_default.version >= 91;
    const hasExtraBorderTop = browser_default.mozilla && browser_default.version >= 70 && !this.option("showRowLines");
    return isZoomedWebkit || hasExtraBorderTop || isChromeLatest ? 1 : 0;
  }
  _columnOptionChanged(e) {
    const {
      optionNames
    } = e;
    if (e.changeTypes.grouping) {
      return;
    }
    if (optionNames.width || optionNames.visibleWidth) {
      super._columnOptionChanged(e);
      this._fireColumnResizedCallbacks();
    }
  }
  getScrollable() {
    return this._scrollable;
  }
  _handleDataChanged(change) {
    const that = this;
    switch (change.changeType) {
      case "refresh":
      case "prepend":
      case "append":
      case "update":
        that.render(null, change);
        break;
      default:
        that._update(change);
    }
  }
  publicMethods() {
    return ["isScrollbarVisible", "getTopVisibleRowData", "getScrollbarWidth", "getCellElement", "getRowElement", "getScrollable"];
  }
  contentWidth() {
    return getWidth(this.element()) - this.getScrollbarWidth();
  }
  getScrollbarWidth(isHorizontal) {
    const scrollableContainer = this._scrollableContainer && this._scrollableContainer.get(0);
    let scrollbarWidth2 = 0;
    if (scrollableContainer) {
      if (!isHorizontal) {
        scrollbarWidth2 = scrollableContainer.clientWidth ? scrollableContainer.offsetWidth - scrollableContainer.clientWidth : 0;
      } else {
        scrollbarWidth2 = scrollableContainer.clientHeight ? scrollableContainer.offsetHeight - scrollableContainer.clientHeight : 0;
        scrollbarWidth2 += getScrollableBottomPadding(this);
      }
    }
    return scrollbarWidth2 > 0 ? scrollbarWidth2 : 0;
  }
  _fireColumnResizedCallbacks() {
    const lastColumnWidths = this._lastColumnWidths || [];
    const columnWidths = [];
    const columns7 = this.getColumns();
    for (let i = 0; i < columns7.length; i++) {
      columnWidths[i] = columns7[i].visibleWidth;
      if (columns7[i].resizedCallbacks && !isDefined(columns7[i].groupIndex) && lastColumnWidths[i] !== columnWidths[i]) {
        columns7[i].resizedCallbacks.fire(columnWidths[i]);
      }
    }
    this._lastColumnWidths = columnWidths;
  }
  _updateLastRowBorder(isFreeSpaceRowVisible) {
    if (this.option("showBorders") && !isFreeSpaceRowVisible) {
      this.element().addClass(LAST_ROW_BORDER);
    } else {
      this.element().removeClass(LAST_ROW_BORDER);
    }
  }
  _updateScrollable() {
    const scrollable = ui_scrollable_default.getInstance(this.element());
    if (scrollable) {
      scrollable.update();
      if (scrollable.option("useNative") || !(null !== scrollable && void 0 !== scrollable && scrollable.isRenovated())) {
        this._updateHorizontalScrollPosition();
      }
    }
  }
  _updateHorizontalScrollPosition() {
    const scrollable = this.getScrollable();
    const scrollLeft = scrollable && scrollable.scrollOffset().left;
    const rtlEnabled = this.option("rtlEnabled");
    if (rtlEnabled) {
      const maxHorizontalScrollOffset = getMaxHorizontalScrollOffset(scrollable);
      const scrollRight = maxHorizontalScrollOffset - scrollLeft;
      if (scrollRight !== this._scrollRight) {
        this._scrollLeft = maxHorizontalScrollOffset - this._scrollRight;
      }
    }
    if (this._scrollLeft >= 0 && scrollLeft !== this._scrollLeft) {
      scrollable.scrollTo({
        x: this._scrollLeft
      });
    }
  }
  _resizeCore() {
    const that = this;
    that._fireColumnResizedCallbacks();
    that._updateRowHeight();
    deferRender(() => {
      that._renderScrollable();
      that.renderNoDataText();
      that.updateFreeSpaceRowHeight();
      deferUpdate(() => {
        that._updateScrollable();
      });
    });
  }
  scrollTo(location) {
    const $element = this.element();
    const dxScrollable = $element && ui_scrollable_default.getInstance($element);
    if (dxScrollable) {
      dxScrollable.scrollTo(location);
    }
  }
  height(height) {
    const that = this;
    const $element = this.element();
    if (0 === arguments.length) {
      return $element ? getOuterHeight($element, true) : 0;
    }
    if (isDefined(height) && $element) {
      that.hasHeight("auto" !== height);
      setHeight2($element, height);
    }
  }
  hasHeight(hasHeight) {
    if (0 === arguments.length) {
      return !!this._hasHeight;
    }
    this._hasHeight = hasHeight;
    return;
  }
  setLoading(isLoading, messageText) {
    const that = this;
    let loadPanel = that._loadPanel;
    const dataController2 = that._dataController;
    const loadPanelOptions = that.option("loadPanel") || {};
    const animation3 = dataController2.isLoaded() ? loadPanelOptions.animation : null;
    const $element = that.element();
    if (!hasWindow()) {
      return;
    }
    if (!loadPanel && void 0 !== messageText && dataController2.isLocalStore() && "auto" === loadPanelOptions.enabled && $element) {
      that._renderLoadPanel($element, $element.parent());
      loadPanel = that._loadPanel;
    }
    if (loadPanel) {
      const visibilityOptions = {
        message: messageText || loadPanelOptions.text,
        animation: animation3,
        visible: isLoading
      };
      if (isLoading) {
        visibilityOptions.position = m_utils_default.calculateLoadPanelPosition($element);
      }
      clearTimeout(that._hideLoadingTimeoutID);
      if (loadPanel.option("visible") && !isLoading) {
        that._hideLoadingTimeoutID = setTimeout(() => {
          loadPanel.option(visibilityOptions);
        }, 200);
      } else {
        loadPanel.option(visibilityOptions);
      }
    }
  }
  toggleDraggableColumnClass(columnIndex, value2) {
    const $rows = this._getRowElements().not(".dx-group-row") || [];
    this._toggleDraggableSourceColumnClass($rows, this.getColumns(), columnIndex, value2);
  }
  _getCellElementsCore(rowIndex) {
    const $cells = super._getCellElementsCore.apply(this, arguments);
    if ($cells) {
      const groupCellIndex = $cells.filter(".dx-group-cell").index();
      if (groupCellIndex >= 0 && $cells.length > groupCellIndex + 1) {
        return $cells.slice(0, groupCellIndex + 1);
      }
    }
    return $cells;
  }
  _getBoundaryVisibleItemIndex(isTop, isFloor) {
    const that = this;
    let itemIndex = 0;
    let prevOffset = 0;
    let offset2 = 0;
    let viewportBoundary = that._scrollTop;
    const $contentElement = that._findContentElement();
    const contentElementOffsetTop = $contentElement && $contentElement.offset().top;
    const items = this._dataController.items();
    const tableElement = that.getTableElement();
    if (items.length && tableElement) {
      const rowElements = that._getRowElements(tableElement).filter(":visible");
      if (!isTop) {
        const height = getOuterHeight(this._hasHeight ? this.element() : getWindow());
        viewportBoundary += height;
      }
      for (itemIndex = 0; itemIndex < items.length; itemIndex++) {
        prevOffset = offset2;
        const $rowElement = renderer_default(rowElements).eq(itemIndex);
        if ($rowElement.length) {
          offset2 = $rowElement.offset();
          offset2 = (isTop ? offset2.top : offset2.top + getOuterHeight($rowElement)) - contentElementOffsetTop;
          if (offset2 > viewportBoundary) {
            if (itemIndex) {
              if (isFloor || 2 * viewportBoundary < Math.round(offset2 + prevOffset)) {
                itemIndex--;
              }
            }
            break;
          }
        }
      }
      if (itemIndex && itemIndex === items.length) {
        itemIndex--;
      }
    }
    return itemIndex;
  }
  getTopVisibleItemIndex(isFloor) {
    return this._getBoundaryVisibleItemIndex(true, isFloor);
  }
  getBottomVisibleItemIndex(isFloor) {
    return this._getBoundaryVisibleItemIndex(false, isFloor);
  }
  getTopVisibleRowData() {
    const itemIndex = this.getTopVisibleItemIndex();
    const items = this._dataController.items();
    if (items[itemIndex]) {
      return items[itemIndex].data;
    }
    return;
  }
  _scrollToElement($element, offset2) {
    const scrollable = this.getScrollable();
    scrollable && scrollable.scrollToElement($element, offset2);
  }
  optionChanged(args) {
    const that = this;
    super.optionChanged(args);
    switch (args.name) {
      case "wordWrapEnabled":
      case "showColumnLines":
      case "showRowLines":
      case "rowAlternationEnabled":
      case "rowTemplate":
      case "dataRowTemplate":
      case "twoWayBindingEnabled":
        that._invalidate(true, true);
        args.handled = true;
        break;
      case "scrolling":
        that._rowHeight = null;
        that._tableElement = null;
        args.handled = true;
        break;
      case "rtlEnabled":
        that._rowHeight = null;
        that._tableElement = null;
        break;
      case "loadPanel":
        that._tableElement = null;
        that._invalidate(true, "loadPanel.enabled" !== args.fullName);
        args.handled = true;
        break;
      case "noDataText":
        that.renderNoDataText();
        args.handled = true;
    }
  }
  setAriaOwns(headerTableId, footerTableId, isFixed) {
    const $contentElement = this._findContentElement();
    const $tableElement = this.getTableElement();
    if (null !== $tableElement && void 0 !== $tableElement && $tableElement.length) {
      this.setAria("owns", `${headerTableId ?? ""} ${$tableElement.attr("id") ?? ""} ${footerTableId ?? ""}`.trim(), $contentElement);
    }
  }
  dispose() {
    super.dispose();
    clearTimeout(this._hideLoadingTimeoutID);
    this._scrollable && this._scrollable.dispose();
  }
  setScrollerSpacing(vScrollbarWidth, hScrollbarWidth) {
  }
  getFixedContentElement() {
    var _this$element;
    const fixedContentClass = this.addWidgetPrefix("content-fixed");
    return null === (_this$element = this.element()) || void 0 === _this$element ? void 0 : _this$element.children(`.${fixedContentClass}`);
  }
  _restoreErrorRow(contentTable) {
  }
  isElementInside($element) {
    const $rowsViewElement = $element.closest(`.${this.addWidgetPrefix("rowsview")}`);
    return $rowsViewElement.is(this.element());
  }
};
var rowsModule = {
  defaultOptions: () => ({
    hoverStateEnabled: false,
    scrolling: {
      useNative: "auto"
    },
    loadPanel: {
      enabled: "auto",
      text: message_default.format("Loading"),
      width: 200,
      height: 90,
      showIndicator: true,
      indicatorSrc: "",
      showPane: true
    },
    dataRowTemplate: null,
    columnAutoWidth: false,
    noDataText: message_default.format("dxDataGrid-noDataText"),
    wordWrapEnabled: false,
    showColumnLines: true,
    showRowLines: false,
    rowAlternationEnabled: false,
    activeStateEnabled: false,
    twoWayBindingEnabled: true
  }),
  views: {
    rowsView: RowsView
  }
};

// node_modules/devextreme/esm/__internal/grids/data_grid/module_not_extended/rows.js
var RowsView2 = rowsModule.views.rowsView;
m_core_default.registerModule("rows", rowsModule);

// node_modules/devextreme/esm/__internal/events/m_hold.js
var {
  abs: abs2
} = Math;
var HoldEmitter = m_emitter_default.inherit({
  start(e) {
    this._startEventData = eventData(e);
    this._startTimer(e);
  },
  _startTimer(e) {
    const holdTimeout = "timeout" in this ? this.timeout : 750;
    this._holdTimer = setTimeout(() => {
      this._requestAccept(e);
      this._fireEvent("dxhold", e, {
        target: e.target
      });
      this._forgetAccept();
    }, holdTimeout);
  },
  move(e) {
    if (this._touchWasMoved(e)) {
      this._cancel(e);
    }
  },
  _touchWasMoved(e) {
    const delta = eventDelta(this._startEventData, eventData(e));
    return abs2(delta.x) > 5 || abs2(delta.y) > 5;
  },
  end() {
    this._stopTimer();
  },
  _stopTimer() {
    clearTimeout(this._holdTimer);
  },
  cancel() {
    this._stopTimer();
  },
  dispose() {
    this._stopTimer();
  }
});
m_emitter_registrator_default({
  emitter: HoldEmitter,
  bubble: true,
  events: ["dxhold"]
});
var m_hold_default = {
  name: "dxhold"
};

// node_modules/devextreme/esm/__internal/events/m_contextmenu.js
var CONTEXTMENU_NAMESPACED_EVENT_NAME = addNamespace2("contextmenu", "dxContexMenu");
var HOLD_NAMESPACED_EVENT_NAME = addNamespace2(m_hold_default.name, "dxContexMenu");
var ContextMenu = class_default.inherit({
  setup(element) {
    const $element = renderer_default(element);
    m_events_engine_default.on($element, CONTEXTMENU_NAMESPACED_EVENT_NAME, this._contextMenuHandler.bind(this));
    if (m_support_default.touch || m_devices_default.isSimulator()) {
      m_events_engine_default.on($element, HOLD_NAMESPACED_EVENT_NAME, this._holdHandler.bind(this));
    }
  },
  _holdHandler(e) {
    if (isMouseEvent(e) && !m_devices_default.isSimulator()) {
      return;
    }
    this._fireContextMenu(e);
  },
  _contextMenuHandler(e) {
    this._fireContextMenu(e);
  },
  _fireContextMenu: (e) => fireEvent({
    type: "dxcontextmenu",
    originalEvent: e
  }),
  teardown(element) {
    m_events_engine_default.off(element, ".dxContexMenu");
  }
});
m_event_registrator_default("dxcontextmenu", new ContextMenu());
var name = "dxcontextmenu";

// node_modules/devextreme/esm/ui/overlay/ui.overlay.js
var ui_overlay_default = m_overlay_default;

// node_modules/devextreme/esm/ui/widget/utils.ink_ripple.js
var initConfig = function() {
  let config3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
  const {
    useHoldAnimation,
    waveSizeCoefficient,
    isCentered,
    wavesNumber
  } = config3;
  return {
    waveSizeCoefficient: waveSizeCoefficient || 2,
    isCentered: isCentered || false,
    wavesNumber: wavesNumber || 1,
    durations: getDurations(useHoldAnimation ?? true)
  };
};
var render = function(args) {
  const config3 = initConfig(args);
  return {
    showWave: showWave.bind(this, config3),
    hideWave: hideWave.bind(this, config3)
  };
};
var getInkRipple = function(element) {
  let result2 = element.children(".dx-inkripple");
  if (0 === result2.length) {
    result2 = renderer_default("<div>").addClass("dx-inkripple").appendTo(element);
  }
  return result2;
};
var getWaves = function(element, wavesNumber) {
  const inkRipple = getInkRipple(renderer_default(element));
  const result2 = inkRipple.children(".dx-inkripple-wave").toArray();
  for (let i = result2.length; i < wavesNumber; i++) {
    const $currentWave = renderer_default("<div>").appendTo(inkRipple).addClass("dx-inkripple-wave");
    result2.push($currentWave[0]);
  }
  return renderer_default(result2);
};
var getWaveStyleConfig = function(args, config3) {
  const element = renderer_default(config3.element);
  const elementWidth = getOuterWidth(element);
  const elementHeight = getOuterHeight(element);
  const elementDiagonal = parseInt(Math.sqrt(elementWidth * elementWidth + elementHeight * elementHeight));
  const waveSize = Math.min(4e3, parseInt(elementDiagonal * args.waveSizeCoefficient));
  let left;
  let top;
  if (args.isCentered) {
    left = (elementWidth - waveSize) / 2;
    top = (elementHeight - waveSize) / 2;
  } else {
    const event = config3.event;
    const position3 = element.offset();
    const x = event.pageX - position3.left;
    const y = event.pageY - position3.top;
    left = x - waveSize / 2;
    top = y - waveSize / 2;
  }
  return {
    left,
    top,
    height: waveSize,
    width: waveSize
  };
};
function showWave(args, config3) {
  const $wave = getWaves(config3.element, args.wavesNumber).eq(config3.wave || 0);
  args.hidingTimeout && clearTimeout(args.hidingTimeout);
  hideSelectedWave($wave);
  $wave.css(getWaveStyleConfig(args, config3));
  args.showingTimeout = setTimeout(showingWaveHandler.bind(this, args, $wave), 0);
}
function showingWaveHandler(args, $wave) {
  const durationCss = args.durations.showingScale + "ms";
  $wave.addClass("dx-inkripple-showing").css("transitionDuration", durationCss);
}
function getDurations(useHoldAnimation) {
  return {
    showingScale: useHoldAnimation ? 1e3 : 300,
    hidingScale: 300,
    hidingOpacity: 300
  };
}
function hideSelectedWave($wave) {
  $wave.removeClass("dx-inkripple-hiding").css("transitionDuration", "");
}
function hideWave(args, config3) {
  args.showingTimeout && clearTimeout(args.showingTimeout);
  const $wave = getWaves(config3.element, config3.wavesNumber).eq(config3.wave || 0);
  const durations = args.durations;
  const durationCss = durations.hidingScale + "ms, " + durations.hidingOpacity + "ms";
  $wave.addClass("dx-inkripple-hiding").removeClass("dx-inkripple-showing").css("transitionDuration", durationCss);
  const animationDuration = Math.max(durations.hidingScale, durations.hidingOpacity);
  args.hidingTimeout = setTimeout(hideSelectedWave.bind(this, $wave), animationDuration);
}

// node_modules/devextreme/esm/__internal/ui/collection/item.js
var forcibleWatcher = (watchMethod, fn, callback) => {
  const filteredCallback = /* @__PURE__ */ (() => {
    let oldValue;
    return (value2) => {
      if (oldValue !== value2) {
        callback(value2, oldValue);
        oldValue = value2;
      }
    };
  })();
  return {
    dispose: watchMethod(fn, filteredCallback),
    force() {
      filteredCallback(fn());
    }
  };
};
var CollectionItem = class extends class_default.inherit({}) {
  ctor($element, options2, rawData) {
    this._$element = $element;
    this._options = options2;
    this._rawData = rawData;
    attachInstanceToElement($element, this, this._dispose);
    this._render();
  }
  _render() {
    const $placeholder = renderer_default("<div>").addClass("dx-item-content-placeholder");
    this._$element.append($placeholder);
    this._watchers = [];
    this._renderWatchers();
  }
  _renderWatchers() {
    this._startWatcher("disabled", this._renderDisabled.bind(this));
    this._startWatcher("visible", this._renderVisible.bind(this));
  }
  _startWatcher(field, render3) {
    const rawData = this._rawData;
    const exprGetter = this._options.fieldGetter(field);
    const watcher = forcibleWatcher(this._options.watchMethod(), () => exprGetter(rawData), (value2, oldValue) => {
      this._dirty = true;
      render3(value2, oldValue);
    });
    this._watchers.push(watcher);
  }
  setDataField() {
    this._dirty = false;
    each(this._watchers, (_, watcher) => {
      watcher.force();
    });
    return this._dirty;
  }
  _renderDisabled(value2, oldValue) {
    this._$element.toggleClass("dx-state-disabled", !!value2);
    this._$element.attr("aria-disabled", !!value2);
    this._updateOwnerFocus(value2);
  }
  _updateOwnerFocus(isDisabled) {
    const ownerComponent = this._options.owner;
    if (ownerComponent && isDisabled) {
      ownerComponent._resetItemFocus(this._$element);
    }
  }
  _renderVisible(value2, oldValue) {
    this._$element.toggleClass("dx-state-invisible", void 0 !== value2 && !value2);
  }
  _dispose() {
    each(this._watchers, (_, watcher) => {
      watcher.dispose();
    });
  }
  static getInstance($element) {
    return getInstanceByElement($element, this);
  }
};
var item_default = CollectionItem;

// node_modules/devextreme/esm/__internal/ui/collection/m_collection_widget.edit.strategy.js
var EditStrategy = class extends class_default.inherit({}) {
  constructor(collectionWidget) {
    super();
    this._collectionWidget = collectionWidget;
  }
  getIndexByItemData(value2) {
    return class_default.abstract();
  }
  getItemDataByIndex(index2) {
    class_default.abstract();
  }
  getKeysByItems(items) {
    class_default.abstract();
  }
  getItemsByKeys(keys, items) {
    class_default.abstract();
  }
  itemsGetter() {
    class_default.abstract();
  }
  getKeyByIndex(index2) {
    const resultIndex = this._denormalizeItemIndex(index2);
    return this.getKeysByItems([this.getItemDataByIndex(resultIndex)])[0];
  }
  _equalKeys(key1, key2) {
    if (this._collectionWidget._isKeySpecified()) {
      return equalByValue(key1, key2);
    }
    return key1 === key2;
  }
  beginCache() {
    this._cache = {};
  }
  endCache() {
    this._cache = null;
  }
  getIndexByKey(key) {
    return class_default.abstract();
  }
  getNormalizedIndex(value2) {
    if (this._isNormalizedItemIndex(value2)) {
      return value2;
    }
    if (this._isItemIndex(value2)) {
      return this._normalizeItemIndex(value2);
    }
    if (this._isNode(value2)) {
      return this._getNormalizedItemIndex(value2);
    }
    return this._normalizeItemIndex(this.getIndexByItemData(value2));
  }
  getIndex(value2) {
    if (this._isNormalizedItemIndex(value2)) {
      return this._denormalizeItemIndex(value2);
    }
    if (this._isItemIndex(value2)) {
      return value2;
    }
    if (this._isNode(value2)) {
      return this._denormalizeItemIndex(this._getNormalizedItemIndex(value2));
    }
    return this.getIndexByItemData(value2);
  }
  getItemElement(value2) {
    if (this._isNormalizedItemIndex(value2)) {
      return this._getItemByNormalizedIndex(value2);
    }
    if (this._isItemIndex(value2)) {
      return this._getItemByNormalizedIndex(this._normalizeItemIndex(value2));
    }
    if (this._isNode(value2)) {
      return renderer_default(value2);
    }
    const normalizedItemIndex = this._normalizeItemIndex(this.getIndexByItemData(value2));
    return this._getItemByNormalizedIndex(normalizedItemIndex);
  }
  _isNode(el) {
    return dom_adapter_default.isNode(el && isRenderer(el) ? el.get(0) : el);
  }
  deleteItemAtIndex(index2) {
    class_default.abstract();
  }
  itemPlacementFunc(movingIndex, destinationIndex) {
    return this._itemsFromSameParent(movingIndex, destinationIndex) && movingIndex < destinationIndex ? "after" : "before";
  }
  moveItemAtIndexToIndex(movingIndex, destinationIndex) {
    class_default.abstract();
  }
  _isNormalizedItemIndex(index2) {
    return "number" === typeof index2 && Math.round(index2) === index2;
  }
  _isItemIndex(index2) {
    return class_default.abstract();
  }
  _getNormalizedItemIndex(value2) {
    return class_default.abstract();
  }
  _normalizeItemIndex(index2) {
    return class_default.abstract();
  }
  _denormalizeItemIndex(index2) {
    return class_default.abstract();
  }
  _getItemByNormalizedIndex(value2) {
    return class_default.abstract();
  }
  _itemsFromSameParent(movingIndex, destinationIndex) {
    return class_default.abstract();
  }
};
var m_collection_widget_edit_strategy_default = EditStrategy;

// node_modules/devextreme/esm/__internal/ui/collection/m_collection_widget.edit.strategy.plain.js
var PlainEditStrategy = class extends m_collection_widget_edit_strategy_default {
  _getPlainItems() {
    return this._collectionWidget.option("items") || [];
  }
  getIndexByItemData(itemData) {
    const keyOf = this._collectionWidget.keyOf.bind(this._collectionWidget);
    if (keyOf) {
      return this.getIndexByKey(keyOf(itemData));
    }
    return this._getPlainItems().indexOf(itemData);
  }
  getItemDataByIndex(index2) {
    return this._getPlainItems()[index2];
  }
  deleteItemAtIndex(index2) {
    this._getPlainItems().splice(index2, 1);
  }
  itemsGetter() {
    return this._getPlainItems();
  }
  getKeysByItems(items) {
    const keyOf = this._collectionWidget.keyOf.bind(this._collectionWidget);
    let result2 = items;
    if (keyOf) {
      result2 = [];
      for (let i = 0; i < items.length; i++) {
        result2.push(keyOf(items[i]));
      }
    }
    return result2;
  }
  getIndexByKey(key) {
    const cache = this._cache;
    const keys = cache && cache.keys || this.getKeysByItems(this._getPlainItems());
    if (cache && !cache.keys) {
      cache.keys = keys;
    }
    if ("object" === typeof key) {
      for (let i = 0, {
        length
      } = keys; i < length; i++) {
        if (this._equalKeys(key, keys[i])) {
          return i;
        }
      }
    } else {
      return keys.indexOf(key);
    }
    return -1;
  }
  getItemsByKeys(keys, items) {
    return (items || keys).slice();
  }
  moveItemAtIndexToIndex(movingIndex, destinationIndex) {
    const items = this._getPlainItems();
    const movedItemData = items[movingIndex];
    items.splice(movingIndex, 1);
    items.splice(destinationIndex, 0, movedItemData);
  }
  _isItemIndex(index2) {
    return "number" === typeof index2 && Math.round(index2) === index2;
  }
  _getNormalizedItemIndex(itemElement) {
    return this._collectionWidget._itemElements().index(itemElement);
  }
  _normalizeItemIndex(index2) {
    return index2;
  }
  _denormalizeItemIndex(index2) {
    return index2;
  }
  _getItemByNormalizedIndex(index2) {
    return index2 > -1 ? this._collectionWidget._itemElements().eq(index2) : null;
  }
  _itemsFromSameParent(firstIndex, secondIndex) {
    return true;
  }
};
var m_collection_widget_edit_strategy_plain_default = PlainEditStrategy;

// node_modules/devextreme/esm/__internal/ui/context_menu/m_menu_base.edit.strategy.js
var MenuBaseEditStrategy = class extends m_collection_widget_edit_strategy_plain_default {
  _getPlainItems() {
    return map(this._collectionWidget.option("items"), function getMenuItems(item) {
      return item.items ? [item].concat(map(item.items, getMenuItems)) : item;
    });
  }
  _stringifyItem(item) {
    return JSON.stringify(item, (key, value2) => {
      if ("template" === key) {
        return this._getTemplateString(value2);
      }
      return value2;
    });
  }
  _getTemplateString(template) {
    let result2;
    if ("object" === typeof template) {
      result2 = renderer_default(template).text();
    } else {
      result2 = template.toString();
    }
    return result2;
  }
};
var m_menu_base_edit_strategy_default = MenuBaseEditStrategy;

// node_modules/devextreme/esm/__internal/core/templates/m_bindable_template.js
var watchChanges = function(rawData, watchMethod, fields, fieldsMap, callback) {
  let fieldsDispose;
  const globalDispose = ((data17, watchMethod2, callback2) => watchMethod2(() => data17, callback2))(rawData, watchMethod, (dataWithRawFields) => {
    fieldsDispose && fieldsDispose();
    if (isPrimitive(dataWithRawFields)) {
      callback(dataWithRawFields);
      return;
    }
    fieldsDispose = function(data17, watchMethod2, fields2, fieldsMap2, callback2) {
      const resolvedData = {};
      const missedFields = fields2.slice();
      const watchHandlers = fields2.map((name2) => {
        const fieldGetter = fieldsMap2[name2];
        return watchMethod2(fieldGetter ? () => fieldGetter(data17) : () => data17[name2], (value2) => {
          resolvedData[name2] = value2;
          if (missedFields.length) {
            const index2 = missedFields.indexOf(name2);
            if (index2 >= 0) {
              missedFields.splice(index2, 1);
            }
          }
          if (!missedFields.length) {
            callback2(resolvedData);
          }
        });
      });
      return function() {
        watchHandlers.forEach((dispose2) => dispose2());
      };
    }(dataWithRawFields, watchMethod, fields, fieldsMap, callback);
  });
  return function() {
    fieldsDispose && fieldsDispose();
    globalDispose && globalDispose();
  };
};
var BindableTemplate = class extends TemplateBase {
  constructor(render3, fields, watchMethod, fieldsMap) {
    super();
    this._render = render3;
    this._fields = fields;
    this._fieldsMap = fieldsMap || {};
    this._watchMethod = watchMethod;
  }
  _renderCore(options2) {
    const $container = renderer_default(options2.container);
    const dispose2 = watchChanges(options2.model, this._watchMethod, this._fields, this._fieldsMap, (data17) => {
      $container.empty();
      this._render($container, data17, options2.model);
    });
    m_events_engine_default.on($container, removeEvent, dispose2);
    return $container.contents();
  }
};

// node_modules/devextreme/esm/__internal/core/utils/m_icon.js
var getImageSourceType = (source) => {
  if (!source || "string" !== typeof source) {
    return false;
  }
  if (/^\s*<svg[^>]*>(.|\r?\n)*?<\/svg>\s*$/i.test(source)) {
    return "svg";
  }
  if (/data:.*base64|\.|[^<\s]\/{1,1}/.test(source)) {
    return "image";
  }
  if (/^[\w-_]+$/.test(source)) {
    return "dxIcon";
  }
  if (/^\s?([\w-_:]\s?)+$/.test(source)) {
    return "fontIcon";
  }
  return false;
};
var getImageContainer = (source) => {
  switch (getImageSourceType(source)) {
    case "image":
      return renderer_default("<img>").attr("src", source).addClass("dx-icon");
    case "fontIcon":
      return renderer_default("<i>").addClass(`dx-icon ${source}`);
    case "dxIcon":
      return renderer_default("<i>").addClass(`dx-icon dx-icon-${source}`);
    case "svg":
      return renderer_default("<i>").addClass("dx-icon dx-svg-icon").append(source);
    default:
      return null;
  }
};

// node_modules/devextreme/esm/__internal/data/m_data_helper.js
var DATA_SOURCE_CHANGED_METHOD2 = "_dataSourceChangedHandler";
var SPECIFIC_DATA_SOURCE_OPTION2 = "_getSpecificDataSourceOption";
var NORMALIZE_DATA_SOURCE2 = "_normalizeDataSource";
var DataHelperMixin2 = {
  postCtor() {
    this.on("disposing", () => {
      this._disposeDataSource();
    });
  },
  _refreshDataSource() {
    this._initDataSource();
    this._loadDataSource();
  },
  _initDataSource() {
    let dataSourceOptions = SPECIFIC_DATA_SOURCE_OPTION2 in this ? this[SPECIFIC_DATA_SOURCE_OPTION2]() : this.option("dataSource");
    let widgetDataSourceOptions;
    let dataSourceType;
    this._disposeDataSource();
    if (dataSourceOptions) {
      if (dataSourceOptions instanceof DataSource) {
        this._isSharedDataSource = true;
        this._dataSource = dataSourceOptions;
      } else {
        widgetDataSourceOptions = "_dataSourceOptions" in this ? this._dataSourceOptions() : {};
        dataSourceType = this._dataSourceType ? this._dataSourceType() : DataSource;
        dataSourceOptions = normalizeDataSourceOptions(dataSourceOptions, {
          fromUrlLoadMode: "_dataSourceFromUrlLoadMode" in this && this._dataSourceFromUrlLoadMode()
        });
        this._dataSource = new dataSourceType(extend(true, {}, widgetDataSourceOptions, dataSourceOptions));
      }
      if (NORMALIZE_DATA_SOURCE2 in this) {
        this._dataSource = this[NORMALIZE_DATA_SOURCE2](this._dataSource);
      }
      this._addDataSourceHandlers();
      this._initDataController();
    }
  },
  _initDataController() {
    var _this$option;
    const dataController2 = null === (_this$option = this.option) || void 0 === _this$option ? void 0 : _this$option.call(this, "_dataController");
    const dataSource = this._dataSource;
    if (dataController2) {
      this._dataController = dataController2;
    } else {
      this._dataController = new m_data_controller_default(dataSource);
    }
  },
  _addDataSourceHandlers() {
    if (DATA_SOURCE_CHANGED_METHOD2 in this) {
      this._addDataSourceChangeHandler();
    }
    if ("_dataSourceLoadErrorHandler" in this) {
      this._addDataSourceLoadErrorHandler();
    }
    if ("_dataSourceLoadingChangedHandler" in this) {
      this._addDataSourceLoadingChangedHandler();
    }
    this._addReadyWatcher();
  },
  _addReadyWatcher() {
    this.readyWatcher = function(isLoading) {
      this._ready && this._ready(!isLoading);
    }.bind(this);
    this._dataSource.on("loadingChanged", this.readyWatcher);
  },
  _addDataSourceChangeHandler() {
    const dataSource = this._dataSource;
    this._proxiedDataSourceChangedHandler = function(e) {
      this[DATA_SOURCE_CHANGED_METHOD2](dataSource.items(), e);
    }.bind(this);
    dataSource.on("changed", this._proxiedDataSourceChangedHandler);
  },
  _addDataSourceLoadErrorHandler() {
    this._proxiedDataSourceLoadErrorHandler = this._dataSourceLoadErrorHandler.bind(this);
    this._dataSource.on("loadError", this._proxiedDataSourceLoadErrorHandler);
  },
  _addDataSourceLoadingChangedHandler() {
    this._proxiedDataSourceLoadingChangedHandler = this._dataSourceLoadingChangedHandler.bind(this);
    this._dataSource.on("loadingChanged", this._proxiedDataSourceLoadingChangedHandler);
  },
  _loadDataSource() {
    const dataSource = this._dataSource;
    if (dataSource) {
      if (dataSource.isLoaded()) {
        this._proxiedDataSourceChangedHandler && this._proxiedDataSourceChangedHandler();
      } else {
        dataSource.load();
      }
    }
  },
  _loadSingle(key, value2) {
    key = "this" === key ? this._dataSource.key() || "this" : key;
    return this._dataSource.loadSingle(key, value2);
  },
  _isLastPage() {
    return !this._dataSource || this._dataSource.isLastPage() || !this._dataSource._pageSize;
  },
  _isDataSourceLoading() {
    return this._dataSource && this._dataSource.isLoading();
  },
  _disposeDataSource() {
    if (this._dataSource) {
      if (this._isSharedDataSource) {
        delete this._isSharedDataSource;
        this._proxiedDataSourceChangedHandler && this._dataSource.off("changed", this._proxiedDataSourceChangedHandler);
        this._proxiedDataSourceLoadErrorHandler && this._dataSource.off("loadError", this._proxiedDataSourceLoadErrorHandler);
        this._proxiedDataSourceLoadingChangedHandler && this._dataSource.off("loadingChanged", this._proxiedDataSourceLoadingChangedHandler);
        if (this._dataSource._eventsStrategy) {
          this._dataSource._eventsStrategy.off("loadingChanged", this.readyWatcher);
        }
      } else {
        this._dataSource.dispose();
      }
      delete this._dataSource;
      delete this._proxiedDataSourceChangedHandler;
      delete this._proxiedDataSourceLoadErrorHandler;
      delete this._proxiedDataSourceLoadingChangedHandler;
    }
  },
  getDataSource() {
    return this._dataSource || null;
  }
};

// node_modules/devextreme/esm/data_helper.js
var data_helper_default = DataHelperMixin2;

// node_modules/devextreme/esm/__internal/ui/collection/collection_widget.base.js
var ITEM_CLASS = "dx-item";
var EMPTY_COLLECTION = "dx-empty-collection";
var ITEM_PATH_REGEX = /^([^.]+\[\d+\]\.)+([\w.]+)$/;
var CollectionWidget = class extends widget_default {
  _supportedKeys() {
    const move2 = (location, e) => {
      if (!isCommandKeyPressed(e)) {
        e.preventDefault();
        e.stopPropagation();
        this._moveFocus(location, e);
      }
    };
    return _extends({}, super._supportedKeys(), {
      space: (e) => {
        e.preventDefault();
        this._enterKeyHandler(e);
      },
      enter: this._enterKeyHandler,
      leftArrow: move2.bind(this, "left"),
      rightArrow: move2.bind(this, "right"),
      upArrow: move2.bind(this, "up"),
      downArrow: move2.bind(this, "down"),
      pageUp: move2.bind(this, "up"),
      pageDown: move2.bind(this, "down"),
      home: move2.bind(this, "first"),
      end: move2.bind(this, "last")
    });
  }
  _getHandlerExtendedParams(e, $target) {
    const params = extend({}, e, {
      target: $target.get(0),
      currentTarget: $target.get(0)
    });
    return params;
  }
  _enterKeyHandler(e) {
    const {
      focusedElement
    } = this.option();
    const $itemElement = renderer_default(focusedElement);
    if (!$itemElement.length) {
      return;
    }
    const itemData = this._getItemData($itemElement);
    if (null !== itemData && void 0 !== itemData && itemData.onClick) {
      this._itemEventHandlerByHandler($itemElement, itemData.onClick, {
        event: e
      });
    }
    this._itemClickHandler(this._getHandlerExtendedParams(e, $itemElement));
  }
  _getDefaultOptions() {
    return _extends({}, super._getDefaultOptions(), {
      selectOnFocus: false,
      loopItemFocus: true,
      items: [],
      itemTemplate: "item",
      onItemRendered: null,
      onItemClick: null,
      onItemHold: null,
      itemHoldTimeout: 750,
      onItemContextMenu: null,
      onFocusedItemChanged: null,
      noDataText: message_default.format("dxCollectionWidget-noDataText"),
      encodeNoDataText: false,
      dataSource: null,
      _dataController: null,
      _itemAttributes: {},
      itemTemplateProperty: "template",
      focusedElement: null,
      displayExpr: void 0,
      disabledExpr: (data17) => data17 ? data17.disabled : void 0,
      visibleExpr: (data17) => data17 ? data17.visible : void 0
    });
  }
  _init() {
    this._compileDisplayGetter();
    this._initDataController();
    super._init();
    this._activeStateUnit = `.${ITEM_CLASS}`;
    this._cleanRenderedItems();
    this._refreshDataSource();
  }
  _compileDisplayGetter() {
    const {
      displayExpr
    } = this.option();
    this._displayGetter = displayExpr ? compileGetter(displayExpr) : void 0;
  }
  _initTemplates() {
    this._initItemsFromMarkup();
    this._initDefaultItemTemplate();
    super._initTemplates();
  }
  _getAnonymousTemplateName() {
    return "item";
  }
  _initDefaultItemTemplate() {
    const fieldsMap = this._getFieldsMap();
    this._templateManager.addDefaultTemplates({
      item: new BindableTemplate(($container, data17) => {
        if (isPlainObject(data17)) {
          this._prepareDefaultItemTemplate(data17, $container);
        } else {
          if (fieldsMap && isFunction(fieldsMap.text)) {
            data17 = fieldsMap.text(data17);
          }
          $container.text(String(ensureDefined(data17, "")));
        }
      }, this._getBindableFields(), this.option("integrationOptions.watchMethod"), fieldsMap)
    });
  }
  _getBindableFields() {
    return ["text", "html"];
  }
  _getFieldsMap() {
    if (this._displayGetter) {
      return {
        text: this._displayGetter
      };
    }
    return;
  }
  _prepareDefaultItemTemplate(data17, $container) {
    const {
      text,
      html
    } = data17;
    if (isDefined(text)) {
      $container.text(text);
    }
    if (isDefined(html)) {
      $container.html(html);
    }
  }
  _initItemsFromMarkup() {
    const rawItems = findTemplates(this.$element(), "dxItem");
    if (!rawItems.length || this.option("items").length) {
      return;
    }
    const items = rawItems.map((_ref) => {
      let {
        element,
        options: options2
      } = _ref;
      const isTemplateRequired = /\S/.test(element.innerHTML) && !options2.template;
      if (isTemplateRequired) {
        options2.template = this._prepareItemTemplate(element);
      } else {
        renderer_default(element).remove();
      }
      return options2;
    });
    this.option("items", items);
  }
  _prepareItemTemplate(item) {
    const templateId = `tmpl-${new guid_default2()}`;
    const $template = renderer_default(item).detach().clone().removeAttr("data-options").addClass("dx-template-wrapper");
    this._saveTemplate(templateId, $template);
    return templateId;
  }
  _dataSourceOptions() {
    return {
      paginate: false
    };
  }
  _cleanRenderedItems() {
    this._renderedItemsCount = 0;
  }
  _focusTarget() {
    return this.$element();
  }
  _focusInHandler(e) {
    super._focusInHandler(e);
    if (!this._isFocusTarget(e.target)) {
      return;
    }
    const $focusedElement = renderer_default(this.option("focusedElement"));
    if ($focusedElement.length) {
      this._shouldSkipSelectOnFocus = true;
      this._setFocusedItem($focusedElement);
      this._shouldSkipSelectOnFocus = false;
    } else {
      const $activeItem = this._getActiveItem();
      if ($activeItem.length) {
        this.option("focusedElement", getPublicElement($activeItem));
      }
    }
  }
  _focusOutHandler(e) {
    super._focusOutHandler(e);
    const {
      focusedElement
    } = this.option();
    const $target = renderer_default(focusedElement);
    this._updateFocusedItemState($target, false);
  }
  _findActiveTarget($element) {
    return $element.find(this._activeStateUnit);
  }
  _getActiveItem(last) {
    const {
      focusedElement
    } = this.option();
    const $focusedElement = renderer_default(focusedElement);
    if ($focusedElement.length) {
      return $focusedElement;
    }
    return this._determineFocusedElement(last);
  }
  _determineFocusedElement(last) {
    let index2 = this._getFocusedElementIndex();
    const activeElements = this._getActiveElement();
    const lastIndex = activeElements.length - 1;
    if (index2 < 0) {
      index2 = last ? lastIndex : 0;
    }
    return activeElements.eq(index2);
  }
  _getFocusedElementIndex() {
    return 0;
  }
  _moveFocus(location, e) {
    const $items = this._getAvailableItems();
    let $newTarget = renderer_default();
    switch (location) {
      case "pageup":
      case "up":
        $newTarget = this._prevItem($items);
        break;
      case "pagedown":
      case "down":
        $newTarget = this._nextItem($items);
        break;
      case "right":
        $newTarget = this.option("rtlEnabled") ? this._prevItem($items) : this._nextItem($items);
        break;
      case "left":
        $newTarget = this.option("rtlEnabled") ? this._nextItem($items) : this._prevItem($items);
        break;
      case "first":
        $newTarget = $items.first();
        break;
      case "last":
        $newTarget = $items.last();
        break;
      default:
        return false;
    }
    if (0 !== $newTarget.length) {
      this.option("focusedElement", getPublicElement($newTarget));
    }
  }
  _getVisibleItems($itemElements) {
    const $items = $itemElements ?? this._itemElements();
    return $items.filter(":visible");
  }
  _getAvailableItems($itemElements) {
    return this._getVisibleItems($itemElements);
  }
  _prevItem($items) {
    const $target = this._getActiveItem();
    const targetIndex = $items.index($target);
    const $last = $items.last();
    let $item = renderer_default($items[targetIndex - 1]);
    const loop = this.option("loopItemFocus");
    if (0 === $item.length && loop) {
      $item = $last;
    }
    return $item;
  }
  _nextItem($items) {
    const $target = this._getActiveItem(true);
    const targetIndex = $items.index($target);
    const $first = $items.first();
    let $item = renderer_default($items[targetIndex + 1]);
    const loop = this.option("loopItemFocus");
    if (0 === $item.length && loop) {
      $item = $first;
    }
    return $item;
  }
  _selectFocusedItem($target) {
    this.selectItem($target);
  }
  _updateFocusedItemState(target, isFocused, needCleanItemId) {
    const $target = renderer_default(target);
    if ($target.length) {
      this._refreshActiveDescendant();
      this._refreshItemId($target, needCleanItemId);
      this._toggleFocusClass(isFocused, $target);
    }
    this._updateParentActiveDescendant();
  }
  _getElementClassToSkipRefreshId() {
    return "";
  }
  _shouldSkipRefreshId(target) {
    const elementClass = this._getElementClassToSkipRefreshId();
    const shouldSkipRefreshId = renderer_default(target).hasClass(elementClass);
    return shouldSkipRefreshId;
  }
  _refreshActiveDescendant($target) {
    const {
      focusedElement
    } = this.option();
    if (isDefined(focusedElement)) {
      const shouldSetExistingId = this._shouldSkipRefreshId(focusedElement);
      const id = shouldSetExistingId ? renderer_default(focusedElement).attr("id") : this.getFocusedItemId();
      this.setAria("activedescendant", id, $target);
      return;
    }
    this.setAria("activedescendant", null, $target);
  }
  _refreshItemId($target, needCleanItemId) {
    const {
      focusedElement
    } = this.option();
    const shouldSkipRefreshId = this._shouldSkipRefreshId($target);
    if (shouldSkipRefreshId) {
      return;
    }
    if (!needCleanItemId && focusedElement) {
      this.setAria("id", this.getFocusedItemId(), $target);
    } else {
      this.setAria("id", null, $target);
    }
  }
  _isDisabled($element) {
    return $element && "true" === renderer_default($element).attr("aria-disabled");
  }
  _setFocusedItem($target) {
    if (!$target || !$target.length) {
      return;
    }
    this._updateFocusedItemState($target, true);
    this.onFocusedItemChanged(this.getFocusedItemId());
    const {
      selectOnFocus
    } = this.option();
    const isTargetDisabled = this._isDisabled($target);
    if (selectOnFocus && !isTargetDisabled && !this._shouldSkipSelectOnFocus) {
      this._selectFocusedItem($target);
    }
  }
  _findItemElementByItem(item) {
    let result2 = renderer_default();
    const itemDataKey = this._itemDataKey();
    this.itemElements().each((index2, itemElement) => {
      const $item = renderer_default(itemElement);
      if ($item.data(itemDataKey) === item) {
        result2 = $item;
        return false;
      }
      return true;
    });
    return result2;
  }
  _getIndexByItem(item) {
    const {
      items
    } = this.option();
    return items.indexOf(item);
  }
  _itemOptionChanged(item, property, value2, prevValue) {
    const $item = this._findItemElementByItem(item);
    if (!$item.length) {
      return;
    }
    if (!this.constructor.ItemClass.getInstance($item).setDataField(property, value2)) {
      this._refreshItem($item, item);
    }
    const isDisabling = "disabled" === property && value2;
    if (isDisabling) {
      this._resetItemFocus($item);
    }
  }
  _resetItemFocus($item) {
    if ($item.is(this.option("focusedElement"))) {
      this._resetFocusedElement();
    }
  }
  _resetFocusedElement() {
    this.option("focusedElement", null);
  }
  _refreshItem($item, item) {
    const itemData = this._getItemData($item);
    const index2 = $item.data(this._itemIndexKey());
    this._renderItem(this._renderedItemsCount + index2, itemData, null, $item);
  }
  _updateParentActiveDescendant() {
  }
  _optionChanged(args) {
    const {
      name: name2,
      value: value2,
      previousValue,
      fullName
    } = args;
    if ("items" === name2) {
      const matches = fullName.match(ITEM_PATH_REGEX);
      if (null !== matches && void 0 !== matches && matches.length) {
        const property = matches[matches.length - 1];
        const itemPath = fullName.replace(`.${property}`, "");
        const item = this.option(itemPath);
        this._itemOptionChanged(item, property, value2, previousValue);
        return;
      }
    }
    switch (name2) {
      case "items":
      case "_itemAttributes":
      case "itemTemplateProperty":
      case "useItemTextAsTitle":
        this._cleanRenderedItems();
        this._invalidate();
        break;
      case "dataSource":
        this._refreshDataSource();
        this._renderEmptyMessage();
        break;
      case "noDataText":
      case "encodeNoDataText":
        this._renderEmptyMessage();
        break;
      case "itemTemplate":
      case "visibleExpr":
      case "disabledExpr":
        this._invalidate();
        break;
      case "onItemRendered":
        this._createItemRenderAction();
        break;
      case "onItemClick":
      case "selectOnFocus":
      case "loopItemFocus":
        break;
      case "onItemHold":
      case "itemHoldTimeout":
        this._attachHoldEvent();
        break;
      case "onItemContextMenu":
        this._attachContextMenuEvent();
        break;
      case "onFocusedItemChanged":
        this.onFocusedItemChanged = this._createActionByOption("onFocusedItemChanged");
        break;
      case "focusedElement":
        this._updateFocusedItemState(previousValue, false, true);
        this._setFocusedItem(renderer_default(value2));
        break;
      case "displayExpr":
        this._compileDisplayGetter();
        this._initDefaultItemTemplate();
        this._invalidate();
        break;
      default:
        super._optionChanged(args);
    }
  }
  _invalidate() {
    this._resetFocusedElement();
    super._invalidate();
  }
  _loadNextPage() {
    this._expectNextPageLoading();
    return this._dataController.loadNextPage();
  }
  _expectNextPageLoading() {
    this._startIndexForAppendedItems = 0;
  }
  _expectLastItemLoading() {
    this._startIndexForAppendedItems = -1;
  }
  _forgetNextPageLoading() {
    this._startIndexForAppendedItems = null;
  }
  _dataSourceChangedHandler(newItems, e) {
    const items = this.option("items");
    if (this._initialized && items && this._shouldAppendItems()) {
      this._renderedItemsCount = items.length;
      if (!this._isLastPage() || -1 !== this._startIndexForAppendedItems) {
        this.option().items = items.concat(newItems.slice(this._startIndexForAppendedItems));
      }
      this._forgetNextPageLoading();
      this._refreshContent();
    } else {
      this.option("items", newItems.slice());
    }
  }
  _refreshContent() {
    this._prepareContent();
    this._renderContent();
  }
  _dataSourceLoadErrorHandler() {
    this._forgetNextPageLoading();
    this.option("items", this.option("items"));
  }
  _shouldAppendItems() {
    return null != this._startIndexForAppendedItems && this._allowDynamicItemsAppend();
  }
  _allowDynamicItemsAppend() {
    return false;
  }
  _clean() {
    this._cleanFocusState();
    this._cleanItemContainer();
    if (this._inkRipple) {
      delete this._inkRipple;
    }
    this._resetActiveState();
  }
  _cleanItemContainer() {
    renderer_default(this._itemContainer()).empty();
  }
  _dispose() {
    super._dispose();
    clearTimeout(this._itemFocusTimeout);
  }
  _refresh() {
    this._cleanRenderedItems();
    super._refresh();
  }
  _itemContainer(searchEnabled, previousSelectAllEnabled) {
    return this.$element();
  }
  _itemClass() {
    return ITEM_CLASS;
  }
  _itemContentClass() {
    return `${this._itemClass()}-content`;
  }
  _itemResponseWaitClass() {
    return "dx-item-response-wait";
  }
  _itemSelector() {
    return `.${this._itemClass()}`;
  }
  _itemDataKey() {
    return "dxItemData";
  }
  _itemIndexKey() {
    return "dxItemIndex";
  }
  _itemElements() {
    return this._itemContainer().find(this._itemSelector());
  }
  _initMarkup() {
    super._initMarkup();
    this.onFocusedItemChanged = this._createActionByOption("onFocusedItemChanged");
    this.$element().addClass("dx-collection");
    this._prepareContent();
  }
  _prepareContent() {
    deferRenderer(() => {
      this._renderContentImpl();
    })();
  }
  _renderContent() {
    this._fireContentReadyAction();
  }
  _render() {
    super._render();
    this._attachClickEvent();
    this._attachHoldEvent();
    this._attachContextMenuEvent();
  }
  _getPointerEvent() {
    return m_pointer_default.down;
  }
  _attachClickEvent() {
    const itemSelector = this._itemSelector();
    const pointerEvent = this._getPointerEvent();
    const clickEventNamespace = addNamespace2(CLICK_EVENT_NAME, this.NAME);
    const pointerEventNamespace = addNamespace2(pointerEvent, this.NAME);
    const pointerAction = new action_default((args) => {
      const {
        event
      } = args;
      this._itemPointerDownHandler(event);
    });
    m_events_engine_default.off(this._itemContainer(), clickEventNamespace, itemSelector);
    m_events_engine_default.off(this._itemContainer(), pointerEventNamespace, itemSelector);
    m_events_engine_default.on(this._itemContainer(), clickEventNamespace, itemSelector, (e) => this._itemClickHandler(e));
    m_events_engine_default.on(this._itemContainer(), pointerEventNamespace, itemSelector, (e) => {
      pointerAction.execute({
        element: renderer_default(e.target),
        event: e
      });
    });
  }
  _itemClickHandler(e, args, config3) {
    this._itemDXEventHandler(e, "onItemClick", args, config3);
  }
  _itemPointerDownHandler(e) {
    if (!this.option("focusStateEnabled")) {
      return;
    }
    this._itemFocusHandler = () => {
      clearTimeout(this._itemFocusTimeout);
      this._itemFocusHandler = void 0;
      if (e.isDefaultPrevented()) {
        return;
      }
      const $target = renderer_default(e.target);
      const $closestItem = $target.closest(this._itemElements());
      const $closestFocusable = this._closestFocusable($target);
      if ($closestItem.length && this._isFocusTarget(null === $closestFocusable || void 0 === $closestFocusable ? void 0 : $closestFocusable.get(0))) {
        this._shouldSkipSelectOnFocus = true;
        this.option("focusedElement", getPublicElement($closestItem));
        this._shouldSkipSelectOnFocus = false;
      }
    };
    this._itemFocusTimeout = setTimeout(this._forcePointerDownFocus.bind(this));
  }
  _closestFocusable($target) {
    if ($target.is(focusable)) {
      return $target;
    }
    let $nextTarget = $target.parent();
    while ($nextTarget.length && !dom_adapter_default.isDocument($nextTarget.get(0)) && !dom_adapter_default.isDocumentFragment($nextTarget.get(0))) {
      if ($nextTarget.is(focusable)) {
        return $nextTarget;
      }
      $nextTarget = $nextTarget.parent();
    }
    return;
  }
  _forcePointerDownFocus() {
    if (this._itemFocusHandler) {
      this._itemFocusHandler();
    }
  }
  _updateFocusState(e, isFocused) {
    super._updateFocusState(e, isFocused);
    this._forcePointerDownFocus();
  }
  _attachHoldEvent() {
    const $itemContainer = this._itemContainer();
    const itemSelector = this._itemSelector();
    const eventName = addNamespace2(m_hold_default.name, this.NAME);
    m_events_engine_default.off($itemContainer, eventName, itemSelector);
    m_events_engine_default.on($itemContainer, eventName, itemSelector, {
      timeout: this._getHoldTimeout()
    }, this._itemHoldHandler.bind(this));
  }
  _getHoldTimeout() {
    const {
      itemHoldTimeout
    } = this.option();
    return itemHoldTimeout;
  }
  _shouldFireHoldEvent() {
    return this.hasActionSubscription("onItemHold");
  }
  _itemHoldHandler(e) {
    if (this._shouldFireHoldEvent()) {
      this._itemDXEventHandler(e, "onItemHold");
    } else {
      e.cancel = true;
    }
  }
  _attachContextMenuEvent() {
    const $itemContainer = this._itemContainer();
    const itemSelector = this._itemSelector();
    const eventName = addNamespace2(name, this.NAME);
    m_events_engine_default.off($itemContainer, eventName, itemSelector);
    m_events_engine_default.on($itemContainer, eventName, itemSelector, this._itemContextMenuHandler.bind(this));
  }
  _shouldFireContextMenuEvent() {
    return this.hasActionSubscription("onItemContextMenu");
  }
  _itemContextMenuHandler(e) {
    if (this._shouldFireContextMenuEvent()) {
      this._itemDXEventHandler(e, "onItemContextMenu");
    } else {
      e.cancel = true;
    }
  }
  _renderContentImpl() {
    const {
      items
    } = this.option();
    const itemsToRender = items ?? [];
    if (this._renderedItemsCount) {
      this._renderItems(itemsToRender.slice(this._renderedItemsCount));
    } else {
      this._renderItems(itemsToRender);
    }
  }
  _renderItems(items) {
    if (items.length) {
      each(items, (index2, itemData) => {
        this._renderItem(this._renderedItemsCount + index2, itemData);
      });
    }
    this._renderEmptyMessage();
  }
  _getItemsContainer() {
    return this._itemContainer();
  }
  _setAttributes($element) {
    const attributes = _extends({}, this.option("_itemAttributes"));
    const {
      class: customClassValue
    } = attributes;
    if (customClassValue) {
      const currentClassValue = $element.get(0).className;
      attributes.class = [currentClassValue, customClassValue].join(" ");
    }
    $element.attr(attributes);
  }
  _renderItem(index2, itemData, $container, $itemToReplace) {
    const itemIndex = (null === index2 || void 0 === index2 ? void 0 : index2.item) ?? index2;
    const $containerToRender = $container ?? this._getItemsContainer();
    const $itemFrame = this._renderItemFrame(itemIndex, itemData, $containerToRender, $itemToReplace);
    this._setElementData($itemFrame, itemData, itemIndex);
    this._setAttributes($itemFrame);
    this._attachItemClickEvent(itemData, $itemFrame);
    const $itemContent = this._getItemContent($itemFrame);
    const {
      itemTemplate
    } = this.option();
    const renderContentPromise = this._renderItemContent({
      index: itemIndex,
      itemData,
      container: getPublicElement($itemContent),
      contentClass: this._itemContentClass(),
      defaultTemplateName: itemTemplate
    });
    when(renderContentPromise).done(($content) => {
      this._postprocessRenderItem({
        itemElement: $itemFrame,
        itemContent: $content,
        itemData,
        itemIndex
      });
      this._executeItemRenderAction(index2, itemData, getPublicElement($itemFrame));
    });
    return $itemFrame;
  }
  _getItemContent($itemFrame) {
    const $itemContent = $itemFrame.find(".dx-item-content-placeholder");
    $itemContent.removeClass("dx-item-content-placeholder");
    return $itemContent;
  }
  _attachItemClickEvent(itemData, $itemElement) {
    if (!itemData || !itemData.onClick) {
      return;
    }
    m_events_engine_default.on($itemElement, CLICK_EVENT_NAME, (e) => {
      this._itemEventHandlerByHandler($itemElement, itemData.onClick, {
        event: e
      });
    });
  }
  _renderItemContent(args) {
    const itemTemplateName = this._getItemTemplateName(args);
    const itemTemplate = this._getTemplate(itemTemplateName);
    this._addItemContentClasses(args);
    const $templateResult = renderer_default(this._createItemByTemplate(itemTemplate, args));
    if (!$templateResult.hasClass("dx-template-wrapper")) {
      return args.container;
    }
    return this._renderItemContentByNode(args, $templateResult);
  }
  _renderItemContentByNode(args, $node) {
    renderer_default(args.container).replaceWith($node);
    args.container = getPublicElement($node);
    this._addItemContentClasses(args);
    return $node;
  }
  _addItemContentClasses(args) {
    const classes = [ITEM_CLASS + "-content", args.contentClass];
    renderer_default(args.container).addClass(classes.join(" "));
  }
  _appendItemToContainer($container, $itemFrame, index2) {
    $itemFrame.appendTo($container);
  }
  _renderItemFrame(index2, itemData, $container, $itemToReplace) {
    const $itemFrame = renderer_default("<div>");
    new this.constructor.ItemClass($itemFrame, this._itemOptions(), itemData || {});
    if (null !== $itemToReplace && void 0 !== $itemToReplace && $itemToReplace.length) {
      $itemToReplace.replaceWith($itemFrame);
    } else {
      this._appendItemToContainer.call(this, $container, $itemFrame, index2);
    }
    if (this.option("useItemTextAsTitle")) {
      const displayValue = this._displayGetter ? this._displayGetter(itemData) : itemData;
      $itemFrame.attr("title", displayValue);
    }
    return $itemFrame;
  }
  _itemOptions() {
    return {
      watchMethod: () => this.option("integrationOptions.watchMethod"),
      owner: this,
      fieldGetter: (field) => {
        const expr = this.option(`${field}Expr`);
        const getter = compileGetter(expr);
        return getter;
      }
    };
  }
  _postprocessRenderItem(args) {
  }
  _executeItemRenderAction(index2, itemData, itemElement) {
    this._getItemRenderAction()({
      itemElement,
      itemIndex: index2,
      itemData
    });
  }
  _setElementData(element, data17, index2) {
    element.addClass([ITEM_CLASS, this._itemClass()].join(" ")).data(this._itemDataKey(), data17).data(this._itemIndexKey(), index2);
  }
  _createItemRenderAction() {
    this._itemRenderAction = this._createActionByOption("onItemRendered", {
      element: this.element(),
      excludeValidators: ["disabled", "readOnly"],
      category: "rendering"
    });
    return this._itemRenderAction;
  }
  _getItemRenderAction() {
    return this._itemRenderAction ?? this._createItemRenderAction();
  }
  _getItemTemplateName(args) {
    const data17 = args.itemData;
    const templateProperty = args.templateProperty || this.option("itemTemplateProperty");
    const template = data17 && data17[templateProperty];
    return template || args.defaultTemplateName;
  }
  _createItemByTemplate(itemTemplate, renderArgs) {
    const {
      itemData,
      container,
      index: index2
    } = renderArgs;
    return itemTemplate.render({
      model: itemData,
      container,
      index: index2,
      onRendered: this._onItemTemplateRendered(itemTemplate, renderArgs)
    });
  }
  _onItemTemplateRendered(itemTemplate, renderArgs) {
    return () => {
    };
  }
  _emptyMessageContainer() {
    return this._itemContainer();
  }
  _renderEmptyMessage(rootNodes) {
    const items = rootNodes ?? this.option("items");
    const noDataText = this.option("noDataText");
    const hideNoData = !noDataText || items && items.length || this._dataController.isLoading();
    if (hideNoData && this._$noData) {
      this._$noData.remove();
      this._$noData = null;
      this.setAria("label", void 0);
    }
    if (!hideNoData) {
      this._$noData = this._$noData ?? renderer_default("<div>").addClass("dx-empty-message");
      this._$noData.appendTo(this._emptyMessageContainer());
      if (this.option("encodeNoDataText")) {
        this._$noData.text(noDataText);
      } else {
        this._$noData.html(noDataText);
      }
    }
    this.$element().toggleClass(EMPTY_COLLECTION, !hideNoData);
  }
  _itemDXEventHandler(dxEvent, handlerOptionName, actionArgs, actionConfig) {
    this._itemEventHandler(dxEvent.target, handlerOptionName, extend(actionArgs, {
      event: dxEvent
    }), actionConfig);
  }
  _itemEventHandler(initiator, handlerOptionName, actionArgs, actionConfig) {
    const action = this._createActionByOption(handlerOptionName, extend({
      validatingTargetName: "itemElement"
    }, actionConfig));
    return this._itemEventHandlerImpl(initiator, action, actionArgs);
  }
  _itemEventHandlerByHandler(initiator, handler, actionArgs, actionConfig) {
    const action = this._createAction(handler, extend({
      validatingTargetName: "itemElement"
    }, actionConfig));
    return this._itemEventHandlerImpl(initiator, action, actionArgs);
  }
  _itemEventHandlerImpl(initiator, action, actionArgs) {
    const $itemElement = this._closestItemElement(renderer_default(initiator));
    const args = extend({}, actionArgs);
    return action(extend(actionArgs, this._extendActionArgs($itemElement), args));
  }
  _extendActionArgs($itemElement) {
    return {
      itemElement: getPublicElement($itemElement),
      itemIndex: this._itemElements().index($itemElement),
      itemData: this._getItemData($itemElement)
    };
  }
  _closestItemElement($element) {
    return renderer_default($element).closest(this._itemSelector());
  }
  _getItemData(itemElement) {
    return renderer_default(itemElement).data(this._itemDataKey());
  }
  _getSummaryItemsSize(dimension, items, includeMargin) {
    let result2 = 0;
    if (items) {
      each(items, (_, item) => {
        if ("width" === dimension) {
          result2 += getOuterWidth(item, includeMargin ?? false);
        } else if ("height" === dimension) {
          result2 += getOuterHeight(item, includeMargin ?? false);
        }
      });
    }
    return result2;
  }
  getFocusedItemId() {
    if (!this._focusedItemId) {
      this._focusedItemId = `dx-${new guid_default2()}`;
    }
    return this._focusedItemId;
  }
  itemElements() {
    return this._itemElements();
  }
  itemsContainer() {
    return this._itemContainer();
  }
};
CollectionWidget.include(data_helper_default);
CollectionWidget.ItemClass = item_default;
var collection_widget_base_default = CollectionWidget;

// node_modules/devextreme/esm/__internal/ui/selection/m_selection.strategy.js
var SelectionStrategy = class {
  constructor(options2) {
    this._lastSelectAllPageDeferred = Deferred().reject();
    this.options = options2;
    this._setOption("disabledItemKeys", []);
    this._clearItemKeys();
  }
  _clearItemKeys() {
    this._setOption("addedItemKeys", []);
    this._setOption("removedItemKeys", []);
    this._setOption("removedItems", []);
    this._setOption("addedItems", []);
  }
  validate() {
  }
  _setOption(name2, value2) {
    this.options[name2] = value2;
  }
  onSelectionChanging() {
    const {
      selectedItems,
      selectedItemKeys,
      addedItemKeys,
      removedItemKeys,
      addedItems,
      removedItems,
      onSelectionChanging = noop2
    } = this.options;
    const selectionChangingArgs = {
      selectedItems,
      selectedItemKeys,
      addedItemKeys,
      removedItemKeys,
      addedItems,
      removedItems,
      cancel: false
    };
    onSelectionChanging(selectionChangingArgs);
    return selectionChangingArgs.cancel;
  }
  _callCallbackIfNotCanceled(callback, cancelCallback) {
    const cancelResult = this.onSelectionChanging();
    if (isPromise(cancelResult)) {
      cancelResult.then((cancel2) => {
        if (!cancel2) {
          callback();
        } else {
          cancelCallback();
        }
      }).catch(() => {
        callback();
      });
    } else if (!cancelResult) {
      callback();
    } else {
      cancelCallback();
    }
  }
  onSelectionChanged() {
    const {
      selectedItems,
      selectedItemKeys,
      addedItemKeys,
      removedItemKeys,
      addedItems,
      removedItems,
      onSelectionChanged = noop2
    } = this.options;
    this._clearItemKeys();
    onSelectionChanged({
      selectedItems,
      selectedItemKeys,
      addedItemKeys,
      removedItemKeys,
      addedItems,
      removedItems
    });
  }
  equalKeys(key1, key2) {
    if (this.options.equalByReference) {
      if (isObject(key1) && isObject(key2)) {
        return key1 === key2;
      }
    }
    return equalByValue(key1, key2);
  }
  getSelectableItems(items) {
    return items.filter((item) => !(null !== item && void 0 !== item && item.disabled));
  }
  _clearSelection(keys, preserve, isDeselect, isSelectAll) {
    keys = keys || [];
    keys = Array.isArray(keys) ? keys : [keys];
    this.validate();
    return this.selectedItemKeys(keys, preserve, isDeselect, isSelectAll);
  }
  _removeTemplateProperty(remoteFilter) {
    if (Array.isArray(remoteFilter)) {
      return remoteFilter.map((f) => this._removeTemplateProperty(f));
    }
    if (isObject(remoteFilter)) {
      delete remoteFilter.template;
    }
    return remoteFilter;
  }
  _getQueryParams() {
    const {
      sensitivity
    } = this.options;
    if (!sensitivity) {
      return;
    }
    return {
      langParams: {
        collatorOptions: {
          sensitivity
        }
      }
    };
  }
  _loadFilteredData(remoteFilter, localFilter, select, isSelectAll) {
    const filterLength = encodeURI(JSON.stringify(this._removeTemplateProperty(remoteFilter))).length;
    const needLoadAllData = this.options.maxFilterLengthInRequest && filterLength > this.options.maxFilterLengthInRequest;
    const deferred = Deferred();
    const queryParams = this._getQueryParams();
    const loadOptions = _extends({
      filter: needLoadAllData ? void 0 : remoteFilter,
      select: needLoadAllData ? this.options.dataFields() : select || this.options.dataFields()
    }, queryParams);
    if (remoteFilter && 0 === remoteFilter.length) {
      deferred.resolve([]);
    } else {
      this.options.load(loadOptions).done((items) => {
        let filteredItems = isPlainObject(items) ? items.data : items;
        if (localFilter && !isSelectAll) {
          filteredItems = filteredItems.filter(localFilter);
        } else if (needLoadAllData) {
          filteredItems = m_query_default(filteredItems).filter(remoteFilter).toArray();
        }
        deferred.resolve(filteredItems);
      }).fail(deferred.reject.bind(deferred));
    }
    return deferred;
  }
  updateSelectedItemKeyHash(keys) {
    for (let i = 0; i < keys.length; i++) {
      const keyHash = getKeyHash(keys[i]);
      if (!isObject(keyHash)) {
        this.options.keyHashIndices[keyHash] = this.options.keyHashIndices[keyHash] || [];
        const keyIndices = this.options.keyHashIndices[keyHash];
        keyIndices.push(i);
      }
    }
  }
  _isAnyItemSelected(items) {
    for (let i = 0; i < items.length; i++) {
      if (this.options.isItemSelected(items[i])) {
        return;
      }
    }
    return false;
  }
  _getFullSelectAllState() {
    const items = this.options.plainItems();
    const dataFilter = this.options.filter();
    let selectedItems = this.options.ignoreDisabledItems ? this.options.selectedItems : this.options.selectedItems.filter((item) => !(null !== item && void 0 !== item && item.disabled));
    if (dataFilter) {
      selectedItems = m_query_default(selectedItems).filter(dataFilter).toArray();
    }
    const selectedItemsLength = selectedItems.length;
    const disabledItemsLength = items.length - this.getSelectableItems(items).length;
    if (!selectedItemsLength) {
      return this._isAnyItemSelected(items);
    }
    if (selectedItemsLength >= this.options.totalCount() - disabledItemsLength) {
      return true;
    }
    return;
  }
  _getVisibleSelectAllState() {
    const items = this.getSelectableItems(this.options.plainItems());
    let hasSelectedItems = false;
    let hasUnselectedItems = false;
    for (let i = 0; i < items.length; i++) {
      const item = items[i];
      const itemData = this.options.getItemData(item);
      const key = this.options.keyOf(itemData);
      if (this.options.isSelectableItem(item)) {
        if (this.isItemKeySelected(key)) {
          hasSelectedItems = true;
        } else {
          hasUnselectedItems = true;
        }
      }
    }
    if (hasSelectedItems) {
      return !hasUnselectedItems ? true : void 0;
    }
    return false;
  }
  isItemKeySelected(itemKey) {
    throw new Error("isItemKeySelected method should be overriden");
  }
  addSelectedItem(itemKey, itemData) {
    throw new Error("addSelectedItem method should be overriden");
  }
  removeSelectedItem(itemKey) {
    throw new Error("removeSelectedItem method should be overriden");
  }
  _selectAllPlainItems(isDeselect) {
    const items = this.getSelectableItems(this.options.plainItems());
    for (let i = 0; i < items.length; i++) {
      const item = items[i];
      if (this.options.isSelectableItem(item)) {
        const itemData = this.options.getItemData(item);
        const itemKey = this.options.keyOf(itemData);
        const isSelected = this.isItemKeySelected(itemKey);
        if (!isSelected && !isDeselect) {
          this.addSelectedItem(itemKey, itemData);
        }
        if (isSelected && isDeselect) {
          this.removeSelectedItem(itemKey);
        }
      }
    }
  }
};

// node_modules/devextreme/esm/__internal/ui/selection/m_selection.strategy.deferred.js
var DeferredStrategy = class extends SelectionStrategy {
  getSelectedItems() {
    return this._loadFilteredData(this.options.selectionFilter);
  }
  getSelectedItemKeys() {
    const d = Deferred();
    const that = this;
    const key = this.options.key();
    const select = isString(key) ? [key] : key;
    this._loadFilteredData(this.options.selectionFilter, null, select).done((items) => {
      const keys = items.map((item) => that.options.keyOf(item));
      d.resolve(keys);
    }).fail(d.reject);
    return d.promise();
  }
  selectedItemKeys(keys, preserve, isDeselect, isSelectAll) {
    if (isSelectAll) {
      const filter = this.options.filter();
      const needResetSelectionFilter = !filter || JSON.stringify(filter) === JSON.stringify(this.options.selectionFilter) && isDeselect;
      if (needResetSelectionFilter) {
        this._setOption("selectionFilter", isDeselect ? [] : null);
      } else {
        this._addSelectionFilter(isDeselect, filter, isSelectAll);
      }
    } else {
      if (!preserve) {
        this._setOption("selectionFilter", []);
      }
      for (let i = 0; i < keys.length; i++) {
        if (isDeselect) {
          this.removeSelectedItem(keys[i]);
        } else {
          this.addSelectedItem(keys[i], isSelectAll, !preserve);
        }
      }
    }
    this.onSelectionChanged();
    return Deferred().resolve();
  }
  setSelectedItems(keys) {
    this._setOption("selectionFilter", null);
    for (let i = 0; i < keys.length; i++) {
      this.addSelectedItem(keys[i]);
    }
  }
  isItemDataSelected(itemData) {
    return this.isItemKeySelected(itemData);
  }
  isItemKeySelected(itemData) {
    const {
      selectionFilter
    } = this.options;
    if (!selectionFilter) {
      return true;
    }
    const queryParams = this._getQueryParams();
    return !!m_query_default([itemData], queryParams).filter(selectionFilter).toArray().length;
  }
  _getKeyExpr() {
    const keyField = this.options.key();
    if (Array.isArray(keyField) && 1 === keyField.length) {
      return keyField[0];
    }
    return keyField;
  }
  _normalizeKey(key) {
    const keyExpr = this.options.key();
    if (Array.isArray(keyExpr) && 1 === keyExpr.length) {
      return key[keyExpr[0]];
    }
    return key;
  }
  _getFilterByKey(key) {
    const keyField = this._getKeyExpr();
    let filter = [keyField, "=", this._normalizeKey(key)];
    if (Array.isArray(keyField)) {
      filter = [];
      for (let i = 0; i < keyField.length; i++) {
        filter.push([keyField[i], "=", key[keyField[i]]]);
        if (i !== keyField.length - 1) {
          filter.push("and");
        }
      }
    }
    return filter;
  }
  addSelectedItem(key, isSelectAll, skipFilter) {
    const filter = this._getFilterByKey(key);
    this._addSelectionFilter(false, filter, isSelectAll, skipFilter);
  }
  removeSelectedItem(key) {
    const filter = this._getFilterByKey(key);
    this._addSelectionFilter(true, filter);
  }
  validate() {
    const {
      key
    } = this.options;
    if (key && void 0 === key()) {
      throw ui_errors_default.Error("E1042", "Deferred selection");
    }
  }
  _findSubFilter(selectionFilter, filter) {
    if (!selectionFilter) {
      return -1;
    }
    const filterString = JSON.stringify(filter);
    for (let index2 = 0; index2 < selectionFilter.length; index2++) {
      const subFilter = selectionFilter[index2];
      if (subFilter && JSON.stringify(subFilter) === filterString) {
        return index2;
      }
    }
    return -1;
  }
  _isLastSubFilter(selectionFilter, filter) {
    if (selectionFilter && filter) {
      return this._findSubFilter(selectionFilter, filter) === selectionFilter.length - 1 || 0 === this._findSubFilter([selectionFilter], filter);
    }
    return false;
  }
  _addFilterOperator(selectionFilter, filterOperator) {
    if (selectionFilter.length > 1 && isString(selectionFilter[1]) && selectionFilter[1] !== filterOperator) {
      selectionFilter = [selectionFilter];
    }
    if (selectionFilter.length) {
      selectionFilter.push(filterOperator);
    }
    return selectionFilter;
  }
  _denormalizeFilter(filter) {
    if (filter && isString(filter[0])) {
      filter = [filter];
    }
    return filter;
  }
  _isOnlyNegativeFiltersLeft(filters) {
    return filters.every((filterItem, i) => {
      if (i % 2 === 0) {
        return Array.isArray(filterItem) && "!" === filterItem[0];
      }
      return "and" === filterItem;
    });
  }
  _addSelectionFilter(isDeselect, filter, isSelectAll, skipFilter) {
    var _selectionFilter;
    const that = this;
    const currentFilter = isDeselect ? ["!", filter] : filter;
    const currentOperation = isDeselect ? "and" : "or";
    let needAddFilter = true;
    let selectionFilter = that.options.selectionFilter || [];
    selectionFilter = that._denormalizeFilter(selectionFilter);
    if (null !== (_selectionFilter = selectionFilter) && void 0 !== _selectionFilter && _selectionFilter.length && !skipFilter) {
      const removedIndex = that._removeSameFilter(selectionFilter, filter, isDeselect, isSelectAll);
      const filterIndex = that._removeSameFilter(selectionFilter, filter, !isDeselect);
      const shouldCleanFilter = isDeselect && (-1 !== removedIndex || -1 !== filterIndex) && this._isOnlyNegativeFiltersLeft(selectionFilter);
      if (shouldCleanFilter) {
        selectionFilter = [];
      }
      const isKeyOperatorsAfterRemoved = this._isKeyFilter(filter) && this._hasKeyFiltersOnlyStartingFromIndex(selectionFilter, filterIndex);
      needAddFilter = filter.length && !isKeyOperatorsAfterRemoved;
    }
    if (needAddFilter) {
      selectionFilter = that._addFilterOperator(selectionFilter, currentOperation);
      selectionFilter.push(currentFilter);
    }
    selectionFilter = that._normalizeFilter(selectionFilter);
    that._setOption("selectionFilter", !isDeselect && !selectionFilter.length ? null : selectionFilter);
  }
  _normalizeFilter(filter) {
    if (filter && 1 === filter.length) {
      filter = filter[0];
    }
    return filter;
  }
  _removeFilterByIndex(filter, filterIndex, isSelectAll) {
    const operation = filter[1];
    if (filterIndex > 0) {
      filter.splice(filterIndex - 1, 2);
    } else {
      filter.splice(filterIndex, 2);
    }
    if (isSelectAll && "and" === operation) {
      filter.splice(0, filter.length);
    }
  }
  _isSimpleKeyFilter(filter, key) {
    return 3 === filter.length && filter[0] === key && "=" === filter[1];
  }
  _isKeyFilter(filter) {
    if (2 === filter.length && "!" === filter[0]) {
      return this._isKeyFilter(filter[1]);
    }
    const keyField = this._getKeyExpr();
    if (Array.isArray(keyField)) {
      if (filter.length !== 2 * keyField.length - 1) {
        return false;
      }
      for (let i = 0; i < keyField.length; i++) {
        if (i > 0 && "and" !== filter[2 * i - 1]) {
          return false;
        }
        if (!this._isSimpleKeyFilter(filter[2 * i], keyField[i])) {
          return false;
        }
      }
      return true;
    }
    return this._isSimpleKeyFilter(filter, keyField);
  }
  _hasKeyFiltersOnlyStartingFromIndex(selectionFilter, filterIndex) {
    if (filterIndex >= 0) {
      for (let i = filterIndex; i < selectionFilter.length; i++) {
        if ("string" !== typeof selectionFilter[i] && !this._isKeyFilter(selectionFilter[i])) {
          return false;
        }
      }
      return true;
    }
    return false;
  }
  _removeSameFilter(selectionFilter, filter, inverted, isSelectAll) {
    filter = inverted ? ["!", filter] : filter;
    if (JSON.stringify(filter) === JSON.stringify(selectionFilter)) {
      selectionFilter.splice(0, selectionFilter.length);
      return 0;
    }
    const filterIndex = this._findSubFilter(selectionFilter, filter);
    if (filterIndex >= 0) {
      this._removeFilterByIndex(selectionFilter, filterIndex, isSelectAll);
      return filterIndex;
    }
    for (let i = 0; i < selectionFilter.length; i++) {
      if (Array.isArray(selectionFilter[i]) && selectionFilter[i].length > 2) {
        const filterIndex2 = this._removeSameFilter(selectionFilter[i], filter, false, isSelectAll);
        if (filterIndex2 >= 0) {
          if (!selectionFilter[i].length) {
            this._removeFilterByIndex(selectionFilter, i, isSelectAll);
          } else if (1 === selectionFilter[i].length) {
            selectionFilter[i] = selectionFilter[i][0];
          }
          return filterIndex2;
        }
      }
    }
    return -1;
  }
  getSelectAllState() {
    const filter = this.options.filter();
    let {
      selectionFilter
    } = this.options;
    if (!selectionFilter) {
      return true;
    }
    if (!selectionFilter.length) {
      return false;
    }
    if (!filter || !filter.length) {
      return;
    }
    selectionFilter = this._denormalizeFilter(selectionFilter);
    if (this._isLastSubFilter(selectionFilter, filter)) {
      return true;
    }
    if (this._isLastSubFilter(selectionFilter, ["!", filter])) {
      return false;
    }
    return;
  }
  loadSelectedItemsWithFilter() {
    const componentFilter = this.options.filter();
    const {
      selectionFilter
    } = this.options;
    const filter = componentFilter ? [componentFilter, "and", selectionFilter] : selectionFilter;
    return this._loadFilteredData(filter);
  }
  _onePageSelectAll(isDeselect) {
    this._selectAllPlainItems(isDeselect);
    this.onSelectionChanged();
    return Deferred().resolve();
  }
};

// node_modules/devextreme/esm/__internal/core/utils/m_selection_filter.js
var SelectionFilterCreator = function(selectedItemKeys, isSelectAll) {
  this.getLocalFilter = function(keyGetter, equalKeys, equalByReference, keyExpr) {
    equalKeys = void 0 === equalKeys ? equalByValue : equalKeys;
    return functionFilter.bind(this, equalKeys, keyGetter, equalByReference, keyExpr);
  };
  this.getExpr = function(keyExpr) {
    if (!keyExpr) {
      return;
    }
    let filterExpr;
    selectedItemKeys.forEach(function(key, index2) {
      filterExpr = filterExpr || [];
      let filterExprPart;
      if (index2 > 0) {
        filterExpr.push(isSelectAll ? "and" : "or");
      }
      if (isString(keyExpr) || isFunction(keyExpr)) {
        filterExprPart = getFilterForPlainKey(keyExpr, key);
      } else {
        filterExprPart = function(keyExpr2, itemKeyValue) {
          const filterExpr2 = [];
          for (let i = 0, {
            length
          } = keyExpr2; i < length; i++) {
            const currentKeyExpr = keyExpr2[i];
            const keyValueGetter = compileGetter(currentKeyExpr);
            const currentKeyValue = itemKeyValue && keyValueGetter(itemKeyValue);
            const filterExprPart2 = getFilterForPlainKey(currentKeyExpr, currentKeyValue);
            if (!filterExprPart2) {
              break;
            }
            if (i > 0) {
              filterExpr2.push(isSelectAll ? "or" : "and");
            }
            filterExpr2.push(filterExprPart2);
          }
          return filterExpr2;
        }(keyExpr, key);
      }
      filterExpr.push(filterExprPart);
    });
    if (filterExpr && 1 === filterExpr.length) {
      filterExpr = filterExpr[0];
    }
    return filterExpr;
  };
  this.getCombinedFilter = function(keyExpr, dataSourceFilter) {
    let forceCombinedFilter = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : false;
    const filterExpr = this.getExpr(keyExpr);
    let combinedFilter = filterExpr;
    if ((forceCombinedFilter || isSelectAll) && dataSourceFilter) {
      if (filterExpr) {
        combinedFilter = [];
        combinedFilter.push(filterExpr);
        combinedFilter.push(dataSourceFilter);
      } else {
        combinedFilter = dataSourceFilter;
      }
    }
    return combinedFilter;
  };
  let selectedItemKeyHashesMap;
  const getSelectedItemKeyHashesMap = function(keyOf, keyExpr) {
    if (!selectedItemKeyHashesMap) {
      selectedItemKeyHashesMap = {};
      const normalizedKeys = normalizeKeys(selectedItemKeys, keyOf, keyExpr);
      for (let i = 0; i < normalizedKeys.length; i++) {
        selectedItemKeyHashesMap[getKeyHash(normalizedKeys[i])] = true;
      }
    }
    return selectedItemKeyHashesMap;
  };
  const normalizeKeys = function(keys, keyOf, keyExpr) {
    return Array.isArray(keyExpr) ? keys.map((key) => keyOf(key)) : keys;
  };
  function functionFilter(equalKeys, keyOf, equalByReference, keyExpr, item) {
    const key = keyOf(item);
    let keyHash;
    let i;
    if (!equalByReference) {
      keyHash = getKeyHash(key);
      if (!isObject(keyHash)) {
        const selectedKeyHashesMap = getSelectedItemKeyHashesMap(keyOf, keyExpr);
        if (selectedKeyHashesMap[keyHash]) {
          return !isSelectAll;
        }
        return !!isSelectAll;
      }
    }
    for (i = 0; i < selectedItemKeys.length; i++) {
      if (equalKeys(selectedItemKeys[i], key)) {
        return !isSelectAll;
      }
    }
    return !!isSelectAll;
  }
  function getFilterForPlainKey(keyExpr, keyValue) {
    if (void 0 === keyValue) {
      return;
    }
    return [keyExpr, isSelectAll ? "<>" : "=", keyValue];
  }
};

// node_modules/devextreme/esm/__internal/ui/selection/m_selection.strategy.standard.js
var StandardStrategy = class extends SelectionStrategy {
  constructor(options2) {
    super(options2);
    this._lastSelectAllPageDeferred = Deferred().reject();
    this._initSelectedItemKeyHash();
  }
  _initSelectedItemKeyHash() {
    this._setOption("keyHashIndices", this.options.equalByReference ? null : {});
  }
  getSelectedItemKeys() {
    return this.options.selectedItemKeys.slice(0);
  }
  getSelectedItems() {
    return this.options.selectedItems.slice(0);
  }
  _preserveSelectionUpdate(items, isDeselect) {
    const {
      keyOf
    } = this.options;
    let keyIndicesToRemoveMap;
    let keyIndex;
    let i;
    if (!keyOf) {
      return;
    }
    const isBatchDeselect = isDeselect && items.length > 1 && !this.options.equalByReference;
    if (isBatchDeselect) {
      keyIndicesToRemoveMap = {};
    }
    for (i = 0; i < items.length; i++) {
      const item = items[i];
      const key = keyOf(item);
      if (isDeselect) {
        keyIndex = this.removeSelectedItem(key, keyIndicesToRemoveMap, null === item || void 0 === item ? void 0 : item.disabled);
        if (keyIndicesToRemoveMap && keyIndex >= 0) {
          keyIndicesToRemoveMap[keyIndex] = true;
        }
      } else {
        this.addSelectedItem(key, item);
      }
    }
    if (isBatchDeselect) {
      this._batchRemoveSelectedItems(keyIndicesToRemoveMap);
    }
  }
  _batchRemoveSelectedItems(keyIndicesToRemoveMap) {
    const selectedItemKeys = this.options.selectedItemKeys.slice(0);
    const selectedItems = this.options.selectedItems.slice(0);
    this.options.selectedItemKeys.length = 0;
    this.options.selectedItems.length = 0;
    for (let i = 0; i < selectedItemKeys.length; i++) {
      if (!keyIndicesToRemoveMap[i]) {
        this.options.selectedItemKeys.push(selectedItemKeys[i]);
        this.options.selectedItems.push(selectedItems[i]);
      }
    }
    this._initSelectedItemKeyHash();
    this.updateSelectedItemKeyHash(this.options.selectedItemKeys);
  }
  _loadSelectedItemsCore(keys, isDeselect, isSelectAll, filter) {
    let forceCombinedFilter = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : false;
    let deferred = Deferred();
    const key = this.options.key();
    if (!keys.length && !isSelectAll) {
      deferred.resolve([]);
      return deferred;
    }
    if (isSelectAll && isDeselect && !filter) {
      deferred.resolve(this.getSelectedItems());
      return deferred;
    }
    const selectionFilterCreator = new SelectionFilterCreator(keys, isSelectAll);
    const combinedFilter = selectionFilterCreator.getCombinedFilter(key, filter, forceCombinedFilter);
    let deselectedItems = [];
    if (isDeselect) {
      const {
        selectedItems
      } = this.options;
      deselectedItems = combinedFilter && keys.length !== selectedItems.length ? m_query_default(selectedItems).filter(combinedFilter).toArray() : selectedItems.slice(0);
    }
    let filteredItems = deselectedItems.length ? deselectedItems : this.options.plainItems(true).filter(this.options.isSelectableItem).map(this.options.getItemData);
    const localFilter = selectionFilterCreator.getLocalFilter(this.options.keyOf, this.equalKeys.bind(this), this.options.equalByReference, key);
    filteredItems = filteredItems.filter(localFilter);
    if (deselectedItems.length || !isSelectAll && filteredItems.length === keys.length) {
      deferred.resolve(filteredItems);
    } else {
      deferred = this._loadFilteredData(combinedFilter, localFilter, null, isSelectAll);
    }
    return deferred;
  }
  _replaceSelectionUpdate(items) {
    const internalKeys = [];
    const {
      keyOf
    } = this.options;
    if (!keyOf) {
      return;
    }
    for (let i = 0; i < items.length; i++) {
      const item = items[i];
      const key = keyOf(item);
      internalKeys.push(key);
    }
    this.setSelectedItems(internalKeys, items);
  }
  _warnOnIncorrectKeys(keys) {
    const {
      allowNullValue
    } = this.options;
    for (let i = 0; i < keys.length; i++) {
      const key = keys[i];
      if ((!allowNullValue || null !== key) && !this.isItemKeySelected(key)) {
        ui_errors_default.log("W1002", key);
      }
    }
  }
  _isMultiSelectEnabled() {
    const {
      mode
    } = this.options;
    return "all" === mode || "multiple" === mode;
  }
  _requestInProgress() {
    var _this$_lastLoadDeferr;
    return "pending" === (null === (_this$_lastLoadDeferr = this._lastLoadDeferred) || void 0 === _this$_lastLoadDeferr ? void 0 : _this$_lastLoadDeferr.state());
  }
  _concatRequestsItems(keys, isDeselect, oldRequestItems, updatedKeys) {
    let selectedItems;
    const deselectedItems = isDeselect ? keys : [];
    if (updatedKeys) {
      selectedItems = updatedKeys;
    } else {
      selectedItems = removeDuplicates(keys, this.options.selectedItemKeys);
    }
    return {
      addedItems: oldRequestItems.added.concat(selectedItems),
      removedItems: oldRequestItems.removed.concat(deselectedItems),
      keys
    };
  }
  _collectLastRequestData(keys, isDeselect, isSelectAll, updatedKeys) {
    const isDeselectAll = isDeselect && isSelectAll;
    const oldRequestItems = {
      added: [],
      removed: []
    };
    const multiSelectEnabled = this._isMultiSelectEnabled();
    let lastRequestData = multiSelectEnabled ? this._lastRequestData : {};
    if (multiSelectEnabled) {
      if (this._shouldMergeWithLastRequest) {
        if (isDeselectAll) {
          this._lastLoadDeferred.reject();
          lastRequestData = {};
        } else if (!isKeysEqual(keys, this.options.selectedItemKeys)) {
          oldRequestItems.added = lastRequestData.addedItems;
          oldRequestItems.removed = lastRequestData.removedItems;
          if (!isDeselect) {
            this._lastLoadDeferred.reject();
          }
        }
      }
      lastRequestData = this._concatRequestsItems(keys, isDeselect, oldRequestItems, this._shouldMergeWithLastRequest ? void 0 : updatedKeys);
    }
    return lastRequestData;
  }
  _updateKeysByLastRequestData(keys, isDeselect, isSelectAll) {
    let currentKeys = keys;
    if (this._isMultiSelectEnabled() && this._shouldMergeWithLastRequest && !isDeselect && !isSelectAll) {
      var _this$_lastRequestDat, _this$_lastRequestDat2;
      currentKeys = removeDuplicates(keys.concat(null === (_this$_lastRequestDat = this._lastRequestData) || void 0 === _this$_lastRequestDat ? void 0 : _this$_lastRequestDat.addedItems), null === (_this$_lastRequestDat2 = this._lastRequestData) || void 0 === _this$_lastRequestDat2 ? void 0 : _this$_lastRequestDat2.removedItems);
      currentKeys = getUniqueValues(currentKeys);
    }
    return currentKeys;
  }
  _loadSelectedItems(keys, isDeselect, isSelectAll, updatedKeys) {
    let forceCombinedFilter = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : false;
    const that = this;
    const deferred = Deferred();
    const filter = that.options.filter();
    this._shouldMergeWithLastRequest = this._requestInProgress();
    this._lastRequestData = this._collectLastRequestData(keys, isDeselect, isSelectAll, updatedKeys);
    when(that._lastLoadDeferred).always(() => {
      const currentKeys = that._updateKeysByLastRequestData(keys, isDeselect, isSelectAll);
      that._shouldMergeWithLastRequest = false;
      that._loadSelectedItemsCore(currentKeys, isDeselect, isSelectAll, filter, forceCombinedFilter).done(deferred.resolve).fail(deferred.reject);
    });
    that._lastLoadDeferred = deferred;
    return deferred;
  }
  selectedItemKeys(keys, preserve, isDeselect, isSelectAll, updatedKeys) {
    let forceCombinedFilter = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : false;
    if (this._isCancelingInProgress) {
      return Deferred().reject();
    }
    const loadingDeferred = this._loadSelectedItems(keys, isDeselect, isSelectAll, updatedKeys, forceCombinedFilter);
    const selectionDeferred = Deferred();
    loadingDeferred.done((items) => {
      this._storeSelectionState();
      if (preserve) {
        this._preserveSelectionUpdate(items, isDeselect);
      } else {
        this._replaceSelectionUpdate(items);
      }
      this._isCancelingInProgress = true;
      this._callCallbackIfNotCanceled(() => {
        this._isCancelingInProgress = false;
        this.onSelectionChanged();
        selectionDeferred.resolve(items);
      }, () => {
        this._isCancelingInProgress = false;
        this._restoreSelectionState();
        selectionDeferred.reject();
      });
    });
    return selectionDeferred;
  }
  addSelectedItem(key, itemData) {
    if (isDefined(itemData) && !this.options.ignoreDisabledItems && itemData.disabled) {
      if (-1 === this.options.disabledItemKeys.indexOf(key)) {
        this.options.disabledItemKeys.push(key);
      }
      return;
    }
    const keyHash = this._getKeyHash(key);
    if (-1 === this._indexOfSelectedItemKey(keyHash)) {
      if (!isObject(keyHash) && this.options.keyHashIndices) {
        this.options.keyHashIndices[keyHash] = [this.options.selectedItemKeys.length];
      }
      this.options.selectedItemKeys.push(key);
      this.options.addedItemKeys.push(key);
      this.options.addedItems.push(itemData);
      this.options.selectedItems.push(itemData);
    }
  }
  _getSelectedIndexByKey(key, ignoreIndicesMap) {
    const {
      selectedItemKeys
    } = this.options;
    for (let index2 = 0; index2 < selectedItemKeys.length; index2++) {
      if ((!ignoreIndicesMap || !ignoreIndicesMap[index2]) && this.equalKeys(selectedItemKeys[index2], key)) {
        return index2;
      }
    }
    return -1;
  }
  _getSelectedIndexByHash(key, ignoreIndicesMap) {
    let indices = this.options.keyHashIndices[key];
    if (indices && indices.length > 1 && ignoreIndicesMap) {
      indices = indices.filter((index2) => !ignoreIndicesMap[index2]);
    }
    return indices && indices[0] >= 0 ? indices[0] : -1;
  }
  _indexOfSelectedItemKey(key, ignoreIndicesMap) {
    let selectedIndex;
    if (this.options.equalByReference) {
      selectedIndex = this.options.selectedItemKeys.indexOf(key);
    } else if (isObject(key)) {
      selectedIndex = this._getSelectedIndexByKey(key, ignoreIndicesMap);
    } else {
      selectedIndex = this._getSelectedIndexByHash(key, ignoreIndicesMap);
    }
    return selectedIndex;
  }
  _shiftSelectedKeyIndices(keyIndex) {
    for (let currentKeyIndex = keyIndex; currentKeyIndex < this.options.selectedItemKeys.length; currentKeyIndex++) {
      const currentKey = this.options.selectedItemKeys[currentKeyIndex];
      const currentKeyHash = getKeyHash(currentKey);
      const currentKeyIndices = this.options.keyHashIndices[currentKeyHash];
      if (!currentKeyIndices) {
        continue;
      }
      for (let i = 0; i < currentKeyIndices.length; i++) {
        if (currentKeyIndices[i] > keyIndex) {
          currentKeyIndices[i]--;
        }
      }
    }
  }
  removeSelectedItem(key, keyIndicesToRemoveMap, isDisabled) {
    if (!this.options.ignoreDisabledItems && isDisabled) {
      return;
    }
    const keyHash = this._getKeyHash(key);
    const isBatchDeselect = !!keyIndicesToRemoveMap;
    const keyIndex = this._indexOfSelectedItemKey(keyHash, keyIndicesToRemoveMap);
    if (keyIndex < 0) {
      return keyIndex;
    }
    this.options.removedItemKeys.push(key);
    this.options.removedItems.push(this.options.selectedItems[keyIndex]);
    if (isBatchDeselect) {
      return keyIndex;
    }
    this.options.selectedItemKeys.splice(keyIndex, 1);
    this.options.selectedItems.splice(keyIndex, 1);
    if (isObject(keyHash) || !this.options.keyHashIndices) {
      return keyIndex;
    }
    const keyIndices = this.options.keyHashIndices[keyHash];
    if (!keyIndices) {
      return keyIndex;
    }
    keyIndices.shift();
    if (!keyIndices.length) {
      delete this.options.keyHashIndices[keyHash];
    }
    this._shiftSelectedKeyIndices(keyIndex);
    return keyIndex;
  }
  _updateAddedItemKeys(keys, items) {
    for (let i = 0; i < keys.length; i++) {
      if (!this.isItemKeySelected(keys[i])) {
        this.options.addedItemKeys.push(keys[i]);
        this.options.addedItems.push(items[i]);
      }
    }
  }
  _updateRemovedItemKeys(keys, oldSelectedKeys, oldSelectedItems) {
    for (let i = 0; i < oldSelectedKeys.length; i++) {
      if (!this.isItemKeySelected(oldSelectedKeys[i])) {
        this.options.removedItemKeys.push(oldSelectedKeys[i]);
        this.options.removedItems.push(oldSelectedItems[i]);
      }
    }
  }
  _isItemSelectionInProgress(key, checkPending) {
    const shouldCheckPending = checkPending && this._lastRequestData && this._requestInProgress();
    if (shouldCheckPending) {
      const addedItems = this._lastRequestData.addedItems ?? [];
      return addedItems.includes(key);
    }
    return false;
  }
  _getKeyHash(key) {
    return this.options.equalByReference ? key : getKeyHash(key);
  }
  setSelectedItems(keys, items) {
    this._updateAddedItemKeys(keys, items);
    const oldSelectedKeys = this.options.selectedItemKeys;
    const oldSelectedItems = this.options.selectedItems;
    if (!this.options.equalByReference) {
      this._initSelectedItemKeyHash();
      this.updateSelectedItemKeyHash(keys);
    }
    this._setOption("selectedItemKeys", keys);
    this._setOption("selectedItems", items);
    this._updateRemovedItemKeys(keys, oldSelectedKeys, oldSelectedItems);
  }
  isItemDataSelected(itemData) {
    let options2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    const key = this.options.keyOf(itemData);
    return this.isItemKeySelected(key, options2);
  }
  isItemKeySelected(key) {
    let options2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    let result2 = this._isItemSelectionInProgress(key, options2.checkPending);
    if (!result2) {
      const keyHash = this._getKeyHash(key);
      const index2 = this._indexOfSelectedItemKey(keyHash);
      result2 = -1 !== index2;
    }
    return result2;
  }
  getSelectAllState(visibleOnly) {
    if (visibleOnly) {
      return this._getVisibleSelectAllState();
    }
    return this._getFullSelectAllState();
  }
  loadSelectedItemsWithFilter() {
    const keyExpr = this.options.key();
    const keys = this.getSelectedItemKeys();
    const filter = this.options.filter();
    if (!keys.length) {
      return Deferred().resolve([]);
    }
    const selectionFilterCreator = new SelectionFilterCreator(keys);
    const combinedFilter = selectionFilterCreator.getCombinedFilter(keyExpr, filter, true);
    return this._loadFilteredData(combinedFilter);
  }
  _storeSelectionState() {
    const {
      selectedItems,
      selectedItemKeys,
      keyHashIndices
    } = this.options;
    this._storedSelectionState = {
      keyHashIndices: JSON.stringify(keyHashIndices),
      selectedItems: [...selectedItems],
      selectedItemKeys: [...selectedItemKeys]
    };
  }
  _restoreSelectionState() {
    this._clearItemKeys();
    const {
      selectedItemKeys,
      selectedItems,
      keyHashIndices
    } = this._storedSelectionState;
    this._setOption("selectedItemKeys", selectedItemKeys);
    this._setOption("selectedItems", selectedItems);
    this._setOption("keyHashIndices", JSON.parse(keyHashIndices));
  }
  _onePageSelectAll(isDeselect) {
    if ("pending" === this._lastSelectAllPageDeferred.state()) {
      return Deferred().reject();
    }
    this._storeSelectionState();
    this._selectAllPlainItems(isDeselect);
    this._lastSelectAllPageDeferred = Deferred();
    this._callCallbackIfNotCanceled(() => {
      this.onSelectionChanged();
      this._lastSelectAllPageDeferred.resolve();
    }, () => {
      this._restoreSelectionState();
      this._lastSelectAllPageDeferred.reject();
    });
    return this._lastSelectAllPageDeferred;
  }
};

// node_modules/devextreme/esm/__internal/ui/selection/m_selection.js
var Selection = class {
  constructor(options2) {
    this.options = extend(this._getDefaultOptions(), options2, {
      selectedItemKeys: options2.selectedKeys || []
    });
    this._selectionStrategy = this.options.deferred ? new DeferredStrategy(this.options) : new StandardStrategy(this.options);
    this._focusedItemIndex = -1;
    if (!this.options.equalByReference) {
      this._selectionStrategy.updateSelectedItemKeyHash(this.options.selectedItemKeys);
    }
  }
  _getDefaultOptions() {
    return {
      allowNullValue: false,
      deferred: false,
      equalByReference: false,
      mode: "multiple",
      selectedItems: [],
      selectionFilter: [],
      maxFilterLengthInRequest: 0,
      onSelectionChanged: noop2,
      key: noop2,
      keyOf: (item) => item,
      load: () => Deferred().resolve([]),
      totalCount: () => -1,
      isSelectableItem: () => true,
      isItemSelected: () => false,
      getItemData: (item) => item,
      dataFields: noop2,
      filter: noop2
    };
  }
  validate() {
    this._selectionStrategy.validate();
  }
  getSelectedItemKeys() {
    return this._selectionStrategy.getSelectedItemKeys();
  }
  getSelectedItems() {
    return this._selectionStrategy.getSelectedItems();
  }
  selectionFilter(value2) {
    if (void 0 === value2) {
      return this.options.selectionFilter;
    }
    const filterIsChanged = this.options.selectionFilter !== value2 && JSON.stringify(this.options.selectionFilter) !== JSON.stringify(value2);
    this.options.selectionFilter = value2;
    filterIsChanged && this.onSelectionChanged();
  }
  setSelection(keys, updatedKeys) {
    return this.selectedItemKeys(keys, false, false, false, updatedKeys);
  }
  select(keys) {
    return this.selectedItemKeys(keys, true);
  }
  deselect(keys) {
    return this.selectedItemKeys(keys, true, true);
  }
  selectedItemKeys(keys, preserve, isDeselect, isSelectAll, updatedKeys) {
    keys = keys ?? [];
    keys = Array.isArray(keys) ? keys : [keys];
    this.validate();
    return this._selectionStrategy.selectedItemKeys(keys, preserve, isDeselect, isSelectAll, updatedKeys);
  }
  clearSelection() {
    return this.selectedItemKeys([]);
  }
  _addSelectedItem(itemData, key) {
    this._selectionStrategy.addSelectedItem(key, itemData);
  }
  _removeSelectedItem(key) {
    this._selectionStrategy.removeSelectedItem(key);
  }
  _setSelectedItems(keys, items) {
    this._selectionStrategy.setSelectedItems(keys, items);
  }
  onSelectionChanged() {
    this._selectionStrategy.onSelectionChanged();
  }
  changeItemSelection(itemIndex, keys, setFocusOnly) {
    var _this$options$allowLo, _this$options;
    let isSelectedItemsChanged;
    const items = this.options.plainItems();
    const item = items[itemIndex];
    let deferred;
    const {
      isVirtualPaging: isVirtualPaging2
    } = this.options;
    const allowLoadByRange = null === (_this$options$allowLo = (_this$options = this.options).allowLoadByRange) || void 0 === _this$options$allowLo ? void 0 : _this$options$allowLo.call(_this$options);
    const {
      alwaysSelectByShift
    } = this.options;
    let indexOffset;
    let focusedItemNotInLoadedRange = false;
    let shiftFocusedItemNotInLoadedRange = false;
    const itemIsNotInLoadedRange = (index2) => index2 >= 0 && !items.filter((it) => it.loadIndex === index2).length;
    if (isVirtualPaging2 && isDefined(item)) {
      if (allowLoadByRange) {
        indexOffset = item.loadIndex - itemIndex;
        itemIndex = item.loadIndex;
      }
      focusedItemNotInLoadedRange = itemIsNotInLoadedRange(this._focusedItemIndex);
      if (isDefined(this._shiftFocusedItemIndex)) {
        shiftFocusedItemNotInLoadedRange = itemIsNotInLoadedRange(this._shiftFocusedItemIndex);
      }
    }
    if (!this.isSelectable() || !this.isDataItem(item)) {
      return false;
    }
    const itemData = this.options.getItemData(item);
    const itemKey = this.options.keyOf(itemData);
    keys = keys || {};
    let allowSelectByShift = keys.shift;
    if (false === alwaysSelectByShift && allowSelectByShift) {
      allowSelectByShift = false !== allowLoadByRange || !focusedItemNotInLoadedRange && !shiftFocusedItemNotInLoadedRange;
    }
    if (allowSelectByShift && "multiple" === this.options.mode && this._focusedItemIndex >= 0) {
      if (allowLoadByRange && (focusedItemNotInLoadedRange || shiftFocusedItemNotInLoadedRange)) {
        isSelectedItemsChanged = itemIndex !== this._shiftFocusedItemIndex || this._focusedItemIndex !== this._shiftFocusedItemIndex;
        if (isSelectedItemsChanged) {
          deferred = this.changeItemSelectionWhenShiftKeyInVirtualPaging(itemIndex);
        }
      } else {
        isSelectedItemsChanged = this.changeItemSelectionWhenShiftKeyPressed(itemIndex, items, indexOffset);
      }
    } else if (keys.control) {
      this._resetItemSelectionWhenShiftKeyPressed();
      if (!setFocusOnly) {
        const isSelected = this._selectionStrategy.isItemDataSelected(itemData);
        if ("single" === this.options.mode) {
          this.clearSelectedItems();
        }
        if (isSelected) {
          this._removeSelectedItem(itemKey);
        } else {
          this._addSelectedItem(itemData, itemKey);
        }
      }
      isSelectedItemsChanged = true;
    } else {
      this._resetItemSelectionWhenShiftKeyPressed();
      const isKeysEqual2 = this._selectionStrategy.equalKeys(this.options.selectedItemKeys[0], itemKey);
      if (1 !== this.options.selectedItemKeys.length || !isKeysEqual2) {
        this._setSelectedItems([itemKey], [itemData]);
        isSelectedItemsChanged = true;
      }
    }
    if (isSelectedItemsChanged) {
      when(deferred).done(() => {
        this._focusedItemIndex = itemIndex;
        !setFocusOnly && this.onSelectionChanged();
      });
      return true;
    }
  }
  isDataItem(item) {
    return this.options.isSelectableItem(item);
  }
  isSelectable() {
    return "single" === this.options.mode || "multiple" === this.options.mode;
  }
  isItemDataSelected(data17) {
    return this._selectionStrategy.isItemDataSelected(data17, {
      checkPending: true
    });
  }
  isItemSelected(arg, options2) {
    return this._selectionStrategy.isItemKeySelected(arg, options2);
  }
  _resetItemSelectionWhenShiftKeyPressed() {
    delete this._shiftFocusedItemIndex;
  }
  _resetFocusedItemIndex() {
    this._focusedItemIndex = -1;
  }
  changeItemSelectionWhenShiftKeyInVirtualPaging(loadIndex) {
    const loadOptions = this.options.getLoadOptions(loadIndex, this._focusedItemIndex, this._shiftFocusedItemIndex);
    const deferred = Deferred();
    const indexOffset = loadOptions.skip;
    this.options.load(loadOptions).done((items) => {
      this.changeItemSelectionWhenShiftKeyPressed(loadIndex, items, indexOffset);
      deferred.resolve();
    });
    return deferred.promise();
  }
  changeItemSelectionWhenShiftKeyPressed(itemIndex, items, indexOffset) {
    let isSelectedItemsChanged = false;
    let itemIndexStep;
    const indexOffsetDefined = isDefined(indexOffset);
    let index2 = indexOffsetDefined ? this._focusedItemIndex - indexOffset : this._focusedItemIndex;
    const {
      keyOf
    } = this.options;
    const focusedItem = items[index2];
    const focusedData = this.options.getItemData(focusedItem);
    const focusedKey = keyOf(focusedData);
    const isFocusedItemSelected = focusedItem && this.isItemDataSelected(focusedData);
    if (!isDefined(this._shiftFocusedItemIndex)) {
      this._shiftFocusedItemIndex = this._focusedItemIndex;
    }
    let data17;
    let itemKey;
    let startIndex;
    let endIndex;
    if (this._shiftFocusedItemIndex !== this._focusedItemIndex) {
      itemIndexStep = this._focusedItemIndex < this._shiftFocusedItemIndex ? 1 : -1;
      startIndex = indexOffsetDefined ? this._focusedItemIndex - indexOffset : this._focusedItemIndex;
      endIndex = indexOffsetDefined ? this._shiftFocusedItemIndex - indexOffset : this._shiftFocusedItemIndex;
      for (index2 = startIndex; index2 !== endIndex; index2 += itemIndexStep) {
        if (indexOffsetDefined || this.isDataItem(items[index2])) {
          itemKey = keyOf(this.options.getItemData(items[index2]));
          this._removeSelectedItem(itemKey);
          isSelectedItemsChanged = true;
        }
      }
    }
    if (itemIndex !== this._shiftFocusedItemIndex) {
      itemIndexStep = itemIndex < this._shiftFocusedItemIndex ? 1 : -1;
      startIndex = indexOffsetDefined ? itemIndex - indexOffset : itemIndex;
      endIndex = indexOffsetDefined ? this._shiftFocusedItemIndex - indexOffset : this._shiftFocusedItemIndex;
      for (index2 = startIndex; index2 !== endIndex; index2 += itemIndexStep) {
        if (indexOffsetDefined || this.isDataItem(items[index2])) {
          data17 = this.options.getItemData(items[index2]);
          itemKey = keyOf(data17);
          this._addSelectedItem(data17, itemKey);
          isSelectedItemsChanged = true;
        }
      }
    }
    if ((indexOffsetDefined || this.isDataItem(focusedItem)) && !isFocusedItemSelected) {
      this._addSelectedItem(focusedData, focusedKey);
      isSelectedItemsChanged = true;
    }
    return isSelectedItemsChanged;
  }
  clearSelectedItems() {
    this._setSelectedItems([], []);
  }
  selectAll(isOnePage) {
    this._resetFocusedItemIndex();
    if (isOnePage) {
      return this._selectionStrategy._onePageSelectAll(false);
    }
    return this.selectedItemKeys([], true, false, true);
  }
  deselectAll(isOnePage) {
    this._resetFocusedItemIndex();
    if (isOnePage) {
      return this._selectionStrategy._onePageSelectAll(true);
    }
    return this.selectedItemKeys([], true, true, true);
  }
  getSelectAllState(visibleOnly) {
    return this._selectionStrategy.getSelectAllState(visibleOnly);
  }
  loadSelectedItemsWithFilter() {
    return this._selectionStrategy.loadSelectedItemsWithFilter();
  }
};

// node_modules/devextreme/esm/__internal/ui/collection/m_collection_widget.edit.js
var NOT_EXISTING_INDEX = -1;
var indexExists = (index2) => index2 !== NOT_EXISTING_INDEX;
var CollectionWidget2 = class extends collection_widget_base_default {
  _setOptionsByReference() {
    super._setOptionsByReference();
    extend(this._optionsByReference, {
      selectedItem: true
    });
  }
  _getDefaultOptions() {
    return _extends({}, super._getDefaultOptions(), {
      selectionMode: "none",
      selectionRequired: false,
      selectByClick: true,
      selectedItems: [],
      selectedItemKeys: [],
      maxFilterLengthInRequest: 1500,
      keyExpr: null,
      selectedIndex: NOT_EXISTING_INDEX,
      focusOnSelectedItem: true,
      selectedItem: null,
      onSelectionChanging: null,
      onSelectionChanged: null,
      onItemReordered: null,
      onItemDeleting: null,
      onItemDeleted: null
    });
  }
  ctor(element, options2) {
    this._userOptions = options2 || {};
    super.ctor(element, options2);
  }
  _init() {
    this._initEditStrategy();
    super._init();
    this._initKeyGetter();
    this._initActions();
    this._initSelectionModule();
  }
  _initKeyGetter() {
    this._keyGetter = compileGetter(this.option("keyExpr"));
  }
  _selectedItemClass() {
    return "dx-item-selected";
  }
  _getActionsList() {
    return ["onSelectionChanging", "onSelectionChanged"];
  }
  _initActions() {
    this._actions = {};
    const actions = this._getActionsList();
    actions.forEach((action) => {
      this._actions[action] = this._createActionByOption(action, {
        excludeValidators: ["disabled", "readOnly"]
      }) ?? noop2;
    });
  }
  _getKeysByItems(selectedItems) {
    return this._editStrategy.getKeysByItems(selectedItems);
  }
  _getItemsByKeys(selectedItemKeys, selectedItems) {
    return this._editStrategy.getItemsByKeys(selectedItemKeys, selectedItems);
  }
  _getKeyByIndex(index2) {
    return this._editStrategy.getKeyByIndex(index2);
  }
  _getIndexByKey(key) {
    return this._editStrategy.getIndexByKey(key);
  }
  _getIndexByItemData(itemData) {
    return this._editStrategy.getIndexByItemData(itemData);
  }
  _isKeySpecified() {
    return !!this._dataController.key();
  }
  _getCombinedFilter() {
    return this._dataController.filter();
  }
  key() {
    const {
      keyExpr
    } = this.option();
    if (keyExpr) {
      return keyExpr;
    }
    return this._dataController.key();
  }
  keyOf(item) {
    let key = item;
    if (this.option("keyExpr")) {
      key = this._keyGetter(item);
    } else if (this._dataController.store()) {
      key = this._dataController.keyOf(item);
    }
    return key;
  }
  _nullValueSelectionSupported() {
    return false;
  }
  _initSelectionModule() {
    const that = this;
    const {
      itemsGetter
    } = this._editStrategy;
    this._selection = new Selection({
      allowNullValue: this._nullValueSelectionSupported(),
      mode: this.option("selectionMode"),
      maxFilterLengthInRequest: this.option("maxFilterLengthInRequest"),
      equalByReference: !this._isKeySpecified(),
      onSelectionChanging: (args) => {
        var _this$_actions$onSele, _this$_actions;
        const isSelectionChanged = args.addedItemKeys.length || args.removedItemKeys.length;
        if (!this._rendered || !isSelectionChanged) {
          return;
        }
        const selectionChangingArgs = {
          removedItems: args.removedItems,
          addedItems: args.addedItems,
          cancel: false
        };
        null === (_this$_actions$onSele = (_this$_actions = this._actions).onSelectionChanging) || void 0 === _this$_actions$onSele || _this$_actions$onSele.call(_this$_actions, selectionChangingArgs);
        args.cancel = selectionChangingArgs.cancel;
      },
      onSelectionChanged: (args) => {
        if (args.addedItemKeys.length || args.removedItemKeys.length) {
          this.option("selectedItems", this._getItemsByKeys(args.selectedItemKeys, args.selectedItems));
          this._updateSelectedItems(args);
        }
      },
      filter: this._getCombinedFilter.bind(this),
      totalCount: () => {
        const {
          items
        } = this.option();
        const totalCount = this._dataController.totalCount();
        return totalCount >= 0 ? totalCount : this._getItemsCount(items);
      },
      key: this.key.bind(this),
      keyOf: this.keyOf.bind(this),
      load(options2) {
        var _dataController$loadO;
        const dataController2 = that._dataController;
        options2.customQueryParams = null === (_dataController$loadO = dataController2.loadOptions()) || void 0 === _dataController$loadO ? void 0 : _dataController$loadO.customQueryParams;
        options2.userData = dataController2.userData();
        if (dataController2.store()) {
          return dataController2.loadFromStore(options2).done((loadResult) => {
            if (that._disposed) {
              return;
            }
            const items = normalizeLoadResult(loadResult).data;
            dataController2.applyMapFunction(items);
          });
        }
        return Deferred().resolve(this.plainItems());
      },
      dataFields: () => this._dataController.select(),
      plainItems: itemsGetter.bind(this._editStrategy)
    });
  }
  _getItemsCount(items) {
    return items.reduce((itemsCount, item) => itemsCount + (item.items ? this._getItemsCount(item.items) : 1), 0);
  }
  _initEditStrategy() {
    this._editStrategy = new m_collection_widget_edit_strategy_plain_default(this);
  }
  _getSelectedItemIndices(keys) {
    const indices = [];
    keys = keys || this._selection.getSelectedItemKeys();
    this._editStrategy.beginCache();
    each(keys, (_, key) => {
      const selectedIndex = this._getIndexByKey(key);
      if (indexExists(selectedIndex)) {
        indices.push(selectedIndex);
      }
    });
    this._editStrategy.endCache();
    return indices;
  }
  _initMarkup() {
    this._rendering = true;
    if (!this._dataController.isLoading()) {
      this._syncSelectionOptions().done(() => this._normalizeSelectedItems());
    }
    super._initMarkup();
  }
  _render() {
    super._render();
    this._rendering = false;
  }
  _fireContentReadyAction() {
    this._rendering = false;
    this._rendered = true;
    super._fireContentReadyAction();
  }
  _syncSelectionOptions(byOption) {
    byOption = byOption ?? this._chooseSelectOption();
    let selectedItem;
    let selectedIndex;
    let selectedItemKeys;
    let selectedItems;
    switch (byOption) {
      case "selectedIndex":
        selectedItem = this._editStrategy.getItemDataByIndex(this.option("selectedIndex"));
        if (isDefined(selectedItem)) {
          this._setOptionWithoutOptionChange("selectedItems", [selectedItem]);
          this._setOptionWithoutOptionChange("selectedItem", selectedItem);
          this._setOptionWithoutOptionChange("selectedItemKeys", this._editStrategy.getKeysByItems([selectedItem]));
        } else {
          this._setOptionWithoutOptionChange("selectedItems", []);
          this._setOptionWithoutOptionChange("selectedItemKeys", []);
          this._setOptionWithoutOptionChange("selectedItem", null);
        }
        break;
      case "selectedItems":
        selectedItems = this.option("selectedItems") || [];
        selectedIndex = selectedItems.length ? this._editStrategy.getIndexByItemData(selectedItems[0]) : NOT_EXISTING_INDEX;
        if (this.option("selectionRequired") && !indexExists(selectedIndex)) {
          return this._syncSelectionOptions("selectedIndex");
        }
        this._setOptionWithoutOptionChange("selectedItem", selectedItems[0]);
        this._setOptionWithoutOptionChange("selectedIndex", selectedIndex);
        this._setOptionWithoutOptionChange("selectedItemKeys", this._editStrategy.getKeysByItems(selectedItems));
        break;
      case "selectedItem":
        selectedItem = this.option("selectedItem");
        selectedIndex = this._editStrategy.getIndexByItemData(selectedItem);
        if (this.option("selectionRequired") && !indexExists(selectedIndex)) {
          return this._syncSelectionOptions("selectedIndex");
        }
        if (isDefined(selectedItem)) {
          this._setOptionWithoutOptionChange("selectedItems", [selectedItem]);
          this._setOptionWithoutOptionChange("selectedIndex", selectedIndex);
          this._setOptionWithoutOptionChange("selectedItemKeys", this._editStrategy.getKeysByItems([selectedItem]));
        } else {
          this._setOptionWithoutOptionChange("selectedItems", []);
          this._setOptionWithoutOptionChange("selectedItemKeys", []);
          this._setOptionWithoutOptionChange("selectedIndex", NOT_EXISTING_INDEX);
        }
        break;
      case "selectedItemKeys":
        selectedItemKeys = this.option("selectedItemKeys");
        if (this.option("selectionRequired")) {
          const selectedItemIndex = this._getIndexByKey(selectedItemKeys[0]);
          if (!indexExists(selectedItemIndex)) {
            return this._syncSelectionOptions("selectedIndex");
          }
        }
        return this._selection.setSelection(selectedItemKeys);
    }
    return Deferred().resolve().promise();
  }
  _chooseSelectOption() {
    let optionName = "selectedIndex";
    const isOptionDefined = (name2) => {
      const optionValue = this.option(name2);
      const length = isDefined(optionValue) && optionValue.length;
      return length || name2 in this._userOptions;
    };
    if (isOptionDefined("selectedItems")) {
      optionName = "selectedItems";
    } else if (isOptionDefined("selectedItem")) {
      optionName = "selectedItem";
    } else if (isOptionDefined("selectedItemKeys")) {
      optionName = "selectedItemKeys";
    }
    return optionName;
  }
  _compareKeys(oldKeys, newKeys) {
    if (oldKeys.length !== newKeys.length) {
      return false;
    }
    for (let i = 0; i < newKeys.length; i++) {
      if (oldKeys[i] !== newKeys[i]) {
        return false;
      }
    }
    return true;
  }
  _normalizeSelectedItems() {
    const {
      selectionMode,
      selectedItems,
      items
    } = this.option();
    if ("none" === selectionMode) {
      this._setOptionWithoutOptionChange("selectedItems", []);
      this._syncSelectionOptions("selectedItems");
    } else if ("single" === selectionMode) {
      const newSelection = selectedItems ?? [];
      if (newSelection.length > 1 || !newSelection.length && this.option("selectionRequired") && null !== items && void 0 !== items && items.length) {
        var _normalizedSelection;
        const currentSelection = this._selection.getSelectedItems();
        let normalizedSelection = void 0 === newSelection[0] ? currentSelection[0] : newSelection[0];
        if (void 0 === normalizedSelection) {
          normalizedSelection = this._editStrategy.itemsGetter()[0];
        }
        if (this.option("grouped") && null !== (_normalizedSelection = normalizedSelection) && void 0 !== _normalizedSelection && _normalizedSelection.items) {
          normalizedSelection.items = [normalizedSelection.items[0]];
        }
        this._selection.setSelection(this._getKeysByItems([normalizedSelection]));
        this._setOptionWithoutOptionChange("selectedItems", [normalizedSelection]);
        return this._syncSelectionOptions("selectedItems");
      }
      this._selection.setSelection(this._getKeysByItems(newSelection));
    } else {
      const newKeys = this._getKeysByItems(this.option("selectedItems"));
      const oldKeys = this._selection.getSelectedItemKeys();
      if (!this._compareKeys(oldKeys, newKeys)) {
        this._selection.setSelection(newKeys);
      }
    }
    return Deferred().resolve().promise();
  }
  _itemClickHandler(e, args, config3) {
    let itemSelectPromise = Deferred().resolve();
    this._createAction((e2) => {
      itemSelectPromise = this._itemSelectHandler(e2.event) ?? itemSelectPromise;
    }, {
      validatingTargetName: "itemElement"
    })({
      itemElement: renderer_default(e.currentTarget),
      event: e
    });
    itemSelectPromise.always(() => {
      super._itemClickHandler(e, args, config3);
    });
  }
  _itemSelectHandler(e, shouldIgnoreSelectByClick) {
    if (!shouldIgnoreSelectByClick && !this.option("selectByClick")) {
      return;
    }
    const $itemElement = e.currentTarget;
    if (this.isItemSelected($itemElement)) {
      this.unselectItem(e.currentTarget);
    } else {
      const itemSelectPromise = this.selectItem(e.currentTarget);
      return null === itemSelectPromise || void 0 === itemSelectPromise ? void 0 : itemSelectPromise.promise();
    }
  }
  _selectedItemElement(index2) {
    return this._itemElements().eq(index2);
  }
  _postprocessRenderItem(args) {
    const {
      selectionMode
    } = this.option();
    if ("none" !== selectionMode) {
      const $itemElement = renderer_default(args.itemElement);
      const normalizedItemIndex = this._editStrategy.getNormalizedIndex($itemElement);
      const isItemSelected = this._isItemSelected(normalizedItemIndex);
      this._processSelectableItem($itemElement, isItemSelected);
    }
  }
  _processSelectableItem($itemElement, isSelected) {
    $itemElement.toggleClass(this._selectedItemClass(), isSelected);
    this._setAriaSelectionAttribute($itemElement, String(isSelected));
  }
  _updateSelectedItems(args) {
    const {
      addedItemKeys,
      removedItemKeys
    } = args;
    if (this._rendered && (addedItemKeys.length || removedItemKeys.length)) {
      if (!this._rendering) {
        const addedSelection = [];
        const removedSelection = [];
        this._editStrategy.beginCache();
        for (let i = 0; i < addedItemKeys.length; i += 1) {
          const normalizedIndex = this._getIndexByKey(addedItemKeys[i]);
          addedSelection.push(normalizedIndex);
          this._addSelection(normalizedIndex);
        }
        for (let i = 0; i < removedItemKeys.length; i += 1) {
          const normalizedIndex = this._getIndexByKey(removedItemKeys[i]);
          removedSelection.push(normalizedIndex);
          this._removeSelection(normalizedIndex);
        }
        this._editStrategy.endCache();
        this._updateSelection(addedSelection, removedSelection);
      }
      this._actions.onSelectionChanged({
        addedItems: args.addedItems,
        removedItems: args.removedItems
      });
    }
  }
  _updateSelection(addedSelection, removedSelection) {
  }
  _setAriaSelectionAttribute($target, value2) {
    this.setAria("selected", value2, $target);
  }
  _getFocusedElementIndex() {
    const {
      focusOnSelectedItem
    } = this.option();
    return focusOnSelectedItem ? this._getFlatIndex() : super._getFocusedElementIndex();
  }
  _getFlatIndex() {
    const {
      selectedIndex = NOT_EXISTING_INDEX
    } = this.option();
    return selectedIndex;
  }
  _removeSelection(normalizedIndex) {
    const $itemElement = this._editStrategy.getItemElement(normalizedIndex);
    if (indexExists(normalizedIndex)) {
      this._processSelectableItem($itemElement, false);
      m_events_engine_default.triggerHandler($itemElement, "stateChanged", false);
    }
  }
  _addSelection(normalizedIndex) {
    const $itemElement = this._editStrategy.getItemElement(normalizedIndex);
    if (indexExists(normalizedIndex)) {
      this._processSelectableItem($itemElement, true);
      m_events_engine_default.triggerHandler($itemElement, "stateChanged", true);
    }
  }
  _isItemSelected(index2) {
    const key = this._getKeyByIndex(index2);
    return this._selection.isItemSelected(key, {
      checkPending: true
    });
  }
  _optionChanged(args) {
    switch (args.name) {
      case "selectionMode":
        this._invalidate();
        break;
      case "dataSource":
        if (!args.value || Array.isArray(args.value) && !args.value.length) {
          this.option("selectedItemKeys", []);
        }
        super._optionChanged(args);
        break;
      case "selectedIndex":
      case "selectedItem":
      case "selectedItems":
      case "selectedItemKeys":
        this._syncSelectionOptions(args.name).done(() => this._normalizeSelectedItems());
        break;
      case "keyExpr":
        this._initKeyGetter();
        break;
      case "selectionRequired":
        this._normalizeSelectedItems();
        break;
      case "onSelectionChanging":
      case "onSelectionChanged":
        this._initActions();
        break;
      case "selectByClick":
      case "onItemDeleting":
      case "onItemDeleted":
      case "onItemReordered":
      case "maxFilterLengthInRequest":
      case "focusOnSelectedItem":
        break;
      default:
        super._optionChanged(args);
    }
  }
  _clearSelectedItems() {
    this._setOptionWithoutOptionChange("selectedItems", []);
    this._syncSelectionOptions("selectedItems");
  }
  _waitDeletingPrepare($itemElement) {
    if ($itemElement.data("dxItemDeleting")) {
      return Deferred().resolve().promise();
    }
    $itemElement.data("dxItemDeleting", true);
    const deferred = Deferred();
    const deletingActionArgs = {
      cancel: false
    };
    const deletePromise = this._itemEventHandler($itemElement, "onItemDeleting", deletingActionArgs, {
      excludeValidators: ["disabled", "readOnly"]
    });
    when(deletePromise).always(function(value2) {
      const deletePromiseExists = !deletePromise;
      const deletePromiseResolved = !deletePromiseExists && "resolved" === deletePromise.state();
      const argumentsSpecified = !!arguments.length;
      const shouldDelete = deletePromiseExists || deletePromiseResolved && !argumentsSpecified || deletePromiseResolved && value2;
      when(fromPromise(deletingActionArgs.cancel)).always(() => {
        $itemElement.data("dxItemDeleting", false);
      }).done((cancel2) => {
        if (shouldDelete && !cancel2) {
          deferred.resolve();
        } else {
          deferred.reject();
        }
      }).fail(deferred.reject);
    });
    return deferred.promise();
  }
  _deleteItemFromDS($item) {
    const dataController2 = this._dataController;
    const deferred = Deferred();
    const disabledState = this.option("disabled");
    const dataStore = dataController2.store();
    if (!dataStore) {
      return Deferred().resolve().promise();
    }
    if (!dataStore.remove) {
      throw ui_errors_default.Error("E1011");
    }
    this.option("disabled", true);
    dataStore.remove(dataController2.keyOf(this._getItemData($item))).done((key) => {
      if (void 0 !== key) {
        deferred.resolve();
      } else {
        deferred.reject();
      }
    }).fail(() => {
      deferred.reject();
    });
    deferred.always(() => {
      this.option("disabled", disabledState);
    });
    return deferred;
  }
  _tryRefreshLastPage() {
    const deferred = Deferred();
    if (this._isLastPage() || this.option("grouped")) {
      deferred.resolve();
    } else {
      this._refreshLastPage().done(() => {
        deferred.resolve();
      });
    }
    return deferred.promise();
  }
  _refreshLastPage() {
    this._expectLastItemLoading();
    return this._dataController.load();
  }
  _updateSelectionAfterDelete(index2) {
    const key = this._getKeyByIndex(index2);
    this._selection.deselect([key]);
  }
  _updateIndicesAfterIndex(index2) {
    const itemElements = this._itemElements();
    for (let i = index2 + 1; i < itemElements.length; i += 1) {
      renderer_default(itemElements[i]).data(this._itemIndexKey(), i - 1);
    }
  }
  _simulateOptionChange(optionName) {
    var _this$_optionChangedA;
    const optionValue = this.option(optionName);
    if (optionValue instanceof DataSource) {
      return;
    }
    null === (_this$_optionChangedA = this._optionChangedAction) || void 0 === _this$_optionChangedA || _this$_optionChangedA.call(this, {
      name: optionName,
      fullName: optionName,
      value: optionValue
    });
  }
  isItemSelected(itemElement) {
    return this._isItemSelected(this._editStrategy.getNormalizedIndex(itemElement));
  }
  selectItem(itemElement) {
    const {
      selectionMode
    } = this.option();
    if ("none" === selectionMode) {
      return Deferred().resolve();
    }
    const itemIndex = this._editStrategy.getNormalizedIndex(itemElement);
    if (!indexExists(itemIndex)) {
      return Deferred().resolve();
    }
    const key = this._getKeyByIndex(itemIndex);
    if (this._selection.isItemSelected(key)) {
      return Deferred().resolve();
    }
    if ("single" === selectionMode) {
      return this._selection.setSelection([key]);
    }
    const {
      selectedItemKeys
    } = this.option();
    return this._selection.setSelection([...selectedItemKeys ?? [], key], [key]);
  }
  unselectItem(itemElement) {
    const itemIndex = this._editStrategy.getNormalizedIndex(itemElement);
    if (!indexExists(itemIndex)) {
      return;
    }
    const selectedItemKeys = this._selection.getSelectedItemKeys();
    if (this.option("selectionRequired") && selectedItemKeys.length <= 1) {
      return;
    }
    const key = this._getKeyByIndex(itemIndex);
    if (!this._selection.isItemSelected(key, {
      checkPending: true
    })) {
      return;
    }
    this._selection.deselect([key]);
  }
  _deleteItemElementByIndex(index2) {
    this._updateSelectionAfterDelete(index2);
    this._updateIndicesAfterIndex(index2);
    this._editStrategy.deleteItemAtIndex(index2);
  }
  _afterItemElementDeleted($item, deletedActionArgs) {
    const changingOption = this._dataController.getDataSource() ? "dataSource" : "items";
    this._simulateOptionChange(changingOption);
    this._itemEventHandler($item, "onItemDeleted", deletedActionArgs, {
      beforeExecute() {
        $item.remove();
      },
      excludeValidators: ["disabled", "readOnly"]
    });
    this._renderEmptyMessage();
  }
  deleteItem(itemElement) {
    const deferred = Deferred();
    const $item = this._editStrategy.getItemElement(itemElement);
    const index2 = this._editStrategy.getNormalizedIndex(itemElement);
    const itemResponseWaitClass = this._itemResponseWaitClass();
    if (indexExists(index2)) {
      this._waitDeletingPrepare($item).done(() => {
        $item.addClass(itemResponseWaitClass);
        const deletedActionArgs = this._extendActionArgs($item);
        this._deleteItemFromDS($item).done(() => {
          this._deleteItemElementByIndex(index2);
          this._afterItemElementDeleted($item, deletedActionArgs);
          this._tryRefreshLastPage().done(() => {
            deferred.resolveWith(this);
          });
        }).fail(() => {
          $item.removeClass(itemResponseWaitClass);
          deferred.rejectWith(this);
        });
      }).fail(() => {
        deferred.rejectWith(this);
      });
    } else {
      deferred.rejectWith(this);
    }
    return deferred.promise();
  }
  reorderItem(itemElement, toItemElement) {
    const deferred = Deferred();
    const strategy3 = this._editStrategy;
    const $movingItem = strategy3.getItemElement(itemElement);
    const $destinationItem = strategy3.getItemElement(toItemElement);
    const movingIndex = strategy3.getNormalizedIndex(itemElement);
    const destinationIndex = strategy3.getNormalizedIndex(toItemElement);
    const changingOption = this._dataController.getDataSource() ? "dataSource" : "items";
    const canMoveItems = indexExists(movingIndex) && indexExists(destinationIndex) && movingIndex !== destinationIndex;
    if (canMoveItems) {
      deferred.resolveWith(this);
    } else {
      deferred.rejectWith(this);
    }
    return deferred.promise().done(() => {
      $destinationItem[strategy3.itemPlacementFunc(movingIndex, destinationIndex)]($movingItem);
      strategy3.moveItemAtIndexToIndex(movingIndex, destinationIndex);
      this._updateIndicesAfterIndex(movingIndex);
      this.option("selectedItems", this._getItemsByKeys(this._selection.getSelectedItemKeys(), this._selection.getSelectedItems()));
      if ("items" === changingOption) {
        this._simulateOptionChange(changingOption);
      }
      this._itemEventHandler($movingItem, "onItemReordered", {
        fromIndex: strategy3.getIndex(movingIndex),
        toIndex: strategy3.getIndex(destinationIndex)
      }, {
        excludeValidators: ["disabled", "readOnly"]
      });
    });
  }
};
var m_collection_widget_edit_default = CollectionWidget2;

// node_modules/devextreme/esm/__internal/ui/collection/m_collection_widget.async.js
var CollectionWidgetAsync = class extends m_collection_widget_edit_default {
  _initMarkup() {
    this._asyncTemplateItemsMap = {};
    super._initMarkup();
  }
  _render() {
    super._render();
    this._planPostRenderActions();
  }
  _renderItemContent(args) {
    const renderContentDeferred = Deferred();
    const itemDeferred = Deferred();
    const uniqueKey = `dx${new guid_default2()}`;
    this._asyncTemplateItemsMap[uniqueKey] = itemDeferred;
    const $itemContent = super._renderItemContent(_extends({}, args, {
      uniqueKey
    }));
    itemDeferred.done(() => {
      renderContentDeferred.resolve($itemContent);
    });
    return renderContentDeferred.promise();
  }
  _onItemTemplateRendered(itemTemplate, renderArgs) {
    return () => {
      const {
        uniqueKey
      } = renderArgs;
      if (uniqueKey) {
        var _this$_asyncTemplateI;
        null === (_this$_asyncTemplateI = this._asyncTemplateItemsMap[uniqueKey]) || void 0 === _this$_asyncTemplateI || _this$_asyncTemplateI.resolve();
      }
    };
  }
  _postProcessRenderItems() {
  }
  _planPostRenderActions() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    const d = Deferred();
    const asyncTemplateItems = Object.values(this._asyncTemplateItemsMap);
    when.apply(this, asyncTemplateItems).done(() => {
      this._postProcessRenderItems(...args);
      d.resolve().done(() => {
        this._asyncTemplateItemsMap = {};
      });
    });
    return d.promise();
  }
  _clean() {
    super._clean();
    const asyncTemplateItems = Object.values(this._asyncTemplateItemsMap);
    asyncTemplateItems.forEach((item) => {
      item.reject();
    });
    this._asyncTemplateItemsMap = {};
  }
};
var m_collection_widget_async_default = CollectionWidgetAsync;

// node_modules/devextreme/esm/ui/collection/ui.collection_widget.async.js
var ui_collection_widget_async_default = m_collection_widget_async_default;

// node_modules/devextreme/esm/__internal/core/m_resize_observer.js
var window18 = m_window_default.getWindow();
var ResizeObserverMock = {
  observe: noop2,
  unobserve: noop2,
  disconnect: noop2
};
var ResizeObserverSingleton = class {
  constructor() {
    if (!m_window_default.hasWindow() || !window18.ResizeObserver) {
      return ResizeObserverMock;
    }
    this._callbacksMap = /* @__PURE__ */ new Map();
    this._observer = new window18.ResizeObserver((entries) => {
      entries.forEach((entry) => {
        var _this$_callbacksMap$g;
        null === (_this$_callbacksMap$g = this._callbacksMap.get(entry.target)) || void 0 === _this$_callbacksMap$g || _this$_callbacksMap$g(entry);
      });
    });
  }
  observe(element, callback) {
    this._callbacksMap.set(element, callback);
    this._observer.observe(element);
  }
  unobserve(element) {
    this._callbacksMap.delete(element);
    this._observer.unobserve(element);
  }
  disconnect() {
    this._callbacksMap.clear();
    this._observer.disconnect();
  }
};
var resizeObserverSingleton = new ResizeObserverSingleton();

// node_modules/devextreme/esm/core/resize_observer.js
var resize_observer_default = resizeObserverSingleton;

// node_modules/devextreme/esm/__internal/ui/m_validation_engine.js
var EMAIL_VALIDATION_REGEX = /^[\d\w.+_-]+@[\d\w._-]+\.[\w]+$/i;
var STATUS = {
  valid: "valid",
  invalid: "invalid",
  pending: "pending"
};
var BaseRuleValidator = class {
  constructor() {
    this.NAME = "base";
  }
  defaultMessage(value2) {
    return message_default.getFormatter(`validation-${this.NAME}`)(value2);
  }
  defaultFormattedMessage(value2) {
    return message_default.getFormatter(`validation-${this.NAME}-formatted`)(value2);
  }
  _isValueEmpty(value2) {
    return !rulesValidators.required.validate(value2, {});
  }
  validate(value2, rule) {
    const valueArray = Array.isArray(value2) ? value2 : [value2];
    let result2 = true;
    if (valueArray.length) {
      valueArray.every((itemValue) => {
        result2 = this._validate(itemValue, rule);
        return result2;
      });
    } else {
      result2 = this._validate(null, rule);
    }
    return result2;
  }
};
var RequiredRuleValidator = class extends BaseRuleValidator {
  constructor() {
    super();
    this.NAME = "required";
  }
  _validate(value2, rule) {
    if (!isDefined(value2)) {
      return false;
    }
    if (false === value2) {
      return false;
    }
    value2 = String(value2);
    if (rule.trim || !isDefined(rule.trim)) {
      value2 = value2.trim();
    }
    return "" !== value2;
  }
};
var NumericRuleValidator = class extends BaseRuleValidator {
  constructor() {
    super();
    this.NAME = "numeric";
  }
  _validate(value2, rule) {
    if (false !== rule.ignoreEmptyValue && this._isValueEmpty(value2)) {
      return true;
    }
    if (rule.useCultureSettings && isString(value2)) {
      return !isNaN(number_default2.parse(value2));
    }
    return isNumeric(value2);
  }
};
var RangeRuleValidator = class extends BaseRuleValidator {
  constructor() {
    super();
    this.NAME = "range";
  }
  _validate(value2, rule) {
    if (false !== rule.ignoreEmptyValue && this._isValueEmpty(value2)) {
      return true;
    }
    const validNumber = rulesValidators.numeric.validate(value2, rule);
    const validValue = isDefined(value2) && "" !== value2;
    const number = validNumber ? parseFloat(value2) : validValue && value2.valueOf();
    const {
      min
    } = rule;
    const {
      max
    } = rule;
    if (!(validNumber || isDate(value2)) && !validValue) {
      return false;
    }
    if (isDefined(min)) {
      if (isDefined(max)) {
        return number >= min && number <= max;
      }
      return number >= min;
    }
    if (isDefined(max)) {
      return number <= max;
    }
    throw errors_default.Error("E0101");
  }
};
var StringLengthRuleValidator = class extends BaseRuleValidator {
  constructor() {
    super();
    this.NAME = "stringLength";
  }
  _validate(value2, rule) {
    value2 = String(value2 ?? "");
    if (rule.trim || !isDefined(rule.trim)) {
      value2 = value2.trim();
    }
    if (rule.ignoreEmptyValue && this._isValueEmpty(value2)) {
      return true;
    }
    return rulesValidators.range.validate(value2.length, extend({}, rule));
  }
};
var CustomRuleValidator = class extends BaseRuleValidator {
  constructor() {
    super();
    this.NAME = "custom";
  }
  validate(value2, rule) {
    if (rule.ignoreEmptyValue && this._isValueEmpty(value2)) {
      return true;
    }
    const {
      validator
    } = rule;
    const dataGetter = validator && isFunction(validator.option) && validator.option("dataGetter");
    const extraParams = isFunction(dataGetter) && dataGetter();
    const params = {
      value: value2,
      validator,
      rule
    };
    if (extraParams) {
      extend(params, extraParams);
    }
    return rule.validationCallback(params);
  }
};
var AsyncRuleValidator = class extends CustomRuleValidator {
  constructor() {
    super();
    this.NAME = "async";
  }
  validate(value2, rule) {
    if (!isDefined(rule.reevaluate)) {
      extend(rule, {
        reevaluate: true
      });
    }
    if (rule.ignoreEmptyValue && this._isValueEmpty(value2)) {
      return true;
    }
    const {
      validator
    } = rule;
    const dataGetter = validator && isFunction(validator.option) && validator.option("dataGetter");
    const extraParams = isFunction(dataGetter) && dataGetter();
    const params = {
      value: value2,
      validator,
      rule
    };
    if (extraParams) {
      extend(params, extraParams);
    }
    const callbackResult = rule.validationCallback(params);
    if (!isPromise(callbackResult)) {
      throw errors_default.Error("E0103");
    }
    return this._getWrappedPromise(fromPromise(callbackResult).promise());
  }
  _getWrappedPromise(promise) {
    const deferred = Deferred();
    promise.then((res) => {
      deferred.resolve(res);
    }, (err) => {
      const res = {
        isValid: false
      };
      if (isDefined(err)) {
        if (isString(err)) {
          res.message = err;
        } else if (isObject(err) && isDefined(err.message) && isString(err.message)) {
          res.message = err.message;
        }
      }
      deferred.resolve(res);
    });
    return deferred.promise();
  }
};
var CompareRuleValidator = class extends BaseRuleValidator {
  constructor() {
    super();
    this.NAME = "compare";
  }
  _validate(value2, rule) {
    if (!rule.comparisonTarget) {
      throw errors_default.Error("E0102");
    }
    if (rule.ignoreEmptyValue && this._isValueEmpty(value2)) {
      return true;
    }
    extend(rule, {
      reevaluate: true
    });
    const otherValue = rule.comparisonTarget();
    const type2 = rule.comparisonType || "==";
    switch (type2) {
      case "==":
        return value2 == otherValue;
      case "!=":
        return value2 != otherValue;
      case "===":
        return value2 === otherValue;
      case "!==":
        return value2 !== otherValue;
      case ">":
        return value2 > otherValue;
      case ">=":
        return value2 >= otherValue;
      case "<":
        return value2 < otherValue;
      case "<=":
        return value2 <= otherValue;
    }
  }
};
var PatternRuleValidator = class extends BaseRuleValidator {
  constructor() {
    super();
    this.NAME = "pattern";
  }
  _validate(value2, rule) {
    if (false !== rule.ignoreEmptyValue && this._isValueEmpty(value2)) {
      return true;
    }
    let {
      pattern
    } = rule;
    if (isString(pattern)) {
      pattern = new RegExp(pattern);
    }
    return pattern.test(value2);
  }
};
var EmailRuleValidator = class extends BaseRuleValidator {
  constructor() {
    super();
    this.NAME = "email";
  }
  _validate(value2, rule) {
    if (false !== rule.ignoreEmptyValue && this._isValueEmpty(value2)) {
      return true;
    }
    return rulesValidators.pattern.validate(value2, extend({}, rule, {
      pattern: EMAIL_VALIDATION_REGEX
    }));
  }
};
var rulesValidators = {
  required: new RequiredRuleValidator(),
  numeric: new NumericRuleValidator(),
  range: new RangeRuleValidator(),
  stringLength: new StringLengthRuleValidator(),
  custom: new CustomRuleValidator(),
  async: new AsyncRuleValidator(),
  compare: new CompareRuleValidator(),
  pattern: new PatternRuleValidator(),
  email: new EmailRuleValidator()
};
var GroupConfig = class extends class_default.inherit({}) {
  ctor(group, isRemovable) {
    this.group = group;
    this.validators = [];
    this._isRemovable = isRemovable;
    this._pendingValidators = [];
    this._onValidatorStatusChanged = this._onValidatorStatusChanged.bind(this);
    this._resetValidationInfo();
    this._eventsStrategy = new EventsStrategy(this);
  }
  validate() {
    const result2 = {
      isValid: true,
      brokenRules: [],
      validators: [],
      status: STATUS.valid,
      complete: null
    };
    this._unsubscribeFromAllChangeEvents();
    this._pendingValidators = [];
    this._resetValidationInfo();
    each(this.validators, (_, validator) => {
      const validatorResult = validator.validate();
      result2.isValid = result2.isValid && validatorResult.isValid;
      if (validatorResult.brokenRules) {
        result2.brokenRules = result2.brokenRules.concat(validatorResult.brokenRules);
      }
      result2.validators.push(validator);
      if (validatorResult.status === STATUS.pending) {
        this._addPendingValidator(validator);
      }
      this._subscribeToChangeEvents(validator);
    });
    if (this._pendingValidators.length) {
      result2.status = STATUS.pending;
    } else {
      result2.status = result2.isValid ? STATUS.valid : STATUS.invalid;
      this._unsubscribeFromAllChangeEvents();
      this._raiseValidatedEvent(result2);
    }
    this._updateValidationInfo(result2);
    return extend({}, this._validationInfo.result);
  }
  _subscribeToChangeEvents(validator) {
    validator.on("validating", this._onValidatorStatusChanged);
    validator.on("validated", this._onValidatorStatusChanged);
  }
  _unsubscribeFromChangeEvents(validator) {
    validator.off("validating", this._onValidatorStatusChanged);
    validator.off("validated", this._onValidatorStatusChanged);
  }
  _unsubscribeFromAllChangeEvents() {
    each(this.validators, (_, validator) => {
      this._unsubscribeFromChangeEvents(validator);
    });
  }
  _updateValidationInfo(result2) {
    this._validationInfo.result = result2;
    if (result2.status !== STATUS.pending) {
      return;
    }
    if (!this._validationInfo.deferred) {
      this._validationInfo.deferred = Deferred();
      this._validationInfo.result.complete = this._validationInfo.deferred.promise();
    }
  }
  _addPendingValidator(validator) {
    const foundValidator = grep(this._pendingValidators, (val) => val === validator)[0];
    if (!foundValidator) {
      this._pendingValidators.push(validator);
    }
  }
  _removePendingValidator(validator) {
    const index2 = this._pendingValidators.indexOf(validator);
    if (index2 >= 0) {
      this._pendingValidators.splice(index2, 1);
    }
  }
  _orderBrokenRules(brokenRules) {
    let orderedRules = [];
    each(this.validators, (_, validator) => {
      const foundRules = grep(brokenRules, (rule) => rule.validator === validator);
      if (foundRules.length) {
        orderedRules = orderedRules.concat(foundRules);
      }
    });
    return orderedRules;
  }
  _updateBrokenRules(result2) {
    if (!this._validationInfo.result) {
      return;
    }
    let {
      brokenRules
    } = this._validationInfo.result;
    const rules = grep(brokenRules, (rule) => rule.validator !== result2.validator);
    if (result2.brokenRules) {
      brokenRules = rules.concat(result2.brokenRules);
    }
    this._validationInfo.result.brokenRules = this._orderBrokenRules(brokenRules);
  }
  _onValidatorStatusChanged(result2) {
    if (result2.status === STATUS.pending) {
      this._addPendingValidator(result2.validator);
      return;
    }
    this._resolveIfComplete(result2);
  }
  _resolveIfComplete(result2) {
    this._removePendingValidator(result2.validator);
    this._updateBrokenRules(result2);
    if (!this._pendingValidators.length) {
      this._unsubscribeFromAllChangeEvents();
      if (!this._validationInfo.result) {
        return;
      }
      this._validationInfo.result.status = 0 === this._validationInfo.result.brokenRules.length ? STATUS.valid : STATUS.invalid;
      this._validationInfo.result.isValid = this._validationInfo.result.status === STATUS.valid;
      const res = extend({}, this._validationInfo.result, {
        complete: null
      });
      const {
        deferred
      } = this._validationInfo;
      this._validationInfo.deferred = null;
      this._raiseValidatedEvent(res);
      deferred && setTimeout(() => {
        deferred.resolve(res);
      });
    }
  }
  _raiseValidatedEvent(result2) {
    this._eventsStrategy.fireEvent("validated", [result2]);
  }
  _resetValidationInfo() {
    this._validationInfo = {
      result: null,
      deferred: null
    };
  }
  _synchronizeValidationInfo() {
    if (this._validationInfo.result) {
      this._validationInfo.result.validators = this.validators;
    }
  }
  removeRegisteredValidator(validator) {
    const index2 = this.validators.indexOf(validator);
    if (index2 > -1) {
      this.validators.splice(index2, 1);
      this._synchronizeValidationInfo();
      this._resolveIfComplete({
        validator
      });
    }
  }
  registerValidator(validator) {
    if (!this.validators.includes(validator)) {
      this.validators.push(validator);
      this._synchronizeValidationInfo();
    }
  }
  reset() {
    each(this.validators, (_, validator) => {
      validator.reset();
    });
    this._pendingValidators = [];
    this._resetValidationInfo();
  }
  on(eventName, eventHandler) {
    this._eventsStrategy.on(eventName, eventHandler);
    return this;
  }
  off(eventName, eventHandler) {
    this._eventsStrategy.off(eventName, eventHandler);
    return this;
  }
};
var ValidationEngine = {
  groups: [],
  getGroupConfig(group) {
    const result2 = grep(this.groups, (config3) => config3.group === group);
    if (result2.length) {
      return result2[0];
    }
  },
  findGroup($element, model) {
    var _$element$data;
    const hasValidationGroup = null === (_$element$data = $element.data()) || void 0 === _$element$data || null === (_$element$data = _$element$data.dxComponents) || void 0 === _$element$data ? void 0 : _$element$data.includes("dxValidationGroup");
    const validationGroup = hasValidationGroup && $element.dxValidationGroup("instance");
    if (validationGroup) {
      return validationGroup;
    }
    const $dxGroup = $element.parents(".dx-validationgroup").first();
    if ($dxGroup.length) {
      return $dxGroup.dxValidationGroup("instance");
    }
    return model;
  },
  initGroups() {
    this.groups = [];
    this.addGroup(void 0, false);
  },
  addGroup(group) {
    let isRemovable = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : true;
    let config3 = this.getGroupConfig(group);
    if (!config3) {
      config3 = new GroupConfig(group, isRemovable);
      this.groups.push(config3);
    }
    return config3;
  },
  removeGroup(group) {
    const config3 = this.getGroupConfig(group);
    const index2 = this.groups.indexOf(config3);
    if (index2 > -1) {
      this.groups.splice(index2, 1);
    }
    return config3;
  },
  _setDefaultMessage(info) {
    const {
      rule,
      validator,
      name: name2
    } = info;
    if (!isDefined(rule.message)) {
      if (validator.defaultFormattedMessage && isDefined(name2)) {
        rule.message = validator.defaultFormattedMessage(name2);
      } else {
        rule.message = validator.defaultMessage();
      }
    }
  },
  _addBrokenRule(info) {
    const {
      result: result2,
      rule
    } = info;
    if (!result2.brokenRule) {
      result2.brokenRule = rule;
    }
    if (!result2.brokenRules) {
      result2.brokenRules = [];
    }
    result2.brokenRules.push(rule);
  },
  validate(value2, rules, name2) {
    var _rules$;
    let result2 = {
      name: name2,
      value: value2,
      brokenRule: null,
      brokenRules: null,
      isValid: true,
      validationRules: rules,
      pendingRules: null,
      status: STATUS.valid,
      complete: null
    };
    const validator = null === rules || void 0 === rules || null === (_rules$ = rules[0]) || void 0 === _rules$ ? void 0 : _rules$.validator;
    const asyncRuleItems = [];
    each(rules || [], (_, rule) => {
      const ruleValidator = rulesValidators[rule.type];
      let ruleValidationResult;
      if (ruleValidator) {
        if (isDefined(rule.isValid) && rule.value === value2 && !rule.reevaluate) {
          if (!rule.isValid) {
            result2.isValid = false;
            this._addBrokenRule({
              result: result2,
              rule
            });
            return false;
          }
          return true;
        }
        rule.value = value2;
        if ("async" === rule.type) {
          asyncRuleItems.push({
            rule,
            ruleValidator
          });
          return true;
        }
        ruleValidationResult = ruleValidator.validate(value2, rule);
        rule.isValid = ruleValidationResult;
        if (!ruleValidationResult) {
          result2.isValid = false;
          this._setDefaultMessage({
            rule,
            validator: ruleValidator,
            name: name2
          });
          this._addBrokenRule({
            result: result2,
            rule
          });
        }
        if (!rule.isValid) {
          return false;
        }
      } else {
        throw errors_default.Error("E0100");
      }
    });
    if (result2.isValid && !result2.brokenRules && asyncRuleItems.length) {
      result2 = this._validateAsyncRules({
        value: value2,
        items: asyncRuleItems,
        result: result2,
        name: name2
      });
    }
    this._synchronizeGroupValidationInfo(validator, result2);
    result2.status = result2.pendingRules ? STATUS.pending : result2.isValid ? STATUS.valid : STATUS.invalid;
    return result2;
  },
  _synchronizeGroupValidationInfo(validator, result2) {
    if (!validator) {
      return;
    }
    const groupConfig = ValidationEngine.getGroupConfig(validator._validationGroup);
    groupConfig._updateBrokenRules.call(groupConfig, {
      validator,
      brokenRules: result2.brokenRules ?? []
    });
  },
  _validateAsyncRules(_ref) {
    let {
      result: result2,
      value: value2,
      items,
      name: name2
    } = _ref;
    const asyncResults = [];
    each(items, (_, item) => {
      const validateResult = item.ruleValidator.validate(value2, item.rule);
      if (!isPromise(validateResult)) {
        this._updateRuleConfig({
          rule: item.rule,
          ruleResult: this._getPatchedRuleResult(validateResult),
          validator: item.ruleValidator,
          name: name2
        });
      } else {
        if (!result2.pendingRules) {
          result2.pendingRules = [];
        }
        result2.pendingRules.push(item.rule);
        const asyncResult = validateResult.then((res) => {
          const ruleResult = this._getPatchedRuleResult(res);
          this._updateRuleConfig({
            rule: item.rule,
            ruleResult,
            validator: item.ruleValidator,
            name: name2
          });
          return ruleResult;
        });
        asyncResults.push(asyncResult);
      }
    });
    if (asyncResults.length) {
      result2.complete = Promise.all(asyncResults).then((values) => this._getAsyncRulesResult({
        result: result2,
        values
      }));
    }
    return result2;
  },
  _updateRuleConfig(_ref2) {
    let {
      rule,
      ruleResult,
      validator,
      name: name2
    } = _ref2;
    rule.isValid = ruleResult.isValid;
    if (!ruleResult.isValid) {
      if (isDefined(ruleResult.message) && isString(ruleResult.message) && ruleResult.message.length) {
        rule.message = ruleResult.message;
      } else {
        this._setDefaultMessage({
          rule,
          validator,
          name: name2
        });
      }
    }
  },
  _getPatchedRuleResult(ruleResult) {
    let result2;
    if (isObject(ruleResult)) {
      result2 = extend({}, ruleResult);
      if (!isDefined(result2.isValid)) {
        result2.isValid = true;
      }
    } else {
      result2 = {
        isValid: isBoolean(ruleResult) ? ruleResult : true
      };
    }
    return result2;
  },
  _getAsyncRulesResult(_ref3) {
    let {
      values,
      result: result2
    } = _ref3;
    each(values, (index2, val) => {
      if (false === val.isValid) {
        result2.isValid = val.isValid;
        const rule = result2.pendingRules[index2];
        this._addBrokenRule({
          result: result2,
          rule
        });
      }
    });
    result2.pendingRules = null;
    result2.complete = null;
    result2.status = result2.isValid ? STATUS.valid : STATUS.invalid;
    return result2;
  },
  registerValidatorInGroup(group, validator) {
    const groupConfig = ValidationEngine.addGroup(group);
    groupConfig.registerValidator.call(groupConfig, validator);
  },
  removeRegisteredValidator(group, validator) {
    const config3 = ValidationEngine.getGroupConfig(group);
    if (config3) {
      config3.removeRegisteredValidator.call(config3, validator);
      const validatorsInGroup = config3.validators;
      const isRemovable = config3._isRemovable;
      const shouldRemoveGroup = 0 === validatorsInGroup.length && isRemovable;
      if (shouldRemoveGroup) {
        this.removeGroup(group);
      }
    }
  },
  initValidationOptions(options2) {
    const initedOptions = {};
    if (options2) {
      const syncOptions = ["isValid", "validationStatus", "validationError", "validationErrors"];
      syncOptions.forEach((prop) => {
        if (prop in options2) {
          extend(initedOptions, this.synchronizeValidationOptions({
            name: prop,
            value: options2[prop]
          }, options2));
        }
      });
    }
    return initedOptions;
  },
  synchronizeValidationOptions(_ref4, options2) {
    let {
      name: name2,
      value: value2
    } = _ref4;
    switch (name2) {
      case "validationStatus": {
        const isValid = value2 === STATUS.valid || value2 === STATUS.pending;
        return options2.isValid !== isValid ? {
          isValid
        } : {};
      }
      case "isValid": {
        const {
          validationStatus
        } = options2;
        let newStatus = validationStatus;
        if (value2 && validationStatus === STATUS.invalid) {
          newStatus = STATUS.valid;
        } else if (!value2 && validationStatus !== STATUS.invalid) {
          newStatus = STATUS.invalid;
        }
        return newStatus !== validationStatus ? {
          validationStatus: newStatus
        } : {};
      }
      case "validationErrors": {
        const validationError = !(null !== value2 && void 0 !== value2 && value2.length) ? null : value2[0];
        return options2.validationError !== validationError ? {
          validationError
        } : {};
      }
      case "validationError": {
        const {
          validationErrors
        } = options2;
        if (!value2 && validationErrors) {
          return {
            validationErrors: null
          };
        }
        if (value2 && !validationErrors) {
          return {
            validationErrors: [value2]
          };
        }
        if (value2 && validationErrors && value2 !== validationErrors[0]) {
          validationErrors[0] = value2;
          return {
            validationErrors: validationErrors.slice()
          };
        }
      }
    }
    return {};
  },
  validateGroup(group) {
    const groupConfig = ValidationEngine.getGroupConfig(group);
    if (!groupConfig) {
      throw errors_default.Error("E0110");
    }
    return groupConfig.validate();
  },
  resetGroup(group) {
    const groupConfig = ValidationEngine.getGroupConfig(group);
    if (!groupConfig) {
      throw errors_default.Error("E0110");
    }
    return groupConfig.reset();
  }
};
ValidationEngine.initGroups();
var m_validation_engine_default = ValidationEngine;

// node_modules/devextreme/esm/ui/validation_engine.js
var validation_engine_default = m_validation_engine_default;

// node_modules/devextreme/esm/__internal/ui/m_validation_message.js
var INVALID_MESSAGE = "dx-invalid-message";
var INVALID_MESSAGE_AUTO = "dx-invalid-message-auto";
var INVALID_MESSAGE_ALWAYS = "dx-invalid-message-always";
var INVALID_MESSAGE_CONTENT = "dx-invalid-message-content";
var ValidationMessage = class extends m_overlay_default {
  _getDefaultOptions() {
    return _extends({}, super._getDefaultOptions(), {
      integrationOptions: {},
      templatesRenderAsynchronously: false,
      shading: false,
      width: "auto",
      height: "auto",
      hideOnOutsideClick: false,
      animation: null,
      visible: true,
      propagateOutsideClick: true,
      _checkParentVisibility: false,
      rtlEnabled: false,
      contentTemplate: this._renderInnerHtml,
      maxWidth: "100%",
      container: this.$element(),
      mode: "auto",
      preventScrollEvents: false,
      positionSide: "top",
      offset: {
        h: 0,
        v: 0
      }
    });
  }
  _init() {
    super._init();
    this.updateMaxWidth();
    this._updatePosition();
  }
  _initMarkup() {
    super._initMarkup();
    this._ensureMessageNotEmpty();
    this._updatePositionByTarget();
    this._toggleModeClass();
    this._updateContentId();
  }
  _updatePositionByTarget() {
    const {
      target
    } = this.option();
    this.option("position.of", target);
  }
  _ensureMessageNotEmpty() {
    this._textMarkup = this._getTextMarkup();
    const shouldShowMessage = this.option("visible") && this._textMarkup;
    this._toggleVisibilityClasses(shouldShowMessage);
  }
  _toggleVisibilityClasses(visible2) {
    if (visible2) {
      this.$element().addClass(INVALID_MESSAGE);
      this.$wrapper().addClass(INVALID_MESSAGE);
    } else {
      this.$element().removeClass(INVALID_MESSAGE);
      this.$wrapper().removeClass(INVALID_MESSAGE);
    }
  }
  _updateContentId() {
    const {
      container,
      contentId
    } = this.option();
    const id = contentId ?? renderer_default(container).attr("aria-describedby");
    this.$content().addClass(INVALID_MESSAGE_CONTENT).attr("id", id);
  }
  _renderInnerHtml(element) {
    const $element = element && renderer_default(element);
    null === $element || void 0 === $element || $element.html(this._textMarkup);
  }
  _getTextMarkup() {
    const validationErrors = this.option("validationErrors") ?? [];
    let validationErrorMessage = "";
    validationErrors.forEach((err) => {
      const separator = validationErrorMessage ? "<br />" : "";
      validationErrorMessage += separator + encodeHtml((null === err || void 0 === err ? void 0 : err.message) ?? "");
    });
    return validationErrorMessage;
  }
  _toggleModeClass() {
    const {
      mode
    } = this.option();
    this.$wrapper().toggleClass(INVALID_MESSAGE_AUTO, "auto" === mode).toggleClass(INVALID_MESSAGE_ALWAYS, "always" === mode);
  }
  updateMaxWidth() {
    const target = this.option("target");
    const targetWidth = getOuterWidth(target);
    let maxWidth = "100%";
    if (targetWidth) {
      maxWidth = Math.max(targetWidth, 100);
    }
    this.option({
      maxWidth
    });
  }
  _getPositionsArray(positionSide, rtlSide) {
    switch (positionSide) {
      case "top":
        return [`${rtlSide} bottom`, `${rtlSide} top`];
      case "left":
        return ["right", "left"];
      case "right":
        return ["left", "right"];
      default:
        return [`${rtlSide} top`, `${rtlSide} bottom`];
    }
  }
  _updatePosition() {
    const {
      positionSide,
      rtlEnabled,
      offset: componentOffset,
      boundary
    } = this.option();
    const rtlSide = getDefaultAlignment(rtlEnabled);
    const positions = this._getPositionsArray(positionSide, rtlSide);
    const offset2 = _extends({}, componentOffset);
    this.$element().addClass(`dx-invalid-message-${positionSide}`);
    if (rtlEnabled && "left" !== positionSide && "right" !== positionSide) {
      offset2.h = -offset2.h;
    }
    if ("top" === positionSide) {
      offset2.v = -offset2.v;
    }
    if ("left" === positionSide) {
      offset2.h = -offset2.h;
    }
    this.option("position", {
      offset: offset2,
      boundary,
      my: positions[0],
      at: positions[1],
      collision: "none flip"
    });
  }
  _optionChanged(args) {
    const {
      name: name2,
      value: value2,
      previousValue
    } = args;
    switch (name2) {
      case "target":
        this._updatePositionByTarget();
        this.updateMaxWidth();
        super._optionChanged(args);
        break;
      case "boundary":
        this.option("position.boundary", value2);
        break;
      case "mode":
        this._toggleModeClass();
        break;
      case "rtlEnabled":
      case "offset":
      case "positionSide":
        this.$element().removeClass(`dx-invalid-message-${previousValue}`);
        this._updatePosition();
        break;
      case "container":
        this._updateContentId();
        super._optionChanged(args);
        break;
      case "contentId":
        this._updateContentId();
        break;
      case "validationErrors":
        this._ensureMessageNotEmpty();
        this._renderInnerHtml(this.$content());
        break;
      default:
        super._optionChanged(args);
    }
  }
};
component_registrator_default("dxValidationMessage", ValidationMessage);
var m_validation_message_default = ValidationMessage;

// node_modules/devextreme/esm/ui/validation_message.js
var validation_message_default = m_validation_message_default;

// node_modules/devextreme/esm/__internal/ui/editor/editor.js
var INVALID_MESSAGE_AUTO2 = "dx-invalid-message-auto";
var DX_INVALID_BADGE_CLASS = "dx-show-invalid-badge";
var VALIDATION_TARGET = "dx-validation-target";
var ALLOWED_STYLING_MODES = ["outlined", "filled", "underlined"];
var VALIDATION_MESSAGE_KEYS_MAP = {
  validationMessageMode: "mode",
  validationMessagePosition: "positionSide",
  validationMessageOffset: "offset",
  validationBoundary: "boundary"
};
var Editor = class extends widget_default {
  ctor(element, options2) {
    this.showValidationMessageTimeout = void 0;
    this.validationRequest = callbacks_default();
    super.ctor(element, options2);
  }
  _createElement(element) {
    super._createElement(element);
    const $element = this.$element();
    if ($element) {
      data($element[0], VALIDATION_TARGET, this);
    }
  }
  _initOptions(options2) {
    super._initOptions(options2);
    this.option(validation_engine_default.initValidationOptions(options2));
  }
  _init() {
    this._initialValue = this.option("value");
    super._init();
    const {
      validationTooltipOptions
    } = this.option();
    this._options.cache("validationTooltipOptions", validationTooltipOptions);
    const $element = this.$element();
    $element.addClass(DX_INVALID_BADGE_CLASS);
  }
  _getDefaultOptions() {
    return _extends({}, super._getDefaultOptions(), {
      value: null,
      name: "",
      onValueChanged: null,
      readOnly: false,
      isValid: true,
      validationError: null,
      validationErrors: null,
      validationStatus: "valid",
      validationMessageMode: "auto",
      validationMessagePosition: "bottom",
      validationBoundary: void 0,
      validationMessageOffset: {
        h: 0,
        v: 0
      },
      validationTooltipOptions: {},
      _showValidationMessage: true,
      isDirty: false
    });
  }
  _shouldAttachKeyboardEvents() {
    const {
      readOnly
    } = this.option();
    return !readOnly;
  }
  _attachKeyboardEvents() {
    if (this._shouldAttachKeyboardEvents()) {
      super._attachKeyboardEvents();
    }
  }
  _setOptionsByReference() {
    super._setOptionsByReference();
    extend(this._optionsByReference, {
      validationError: true
    });
  }
  _createValueChangeAction() {
    this._valueChangeAction = this._createActionByOption("onValueChanged", {
      excludeValidators: ["disabled", "readOnly"]
    });
  }
  _suppressValueChangeAction() {
    this._valueChangeActionSuppressed = true;
  }
  _resumeValueChangeAction() {
    this._valueChangeActionSuppressed = false;
  }
  _initMarkup() {
    this._toggleReadOnlyState();
    const {
      name: name2,
      _onMarkupRendered: markupRendered
    } = this.option();
    this._setSubmitElementName(name2);
    super._initMarkup();
    this._renderValidationState();
    null === markupRendered || void 0 === markupRendered || markupRendered();
  }
  _raiseValueChangeAction(value2, previousValue) {
    if (!this._valueChangeAction) {
      this._createValueChangeAction();
    }
    this._valueChangeAction(this._valueChangeArgs(value2, previousValue));
  }
  _valueChangeArgs(value2, previousValue) {
    return {
      value: value2,
      previousValue,
      event: this._valueChangeEventInstance
    };
  }
  _saveValueChangeEvent(e) {
    this._valueChangeEventInstance = e;
  }
  _focusInHandler(e) {
    const {
      validationMessageMode
    } = this.option();
    const isValidationMessageShownOnFocus = "auto" === validationMessageMode;
    if (this._canValueBeChangedByClick() && isValidationMessageShownOnFocus) {
      var _this$_validationMess;
      const $validationMessageWrapper = null === (_this$_validationMess = this._validationMessage) || void 0 === _this$_validationMess ? void 0 : _this$_validationMess.$wrapper();
      null === $validationMessageWrapper || void 0 === $validationMessageWrapper || $validationMessageWrapper.removeClass(INVALID_MESSAGE_AUTO2);
      clearTimeout(this.showValidationMessageTimeout);
      this.showValidationMessageTimeout = setTimeout(() => null === $validationMessageWrapper || void 0 === $validationMessageWrapper ? void 0 : $validationMessageWrapper.addClass(INVALID_MESSAGE_AUTO2), 150);
    }
    super._focusInHandler(e);
  }
  _canValueBeChangedByClick() {
    return false;
  }
  _getStylingModePrefix() {
    return "dx-editor-";
  }
  _renderStylingMode() {
    const {
      stylingMode
    } = this.option();
    const prefix = this._getStylingModePrefix();
    const allowedStylingClasses = ALLOWED_STYLING_MODES.map((mode) => prefix + mode);
    allowedStylingClasses.forEach((className) => this.$element().removeClass(className));
    let stylingModeClass = prefix + String(stylingMode);
    if (!allowedStylingClasses.includes(stylingModeClass)) {
      const optionName = "stylingMode";
      const defaultOptionValue = this._getDefaultOptions()[optionName];
      const platformOptionValue = this._convertRulesToOptions(this._defaultOptionsRules())[optionName];
      stylingModeClass = prefix + (platformOptionValue ?? defaultOptionValue);
    }
    this.$element().addClass(stylingModeClass);
  }
  _getValidationErrors() {
    let {
      validationErrors
    } = this.option();
    const {
      validationError
    } = this.option();
    if (!validationErrors && validationError) {
      validationErrors = [validationError];
    }
    return validationErrors;
  }
  _disposeValidationMessage() {
    if (this._$validationMessage) {
      this._$validationMessage.remove();
      this.setAria("describedby", null);
      this._$validationMessage = void 0;
      this._validationMessage = void 0;
    }
  }
  _toggleValidationClasses(isInvalid3) {
    this.$element().toggleClass("dx-invalid", isInvalid3);
    this.setAria("invalid", isInvalid3 || void 0);
  }
  _renderValidationState() {
    const {
      validationStatus,
      _showValidationMessage: showValidationMessage
    } = this.option();
    const isValid = this.option("isValid") && "invalid" !== validationStatus;
    const validationErrors = this._getValidationErrors();
    const $element = this.$element();
    this._toggleValidationClasses(!isValid);
    if (!hasWindow() || !showValidationMessage) {
      return;
    }
    this._disposeValidationMessage();
    if (!isValid && validationErrors) {
      const {
        validationMessageMode,
        validationMessageOffset,
        validationBoundary,
        rtlEnabled
      } = this.option();
      this._$validationMessage = renderer_default("<div>").appendTo($element);
      const validationMessageContentId = `dx-${new guid_default2()}`;
      this.setAria("describedby", validationMessageContentId);
      this._validationMessage = new validation_message_default(this._$validationMessage, extend({
        validationErrors,
        rtlEnabled,
        target: this._getValidationMessageTarget(),
        visualContainer: $element,
        mode: validationMessageMode,
        positionSide: this._getValidationMessagePosition(),
        offset: validationMessageOffset,
        boundary: validationBoundary,
        contentId: validationMessageContentId
      }, this._options.cache("validationTooltipOptions")));
      this._bindInnerWidgetOptions(this._validationMessage, "validationTooltipOptions");
    }
  }
  _getValidationMessagePosition() {
    const {
      validationMessagePosition
    } = this.option();
    return validationMessagePosition;
  }
  _getValidationMessageTarget() {
    return this.$element();
  }
  _toggleReadOnlyState() {
    const {
      readOnly
    } = this.option();
    this._toggleBackspaceHandler(readOnly);
    this.$element().toggleClass("dx-state-readonly", !!readOnly);
    this._setAriaReadonly(readOnly);
  }
  _setAriaReadonly(readOnly) {
    this.setAria("readonly", readOnly || void 0);
  }
  _toggleBackspaceHandler(isReadOnly) {
    const $eventTarget = this._keyboardEventBindingTarget();
    const eventName = addNamespace2("keydown", "editorReadOnly");
    m_events_engine_default.off($eventTarget, eventName);
    if (isReadOnly) {
      m_events_engine_default.on($eventTarget, eventName, (e) => {
        if ("backspace" === normalizeKeyName(e)) {
          e.preventDefault();
        }
      });
    }
  }
  _dispose() {
    const element = this.$element()[0];
    data(element, VALIDATION_TARGET, null);
    clearTimeout(this.showValidationMessageTimeout);
    this._disposeValidationMessage();
    super._dispose();
  }
  _setSubmitElementName(name2) {
    const $submitElement = this._getSubmitElement();
    if (!$submitElement) {
      return;
    }
    if (name2 && name2.length > 0) {
      $submitElement.attr("name", name2);
    } else {
      $submitElement.removeAttr("name");
    }
  }
  _getSubmitElement() {
    return null;
  }
  _setValidationMessageOption(_ref) {
    var _this$_validationMess2;
    let {
      name: name2,
      value: value2
    } = _ref;
    const optionKey = VALIDATION_MESSAGE_KEYS_MAP[String(name2)] ? VALIDATION_MESSAGE_KEYS_MAP[String(name2)] : name2;
    null === (_this$_validationMess2 = this._validationMessage) || void 0 === _this$_validationMess2 || _this$_validationMess2.option(optionKey, value2);
  }
  _hasActiveElement() {
    return false;
  }
  _optionChanged(args) {
    var _this$_validationMess3;
    const {
      name: name2,
      value: value2,
      previousValue
    } = args;
    switch (name2) {
      case "onValueChanged":
        this._createValueChangeAction();
        break;
      case "readOnly":
        this._toggleReadOnlyState();
        this._refreshFocusState();
        break;
      case "value":
        if (value2 != previousValue) {
          this.option("isDirty", this._initialValue !== value2);
          this.validationRequest.fire({
            value: value2,
            editor: this
          });
        }
        if (!this._valueChangeActionSuppressed) {
          this._raiseValueChangeAction(value2, previousValue);
          this._saveValueChangeEvent(void 0);
        }
        break;
      case "width":
        super._optionChanged(args);
        null === (_this$_validationMess3 = this._validationMessage) || void 0 === _this$_validationMess3 || _this$_validationMess3.updateMaxWidth();
        break;
      case "name":
        this._setSubmitElementName(value2);
        break;
      case "isValid":
      case "validationError":
      case "validationErrors":
      case "validationStatus":
        this.option(validation_engine_default.synchronizeValidationOptions(args, this.option()));
        this._renderValidationState();
        break;
      case "validationBoundary":
      case "validationMessageMode":
      case "validationMessagePosition":
      case "validationMessageOffset":
        this._setValidationMessageOption(args);
        break;
      case "rtlEnabled":
        this._setValidationMessageOption(args);
        super._optionChanged(args);
        break;
      case "validationTooltipOptions":
        this._innerWidgetOptionChanged(this._validationMessage, args);
        break;
      case "_showValidationMessage":
      case "isDirty":
        break;
      default:
        super._optionChanged(args);
    }
  }
  _resetToInitialValue() {
    this.option("value", this._initialValue);
  }
  blur() {
    if (this._hasActiveElement()) {
      m_dom_default.resetActiveElement();
    }
  }
  clear() {
    const defaultOptions4 = this._getDefaultOptions();
    this.option("value", defaultOptions4.value);
  }
  reset() {
    let value2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : void 0;
    if (arguments.length) {
      this._initialValue = value2;
    }
    this._resetToInitialValue();
    this.option("isDirty", false);
    this.option("isValid", true);
  }
};
Editor.isEditor = (instance) => instance instanceof Editor;
var editor_default = Editor;

// node_modules/devextreme/esm/__internal/ui/text_box/texteditor_button_collection/m_button.js
var TextEditorButton = class {
  constructor(name2, editor, options2) {
    this.instance = null;
    this.$container = null;
    this.$placeMarker = null;
    this.editor = editor;
    this.name = name2;
    this.options = options2 || {};
  }
  _addPlaceMarker($container) {
    this.$placeMarker = renderer_default("<div>").appendTo($container);
  }
  _addToContainer($element) {
    const {
      $placeMarker,
      $container
    } = this;
    if ($placeMarker) {
      $placeMarker.replaceWith($element);
    } else {
      $element.appendTo($container);
    }
  }
  _attachEvents(instance, $element) {
    throw "Not implemented";
  }
  _create() {
    throw "Not implemented";
  }
  _isRendered() {
    return !!this.instance;
  }
  _isVisible() {
    const {
      editor,
      options: options2
    } = this;
    return options2.visible || !editor.option("readOnly");
  }
  _isDisabled() {
    throw "Not implemented";
  }
  _shouldRender() {
    return this._isVisible() && !this._isRendered();
  }
  dispose() {
    const {
      instance,
      $placeMarker
    } = this;
    if (instance) {
      if (instance.dispose) {
        instance.dispose();
      } else {
        instance.remove();
      }
      this.instance = null;
    }
    null === $placeMarker || void 0 === $placeMarker || $placeMarker.remove();
  }
  render() {
    let $container = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.$container;
    this.$container = $container;
    if (this._isVisible()) {
      const {
        instance,
        $element
      } = this._create();
      this.instance = instance;
      this._attachEvents(instance, $element);
    } else {
      this._addPlaceMarker($container);
    }
  }
  update() {
    if (this._shouldRender()) {
      this.render();
    }
    return !!this.instance;
  }
};

// node_modules/devextreme/esm/__internal/ui/text_box/m_text_editor.clear.js
var pointerDown = m_pointer_default.down;
var ClearButton = class extends TextEditorButton {
  _create() {
    const $element = renderer_default("<span>").addClass("dx-clear-button-area").append(renderer_default("<span>").addClass("dx-icon").addClass("dx-icon-clear"));
    this._addToContainer($element);
    this.update(true);
    return {
      instance: $element,
      $element
    };
  }
  _isVisible() {
    const {
      editor
    } = this;
    return editor._isClearButtonVisible();
  }
  _attachEvents(instance, $button) {
    const {
      editor
    } = this;
    const editorName = editor.NAME;
    m_events_engine_default.on($button, addNamespace2(pointerDown, editorName), (e) => {
      e.preventDefault();
      if ("mouse" !== e.pointerType) {
        editor._clearValueHandler(e);
      }
    });
    m_events_engine_default.on($button, addNamespace2(CLICK_EVENT_NAME, editorName), (e) => editor._clearValueHandler(e));
  }
  _legacyRender($editor, isVisible2) {
    $editor.toggleClass("dx-show-clear-button", isVisible2);
  }
  update() {
    let rendered = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : false;
    if (!rendered) {
      super.update();
    }
    const {
      editor,
      instance
    } = this;
    const $editor = editor.$element();
    const isVisible2 = this._isVisible();
    if (instance) {
      instance.toggleClass("dx-state-invisible", !isVisible2);
    }
    this._legacyRender($editor, isVisible2);
  }
};

// node_modules/devextreme/esm/__internal/ui/text_box/m_text_editor.label.js
var TextEditorLabel = class {
  constructor(props) {
    this.NAME = "dxLabel";
    this._props = props;
    this._id = `dx-texteditor-label-${new guid_default2()}`;
    this._render();
    this._toggleMarkupVisibility();
  }
  _isVisible() {
    return !!this._props.text && "hidden" !== this._props.mode;
  }
  _render() {
    this._$before = renderer_default("<div>").addClass("dx-label-before");
    this._$labelSpan = renderer_default("<span>");
    this._$label = renderer_default("<div>").addClass("dx-label").append(this._$labelSpan);
    this._$after = renderer_default("<div>").addClass("dx-label-after");
    this._$root = renderer_default("<div>").addClass("dx-texteditor-label").attr("id", this._id).append(this._$before).append(this._$label).append(this._$after);
    this._updateMark();
    this._updateText();
    this._updateBeforeWidth();
    this._updateMaxWidth();
  }
  _toggleMarkupVisibility() {
    const visible2 = this._isVisible();
    this._updateEditorBeforeButtonsClass(visible2);
    this._updateEditorLabelClass(visible2);
    visible2 ? this._$root.appendTo(this._props.$editor) : this._$root.detach();
    this._attachEvents();
  }
  _attachEvents() {
    const clickEventName = addNamespace2(CLICK_EVENT_NAME, this.NAME);
    const hoverStartEventName = addNamespace2(HOVERSTART, this.NAME);
    const activeEventName = addNamespace2(ACTIVE_EVENT_NAME, this.NAME);
    m_events_engine_default.off(this._$labelSpan, clickEventName);
    m_events_engine_default.off(this._$labelSpan, hoverStartEventName);
    m_events_engine_default.off(this._$labelSpan, activeEventName);
    if (this._isVisible() && this._isOutsideMode()) {
      m_events_engine_default.on(this._$labelSpan, clickEventName, (e) => {
        const selectedText = getWindow().getSelection().toString();
        if ("" === selectedText) {
          this._props.onClickHandler();
          e.preventDefault();
        }
      });
      m_events_engine_default.on(this._$labelSpan, hoverStartEventName, (e) => {
        this._props.onHoverHandler(e);
      });
      m_events_engine_default.on(this._$labelSpan, activeEventName, (e) => {
        this._props.onActiveHandler(e);
      });
    }
  }
  _updateEditorLabelClass(visible2) {
    this._props.$editor.removeClass("dx-texteditor-with-floating-label").removeClass("dx-texteditor-label-outside").removeClass("dx-texteditor-with-label");
    if (visible2) {
      const labelClass = "floating" === this._props.mode ? "dx-texteditor-with-floating-label" : "dx-texteditor-with-label";
      this._props.$editor.addClass(labelClass);
      if (this._isOutsideMode()) {
        this._props.$editor.addClass("dx-texteditor-label-outside");
      }
    }
  }
  _isOutsideMode() {
    return "outside" === this._props.mode;
  }
  _updateEditorBeforeButtonsClass() {
    let visible2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this._isVisible();
    this._props.$editor.removeClass("dx-texteditor-with-before-buttons");
    if (visible2) {
      const beforeButtonsClass = this._props.containsButtonsBefore ? "dx-texteditor-with-before-buttons" : "";
      this._props.$editor.addClass(beforeButtonsClass);
    }
  }
  _updateMark() {
    this._$labelSpan.attr("data-mark", this._props.mark);
  }
  _updateText() {
    this._$labelSpan.text(this._props.text);
  }
  _updateBeforeWidth() {
    if (this._isVisible()) {
      const width = this._props.beforeWidth ?? this._props.getBeforeWidth();
      this._$before.css({
        width
      });
      this._updateLabelTransform();
    }
  }
  _updateLabelTransform() {
    let offset2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0;
    this._$labelSpan.css("transform", "");
    if (this._isVisible() && this._isOutsideMode()) {
      const sign2 = this._props.rtlEnabled ? 1 : -1;
      const labelTranslateX = sign2 * (getWidth(this._$before) + offset2);
      this._$labelSpan.css("transform", `translateX(${labelTranslateX}px)`);
    }
  }
  _updateMaxWidth() {
    if (this._isVisible() && !this._isOutsideMode()) {
      const maxWidth = this._props.containerWidth ?? this._props.getContainerWidth();
      this._$label.css({
        maxWidth
      });
    }
  }
  $element() {
    return this._$root;
  }
  isVisible() {
    return this._isVisible();
  }
  getId() {
    if (this._isVisible()) {
      return this._id;
    }
  }
  updateMode(mode) {
    this._props.mode = mode;
    this._toggleMarkupVisibility();
    this._updateBeforeWidth();
    this._updateMaxWidth();
  }
  updateText(text) {
    this._props.text = text;
    this._updateText();
    this._toggleMarkupVisibility();
    this._updateBeforeWidth();
    this._updateMaxWidth();
  }
  updateMark(mark) {
    this._props.mark = mark;
    this._updateMark();
  }
  updateContainsButtonsBefore(containsButtonsBefore) {
    this._props.containsButtonsBefore = containsButtonsBefore;
    this._updateEditorBeforeButtonsClass();
  }
  updateBeforeWidth(beforeWidth) {
    this._props.beforeWidth = beforeWidth;
    this._updateBeforeWidth();
  }
  updateMaxWidth(containerWidth) {
    this._props.containerWidth = containerWidth;
    this._updateMaxWidth();
  }
};

// node_modules/devextreme/esm/core/dom_component.js
var dom_component_default2 = dom_component_default;

// node_modules/inferno/dist/index.esm.js
var isArray = Array.isArray;
function isStringOrNumber(o) {
  var type2 = typeof o;
  return type2 === "string" || type2 === "number";
}
function isNullOrUndef(o) {
  return o === void 0 || o === null;
}
function isInvalid(o) {
  return o === null || o === false || o === true || o === void 0;
}
function isFunction2(o) {
  return typeof o === "function";
}
function isString2(o) {
  return typeof o === "string";
}
function isNumber(o) {
  return typeof o === "number";
}
function isNull(o) {
  return o === null;
}
function isUndefined(o) {
  return o === void 0;
}
function combineFrom(first, second) {
  var out = {};
  if (first) {
    for (var key in first) {
      out[key] = first[key];
    }
  }
  if (second) {
    for (var _key in second) {
      out[_key] = second[_key];
    }
  }
  return out;
}
function isLinkEventObject(o) {
  return !isNull(o) && typeof o === "object";
}
var EMPTY_OBJ = {};
var Fragment = "$F";
var AnimationQueues = function AnimationQueues2() {
  this.componentDidAppear = [];
  this.componentWillDisappear = [];
  this.componentWillMove = [];
};
function normalizeEventName(name2) {
  return name2.substring(2).toLowerCase();
}
function appendChild(parentDOM, dom) {
  parentDOM.appendChild(dom);
}
function insertOrAppend(parentDOM, newNode, nextNode) {
  if (isNull(nextNode)) {
    appendChild(parentDOM, newNode);
  } else {
    parentDOM.insertBefore(newNode, nextNode);
  }
}
function documentCreateElement(tag, isSVG) {
  if (isSVG) {
    return document.createElementNS("http://www.w3.org/2000/svg", tag);
  }
  return document.createElement(tag);
}
function replaceChild(parentDOM, newDom, lastDom) {
  parentDOM.replaceChild(newDom, lastDom);
}
function removeChild(parentDOM, childNode) {
  parentDOM.removeChild(childNode);
}
function callAll(arrayFn) {
  for (var i = 0; i < arrayFn.length; i++) {
    arrayFn[i]();
  }
}
function findChildVNode(vNode, startEdge, flags) {
  var children = vNode.children;
  if (flags & 4) {
    return children.$LI;
  }
  if (flags & 8192) {
    return vNode.childFlags === 2 ? children : children[startEdge ? 0 : children.length - 1];
  }
  return children;
}
function findDOMFromVNode(vNode, startEdge) {
  var flags;
  while (vNode) {
    flags = vNode.flags;
    if (flags & 1521) {
      return vNode.dom;
    }
    vNode = findChildVNode(vNode, startEdge, flags);
  }
  return null;
}
function callAllAnimationHooks(animationQueue, callback) {
  var animationsLeft = animationQueue.length;
  var fn;
  while ((fn = animationQueue.pop()) !== void 0) {
    fn(function() {
      if (--animationsLeft <= 0 && isFunction2(callback)) {
        callback();
      }
    });
  }
}
function callAllMoveAnimationHooks(animationQueue) {
  for (var i = 0; i < animationQueue.length; i++) {
    animationQueue[i].fn();
  }
  for (var _i = 0; _i < animationQueue.length; _i++) {
    var tmp = animationQueue[_i];
    insertOrAppend(tmp.parent, tmp.dom, tmp.next);
  }
  animationQueue.splice(0, animationQueue.length);
}
function clearVNodeDOM(vNode, parentDOM, deferredRemoval) {
  do {
    var flags = vNode.flags;
    if (flags & 1521) {
      if (!deferredRemoval || vNode.dom.parentNode === parentDOM) {
        removeChild(parentDOM, vNode.dom);
      }
      return;
    }
    var children = vNode.children;
    if (flags & 4) {
      vNode = children.$LI;
    }
    if (flags & 8) {
      vNode = children;
    }
    if (flags & 8192) {
      if (vNode.childFlags === 2) {
        vNode = children;
      } else {
        for (var i = 0, len = children.length; i < len; ++i) {
          clearVNodeDOM(children[i], parentDOM, false);
        }
        return;
      }
    }
  } while (vNode);
}
function createDeferComponentClassRemovalCallback(vNode, parentDOM) {
  return function() {
    clearVNodeDOM(vNode, parentDOM, true);
  };
}
function removeVNodeDOM(vNode, parentDOM, animations) {
  if (animations.componentWillDisappear.length > 0) {
    callAllAnimationHooks(animations.componentWillDisappear, createDeferComponentClassRemovalCallback(vNode, parentDOM));
  } else {
    clearVNodeDOM(vNode, parentDOM, false);
  }
}
function addMoveAnimationHook(animations, parentVNode, refOrInstance, dom, parentDOM, nextNode, flags, props) {
  animations.componentWillMove.push({
    dom,
    fn: function fn() {
      if (flags & 4) {
        refOrInstance.componentWillMove(parentVNode, parentDOM, dom);
      } else if (flags & 8) {
        refOrInstance.onComponentWillMove(parentVNode, parentDOM, dom, props);
      }
    },
    next: nextNode,
    parent: parentDOM
  });
}
function moveVNodeDOM(parentVNode, vNode, parentDOM, nextNode, animations) {
  var refOrInstance;
  var instanceProps;
  var instanceFlags = vNode.flags;
  do {
    var flags = vNode.flags;
    if (flags & 1521) {
      if (!isNullOrUndef(refOrInstance) && (isFunction2(refOrInstance.componentWillMove) || isFunction2(refOrInstance.onComponentWillMove))) {
        addMoveAnimationHook(animations, parentVNode, refOrInstance, vNode.dom, parentDOM, nextNode, instanceFlags, instanceProps);
      } else {
        insertOrAppend(parentDOM, vNode.dom, nextNode);
      }
      return;
    }
    var children = vNode.children;
    if (flags & 4) {
      refOrInstance = vNode.children;
      instanceProps = vNode.props;
      vNode = children.$LI;
    } else if (flags & 8) {
      refOrInstance = vNode.ref;
      instanceProps = vNode.props;
      vNode = children;
    } else if (flags & 8192) {
      if (vNode.childFlags === 2) {
        vNode = children;
      } else {
        for (var i = 0, len = children.length; i < len; ++i) {
          moveVNodeDOM(parentVNode, children[i], parentDOM, nextNode, animations);
        }
        return;
      }
    }
  } while (vNode);
}
function createDerivedState(instance, nextProps, state) {
  if (instance.constructor.getDerivedStateFromProps) {
    return combineFrom(state, instance.constructor.getDerivedStateFromProps(nextProps, state));
  }
  return state;
}
var renderCheck = {
  v: false
};
var options = {
  componentComparator: null,
  createVNode: null,
  renderComplete: null
};
function setTextContent(dom, children) {
  dom.textContent = children;
}
function isLastValueSameLinkEvent(lastValue, nextValue) {
  return isLinkEventObject(lastValue) && lastValue.event === nextValue.event && lastValue.data === nextValue.data;
}
function mergeUnsetProperties(to, from) {
  for (var propName in from) {
    if (isUndefined(to[propName])) {
      to[propName] = from[propName];
    }
  }
  return to;
}
function safeCall1(method, arg1) {
  return !!isFunction2(method) && (method(arg1), true);
}
var keyPrefix = "$";
function V(childFlags, children, className, flags, key, props, ref, type2) {
  this.childFlags = childFlags;
  this.children = children;
  this.className = className;
  this.dom = null;
  this.flags = flags;
  this.key = key === void 0 ? null : key;
  this.props = props === void 0 ? null : props;
  this.ref = ref === void 0 ? null : ref;
  this.type = type2;
}
function createVNode(flags, type2, className, children, childFlags, props, key, ref) {
  var childFlag = childFlags === void 0 ? 1 : childFlags;
  var vNode = new V(childFlag, children, className, flags, key, props, ref, type2);
  if (options.createVNode) {
    options.createVNode(vNode);
  }
  if (childFlag === 0) {
    normalizeChildren(vNode, vNode.children);
  }
  return vNode;
}
function mergeDefaultHooks(flags, type2, ref) {
  if (flags & 4) {
    return ref;
  }
  var defaultHooks = (flags & 32768 ? type2.render : type2).defaultHooks;
  if (isNullOrUndef(defaultHooks)) {
    return ref;
  }
  if (isNullOrUndef(ref)) {
    return defaultHooks;
  }
  return mergeUnsetProperties(ref, defaultHooks);
}
function mergeDefaultProps(flags, type2, props) {
  var defaultProps = (flags & 32768 ? type2.render : type2).defaultProps;
  if (isNullOrUndef(defaultProps)) {
    return props;
  }
  if (isNullOrUndef(props)) {
    return combineFrom(defaultProps, null);
  }
  return mergeUnsetProperties(props, defaultProps);
}
function resolveComponentFlags(flags, type2) {
  if (flags & 12) {
    return flags;
  }
  if (type2.prototype && type2.prototype.render) {
    return 4;
  }
  if (type2.render) {
    return 32776;
  }
  return 8;
}
function createComponentVNode(flags, type2, props, key, ref) {
  flags = resolveComponentFlags(flags, type2);
  var vNode = new V(1, null, null, flags, key, mergeDefaultProps(flags, type2, props), mergeDefaultHooks(flags, type2, ref), type2);
  if (options.createVNode) {
    options.createVNode(vNode);
  }
  return vNode;
}
function createTextVNode(text, key) {
  return new V(1, isNullOrUndef(text) || text === true || text === false ? "" : text, null, 16, key, null, null, null);
}
function createFragment(children, childFlags, key) {
  var fragment = createVNode(8192, 8192, null, children, childFlags, null, key, null);
  switch (fragment.childFlags) {
    case 1:
      fragment.children = createVoidVNode();
      fragment.childFlags = 2;
      break;
    case 16:
      fragment.children = [createTextVNode(children)];
      fragment.childFlags = 4;
      break;
  }
  return fragment;
}
function normalizeProps(vNode) {
  var props = vNode.props;
  if (props) {
    var flags = vNode.flags;
    if (flags & 481) {
      if (props.children !== void 0 && isNullOrUndef(vNode.children)) {
        normalizeChildren(vNode, props.children);
      }
      if (props.className !== void 0) {
        if (isNullOrUndef(vNode.className)) {
          vNode.className = props.className || null;
        }
        props.className = void 0;
      }
    }
    if (props.key !== void 0) {
      vNode.key = props.key;
      props.key = void 0;
    }
    if (props.ref !== void 0) {
      if (flags & 8) {
        vNode.ref = combineFrom(vNode.ref, props.ref);
      } else {
        vNode.ref = props.ref;
      }
      props.ref = void 0;
    }
  }
  return vNode;
}
function cloneFragment(vNodeToClone) {
  var oldChildren = vNodeToClone.children;
  var childFlags = vNodeToClone.childFlags;
  return createFragment(childFlags === 2 ? directClone(oldChildren) : oldChildren.map(directClone), childFlags, vNodeToClone.key);
}
function directClone(vNodeToClone) {
  var flags = vNodeToClone.flags & -16385;
  var props = vNodeToClone.props;
  if (flags & 14) {
    if (!isNull(props)) {
      var propsToClone = props;
      props = {};
      for (var key in propsToClone) {
        props[key] = propsToClone[key];
      }
    }
  }
  if ((flags & 8192) === 0) {
    return new V(vNodeToClone.childFlags, vNodeToClone.children, vNodeToClone.className, flags, vNodeToClone.key, props, vNodeToClone.ref, vNodeToClone.type);
  }
  return cloneFragment(vNodeToClone);
}
function createVoidVNode() {
  return createTextVNode("", null);
}
function _normalizeVNodes(nodes, result2, index2, currentKey) {
  for (var len = nodes.length; index2 < len; index2++) {
    var n = nodes[index2];
    if (!isInvalid(n)) {
      var newKey = currentKey + keyPrefix + index2;
      if (isArray(n)) {
        _normalizeVNodes(n, result2, 0, newKey);
      } else {
        if (isStringOrNumber(n)) {
          n = createTextVNode(n, newKey);
        } else {
          var oldKey = n.key;
          var isPrefixedKey = isString2(oldKey) && oldKey[0] === keyPrefix;
          if (n.flags & 81920 || isPrefixedKey) {
            n = directClone(n);
          }
          n.flags |= 65536;
          if (!isPrefixedKey) {
            if (isNull(oldKey)) {
              n.key = newKey;
            } else {
              n.key = currentKey + oldKey;
            }
          } else if (oldKey.substring(0, currentKey.length) !== currentKey) {
            n.key = currentKey + oldKey;
          }
        }
        result2.push(n);
      }
    }
  }
}
function getFlagsForElementVnode(type2) {
  switch (type2) {
    case "svg":
      return 32;
    case "input":
      return 64;
    case "select":
      return 256;
    case "textarea":
      return 128;
    // @ts-ignore
    case Fragment:
      return 8192;
    default:
      return 1;
  }
}
function normalizeChildren(vNode, children) {
  var newChildren;
  var newChildFlags = 1;
  if (isInvalid(children)) {
    newChildren = children;
  } else if (isStringOrNumber(children)) {
    newChildFlags = 16;
    newChildren = children;
  } else if (isArray(children)) {
    var len = children.length;
    for (var i = 0; i < len; ++i) {
      var n = children[i];
      if (isInvalid(n) || isArray(n)) {
        newChildren = newChildren || children.slice(0, i);
        _normalizeVNodes(children, newChildren, i, "");
        break;
      } else if (isStringOrNumber(n)) {
        newChildren = newChildren || children.slice(0, i);
        newChildren.push(createTextVNode(n, keyPrefix + i));
      } else {
        var key = n.key;
        var needsCloning = (n.flags & 81920) > 0;
        var isNullKey = isNull(key);
        var isPrefixed = isString2(key) && key[0] === keyPrefix;
        if (needsCloning || isNullKey || isPrefixed) {
          newChildren = newChildren || children.slice(0, i);
          if (needsCloning || isPrefixed) {
            n = directClone(n);
          }
          if (isNullKey || isPrefixed) {
            n.key = keyPrefix + i;
          }
          newChildren.push(n);
        } else if (newChildren) {
          newChildren.push(n);
        }
        n.flags |= 65536;
      }
    }
    newChildren = newChildren || children;
    if (newChildren.length === 0) {
      newChildFlags = 1;
    } else {
      newChildFlags = 8;
    }
  } else {
    newChildren = children;
    newChildren.flags |= 65536;
    if (children.flags & 81920) {
      newChildren = directClone(children);
    }
    newChildFlags = 2;
  }
  vNode.children = newChildren;
  vNode.childFlags = newChildFlags;
  return vNode;
}
function normalizeRoot(input) {
  if (isInvalid(input) || isStringOrNumber(input)) {
    return createTextVNode(input, null);
  }
  if (isArray(input)) {
    return createFragment(input, 0, null);
  }
  return input.flags & 16384 ? directClone(input) : input;
}
var xlinkNS = "http://www.w3.org/1999/xlink";
var xmlNS = "http://www.w3.org/XML/1998/namespace";
var namespaces = {
  "xlink:actuate": xlinkNS,
  "xlink:arcrole": xlinkNS,
  "xlink:href": xlinkNS,
  "xlink:role": xlinkNS,
  "xlink:show": xlinkNS,
  "xlink:title": xlinkNS,
  "xlink:type": xlinkNS,
  "xml:base": xmlNS,
  "xml:lang": xmlNS,
  "xml:space": xmlNS
};
function getDelegatedEventObject(v) {
  return {
    onClick: v,
    onDblClick: v,
    onFocusIn: v,
    onFocusOut: v,
    onKeyDown: v,
    onKeyPress: v,
    onKeyUp: v,
    onMouseDown: v,
    onMouseMove: v,
    onMouseUp: v,
    onTouchEnd: v,
    onTouchMove: v,
    onTouchStart: v
  };
}
var attachedEventCounts = getDelegatedEventObject(0);
var attachedEvents = getDelegatedEventObject(null);
var syntheticEvents = getDelegatedEventObject(true);
function updateOrAddSyntheticEvent(name2, dom) {
  var eventsObject = dom.$EV;
  if (!eventsObject) {
    eventsObject = dom.$EV = getDelegatedEventObject(null);
  }
  if (!eventsObject[name2]) {
    if (++attachedEventCounts[name2] === 1) {
      attachedEvents[name2] = attachEventToDocument(name2);
    }
  }
  return eventsObject;
}
function unmountSyntheticEvent(name2, dom) {
  var eventsObject = dom.$EV;
  if (eventsObject && eventsObject[name2]) {
    if (--attachedEventCounts[name2] === 0) {
      document.removeEventListener(normalizeEventName(name2), attachedEvents[name2]);
      attachedEvents[name2] = null;
    }
    eventsObject[name2] = null;
  }
}
function handleSyntheticEvent(name2, lastEvent, nextEvent, dom) {
  if (isFunction2(nextEvent)) {
    updateOrAddSyntheticEvent(name2, dom)[name2] = nextEvent;
  } else if (isLinkEventObject(nextEvent)) {
    if (isLastValueSameLinkEvent(lastEvent, nextEvent)) {
      return;
    }
    updateOrAddSyntheticEvent(name2, dom)[name2] = nextEvent;
  } else {
    unmountSyntheticEvent(name2, dom);
  }
}
function getTargetNode(event) {
  return isFunction2(event.composedPath) ? event.composedPath()[0] : event.target;
}
function dispatchEvents(event, isClick, name2, eventData2) {
  var dom = getTargetNode(event);
  do {
    if (isClick && dom.disabled) {
      return;
    }
    var eventsObject = dom.$EV;
    if (eventsObject) {
      var currentEvent = eventsObject[name2];
      if (currentEvent) {
        eventData2.dom = dom;
        currentEvent.event ? currentEvent.event(currentEvent.data, event) : currentEvent(event);
        if (event.cancelBubble) {
          return;
        }
      }
    }
    dom = dom.parentNode;
  } while (!isNull(dom));
}
function stopPropagation() {
  this.cancelBubble = true;
  if (!this.immediatePropagationStopped) {
    this.stopImmediatePropagation();
  }
}
function isDefaultPrevented() {
  return this.defaultPrevented;
}
function isPropagationStopped() {
  return this.cancelBubble;
}
function extendEventProperties(event) {
  var eventData2 = {
    dom: document
  };
  event.isDefaultPrevented = isDefaultPrevented;
  event.isPropagationStopped = isPropagationStopped;
  event.stopPropagation = stopPropagation;
  Object.defineProperty(event, "currentTarget", {
    configurable: true,
    get: function get() {
      return eventData2.dom;
    }
  });
  return eventData2;
}
function rootClickEvent(name2) {
  return function(event) {
    if (event.button !== 0) {
      event.stopPropagation();
      return;
    }
    dispatchEvents(event, true, name2, extendEventProperties(event));
  };
}
function rootEvent(name2) {
  return function(event) {
    dispatchEvents(event, false, name2, extendEventProperties(event));
  };
}
function attachEventToDocument(name2) {
  var attachedEvent = name2 === "onClick" || name2 === "onDblClick" ? rootClickEvent(name2) : rootEvent(name2);
  document.addEventListener(normalizeEventName(name2), attachedEvent);
  return attachedEvent;
}
function isSameInnerHTML(dom, innerHTML) {
  var tempdom = document.createElement("i");
  tempdom.innerHTML = innerHTML;
  return tempdom.innerHTML === dom.innerHTML;
}
function triggerEventListener(props, methodName, e) {
  if (props[methodName]) {
    var listener = props[methodName];
    if (listener.event) {
      listener.event(listener.data, e);
    } else {
      listener(e);
    }
  } else {
    var nativeListenerName = methodName.toLowerCase();
    if (props[nativeListenerName]) {
      props[nativeListenerName](e);
    }
  }
}
function createWrappedFunction(methodName, applyValue) {
  var fnMethod = function fnMethod2(e) {
    var vNode = this.$V;
    if (!vNode) {
      return;
    }
    var props = vNode.props || EMPTY_OBJ;
    var dom = vNode.dom;
    if (isString2(methodName)) {
      triggerEventListener(props, methodName, e);
    } else {
      for (var i = 0; i < methodName.length; ++i) {
        triggerEventListener(props, methodName[i], e);
      }
    }
    if (isFunction2(applyValue)) {
      var newVNode = this.$V;
      var newProps = newVNode.props || EMPTY_OBJ;
      applyValue(newProps, dom, false, newVNode);
    }
  };
  Object.defineProperty(fnMethod, "wrapped", {
    configurable: false,
    enumerable: false,
    value: true,
    writable: false
  });
  return fnMethod;
}
function attachEvent(dom, eventName, handler) {
  var previousKey = "$" + eventName;
  var previousArgs = dom[previousKey];
  if (previousArgs) {
    if (previousArgs[1].wrapped) {
      return;
    }
    dom.removeEventListener(previousArgs[0], previousArgs[1]);
    dom[previousKey] = null;
  }
  if (isFunction2(handler)) {
    dom.addEventListener(eventName, handler);
    dom[previousKey] = [eventName, handler];
  }
}
function isCheckedType(type2) {
  return type2 === "checkbox" || type2 === "radio";
}
var onTextInputChange = createWrappedFunction("onInput", applyValueInput);
var wrappedOnChange$1 = createWrappedFunction(["onClick", "onChange"], applyValueInput);
function emptywrapper(event) {
  event.stopPropagation();
}
emptywrapper.wrapped = true;
function inputEvents(dom, nextPropsOrEmpty) {
  if (isCheckedType(nextPropsOrEmpty.type)) {
    attachEvent(dom, "change", wrappedOnChange$1);
    attachEvent(dom, "click", emptywrapper);
  } else {
    attachEvent(dom, "input", onTextInputChange);
  }
}
function applyValueInput(nextPropsOrEmpty, dom) {
  var type2 = nextPropsOrEmpty.type;
  var value2 = nextPropsOrEmpty.value;
  var checked = nextPropsOrEmpty.checked;
  var multiple = nextPropsOrEmpty.multiple;
  var defaultValue = nextPropsOrEmpty.defaultValue;
  var hasValue = !isNullOrUndef(value2);
  if (type2 && type2 !== dom.type) {
    dom.setAttribute("type", type2);
  }
  if (!isNullOrUndef(multiple) && multiple !== dom.multiple) {
    dom.multiple = multiple;
  }
  if (!isNullOrUndef(defaultValue) && !hasValue) {
    dom.defaultValue = defaultValue + "";
  }
  if (isCheckedType(type2)) {
    if (hasValue) {
      dom.value = value2;
    }
    if (!isNullOrUndef(checked)) {
      dom.checked = checked;
    }
  } else {
    if (hasValue && dom.value !== value2) {
      dom.defaultValue = value2;
      dom.value = value2;
    } else if (!isNullOrUndef(checked)) {
      dom.checked = checked;
    }
  }
}
function updateChildOptions(vNode, value2) {
  if (vNode.type === "option") {
    updateChildOption(vNode, value2);
  } else {
    var children = vNode.children;
    var flags = vNode.flags;
    if (flags & 4) {
      updateChildOptions(children.$LI, value2);
    } else if (flags & 8) {
      updateChildOptions(children, value2);
    } else if (vNode.childFlags === 2) {
      updateChildOptions(children, value2);
    } else if (vNode.childFlags & 12) {
      for (var i = 0, len = children.length; i < len; ++i) {
        updateChildOptions(children[i], value2);
      }
    }
  }
}
function updateChildOption(vNode, value2) {
  var props = vNode.props || EMPTY_OBJ;
  var dom = vNode.dom;
  dom.value = props.value;
  if (props.value === value2 || isArray(value2) && value2.indexOf(props.value) !== -1) {
    dom.selected = true;
  } else if (!isNullOrUndef(value2) || !isNullOrUndef(props.selected)) {
    dom.selected = props.selected || false;
  }
}
var onSelectChange = createWrappedFunction("onChange", applyValueSelect);
function selectEvents(dom) {
  attachEvent(dom, "change", onSelectChange);
}
function applyValueSelect(nextPropsOrEmpty, dom, mounting, vNode) {
  var multiplePropInBoolean = Boolean(nextPropsOrEmpty.multiple);
  if (!isNullOrUndef(nextPropsOrEmpty.multiple) && multiplePropInBoolean !== dom.multiple) {
    dom.multiple = multiplePropInBoolean;
  }
  var index2 = nextPropsOrEmpty.selectedIndex;
  if (index2 === -1) {
    dom.selectedIndex = -1;
  }
  var childFlags = vNode.childFlags;
  if (childFlags !== 1) {
    var value2 = nextPropsOrEmpty.value;
    if (isNumber(index2) && index2 > -1 && dom.options[index2]) {
      value2 = dom.options[index2].value;
    }
    if (mounting && isNullOrUndef(value2)) {
      value2 = nextPropsOrEmpty.defaultValue;
    }
    updateChildOptions(vNode, value2);
  }
}
var onTextareaInputChange = createWrappedFunction("onInput", applyValueTextArea);
var wrappedOnChange = createWrappedFunction("onChange");
function textAreaEvents(dom, nextPropsOrEmpty) {
  attachEvent(dom, "input", onTextareaInputChange);
  if (nextPropsOrEmpty.onChange) {
    attachEvent(dom, "change", wrappedOnChange);
  }
}
function applyValueTextArea(nextPropsOrEmpty, dom, mounting) {
  var value2 = nextPropsOrEmpty.value;
  var domValue = dom.value;
  if (isNullOrUndef(value2)) {
    if (mounting) {
      var defaultValue = nextPropsOrEmpty.defaultValue;
      if (!isNullOrUndef(defaultValue) && defaultValue !== domValue) {
        dom.defaultValue = defaultValue;
        dom.value = defaultValue;
      }
    }
  } else if (domValue !== value2) {
    dom.defaultValue = value2;
    dom.value = value2;
  }
}
function processElement(flags, vNode, dom, nextPropsOrEmpty, mounting, isControlled) {
  if (flags & 64) {
    applyValueInput(nextPropsOrEmpty, dom);
  } else if (flags & 256) {
    applyValueSelect(nextPropsOrEmpty, dom, mounting, vNode);
  } else if (flags & 128) {
    applyValueTextArea(nextPropsOrEmpty, dom, mounting);
  }
  if (isControlled) {
    dom.$V = vNode;
  }
}
function addFormElementEventHandlers(flags, dom, nextPropsOrEmpty) {
  if (flags & 64) {
    inputEvents(dom, nextPropsOrEmpty);
  } else if (flags & 256) {
    selectEvents(dom);
  } else if (flags & 128) {
    textAreaEvents(dom, nextPropsOrEmpty);
  }
}
function isControlledFormElement(nextPropsOrEmpty) {
  return nextPropsOrEmpty.type && isCheckedType(nextPropsOrEmpty.type) ? !isNullOrUndef(nextPropsOrEmpty.checked) : !isNullOrUndef(nextPropsOrEmpty.value);
}
function createRef() {
  return {
    current: null
  };
}
function unmountRef(ref) {
  if (ref) {
    if (!safeCall1(ref, null) && ref.current) {
      ref.current = null;
    }
  }
}
function mountRef(ref, value2, lifecycle) {
  if (ref && (isFunction2(ref) || ref.current !== void 0)) {
    lifecycle.push(function() {
      if (!safeCall1(ref, value2) && ref.current !== void 0) {
        ref.current = value2;
      }
    });
  }
}
function remove3(vNode, parentDOM, animations) {
  unmount(vNode, animations);
  removeVNodeDOM(vNode, parentDOM, animations);
}
function unmount(vNode, animations) {
  var flags = vNode.flags;
  var children = vNode.children;
  var ref;
  if (flags & 481) {
    ref = vNode.ref;
    var props = vNode.props;
    unmountRef(ref);
    var childFlags = vNode.childFlags;
    if (!isNull(props)) {
      var keys = Object.keys(props);
      for (var i = 0, len = keys.length; i < len; i++) {
        var key = keys[i];
        if (syntheticEvents[key]) {
          unmountSyntheticEvent(key, vNode.dom);
        }
      }
    }
    if (childFlags & 12) {
      unmountAllChildren(children, animations);
    } else if (childFlags === 2) {
      unmount(children, animations);
    }
  } else if (children) {
    if (flags & 4) {
      if (isFunction2(children.componentWillUnmount)) {
        children.componentWillUnmount();
      }
      var childAnimations = animations;
      if (isFunction2(children.componentWillDisappear)) {
        childAnimations = new AnimationQueues();
        addDisappearAnimationHook(animations, children, children.$LI.dom, flags, void 0);
      }
      unmountRef(vNode.ref);
      children.$UN = true;
      unmount(children.$LI, childAnimations);
    } else if (flags & 8) {
      var _childAnimations = animations;
      ref = vNode.ref;
      if (!isNullOrUndef(ref)) {
        var domEl = null;
        if (isFunction2(ref.onComponentWillUnmount)) {
          domEl = findDOMFromVNode(vNode, true);
          ref.onComponentWillUnmount(domEl, vNode.props || EMPTY_OBJ);
        }
        if (isFunction2(ref.onComponentWillDisappear)) {
          _childAnimations = new AnimationQueues();
          domEl = domEl || findDOMFromVNode(vNode, true);
          addDisappearAnimationHook(animations, ref, domEl, flags, vNode.props);
        }
      }
      unmount(children, _childAnimations);
    } else if (flags & 1024) {
      remove3(children, vNode.ref, animations);
    } else if (flags & 8192) {
      if (vNode.childFlags & 12) {
        unmountAllChildren(children, animations);
      }
    }
  }
}
function unmountAllChildren(children, animations) {
  for (var i = 0, len = children.length; i < len; ++i) {
    unmount(children[i], animations);
  }
}
function createClearAllCallback(children, parentDOM) {
  return function() {
    if (parentDOM) {
      for (var i = 0; i < children.length; i++) {
        var vNode = children[i];
        clearVNodeDOM(vNode, parentDOM, false);
      }
    }
  };
}
function clearDOM(parentDOM, children, animations) {
  if (animations.componentWillDisappear.length > 0) {
    callAllAnimationHooks(animations.componentWillDisappear, createClearAllCallback(children, parentDOM));
  } else {
    parentDOM.textContent = "";
  }
}
function removeAllChildren(dom, vNode, children, animations) {
  unmountAllChildren(children, animations);
  if (vNode.flags & 8192) {
    removeVNodeDOM(vNode, dom, animations);
  } else {
    clearDOM(dom, children, animations);
  }
}
function addDisappearAnimationHook(animations, instanceOrRef, dom, flags, props) {
  animations.componentWillDisappear.push(function(callback) {
    if (flags & 4) {
      instanceOrRef.componentWillDisappear(dom, callback);
    } else if (flags & 8) {
      instanceOrRef.onComponentWillDisappear(dom, props, callback);
    }
  });
}
function wrapLinkEvent(nextValue) {
  var ev = nextValue.event;
  return function(e) {
    ev(nextValue.data, e);
  };
}
function patchEvent(name2, lastValue, nextValue, dom) {
  if (isLinkEventObject(nextValue)) {
    if (isLastValueSameLinkEvent(lastValue, nextValue)) {
      return;
    }
    nextValue = wrapLinkEvent(nextValue);
  }
  attachEvent(dom, normalizeEventName(name2), nextValue);
}
function patchStyle(lastAttrValue, nextAttrValue, dom) {
  if (isNullOrUndef(nextAttrValue)) {
    dom.removeAttribute("style");
    return;
  }
  var domStyle = dom.style;
  var style;
  var value2;
  if (isString2(nextAttrValue)) {
    domStyle.cssText = nextAttrValue;
    return;
  }
  if (!isNullOrUndef(lastAttrValue) && !isString2(lastAttrValue)) {
    for (style in nextAttrValue) {
      value2 = nextAttrValue[style];
      if (value2 !== lastAttrValue[style]) {
        domStyle.setProperty(style, value2);
      }
    }
    for (style in lastAttrValue) {
      if (isNullOrUndef(nextAttrValue[style])) {
        domStyle.removeProperty(style);
      }
    }
  } else {
    for (style in nextAttrValue) {
      value2 = nextAttrValue[style];
      domStyle.setProperty(style, value2);
    }
  }
}
function patchDangerInnerHTML(lastValue, nextValue, lastVNode, dom, animations) {
  var lastHtml = lastValue && lastValue.__html || "";
  var nextHtml = nextValue && nextValue.__html || "";
  if (lastHtml !== nextHtml) {
    if (!isNullOrUndef(nextHtml) && !isSameInnerHTML(dom, nextHtml)) {
      if (!isNull(lastVNode)) {
        if (lastVNode.childFlags & 12) {
          unmountAllChildren(lastVNode.children, animations);
        } else if (lastVNode.childFlags === 2) {
          unmount(lastVNode.children, animations);
        }
        lastVNode.children = null;
        lastVNode.childFlags = 1;
      }
      dom.innerHTML = nextHtml;
    }
  }
}
function patchProp(prop, lastValue, nextValue, dom, isSVG, hasControlledValue, lastVNode, animations) {
  switch (prop) {
    case "children":
    case "childrenType":
    case "className":
    case "defaultValue":
    case "key":
    case "multiple":
    case "ref":
    case "selectedIndex":
      break;
    case "autoFocus":
      dom.autofocus = !!nextValue;
      break;
    case "allowfullscreen":
    case "autoplay":
    case "capture":
    case "checked":
    case "controls":
    case "default":
    case "disabled":
    case "hidden":
    case "indeterminate":
    case "loop":
    case "muted":
    case "novalidate":
    case "open":
    case "readOnly":
    case "required":
    case "reversed":
    case "scoped":
    case "seamless":
    case "selected":
      dom[prop] = !!nextValue;
      break;
    case "defaultChecked":
    case "value":
    case "volume":
      if (hasControlledValue && prop === "value") {
        break;
      }
      var value2 = isNullOrUndef(nextValue) ? "" : nextValue;
      if (dom[prop] !== value2) {
        dom[prop] = value2;
      }
      break;
    case "style":
      patchStyle(lastValue, nextValue, dom);
      break;
    case "dangerouslySetInnerHTML":
      patchDangerInnerHTML(lastValue, nextValue, lastVNode, dom, animations);
      break;
    default:
      if (syntheticEvents[prop]) {
        handleSyntheticEvent(prop, lastValue, nextValue, dom);
      } else if (prop.charCodeAt(0) === 111 && prop.charCodeAt(1) === 110) {
        patchEvent(prop, lastValue, nextValue, dom);
      } else if (isNullOrUndef(nextValue)) {
        dom.removeAttribute(prop);
      } else if (isSVG && namespaces[prop]) {
        dom.setAttributeNS(namespaces[prop], prop, nextValue);
      } else {
        dom.setAttribute(prop, nextValue);
      }
      break;
  }
}
function mountProps(vNode, flags, props, dom, isSVG, animations) {
  var hasControlledValue = false;
  var isFormElement = (flags & 448) > 0;
  if (isFormElement) {
    hasControlledValue = isControlledFormElement(props);
    if (hasControlledValue) {
      addFormElementEventHandlers(flags, dom, props);
    }
  }
  for (var prop in props) {
    patchProp(prop, null, props[prop], dom, isSVG, hasControlledValue, null, animations);
  }
  if (isFormElement) {
    processElement(flags, vNode, dom, props, true, hasControlledValue);
  }
}
function renderNewInput(instance, props, context2) {
  var nextInput = normalizeRoot(instance.render(props, instance.state, context2));
  var childContext = context2;
  if (isFunction2(instance.getChildContext)) {
    childContext = combineFrom(context2, instance.getChildContext());
  }
  instance.$CX = childContext;
  return nextInput;
}
function createClassComponentInstance(vNode, Component3, props, context2, isSVG, lifecycle) {
  var instance = new Component3(props, context2);
  var usesNewAPI = instance.$N = Boolean(Component3.getDerivedStateFromProps || instance.getSnapshotBeforeUpdate);
  instance.$SVG = isSVG;
  instance.$L = lifecycle;
  vNode.children = instance;
  instance.$BS = false;
  instance.context = context2;
  if (instance.props === EMPTY_OBJ) {
    instance.props = props;
  }
  if (!usesNewAPI) {
    if (isFunction2(instance.componentWillMount)) {
      instance.$BR = true;
      instance.componentWillMount();
      var pending = instance.$PS;
      if (!isNull(pending)) {
        var state = instance.state;
        if (isNull(state)) {
          instance.state = pending;
        } else {
          for (var key in pending) {
            state[key] = pending[key];
          }
        }
        instance.$PS = null;
      }
      instance.$BR = false;
    }
  } else {
    instance.state = createDerivedState(instance, props, instance.state);
  }
  instance.$LI = renderNewInput(instance, props, context2);
  return instance;
}
function renderFunctionalComponent(vNode, context2) {
  var props = vNode.props || EMPTY_OBJ;
  return vNode.flags & 32768 ? vNode.type.render(props, vNode.ref, context2) : vNode.type(props, context2);
}
function mount2(vNode, parentDOM, context2, isSVG, nextNode, lifecycle, animations) {
  var flags = vNode.flags |= 16384;
  if (flags & 481) {
    mountElement(vNode, parentDOM, context2, isSVG, nextNode, lifecycle, animations);
  } else if (flags & 4) {
    mountClassComponent(vNode, parentDOM, context2, isSVG, nextNode, lifecycle, animations);
  } else if (flags & 8) {
    mountFunctionalComponent(vNode, parentDOM, context2, isSVG, nextNode, lifecycle, animations);
  } else if (flags & 16) {
    mountText(vNode, parentDOM, nextNode);
  } else if (flags & 8192) {
    mountFragment(vNode, context2, parentDOM, isSVG, nextNode, lifecycle, animations);
  } else if (flags & 1024) {
    mountPortal(vNode, context2, parentDOM, nextNode, lifecycle, animations);
  } else ;
}
function mountPortal(vNode, context2, parentDOM, nextNode, lifecycle, animations) {
  mount2(vNode.children, vNode.ref, context2, false, null, lifecycle, animations);
  var placeHolderVNode = createVoidVNode();
  mountText(placeHolderVNode, parentDOM, nextNode);
  vNode.dom = placeHolderVNode.dom;
}
function mountFragment(vNode, context2, parentDOM, isSVG, nextNode, lifecycle, animations) {
  var children = vNode.children;
  var childFlags = vNode.childFlags;
  if (childFlags & 12 && children.length === 0) {
    childFlags = vNode.childFlags = 2;
    children = vNode.children = createVoidVNode();
  }
  if (childFlags === 2) {
    mount2(children, parentDOM, context2, isSVG, nextNode, lifecycle, animations);
  } else {
    mountArrayChildren(children, parentDOM, context2, isSVG, nextNode, lifecycle, animations);
  }
}
function mountText(vNode, parentDOM, nextNode) {
  var dom = vNode.dom = document.createTextNode(vNode.children);
  if (!isNull(parentDOM)) {
    insertOrAppend(parentDOM, dom, nextNode);
  }
}
function mountElement(vNode, parentDOM, context2, isSVG, nextNode, lifecycle, animations) {
  var flags = vNode.flags;
  var props = vNode.props;
  var className = vNode.className;
  var childFlags = vNode.childFlags;
  var dom = vNode.dom = documentCreateElement(vNode.type, isSVG = isSVG || (flags & 32) > 0);
  var children = vNode.children;
  if (!isNullOrUndef(className) && className !== "") {
    if (isSVG) {
      dom.setAttribute("class", className);
    } else {
      dom.className = className;
    }
  }
  if (childFlags === 16) {
    setTextContent(dom, children);
  } else if (childFlags !== 1) {
    var childrenIsSVG = isSVG && vNode.type !== "foreignObject";
    if (childFlags === 2) {
      if (children.flags & 16384) {
        vNode.children = children = directClone(children);
      }
      mount2(children, dom, context2, childrenIsSVG, null, lifecycle, animations);
    } else if (childFlags === 8 || childFlags === 4) {
      mountArrayChildren(children, dom, context2, childrenIsSVG, null, lifecycle, animations);
    }
  }
  if (!isNull(parentDOM)) {
    insertOrAppend(parentDOM, dom, nextNode);
  }
  if (!isNull(props)) {
    mountProps(vNode, flags, props, dom, isSVG, animations);
  }
  mountRef(vNode.ref, dom, lifecycle);
}
function mountArrayChildren(children, dom, context2, isSVG, nextNode, lifecycle, animations) {
  for (var i = 0; i < children.length; ++i) {
    var child = children[i];
    if (child.flags & 16384) {
      children[i] = child = directClone(child);
    }
    mount2(child, dom, context2, isSVG, nextNode, lifecycle, animations);
  }
}
function mountClassComponent(vNode, parentDOM, context2, isSVG, nextNode, lifecycle, animations) {
  var instance = createClassComponentInstance(vNode, vNode.type, vNode.props || EMPTY_OBJ, context2, isSVG, lifecycle);
  var childAnimations = animations;
  if (isFunction2(instance.componentDidAppear)) {
    childAnimations = new AnimationQueues();
  }
  mount2(instance.$LI, parentDOM, instance.$CX, isSVG, nextNode, lifecycle, childAnimations);
  mountClassComponentCallbacks(vNode.ref, instance, lifecycle, animations);
}
function mountFunctionalComponent(vNode, parentDOM, context2, isSVG, nextNode, lifecycle, animations) {
  var ref = vNode.ref;
  var childAnimations = animations;
  if (!isNullOrUndef(ref) && isFunction2(ref.onComponentDidAppear)) {
    childAnimations = new AnimationQueues();
  }
  mount2(vNode.children = normalizeRoot(renderFunctionalComponent(vNode, context2)), parentDOM, context2, isSVG, nextNode, lifecycle, childAnimations);
  mountFunctionalComponentCallbacks(vNode, lifecycle, animations);
}
function createClassMountCallback(instance) {
  return function() {
    instance.componentDidMount();
  };
}
function addAppearAnimationHook(animations, instanceOrRef, dom, flags, props) {
  animations.componentDidAppear.push(function() {
    if (flags & 4) {
      instanceOrRef.componentDidAppear(dom);
    } else if (flags & 8) {
      instanceOrRef.onComponentDidAppear(dom, props);
    }
  });
}
function mountClassComponentCallbacks(ref, instance, lifecycle, animations) {
  mountRef(ref, instance, lifecycle);
  if (isFunction2(instance.componentDidMount)) {
    lifecycle.push(createClassMountCallback(instance));
  }
  if (isFunction2(instance.componentDidAppear)) {
    addAppearAnimationHook(animations, instance, instance.$LI.dom, 4, void 0);
  }
}
function createOnMountCallback(ref, vNode) {
  return function() {
    ref.onComponentDidMount(findDOMFromVNode(vNode, true), vNode.props || EMPTY_OBJ);
  };
}
function mountFunctionalComponentCallbacks(vNode, lifecycle, animations) {
  var ref = vNode.ref;
  if (!isNullOrUndef(ref)) {
    safeCall1(ref.onComponentWillMount, vNode.props || EMPTY_OBJ);
    if (isFunction2(ref.onComponentDidMount)) {
      lifecycle.push(createOnMountCallback(ref, vNode));
    }
    if (isFunction2(ref.onComponentDidAppear)) {
      addAppearAnimationHook(animations, ref, findDOMFromVNode(vNode, true), 8, vNode.props);
    }
  }
}
function replaceWithNewNode(lastVNode, nextVNode, parentDOM, context2, isSVG, lifecycle, animations) {
  unmount(lastVNode, animations);
  if ((nextVNode.flags & lastVNode.flags & 1521) !== 0) {
    mount2(nextVNode, null, context2, isSVG, null, lifecycle, animations);
    replaceChild(parentDOM, nextVNode.dom, lastVNode.dom);
  } else {
    mount2(nextVNode, parentDOM, context2, isSVG, findDOMFromVNode(lastVNode, true), lifecycle, animations);
    removeVNodeDOM(lastVNode, parentDOM, animations);
  }
}
function patch(lastVNode, nextVNode, parentDOM, context2, isSVG, nextNode, lifecycle, animations) {
  var nextFlags = nextVNode.flags |= 16384;
  if (lastVNode.flags !== nextFlags || lastVNode.type !== nextVNode.type || lastVNode.key !== nextVNode.key || nextFlags & 2048) {
    if (lastVNode.flags & 16384) {
      replaceWithNewNode(lastVNode, nextVNode, parentDOM, context2, isSVG, lifecycle, animations);
    } else {
      mount2(nextVNode, parentDOM, context2, isSVG, nextNode, lifecycle, animations);
    }
  } else if (nextFlags & 481) {
    patchElement(lastVNode, nextVNode, context2, isSVG, nextFlags, lifecycle, animations);
  } else if (nextFlags & 4) {
    patchClassComponent(lastVNode, nextVNode, parentDOM, context2, isSVG, nextNode, lifecycle, animations);
  } else if (nextFlags & 8) {
    patchFunctionalComponent(lastVNode, nextVNode, parentDOM, context2, isSVG, nextNode, lifecycle, animations);
  } else if (nextFlags & 16) {
    patchText(lastVNode, nextVNode);
  } else if (nextFlags & 8192) {
    patchFragment(lastVNode, nextVNode, parentDOM, context2, isSVG, lifecycle, animations);
  } else {
    patchPortal(lastVNode, nextVNode, context2, lifecycle, animations);
  }
}
function patchSingleTextChild(lastChildren, nextChildren, parentDOM) {
  if (lastChildren !== nextChildren) {
    if (lastChildren !== "") {
      parentDOM.firstChild.nodeValue = nextChildren;
    } else {
      setTextContent(parentDOM, nextChildren);
    }
  }
}
function patchContentEditableChildren(dom, nextChildren) {
  if (dom.textContent !== nextChildren) {
    dom.textContent = nextChildren;
  }
}
function patchFragment(lastVNode, nextVNode, parentDOM, context2, isSVG, lifecycle, animations) {
  var lastChildren = lastVNode.children;
  var nextChildren = nextVNode.children;
  var lastChildFlags = lastVNode.childFlags;
  var nextChildFlags = nextVNode.childFlags;
  var nextNode = null;
  if (nextChildFlags & 12 && nextChildren.length === 0) {
    nextChildFlags = nextVNode.childFlags = 2;
    nextChildren = nextVNode.children = createVoidVNode();
  }
  var nextIsSingle = (nextChildFlags & 2) !== 0;
  if (lastChildFlags & 12) {
    var lastLen = lastChildren.length;
    if (
      // It uses keyed algorithm
      lastChildFlags & 8 && nextChildFlags & 8 || // It transforms from many to single
      nextIsSingle || // It will append more nodes
      !nextIsSingle && nextChildren.length > lastLen
    ) {
      nextNode = findDOMFromVNode(lastChildren[lastLen - 1], false).nextSibling;
    }
  }
  patchChildren(lastChildFlags, nextChildFlags, lastChildren, nextChildren, parentDOM, context2, isSVG, nextNode, lastVNode, lifecycle, animations);
}
function patchPortal(lastVNode, nextVNode, context2, lifecycle, animations) {
  var lastContainer = lastVNode.ref;
  var nextContainer = nextVNode.ref;
  var nextChildren = nextVNode.children;
  patchChildren(lastVNode.childFlags, nextVNode.childFlags, lastVNode.children, nextChildren, lastContainer, context2, false, null, lastVNode, lifecycle, animations);
  nextVNode.dom = lastVNode.dom;
  if (lastContainer !== nextContainer && !isInvalid(nextChildren)) {
    var node = nextChildren.dom;
    removeChild(lastContainer, node);
    appendChild(nextContainer, node);
  }
}
function patchElement(lastVNode, nextVNode, context2, isSVG, nextFlags, lifecycle, animations) {
  var dom = nextVNode.dom = lastVNode.dom;
  var lastProps = lastVNode.props;
  var nextProps = nextVNode.props;
  var isFormElement = false;
  var hasControlledValue = false;
  var nextPropsOrEmpty;
  isSVG = isSVG || (nextFlags & 32) > 0;
  if (lastProps !== nextProps) {
    var lastPropsOrEmpty = lastProps || EMPTY_OBJ;
    nextPropsOrEmpty = nextProps || EMPTY_OBJ;
    if (nextPropsOrEmpty !== EMPTY_OBJ) {
      isFormElement = (nextFlags & 448) > 0;
      if (isFormElement) {
        hasControlledValue = isControlledFormElement(nextPropsOrEmpty);
      }
      for (var prop in nextPropsOrEmpty) {
        var lastValue = lastPropsOrEmpty[prop];
        var nextValue = nextPropsOrEmpty[prop];
        if (lastValue !== nextValue) {
          patchProp(prop, lastValue, nextValue, dom, isSVG, hasControlledValue, lastVNode, animations);
        }
      }
    }
    if (lastPropsOrEmpty !== EMPTY_OBJ) {
      for (var _prop in lastPropsOrEmpty) {
        if (isNullOrUndef(nextPropsOrEmpty[_prop]) && !isNullOrUndef(lastPropsOrEmpty[_prop])) {
          patchProp(_prop, lastPropsOrEmpty[_prop], null, dom, isSVG, hasControlledValue, lastVNode, animations);
        }
      }
    }
  }
  var nextChildren = nextVNode.children;
  var nextClassName = nextVNode.className;
  if (lastVNode.className !== nextClassName) {
    if (isNullOrUndef(nextClassName)) {
      dom.removeAttribute("class");
    } else if (isSVG) {
      dom.setAttribute("class", nextClassName);
    } else {
      dom.className = nextClassName;
    }
  }
  if (nextFlags & 4096) {
    patchContentEditableChildren(dom, nextChildren);
  } else {
    patchChildren(lastVNode.childFlags, nextVNode.childFlags, lastVNode.children, nextChildren, dom, context2, isSVG && nextVNode.type !== "foreignObject", null, lastVNode, lifecycle, animations);
  }
  if (isFormElement) {
    processElement(nextFlags, nextVNode, dom, nextPropsOrEmpty, false, hasControlledValue);
  }
  var nextRef = nextVNode.ref;
  var lastRef = lastVNode.ref;
  if (lastRef !== nextRef) {
    unmountRef(lastRef);
    mountRef(nextRef, dom, lifecycle);
  }
}
function replaceOneVNodeWithMultipleVNodes(lastChildren, nextChildren, parentDOM, context2, isSVG, lifecycle, animations) {
  unmount(lastChildren, animations);
  mountArrayChildren(nextChildren, parentDOM, context2, isSVG, findDOMFromVNode(lastChildren, true), lifecycle, animations);
  removeVNodeDOM(lastChildren, parentDOM, animations);
}
function patchChildren(lastChildFlags, nextChildFlags, lastChildren, nextChildren, parentDOM, context2, isSVG, nextNode, parentVNode, lifecycle, animations) {
  switch (lastChildFlags) {
    case 2:
      switch (nextChildFlags) {
        case 2:
          patch(lastChildren, nextChildren, parentDOM, context2, isSVG, nextNode, lifecycle, animations);
          break;
        case 1:
          remove3(lastChildren, parentDOM, animations);
          break;
        case 16:
          unmount(lastChildren, animations);
          setTextContent(parentDOM, nextChildren);
          break;
        default:
          replaceOneVNodeWithMultipleVNodes(lastChildren, nextChildren, parentDOM, context2, isSVG, lifecycle, animations);
          break;
      }
      break;
    case 1:
      switch (nextChildFlags) {
        case 2:
          mount2(nextChildren, parentDOM, context2, isSVG, nextNode, lifecycle, animations);
          break;
        case 1:
          break;
        case 16:
          setTextContent(parentDOM, nextChildren);
          break;
        default:
          mountArrayChildren(nextChildren, parentDOM, context2, isSVG, nextNode, lifecycle, animations);
          break;
      }
      break;
    case 16:
      switch (nextChildFlags) {
        case 16:
          patchSingleTextChild(lastChildren, nextChildren, parentDOM);
          break;
        case 2:
          clearDOM(parentDOM, lastChildren, animations);
          mount2(nextChildren, parentDOM, context2, isSVG, nextNode, lifecycle, animations);
          break;
        case 1:
          clearDOM(parentDOM, lastChildren, animations);
          break;
        default:
          clearDOM(parentDOM, lastChildren, animations);
          mountArrayChildren(nextChildren, parentDOM, context2, isSVG, nextNode, lifecycle, animations);
          break;
      }
      break;
    default:
      switch (nextChildFlags) {
        case 16:
          unmountAllChildren(lastChildren, animations);
          setTextContent(parentDOM, nextChildren);
          break;
        case 2:
          removeAllChildren(parentDOM, parentVNode, lastChildren, animations);
          mount2(nextChildren, parentDOM, context2, isSVG, nextNode, lifecycle, animations);
          break;
        case 1:
          removeAllChildren(parentDOM, parentVNode, lastChildren, animations);
          break;
        default:
          var lastLength = lastChildren.length | 0;
          var nextLength = nextChildren.length | 0;
          if (lastLength === 0) {
            if (nextLength > 0) {
              mountArrayChildren(nextChildren, parentDOM, context2, isSVG, nextNode, lifecycle, animations);
            }
          } else if (nextLength === 0) {
            removeAllChildren(parentDOM, parentVNode, lastChildren, animations);
          } else if (nextChildFlags === 8 && lastChildFlags === 8) {
            patchKeyedChildren(lastChildren, nextChildren, parentDOM, context2, isSVG, lastLength, nextLength, nextNode, parentVNode, lifecycle, animations);
          } else {
            patchNonKeyedChildren(lastChildren, nextChildren, parentDOM, context2, isSVG, lastLength, nextLength, nextNode, lifecycle, animations);
          }
          break;
      }
      break;
  }
}
function createDidUpdate(instance, lastProps, lastState, snapshot, lifecycle) {
  lifecycle.push(function() {
    instance.componentDidUpdate(lastProps, lastState, snapshot);
  });
}
function updateClassComponent(instance, nextState, nextProps, parentDOM, context2, isSVG, force, nextNode, lifecycle, animations) {
  var lastState = instance.state;
  var lastProps = instance.props;
  var usesNewAPI = Boolean(instance.$N);
  var hasSCU = isFunction2(instance.shouldComponentUpdate);
  if (usesNewAPI) {
    nextState = createDerivedState(instance, nextProps, nextState !== lastState ? combineFrom(lastState, nextState) : nextState);
  }
  if (force || !hasSCU || hasSCU && instance.shouldComponentUpdate(nextProps, nextState, context2)) {
    if (!usesNewAPI && isFunction2(instance.componentWillUpdate)) {
      instance.componentWillUpdate(nextProps, nextState, context2);
    }
    instance.props = nextProps;
    instance.state = nextState;
    instance.context = context2;
    var snapshot = null;
    var nextInput = renderNewInput(instance, nextProps, context2);
    if (usesNewAPI && isFunction2(instance.getSnapshotBeforeUpdate)) {
      snapshot = instance.getSnapshotBeforeUpdate(lastProps, lastState);
    }
    patch(instance.$LI, nextInput, parentDOM, instance.$CX, isSVG, nextNode, lifecycle, animations);
    instance.$LI = nextInput;
    if (isFunction2(instance.componentDidUpdate)) {
      createDidUpdate(instance, lastProps, lastState, snapshot, lifecycle);
    }
  } else {
    instance.props = nextProps;
    instance.state = nextState;
    instance.context = context2;
  }
}
function patchClassComponent(lastVNode, nextVNode, parentDOM, context2, isSVG, nextNode, lifecycle, animations) {
  var instance = nextVNode.children = lastVNode.children;
  if (isNull(instance)) {
    return;
  }
  instance.$L = lifecycle;
  var nextProps = nextVNode.props || EMPTY_OBJ;
  var nextRef = nextVNode.ref;
  var lastRef = lastVNode.ref;
  var nextState = instance.state;
  if (!instance.$N) {
    if (isFunction2(instance.componentWillReceiveProps)) {
      instance.$BR = true;
      instance.componentWillReceiveProps(nextProps, context2);
      if (instance.$UN) {
        return;
      }
      instance.$BR = false;
    }
    if (!isNull(instance.$PS)) {
      nextState = combineFrom(nextState, instance.$PS);
      instance.$PS = null;
    }
  }
  updateClassComponent(instance, nextState, nextProps, parentDOM, context2, isSVG, false, nextNode, lifecycle, animations);
  if (lastRef !== nextRef) {
    unmountRef(lastRef);
    mountRef(nextRef, instance, lifecycle);
  }
}
function patchFunctionalComponent(lastVNode, nextVNode, parentDOM, context2, isSVG, nextNode, lifecycle, animations) {
  var shouldUpdate = true;
  var nextProps = nextVNode.props || EMPTY_OBJ;
  var nextRef = nextVNode.ref;
  var lastProps = lastVNode.props;
  var nextHooksDefined = !isNullOrUndef(nextRef);
  var lastInput = lastVNode.children;
  if (nextHooksDefined && isFunction2(nextRef.onComponentShouldUpdate)) {
    shouldUpdate = nextRef.onComponentShouldUpdate(lastProps, nextProps);
  }
  if (shouldUpdate !== false) {
    if (nextHooksDefined && isFunction2(nextRef.onComponentWillUpdate)) {
      nextRef.onComponentWillUpdate(lastProps, nextProps);
    }
    var nextInput = normalizeRoot(renderFunctionalComponent(nextVNode, context2));
    patch(lastInput, nextInput, parentDOM, context2, isSVG, nextNode, lifecycle, animations);
    nextVNode.children = nextInput;
    if (nextHooksDefined && isFunction2(nextRef.onComponentDidUpdate)) {
      nextRef.onComponentDidUpdate(lastProps, nextProps);
    }
  } else {
    nextVNode.children = lastInput;
  }
}
function patchText(lastVNode, nextVNode) {
  var nextText = nextVNode.children;
  var dom = nextVNode.dom = lastVNode.dom;
  if (nextText !== lastVNode.children) {
    dom.nodeValue = nextText;
  }
}
function patchNonKeyedChildren(lastChildren, nextChildren, dom, context2, isSVG, lastChildrenLength, nextChildrenLength, nextNode, lifecycle, animations) {
  var commonLength = lastChildrenLength > nextChildrenLength ? nextChildrenLength : lastChildrenLength;
  var i = 0;
  var nextChild;
  var lastChild;
  for (; i < commonLength; ++i) {
    nextChild = nextChildren[i];
    lastChild = lastChildren[i];
    if (nextChild.flags & 16384) {
      nextChild = nextChildren[i] = directClone(nextChild);
    }
    patch(lastChild, nextChild, dom, context2, isSVG, nextNode, lifecycle, animations);
    lastChildren[i] = nextChild;
  }
  if (lastChildrenLength < nextChildrenLength) {
    for (i = commonLength; i < nextChildrenLength; ++i) {
      nextChild = nextChildren[i];
      if (nextChild.flags & 16384) {
        nextChild = nextChildren[i] = directClone(nextChild);
      }
      mount2(nextChild, dom, context2, isSVG, nextNode, lifecycle, animations);
    }
  } else if (lastChildrenLength > nextChildrenLength) {
    for (i = commonLength; i < lastChildrenLength; ++i) {
      remove3(lastChildren[i], dom, animations);
    }
  }
}
function patchKeyedChildren(a, b, dom, context2, isSVG, aLength, bLength, outerEdge, parentVNode, lifecycle, animations) {
  var aEnd = aLength - 1;
  var bEnd = bLength - 1;
  var j = 0;
  var aNode = a[j];
  var bNode = b[j];
  var nextPos;
  var nextNode;
  outer: {
    while (aNode.key === bNode.key) {
      if (bNode.flags & 16384) {
        b[j] = bNode = directClone(bNode);
      }
      patch(aNode, bNode, dom, context2, isSVG, outerEdge, lifecycle, animations);
      a[j] = bNode;
      ++j;
      if (j > aEnd || j > bEnd) {
        break outer;
      }
      aNode = a[j];
      bNode = b[j];
    }
    aNode = a[aEnd];
    bNode = b[bEnd];
    while (aNode.key === bNode.key) {
      if (bNode.flags & 16384) {
        b[bEnd] = bNode = directClone(bNode);
      }
      patch(aNode, bNode, dom, context2, isSVG, outerEdge, lifecycle, animations);
      a[aEnd] = bNode;
      aEnd--;
      bEnd--;
      if (j > aEnd || j > bEnd) {
        break outer;
      }
      aNode = a[aEnd];
      bNode = b[bEnd];
    }
  }
  if (j > aEnd) {
    if (j <= bEnd) {
      nextPos = bEnd + 1;
      nextNode = nextPos < bLength ? findDOMFromVNode(b[nextPos], true) : outerEdge;
      while (j <= bEnd) {
        bNode = b[j];
        if (bNode.flags & 16384) {
          b[j] = bNode = directClone(bNode);
        }
        ++j;
        mount2(bNode, dom, context2, isSVG, nextNode, lifecycle, animations);
      }
    }
  } else if (j > bEnd) {
    while (j <= aEnd) {
      remove3(a[j++], dom, animations);
    }
  } else {
    patchKeyedChildrenComplex(a, b, context2, aLength, bLength, aEnd, bEnd, j, dom, isSVG, outerEdge, parentVNode, lifecycle, animations);
  }
}
function patchKeyedChildrenComplex(a, b, context2, aLength, bLength, aEnd, bEnd, j, dom, isSVG, outerEdge, parentVNode, lifecycle, animations) {
  var aNode;
  var bNode;
  var nextPos = 0;
  var i = 0;
  var aStart = j;
  var bStart = j;
  var aLeft = aEnd - j + 1;
  var bLeft = bEnd - j + 1;
  var sources = new Int32Array(bLeft + 1);
  var canRemoveWholeContent = aLeft === aLength;
  var moved = false;
  var pos = 0;
  var patched = 0;
  if (bLength < 4 || (aLeft | bLeft) < 32) {
    for (i = aStart; i <= aEnd; ++i) {
      aNode = a[i];
      if (patched < bLeft) {
        for (j = bStart; j <= bEnd; j++) {
          bNode = b[j];
          if (aNode.key === bNode.key) {
            sources[j - bStart] = i + 1;
            if (canRemoveWholeContent) {
              canRemoveWholeContent = false;
              while (aStart < i) {
                remove3(a[aStart++], dom, animations);
              }
            }
            if (pos > j) {
              moved = true;
            } else {
              pos = j;
            }
            if (bNode.flags & 16384) {
              b[j] = bNode = directClone(bNode);
            }
            patch(aNode, bNode, dom, context2, isSVG, outerEdge, lifecycle, animations);
            ++patched;
            break;
          }
        }
        if (!canRemoveWholeContent && j > bEnd) {
          remove3(aNode, dom, animations);
        }
      } else if (!canRemoveWholeContent) {
        remove3(aNode, dom, animations);
      }
    }
  } else {
    var keyIndex = {};
    for (i = bStart; i <= bEnd; ++i) {
      keyIndex[b[i].key] = i;
    }
    for (i = aStart; i <= aEnd; ++i) {
      aNode = a[i];
      if (patched < bLeft) {
        j = keyIndex[aNode.key];
        if (j !== void 0) {
          if (canRemoveWholeContent) {
            canRemoveWholeContent = false;
            while (i > aStart) {
              remove3(a[aStart++], dom, animations);
            }
          }
          sources[j - bStart] = i + 1;
          if (pos > j) {
            moved = true;
          } else {
            pos = j;
          }
          bNode = b[j];
          if (bNode.flags & 16384) {
            b[j] = bNode = directClone(bNode);
          }
          patch(aNode, bNode, dom, context2, isSVG, outerEdge, lifecycle, animations);
          ++patched;
        } else if (!canRemoveWholeContent) {
          remove3(aNode, dom, animations);
        }
      } else if (!canRemoveWholeContent) {
        remove3(aNode, dom, animations);
      }
    }
  }
  if (canRemoveWholeContent) {
    removeAllChildren(dom, parentVNode, a, animations);
    mountArrayChildren(b, dom, context2, isSVG, outerEdge, lifecycle, animations);
  } else if (moved) {
    var seq = lis_algorithm(sources);
    j = seq.length - 1;
    for (i = bLeft - 1; i >= 0; i--) {
      if (sources[i] === 0) {
        pos = i + bStart;
        bNode = b[pos];
        if (bNode.flags & 16384) {
          b[pos] = bNode = directClone(bNode);
        }
        nextPos = pos + 1;
        mount2(bNode, dom, context2, isSVG, nextPos < bLength ? findDOMFromVNode(b[nextPos], true) : outerEdge, lifecycle, animations);
      } else if (j < 0 || i !== seq[j]) {
        pos = i + bStart;
        bNode = b[pos];
        nextPos = pos + 1;
        moveVNodeDOM(parentVNode, bNode, dom, nextPos < bLength ? findDOMFromVNode(b[nextPos], true) : outerEdge, animations);
      } else {
        j--;
      }
    }
    if (animations.componentWillMove.length > 0) {
      callAllMoveAnimationHooks(animations.componentWillMove);
    }
  } else if (patched !== bLeft) {
    for (i = bLeft - 1; i >= 0; i--) {
      if (sources[i] === 0) {
        pos = i + bStart;
        bNode = b[pos];
        if (bNode.flags & 16384) {
          b[pos] = bNode = directClone(bNode);
        }
        nextPos = pos + 1;
        mount2(bNode, dom, context2, isSVG, nextPos < bLength ? findDOMFromVNode(b[nextPos], true) : outerEdge, lifecycle, animations);
      }
    }
  }
}
var result;
var p;
var maxLen = 0;
function lis_algorithm(arr) {
  var arrI = 0;
  var i = 0;
  var j = 0;
  var k = 0;
  var u = 0;
  var v = 0;
  var c = 0;
  var len = arr.length;
  if (len > maxLen) {
    maxLen = len;
    result = new Int32Array(len);
    p = new Int32Array(len);
  }
  for (; i < len; ++i) {
    arrI = arr[i];
    if (arrI !== 0) {
      j = result[k];
      if (arr[j] < arrI) {
        p[i] = j;
        result[++k] = i;
        continue;
      }
      u = 0;
      v = k;
      while (u < v) {
        c = u + v >> 1;
        if (arr[result[c]] < arrI) {
          u = c + 1;
        } else {
          v = c;
        }
      }
      if (arrI < arr[result[u]]) {
        if (u > 0) {
          p[i] = result[u - 1];
        }
        result[u] = i;
      }
    }
  }
  u = k + 1;
  var seq = new Int32Array(u);
  v = result[u - 1];
  while (u-- > 0) {
    seq[u] = v;
    v = p[v];
    result[u] = 0;
  }
  return seq;
}
var hasDocumentAvailable = typeof document !== "undefined";
if (hasDocumentAvailable) {
  if (window.Node) {
    Node.prototype.$EV = null;
    Node.prototype.$V = null;
  }
}
function __render(input, parentDOM, callback, context2) {
  var lifecycle = [];
  var animations = new AnimationQueues();
  var rootInput = parentDOM.$V;
  renderCheck.v = true;
  if (isNullOrUndef(rootInput)) {
    if (!isNullOrUndef(input)) {
      if (input.flags & 16384) {
        input = directClone(input);
      }
      mount2(input, parentDOM, context2, false, null, lifecycle, animations);
      parentDOM.$V = input;
      rootInput = input;
    }
  } else {
    if (isNullOrUndef(input)) {
      remove3(rootInput, parentDOM, animations);
      parentDOM.$V = null;
    } else {
      if (input.flags & 16384) {
        input = directClone(input);
      }
      patch(rootInput, input, parentDOM, context2, false, null, lifecycle, animations);
      rootInput = parentDOM.$V = input;
    }
  }
  callAll(lifecycle);
  callAllAnimationHooks(animations.componentDidAppear);
  renderCheck.v = false;
  if (isFunction2(callback)) {
    callback();
  }
  if (isFunction2(options.renderComplete)) {
    options.renderComplete(rootInput, parentDOM);
  }
}
function render2(input, parentDOM, callback, context2) {
  if (callback === void 0) {
    callback = null;
  }
  if (context2 === void 0) {
    context2 = EMPTY_OBJ;
  }
  __render(input, parentDOM, callback, context2);
}
var COMPONENTS_QUEUE = [];
var nextTick = typeof Promise !== "undefined" ? Promise.resolve().then.bind(Promise.resolve()) : function(a) {
  window.setTimeout(a, 0);
};
var microTaskPending = false;
function queueStateChanges(component, newState, callback, force) {
  var pending = component.$PS;
  if (isFunction2(newState)) {
    newState = newState(pending ? combineFrom(component.state, pending) : component.state, component.props, component.context);
  }
  if (isNullOrUndef(pending)) {
    component.$PS = newState;
  } else {
    for (var stateKey in newState) {
      pending[stateKey] = newState[stateKey];
    }
  }
  if (!component.$BR) {
    if (!renderCheck.v) {
      if (COMPONENTS_QUEUE.length === 0) {
        applyState(component, force);
        if (isFunction2(callback)) {
          callback.call(component);
        }
        return;
      }
    }
    if (COMPONENTS_QUEUE.indexOf(component) === -1) {
      COMPONENTS_QUEUE.push(component);
    }
    if (force) {
      component.$F = true;
    }
    if (!microTaskPending) {
      microTaskPending = true;
      nextTick(rerender);
    }
    if (isFunction2(callback)) {
      var QU = component.$QU;
      if (!QU) {
        QU = component.$QU = [];
      }
      QU.push(callback);
    }
  } else if (isFunction2(callback)) {
    component.$L.push(callback.bind(component));
  }
}
function callSetStateCallbacks(component) {
  var queue = component.$QU;
  for (var i = 0; i < queue.length; ++i) {
    queue[i].call(component);
  }
  component.$QU = null;
}
function rerender() {
  var component;
  microTaskPending = false;
  while (component = COMPONENTS_QUEUE.shift()) {
    if (!component.$UN) {
      var force = component.$F;
      component.$F = false;
      applyState(component, force);
      if (component.$QU) {
        callSetStateCallbacks(component);
      }
    }
  }
}
function applyState(component, force) {
  if (force || !component.$BR) {
    var pendingState = component.$PS;
    component.$PS = null;
    var lifecycle = [];
    var animations = new AnimationQueues();
    renderCheck.v = true;
    updateClassComponent(component, combineFrom(component.state, pendingState), component.props, findDOMFromVNode(component.$LI, true).parentNode, component.context, component.$SVG, force, null, lifecycle, animations);
    callAll(lifecycle);
    callAllAnimationHooks(animations.componentDidAppear);
    renderCheck.v = false;
  } else {
    component.state = component.$PS;
    component.$PS = null;
  }
}
var Component2 = function() {
  function Component3(props, context2) {
    this.state = null;
    this.props = void 0;
    this.context = void 0;
    this.displayName = void 0;
    this.$BR = false;
    this.$BS = true;
    this.$PS = null;
    this.$LI = null;
    this.$UN = false;
    this.$CX = null;
    this.$QU = null;
    this.$N = false;
    this.$SSR = void 0;
    this.$L = null;
    this.$SVG = false;
    this.$F = false;
    this.props = props || EMPTY_OBJ;
    this.context = context2 || EMPTY_OBJ;
  }
  var _proto = Component3.prototype;
  _proto.forceUpdate = function forceUpdate(callback) {
    if (this.$UN) {
      return;
    }
    queueStateChanges(this, {}, callback, true);
  };
  _proto.setState = function setState(newState, callback) {
    if (this.$UN) {
      return;
    }
    if (!this.$BS) {
      queueStateChanges(this, newState, callback, false);
    }
  };
  _proto.render = function render3(props, state, context2) {
    return null;
  };
  return Component3;
}();
Component2.defaultProps = null;

// node_modules/inferno/index.esm.js
if (true) {
  console.warn("You are running production build of Inferno in development mode. Use dev:module entry point.");
}

// node_modules/devextreme/esm/__internal/core/r1/runtime/inferno/effect_host.js
var InfernoEffectHost = {
  lockCount: 0,
  lock() {
    this.lockCount++;
  },
  callbacks: [],
  callEffects() {
    this.lockCount--;
    if (this.lockCount < 0) {
      throw new Error("Unexpected Effect Call");
    }
    if (0 === this.lockCount) {
      const effects = this.callbacks;
      this.callbacks = [];
      effects.forEach((callback) => callback());
    }
  }
};

// node_modules/devextreme/esm/__internal/core/r1/runtime/inferno/base_component.js
var areObjectsEqual = (firstObject, secondObject) => {
  const bothAreObjects = firstObject instanceof Object && secondObject instanceof Object;
  if (!bothAreObjects) {
    return firstObject === secondObject;
  }
  const firstObjectKeys = Object.keys(firstObject);
  const secondObjectKeys = Object.keys(secondObject);
  if (firstObjectKeys.length !== secondObjectKeys.length) {
    return false;
  }
  const hasDifferentElement = firstObjectKeys.some((key) => firstObject[key] !== secondObject[key]);
  return !hasDifferentElement;
};
var BaseInfernoComponent = class extends Component2 {
  constructor() {
    super(...arguments);
    this._pendingContext = this.context;
  }
  componentWillReceiveProps(_, context2) {
    this._pendingContext = context2 ?? {};
  }
  shouldComponentUpdate(nextProps, nextState) {
    return !areObjectsEqual(this.props, nextProps) || !areObjectsEqual(this.state, nextState) || !areObjectsEqual(this.context, this._pendingContext);
  }
};
var InfernoComponent = class extends BaseInfernoComponent {
  constructor() {
    super(...arguments);
    this._effects = [];
  }
  createEffects() {
    return [];
  }
  updateEffects() {
  }
  componentWillMount() {
    InfernoEffectHost.lock();
  }
  componentWillUpdate(_nextProps, _nextState, _context) {
    InfernoEffectHost.lock();
  }
  componentDidMount() {
    InfernoEffectHost.callbacks.push(() => {
      this._effects = this.createEffects();
    });
    InfernoEffectHost.callEffects();
  }
  componentDidUpdate() {
    InfernoEffectHost.callbacks.push(() => this.updateEffects());
    InfernoEffectHost.callEffects();
  }
  destroyEffects() {
    this._effects.forEach((e) => e.dispose());
  }
  componentWillUnmount() {
    this.destroyEffects();
  }
};
var InfernoWrapperComponent = class extends InfernoComponent {
  constructor() {
    super(...arguments);
    this.vDomElement = null;
  }
  vDomUpdateClasses() {
    var _el$className;
    const el = this.vDomElement;
    const currentClasses = null !== (_el$className = el.className) && void 0 !== _el$className && _el$className.length ? el.className.split(" ") : [];
    const addedClasses = currentClasses.filter((className) => !el.dxClasses.previous.includes(className));
    const removedClasses = el.dxClasses.previous.filter((className) => !currentClasses.includes(className));
    addedClasses.forEach((value2) => {
      const indexInRemoved = el.dxClasses.removed.indexOf(value2);
      if (indexInRemoved > -1) {
        el.dxClasses.removed.splice(indexInRemoved, 1);
      } else if (!el.dxClasses.added.includes(value2)) {
        el.dxClasses.added.push(value2);
      }
    });
    removedClasses.forEach((value2) => {
      const indexInAdded = el.dxClasses.added.indexOf(value2);
      if (indexInAdded > -1) {
        el.dxClasses.added.splice(indexInAdded, 1);
      } else if (!el.dxClasses.removed.includes(value2)) {
        el.dxClasses.removed.push(value2);
      }
    });
  }
  componentDidMount() {
    var _el$className2;
    const el = findDOMFromVNode(this.$LI, true);
    this.vDomElement = el;
    super.componentDidMount();
    el.dxClasses = el.dxClasses || {
      removed: [],
      added: [],
      previous: []
    };
    el.dxClasses.previous = null !== el && void 0 !== el && null !== (_el$className2 = el.className) && void 0 !== _el$className2 && _el$className2.length ? el.className.split(" ") : [];
  }
  componentDidUpdate() {
    super.componentDidUpdate();
    const el = this.vDomElement;
    if (null !== el) {
      var _el$className3;
      el.dxClasses.added.forEach((className) => el.classList.add(className));
      el.dxClasses.removed.forEach((className) => el.classList.remove(className));
      el.dxClasses.previous = null !== (_el$className3 = el.className) && void 0 !== _el$className3 && _el$className3.length ? el.className.split(" ") : [];
    }
  }
  shouldComponentUpdate(nextProps, nextState) {
    const shouldUpdate = super.shouldComponentUpdate(nextProps, nextState);
    if (shouldUpdate) {
      this.vDomUpdateClasses();
    }
    return shouldUpdate;
  }
};

// node_modules/devextreme/esm/__internal/core/r1/runtime/inferno/create_context.js
var contextId = 0;
var createContext = function(defaultValue) {
  const id = contextId++;
  return {
    id,
    defaultValue,
    Provider: class extends Component2 {
      getChildContext() {
        return _extends({}, this.context, {
          [id]: this.props.value || defaultValue
        });
      }
      render() {
        return this.props.children;
      }
    }
  };
};

// node_modules/devextreme/esm/__internal/core/r1/runtime/inferno/effect.js
var InfernoEffect = class {
  constructor(effect, dependency) {
    this.dependency = dependency;
    this.effect = effect;
    this.destroy = effect();
  }
  update(dependency) {
    const currentDependency = this.dependency;
    if (dependency) {
      this.dependency = dependency;
    }
    if (!dependency || dependency.some((d, i) => currentDependency[i] !== d)) {
      this.dispose();
      this.destroy = this.effect();
    }
  }
  dispose() {
    if (this.destroy) {
      this.destroy();
    }
  }
};

// node_modules/devextreme/esm/__internal/core/r1/runtime/inferno/mocked/shared.js
var ERROR_MSG = "a runtime error occured! Use Inferno in development environment to find the error.";
function isNullOrUndef2(o) {
  return void 0 === o || null === o;
}
function isInvalid2(o) {
  return null === o || false === o || true === o || void 0 === o;
}
function isFunction3(o) {
  return "function" === typeof o;
}
function isNull2(o) {
  return null === o;
}
function throwError(message) {
  if (!message) {
    message = ERROR_MSG;
  }
  throw new Error(`Inferno Error: ${message}`);
}

// node_modules/devextreme/esm/__internal/core/r1/runtime/inferno/mocked/vnode-flags.js
var VNodeFlags;
!function(VNodeFlags2) {
  VNodeFlags2[VNodeFlags2.HtmlElement = 1] = "HtmlElement";
  VNodeFlags2[VNodeFlags2.ComponentUnknown = 2] = "ComponentUnknown";
  VNodeFlags2[VNodeFlags2.ComponentClass = 4] = "ComponentClass";
  VNodeFlags2[VNodeFlags2.ComponentFunction = 8] = "ComponentFunction";
  VNodeFlags2[VNodeFlags2.Text = 16] = "Text";
  VNodeFlags2[VNodeFlags2.SvgElement = 32] = "SvgElement";
  VNodeFlags2[VNodeFlags2.InputElement = 64] = "InputElement";
  VNodeFlags2[VNodeFlags2.TextareaElement = 128] = "TextareaElement";
  VNodeFlags2[VNodeFlags2.SelectElement = 256] = "SelectElement";
  VNodeFlags2[VNodeFlags2.Void = 512] = "Void";
  VNodeFlags2[VNodeFlags2.Portal = 1024] = "Portal";
  VNodeFlags2[VNodeFlags2.ReCreate = 2048] = "ReCreate";
  VNodeFlags2[VNodeFlags2.ContentEditable = 4096] = "ContentEditable";
  VNodeFlags2[VNodeFlags2.Fragment = 8192] = "Fragment";
  VNodeFlags2[VNodeFlags2.InUse = 16384] = "InUse";
  VNodeFlags2[VNodeFlags2.ForwardRef = 32768] = "ForwardRef";
  VNodeFlags2[VNodeFlags2.Normalized = 65536] = "Normalized";
  VNodeFlags2[VNodeFlags2.ForwardRefComponent = 32776] = "ForwardRefComponent";
  VNodeFlags2[VNodeFlags2.FormElement = 448] = "FormElement";
  VNodeFlags2[VNodeFlags2.Element = 481] = "Element";
  VNodeFlags2[VNodeFlags2.Component = 14] = "Component";
  VNodeFlags2[VNodeFlags2.DOMRef = 2033] = "DOMRef";
  VNodeFlags2[VNodeFlags2.InUseOrNormalized = 81920] = "InUseOrNormalized";
  VNodeFlags2[VNodeFlags2.ClearInUse = -16385] = "ClearInUse";
  VNodeFlags2[VNodeFlags2.ComponentKnown = 12] = "ComponentKnown";
}(VNodeFlags || (VNodeFlags = {}));
var ChildFlags;
!function(ChildFlags2) {
  ChildFlags2[ChildFlags2.UnknownChildren = 0] = "UnknownChildren";
  ChildFlags2[ChildFlags2.HasInvalidChildren = 1] = "HasInvalidChildren";
  ChildFlags2[ChildFlags2.HasVNodeChildren = 2] = "HasVNodeChildren";
  ChildFlags2[ChildFlags2.HasNonKeyedChildren = 4] = "HasNonKeyedChildren";
  ChildFlags2[ChildFlags2.HasKeyedChildren = 8] = "HasKeyedChildren";
  ChildFlags2[ChildFlags2.HasTextChildren = 16] = "HasTextChildren";
  ChildFlags2[ChildFlags2.MultipleChildren = 12] = "MultipleChildren";
}(ChildFlags || (ChildFlags = {}));

// node_modules/devextreme/esm/__internal/core/r1/runtime/inferno/mocked/hydrate.js
function isSameInnerHTML2(dom, innerHTML) {
  const tempdom = document.createElement("i");
  tempdom.innerHTML = innerHTML;
  return tempdom.innerHTML === dom.innerHTML;
}
function findLastDOMFromVNode(vNode) {
  let flags;
  let children;
  while (vNode) {
    flags = vNode.flags;
    if (flags & VNodeFlags.DOMRef) {
      return vNode.dom;
    }
    children = vNode.children;
    if (flags & VNodeFlags.Fragment) {
      vNode = vNode.childFlags === ChildFlags.HasVNodeChildren ? children : children[children.length - 1];
    } else if (flags & VNodeFlags.ComponentClass) {
      vNode = children.$LI;
    } else {
      vNode = children;
    }
  }
  return null;
}
function isSamePropsInnerHTML(dom, props) {
  return Boolean(props && props.dangerouslySetInnerHTML && props.dangerouslySetInnerHTML.__html && isSameInnerHTML2(dom, props.dangerouslySetInnerHTML.__html));
}
function hydrateComponent(vNode, parentDOM, dom, context2, isSVG, isClass, lifecycle, animations) {
  const type2 = vNode.type;
  const ref = vNode.ref;
  const props = vNode.props || EMPTY_OBJ;
  let currentNode;
  if (isClass) {
    const instance = createClassComponentInstance(vNode, type2, props, context2, isSVG, lifecycle);
    const input = instance.$LI;
    currentNode = hydrateVNode(input, parentDOM, dom, instance.$CX, isSVG, lifecycle, animations);
    mountClassComponentCallbacks(ref, instance, lifecycle, animations);
  } else {
    const input = normalizeRoot(renderFunctionalComponent(vNode, context2));
    currentNode = hydrateVNode(input, parentDOM, dom, context2, isSVG, lifecycle, animations);
    vNode.children = input;
    mountFunctionalComponentCallbacks(vNode, lifecycle, animations);
  }
  return currentNode;
}
function hydrateChildren(parentVNode, parentNode, currentNode, context2, isSVG, lifecycle, animations) {
  const childFlags = parentVNode.childFlags;
  const children = parentVNode.children;
  const props = parentVNode.props;
  const flags = parentVNode.flags;
  if (childFlags !== ChildFlags.HasInvalidChildren) {
    if (childFlags === ChildFlags.HasVNodeChildren) {
      if (isNull2(currentNode)) {
        mount2(children, parentNode, context2, isSVG, null, lifecycle, animations);
      } else {
        currentNode = hydrateVNode(children, parentNode, currentNode, context2, isSVG, lifecycle, animations);
        currentNode = currentNode ? currentNode.nextSibling : null;
      }
    } else if (childFlags === ChildFlags.HasTextChildren) {
      if (isNull2(currentNode)) {
        parentNode.appendChild(document.createTextNode(children));
      } else if (1 !== parentNode.childNodes.length || 3 !== currentNode.nodeType) {
        parentNode.textContent = children;
      } else if (currentNode.nodeValue !== children) {
        currentNode.nodeValue = children;
      }
      currentNode = null;
    } else if (childFlags & ChildFlags.MultipleChildren) {
      let prevVNodeIsTextNode = false;
      for (let i = 0, len = children.length; i < len; ++i) {
        const child = children[i];
        if (isNull2(currentNode) || prevVNodeIsTextNode && (child.flags & VNodeFlags.Text) > 0) {
          mount2(child, parentNode, context2, isSVG, currentNode, lifecycle, animations);
        } else {
          currentNode = hydrateVNode(child, parentNode, currentNode, context2, isSVG, lifecycle, animations);
          currentNode = currentNode ? currentNode.nextSibling : null;
        }
        prevVNodeIsTextNode = (child.flags & VNodeFlags.Text) > 0;
      }
    }
    if (0 === (flags & VNodeFlags.Fragment)) {
      let nextSibling = null;
      while (currentNode) {
        nextSibling = currentNode.nextSibling;
        parentNode.removeChild(currentNode);
        currentNode = nextSibling;
      }
    }
  } else if (!isNull2(parentNode.firstChild) && !isSamePropsInnerHTML(parentNode, props)) {
    parentNode.textContent = "";
    if (flags & VNodeFlags.FormElement) {
      parentNode.defaultValue = "";
    }
  }
}
function hydrateElement(vNode, parentDOM, dom, context2, isSVG, lifecycle, animations) {
  const props = vNode.props;
  const className = vNode.className;
  const flags = vNode.flags;
  const ref = vNode.ref;
  isSVG = isSVG || (flags & VNodeFlags.SvgElement) > 0;
  if (1 !== dom.nodeType) {
    mountElement(vNode, null, context2, isSVG, null, lifecycle, animations);
    parentDOM.replaceChild(vNode.dom, dom);
  } else {
    vNode.dom = dom;
    hydrateChildren(vNode, dom, dom.firstChild, context2, isSVG, lifecycle, animations);
    if (!isNull2(props)) {
      mountProps(vNode, flags, props, dom, isSVG, animations);
    }
    if (isNullOrUndef2(className)) {
      if ("" !== dom.className) {
        dom.removeAttribute("class");
      }
    } else if (isSVG) {
      dom.setAttribute("class", className);
    } else {
      dom.className = className;
    }
    mountRef(ref, dom, lifecycle);
  }
  return vNode.dom;
}
function hydrateText(vNode, parentDOM, dom) {
  if (3 !== dom.nodeType) {
    parentDOM.replaceChild(vNode.dom = document.createTextNode(vNode.children), dom);
  } else {
    const text = vNode.children;
    if (dom.nodeValue !== text) {
      dom.nodeValue = text;
    }
    vNode.dom = dom;
  }
  return vNode.dom;
}
function hydrateFragment(vNode, parentDOM, dom, context2, isSVG, lifecycle, animations) {
  const children = vNode.children;
  if (vNode.childFlags === ChildFlags.HasVNodeChildren) {
    hydrateText(children, parentDOM, dom);
    return children.dom;
  }
  hydrateChildren(vNode, parentDOM, dom, context2, isSVG, lifecycle, animations);
  return findLastDOMFromVNode(children[children.length - 1]);
}
function hydrateVNode(vNode, parentDOM, currentDom, context2, isSVG, lifecycle, animations) {
  const flags = vNode.flags |= VNodeFlags.InUse;
  if (flags & VNodeFlags.Component) {
    return hydrateComponent(vNode, parentDOM, currentDom, context2, isSVG, (flags & VNodeFlags.ComponentClass) > 0, lifecycle, animations);
  }
  if (flags & VNodeFlags.Element) {
    return hydrateElement(vNode, parentDOM, currentDom, context2, isSVG, lifecycle, animations);
  }
  if (flags & VNodeFlags.Text) {
    return hydrateText(vNode, parentDOM, currentDom);
  }
  if (flags & VNodeFlags.Void) {
    return vNode.dom = currentDom;
  }
  if (flags & VNodeFlags.Fragment) {
    return hydrateFragment(vNode, parentDOM, currentDom, context2, isSVG, lifecycle, animations);
  }
  throwError();
  return null;
}
function hydrate(input, parentDOM, callback) {
  let dom = parentDOM.firstChild;
  if (isNull2(dom)) {
    render2(input, parentDOM, callback);
  } else {
    const lifecycle = [];
    const animations = new AnimationQueues();
    if (!isInvalid2(input)) {
      dom = hydrateVNode(input, parentDOM, dom, {}, false, lifecycle, animations);
    }
    while (dom && (dom = dom.nextSibling)) {
      parentDOM.removeChild(dom);
    }
    if (lifecycle.length > 0) {
      let listener;
      while (void 0 !== (listener = lifecycle.shift())) {
        listener();
      }
    }
  }
  parentDOM.$V = input;
  if (isFunction3(callback)) {
    callback();
  }
}

// node_modules/devextreme/esm/__internal/core/r1/runtime/inferno/normalize_styles.js
var NUMBER_STYLES = /* @__PURE__ */ new Set(["animationIterationCount", "borderImageOutset", "borderImageSlice", "border-imageWidth", "boxFlex", "boxFlexGroup", "boxOrdinalGroup", "columnCount", "fillOpacity", "flex", "flexGrow", "flexNegative", "flexOrder", "flexPositive", "flexShrink", "floodOpacity", "fontWeight", "gridColumn", "gridRow", "lineClamp", "lineHeight", "opacity", "order", "orphans", "stopOpacity", "strokeDasharray", "strokeDashoffset", "strokeMiterlimit", "strokeOpacity", "strokeWidth", "tabSize", "widows", "zIndex", "zoom"]);
var isNumeric2 = (value2) => {
  if ("number" === typeof value2) {
    return true;
  }
  return !Number.isNaN(Number(value2));
};
var getNumberStyleValue = (style, value2) => NUMBER_STYLES.has(style) ? value2 : `${value2}px`;
var uppercasePattern = /[A-Z]/g;
var kebabCase = (str) => str.replace(uppercasePattern, "-$&").toLowerCase();
function normalizeStyles(styles) {
  if (!(styles instanceof Object)) {
    return;
  }
  return Object.entries(styles).reduce((acc, _ref) => {
    let [key, value2] = _ref;
    acc[kebabCase(key)] = isNumeric2(value2) ? getNumberStyleValue(key, value2) : value2;
    return acc;
  }, {});
}

// node_modules/devextreme/esm/__internal/core/r1/runtime/inferno/re_render_effect.js
var createReRenderEffect = () => new InfernoEffect(() => {
  rerender();
}, []);

// node_modules/inferno-create-element/dist/index.esm.js
function isNullOrUndef3(o) {
  return o === void 0 || o === null;
}
function isString3(o) {
  return typeof o === "string";
}
function isUndefined2(o) {
  return o === void 0;
}
var componentHooks = {
  onComponentDidAppear: 1,
  onComponentDidMount: 1,
  onComponentDidUpdate: 1,
  onComponentShouldUpdate: 1,
  onComponentWillDisappear: 1,
  onComponentWillMount: 1,
  onComponentWillUnmount: 1,
  onComponentWillUpdate: 1
};
function createElement(type2, props, _children) {
  var children;
  var ref = null;
  var key = null;
  var className = null;
  var flags;
  var newProps;
  var childLen = arguments.length - 2;
  if (childLen === 1) {
    children = _children;
  } else if (childLen > 1) {
    children = [];
    while (childLen-- > 0) {
      children[childLen] = arguments[childLen + 2];
    }
  }
  if (isString3(type2)) {
    flags = getFlagsForElementVnode(type2);
    if (!isNullOrUndef3(props)) {
      newProps = {};
      for (var prop in props) {
        if (prop === "className" || prop === "class") {
          className = props[prop];
        } else if (prop === "key") {
          key = props.key;
        } else if (prop === "children" && isUndefined2(children)) {
          children = props.children;
        } else if (prop === "ref") {
          ref = props.ref;
        } else {
          if (prop === "contenteditable") {
            flags |= 4096;
          }
          newProps[prop] = props[prop];
        }
      }
    }
  } else {
    flags = 2;
    if (!isUndefined2(children)) {
      if (!props) {
        props = {};
      }
      props.children = children;
    }
    if (!isNullOrUndef3(props)) {
      newProps = {};
      for (var _prop in props) {
        if (_prop === "key") {
          key = props.key;
        } else if (_prop === "ref") {
          ref = props.ref;
        } else if (componentHooks[_prop] === 1) {
          if (!ref) {
            ref = {};
          }
          ref[_prop] = props[_prop];
        } else {
          newProps[_prop] = props[_prop];
        }
      }
    }
    return createComponentVNode(flags, type2, newProps, key, ref);
  }
  if (flags & 8192) {
    return createFragment(childLen === 1 ? [children] : children, 0, key);
  }
  return createVNode(flags, type2, className, children, 0, newProps, key, ref);
}

// node_modules/devextreme/esm/__internal/core/r1/runtime/inferno/render_template.js
var getContainer = (props) => {
  var _props$container, _props$item;
  return (null === (_props$container = props.container) || void 0 === _props$container ? void 0 : _props$container.get(0)) || (null === (_props$item = props.item) || void 0 === _props$item ? void 0 : _props$item.get(0));
};
function renderTemplate(template, props, _component) {
  setTimeout(() => {
    render2(createElement(template, props), getContainer(props));
  }, 0);
}
var hasTemplate2 = (name2, properties, _component) => {
  const value2 = properties[name2];
  return !!value2 && "string" !== typeof value2;
};

// node_modules/devextreme/esm/__internal/core/m_inferno_renderer.js
var remove4 = (element) => {
  const {
    parentNode
  } = element;
  if (parentNode) {
    const {
      nextSibling
    } = element;
    cleanDataRecursive(element);
    parentNode.$V = element.$V;
    render2(null, parentNode);
    parentNode.insertBefore(element, nextSibling);
    element.innerHTML = "";
    delete parentNode.$V;
  }
  delete element.$V;
};
var infernoRenderer = dependency_injector_default({
  createElement: (component, props) => createElement(component, props),
  remove: remove4,
  onAfterRender: () => {
    InfernoEffectHost.callEffects();
  },
  onPreRender: () => {
    InfernoEffectHost.lock();
  },
  render: (component, props, container, replace) => {
    if (!replace) {
      const {
        parentNode
      } = container;
      const nextNode = null === container || void 0 === container ? void 0 : container.nextSibling;
      const rootNode = dom_adapter_default.createElement("div");
      rootNode.appendChild(container);
      const mountNode = dom_adapter_default.createDocumentFragment().appendChild(rootNode);
      const vNodeAlreadyExists = !!container.$V;
      vNodeAlreadyExists && remove4(container);
      hydrate(createElement(component, props), mountNode);
      container.$V = mountNode.$V;
      if (parentNode) {
        parentNode.insertBefore(container, nextNode);
      }
    } else {
      render2(createElement(component, props), container);
    }
  },
  renderIntoContainer: (jsx, container, replace) => {
    if (!replace) {
      hydrate(jsx, container);
    } else {
      render2(jsx, container);
    }
  }
});

// node_modules/devextreme/esm/core/inferno_renderer.js
var inferno_renderer_default = infernoRenderer;

// node_modules/devextreme/esm/__internal/core/r1/utils/shallow_equals.js
var shallowEquals = (firstObject, secondObject) => {
  if (Object.keys(firstObject).length !== Object.keys(secondObject).length) {
    return false;
  }
  return Object.entries(firstObject).every((_ref) => {
    let [key, firstValue] = _ref;
    const secondValue = secondObject[key];
    if (firstValue instanceof Date && secondValue instanceof Date) {
      return firstValue.getTime() === secondValue.getTime();
    }
    return firstValue === secondValue;
  });
};

// node_modules/devextreme/esm/__internal/core/r1/template_wrapper.js
var _excluded4 = ["isEqual"];
var isDxElementWrapper = (element) => !!element.toArray;
var buildTemplateArgs = (model, template) => {
  const args = {
    template,
    model: _extends({}, model)
  };
  const _ref = model.data ?? {}, {
    isEqual: isEqual2
  } = _ref, data17 = _objectWithoutPropertiesLoose(_ref, _excluded4);
  if (isEqual2) {
    args.model.data = data17;
    args.isEqual = isEqual2;
  }
  return args;
};
var renderTemplateContent = (props, container) => {
  const {
    data: data17,
    index: index2
  } = props.model ?? {
    data: {}
  };
  if (data17) {
    Object.keys(data17).forEach((name2) => {
      if (data17[name2] && dom_adapter_default.isNode(data17[name2])) {
        data17[name2] = getPublicElement(renderer_default(data17[name2]));
      }
    });
  }
  const rendered = props.template.render(_extends({
    container,
    transclude: props.transclude
  }, {
    renovated: props.renovated
  }, !props.transclude ? {
    model: data17
  } : {}, !props.transclude && Number.isFinite(index2) ? {
    index: index2
  } : {}));
  if (void 0 === rendered) {
    return [];
  }
  return isDxElementWrapper(rendered) ? rendered.toArray() : [renderer_default(rendered).get(0)];
};
var removeDifferentElements = (oldChildren, newChildren) => {
  newChildren.forEach((newElement) => {
    const hasOldChild = !!oldChildren.find((oldElement) => newElement === oldElement);
    if (!hasOldChild && newElement.parentNode) {
      renderer_default(newElement).remove();
    }
  });
};
var TemplateWrapper = class extends InfernoComponent {
  constructor(props) {
    super(props);
    this.renderTemplate = this.renderTemplate.bind(this);
  }
  renderTemplate() {
    const node = findDOMFromVNode(this.$LI, true);
    if (!(null !== node && void 0 !== node && node.parentNode)) {
      return () => {
      };
    }
    const container = node.parentNode;
    const $container = renderer_default(container);
    const $oldContainerContent = $container.contents().toArray();
    const content = renderTemplateContent(this.props, getPublicElement($container));
    replaceWith(renderer_default(node), renderer_default(content));
    return () => {
      const $actualContainerContent = renderer_default(container).contents().toArray();
      removeDifferentElements($oldContainerContent, $actualContainerContent);
      container.appendChild(node);
    };
  }
  shouldComponentUpdate(nextProps) {
    const {
      template,
      model
    } = this.props;
    const {
      template: nextTemplate,
      model: nextModel,
      isEqual: isEqual2
    } = nextProps;
    const equalityComparer = isEqual2 ?? shallowEquals;
    if (template !== nextTemplate) {
      return true;
    }
    if (!isDefined(model) || !isDefined(nextModel)) {
      return model !== nextModel;
    }
    const {
      data: data17,
      index: index2
    } = model;
    const {
      data: nextData,
      index: nextIndex
    } = nextModel;
    if (index2 !== nextIndex) {
      return true;
    }
    if (!isDefined(data17) || !isDefined(nextData)) {
      return model !== nextModel;
    }
    return !equalityComparer(data17, nextData);
  }
  createEffects() {
    return [new InfernoEffect(this.renderTemplate, [this.props.template, this.props.model])];
  }
  updateEffects() {
    this._effects[0].update([this.props.template, this.props.model]);
  }
  componentWillUnmount() {
  }
  render() {
    return null;
  }
};

// node_modules/devextreme/esm/__internal/core/r1/utils/get_template.js
var getTemplate = (TemplateProp) => TemplateProp && (TemplateProp.defaultProps ? (props) => normalizeProps(createComponentVNode(2, TemplateProp, _extends({}, props))) : TemplateProp);

// node_modules/devextreme/esm/__internal/core/r1/utils/update_props_immutable.js
var cloneObjectValue = (value2) => Array.isArray(value2) ? [...value2] : _extends({}, value2);
var cloneObjectProp = (value2, prevValue, fullNameParts) => {
  const result2 = fullNameParts.length > 0 && prevValue && value2 !== prevValue ? cloneObjectValue(prevValue) : cloneObjectValue(value2);
  const name2 = fullNameParts[0];
  if (fullNameParts.length > 1) {
    result2[name2] = cloneObjectProp(value2[name2], null === prevValue || void 0 === prevValue ? void 0 : prevValue[name2], fullNameParts.slice(1));
  } else if (name2) {
    if (isPlainObject(value2[name2])) {
      result2[name2] = cloneObjectValue(value2[name2]);
    } else {
      result2[name2] = value2[name2];
    }
  }
  return result2;
};
var updatePropsImmutable = (props, option, name2, fullName) => {
  const currentPropsValue = option[name2];
  const prevPropsValue = props[name2];
  const result2 = props;
  if (isPlainObject(currentPropsValue) || name2 !== fullName && Array.isArray(currentPropsValue)) {
    result2[name2] = cloneObjectProp(currentPropsValue, prevPropsValue, getPathParts(fullName).slice(1));
  } else {
    result2[name2] = currentPropsValue;
  }
};

// node_modules/devextreme/esm/__internal/core/r1/component_wrapper.js
var setDefaultOptionValue = (options2, defaultValueGetter) => (name2) => {
  if (Object.prototype.hasOwnProperty.call(options2, name2) && void 0 === options2[name2]) {
    options2[name2] = defaultValueGetter(name2);
  }
};
var ComponentWrapper = class extends dom_component_default2 {
  get _propsInfo() {
    return {
      allowNull: [],
      twoWay: [],
      elements: [],
      templates: [],
      props: []
    };
  }
  constructor(element, options2) {
    super(element, options2);
    this._shouldRaiseContentReady = false;
    this.validateKeyDownHandler();
  }
  validateKeyDownHandler() {
    const supportedKeyNames = this.getSupportedKeyNames();
    const hasComponentDefaultKeyHandlers = supportedKeyNames.length > 0;
    const hasComponentKeyDownMethod = "function" === typeof this._viewComponent.prototype.keyDown;
    if (hasComponentDefaultKeyHandlers && !hasComponentKeyDownMethod) {
      throw Error("Component's declaration must have 'keyDown' method.");
    }
  }
  get viewRef() {
    var _this$_viewRef;
    return null === (_this$_viewRef = this._viewRef) || void 0 === _this$_viewRef ? void 0 : _this$_viewRef.current;
  }
  _checkContentReadyOption(fullName) {
    const contentReadyOptions = this._getContentReadyOptions().reduce((options2, name2) => {
      options2[name2] = true;
      return options2;
    }, {});
    this._checkContentReadyOption = (optionName) => !!contentReadyOptions[optionName];
    return this._checkContentReadyOption(fullName);
  }
  _getContentReadyOptions() {
    return ["rtlEnabled"];
  }
  _fireContentReady() {
    this._actionsMap.onContentReady({});
  }
  _getDefaultOptions() {
    const viewDefaultProps = this._getViewComponentDefaultProps();
    return extend(true, super._getDefaultOptions(), viewDefaultProps, this._propsInfo.twoWay.reduce((options2, _ref) => {
      let [name2, defaultName, eventName] = _ref;
      return _extends({}, options2, {
        [name2]: viewDefaultProps[defaultName],
        [eventName]: (value2) => this.option(name2, value2)
      });
    }, {}), this._propsInfo.templates.reduce((options2, name2) => _extends({}, options2, {
      [name2]: null
    }), {}));
  }
  _getUnwrappedOption() {
    const unwrappedProps = {};
    Object.keys(this.option()).forEach((key) => {
      unwrappedProps[key] = this.option(key);
    });
    return unwrappedProps;
  }
  _initializeComponent() {
    var _this$_templateManage;
    super._initializeComponent();
    null === (_this$_templateManage = this._templateManager) || void 0 === _this$_templateManage || _this$_templateManage.addDefaultTemplates(this.getDefaultTemplates());
    const optionProxy = this._getUnwrappedOption();
    this._props = this._optionsWithDefaultTemplates(optionProxy);
    this._propsInfo.templates.forEach((template) => {
      this._componentTemplates[template] = this._createTemplateComponent(this._props[template]);
    });
    Object.keys(this._getActionConfigsFull()).forEach((name2) => this._addAction(name2));
    this._viewRef = createRef();
    this.defaultKeyHandlers = this._createDefaultKeyHandlers();
  }
  _initMarkup() {
    const props = this.getProps();
    this._renderWrapper(props);
  }
  _renderWrapper(props) {
    const containerNode = this.$element()[0];
    if (!this._isNodeReplaced) {
      inferno_renderer_default.onPreRender();
    }
    inferno_renderer_default.render(this._viewComponent, props, containerNode, this._isNodeReplaced);
    if (!this._isNodeReplaced) {
      this._isNodeReplaced = true;
      inferno_renderer_default.onAfterRender();
      this._shouldRaiseContentReady = true;
    }
    if (this._shouldRaiseContentReady) {
      this._fireContentReady();
      this._shouldRaiseContentReady = false;
    }
  }
  _silent(name2, value2) {
    this._options.silent(name2, value2);
  }
  _render() {
  }
  _removeWidget() {
    inferno_renderer_default.remove(this.$element()[0]);
  }
  _dispose() {
    this._removeWidget();
    super._dispose();
  }
  get elementAttr() {
    const element = this.$element()[0];
    if (!this._elementAttr) {
      const {
        attributes
      } = element;
      const attrs = Array.from(attributes).filter((attr) => {
        var _attributes$attr$name;
        return !this._propsInfo.templates.includes(attr.name) && (null === (_attributes$attr$name = attributes[attr.name]) || void 0 === _attributes$attr$name ? void 0 : _attributes$attr$name.specified);
      }).reduce((result2, _ref2) => {
        let {
          name: name2,
          value: value2
        } = _ref2;
        const updatedAttributes = result2;
        const isDomAttr = name2 in element;
        updatedAttributes[name2] = "" === value2 && isDomAttr ? element[name2] : value2;
        return updatedAttributes;
      }, {});
      this._elementAttr = attrs;
      this._storedClasses = element.getAttribute("class") || "";
    }
    const elemStyle = element.style;
    const style = {};
    for (let i = 0; i < elemStyle.length; i += 1) {
      style[elemStyle[i]] = elemStyle.getPropertyValue(elemStyle[i]);
    }
    this._elementAttr.style = style;
    this._elementAttr.class = this._storedClasses;
    return this._elementAttr;
  }
  _getAdditionalActionConfigs() {
    return {
      onContentReady: {
        excludeValidators: ["disabled", "readOnly"]
      }
    };
  }
  _getAdditionalProps() {
    return [];
  }
  _patchOptionValues(options2) {
    const {
      allowNull,
      twoWay,
      elements,
      props
    } = this._propsInfo;
    const viewDefaultProps = this._getViewComponentDefaultProps();
    const defaultWidgetPropsKeys = Object.keys(viewDefaultProps);
    const defaultOptions4 = this._getDefaultOptions();
    const {
      ref,
      children,
      onKeyboardHandled
    } = options2;
    const onKeyDown = onKeyboardHandled ? (_, event_options) => {
      onKeyboardHandled(event_options);
    } : void 0;
    const widgetProps = {
      ref,
      children,
      onKeyDown
    };
    [...props, ...this._getAdditionalProps()].forEach((propName) => {
      if (Object.prototype.hasOwnProperty.call(options2, propName)) {
        widgetProps[propName] = options2[propName];
      }
    });
    allowNull.forEach(setDefaultOptionValue(widgetProps, () => null));
    defaultWidgetPropsKeys.forEach(setDefaultOptionValue(widgetProps, (name2) => defaultOptions4[name2]));
    twoWay.forEach((_ref3) => {
      let [name2, defaultName] = _ref3;
      setDefaultOptionValue(widgetProps, () => defaultOptions4[defaultName])(name2);
    });
    elements.forEach((name2) => {
      if (name2 in widgetProps) {
        const value2 = widgetProps[name2];
        if (isRenderer(value2)) {
          widgetProps[name2] = this._patchElementParam(value2);
        }
      }
    });
    return widgetProps;
  }
  getSupportedKeyNames() {
    return [];
  }
  prepareStyleProp(props) {
    if ("string" === typeof props.style) {
      return _extends({}, props, {
        style: {},
        cssText: props.style
      });
    }
    return props;
  }
  getProps() {
    const {
      elementAttr
    } = this.option();
    const options2 = this._patchOptionValues(_extends({}, this._props, {
      ref: this._viewRef,
      children: this._extractDefaultSlot(),
      aria: this._aria
    }));
    this._propsInfo.templates.forEach((template) => {
      options2[template] = this._componentTemplates[template];
    });
    return this.prepareStyleProp(_extends({}, options2, this.elementAttr, elementAttr, {
      className: [...(this.elementAttr.class ?? "").split(" "), ...((null === elementAttr || void 0 === elementAttr ? void 0 : elementAttr.class) ?? "").split(" ")].filter((c, i, a) => c && a.indexOf(c) === i).join(" ").trim(),
      class: ""
    }, this._actionsMap));
  }
  _getActionConfigs() {
    return {};
  }
  _getActionConfigsFull() {
    return _extends({}, this._getActionConfigs(), this._getAdditionalActionConfigs());
  }
  getDefaultTemplates() {
    const defaultTemplates = Object.values(this._templatesInfo);
    const result2 = {};
    defaultTemplates.forEach((template) => {
      result2[template] = "dx-renovation-template-mock";
    });
    return result2;
  }
  get _templatesInfo() {
    return {};
  }
  _optionsWithDefaultTemplates(options2) {
    const templateOptions = Object.entries(this._templatesInfo).reduce((result2, _ref4) => {
      let [templateName, templateValue] = _ref4;
      return _extends({}, result2, {
        [templateName]: options2[templateName] ?? templateValue
      });
    }, {});
    return _extends({}, options2, templateOptions);
  }
  _init() {
    super._init();
    this.customKeyHandlers = {};
    this._actionsMap = {};
    this._aria = {};
    this._componentTemplates = {};
  }
  _createDefaultKeyHandlers() {
    const result2 = {};
    const keys = this.getSupportedKeyNames();
    keys.forEach((key) => {
      result2[key] = (e) => this.viewRef.keyDown(m_keyboard_processor_default.createKeyDownOptions(e));
    });
    return result2;
  }
  _addAction(event, actionToAdd) {
    let action = actionToAdd;
    if (!action) {
      const actionByOption = this._createActionByOption(event, this._getActionConfigsFull()[event]);
      action = (actArgs) => {
        Object.keys(actArgs).forEach((name2) => {
          if (isDefined(actArgs[name2]) && dom_adapter_default.isNode(actArgs[name2])) {
            actArgs[name2] = getPublicElement(renderer_default(actArgs[name2]));
          }
        });
        return actionByOption(actArgs);
      };
    }
    this._actionsMap[event] = action;
  }
  _optionChanged(option) {
    const {
      name: name2,
      fullName,
      value: value2,
      previousValue
    } = option;
    updatePropsImmutable(this._props, this.option(), name2, fullName);
    if (this._propsInfo.templates.includes(name2) && value2 !== previousValue) {
      this._componentTemplates[name2] = this._createTemplateComponent(value2);
    }
    if (name2 && this._getActionConfigsFull()[name2]) {
      this._addAction(name2);
    }
    this._shouldRaiseContentReady = this._shouldRaiseContentReady || this._checkContentReadyOption(fullName);
    super._optionChanged(option);
    this._invalidate();
  }
  _validateOptions(options2) {
    return super._validateOptions(options2);
  }
  _extractDefaultSlot() {
    if (this.option("_hasAnonymousTemplateContent")) {
      return inferno_renderer_default.createElement(TemplateWrapper, {
        template: this._getTemplate(this._templateManager.anonymousTemplateName),
        transclude: true,
        renovated: true
      });
    }
    return null;
  }
  _createTemplateComponent(templateOption) {
    if (!templateOption) {
      return;
    }
    const template = this._getTemplate(templateOption);
    if (isString(template) && "dx-renovation-template-mock" === template) {
      return;
    }
    return (model) => inferno_renderer_default.createElement(TemplateWrapper, buildTemplateArgs(model, template));
  }
  _wrapKeyDownHandler(initialHandler) {
    return (options2) => {
      const {
        originalEvent,
        keyName,
        which
      } = options2;
      const keys = this.customKeyHandlers;
      const func = keys[keyName] || keys[which];
      if (void 0 !== func) {
        const handler = func.bind(this);
        const result2 = handler(originalEvent, options2);
        if (!result2) {
          originalEvent.cancel = true;
          return originalEvent;
        }
      }
      return null === initialHandler || void 0 === initialHandler ? void 0 : initialHandler(originalEvent, options2);
    };
  }
  _toPublicElement(element) {
    return getPublicElement(renderer_default(element));
  }
  _patchElementParam(value2) {
    try {
      const result2 = renderer_default(value2);
      const element = null === result2 || void 0 === result2 ? void 0 : result2.get(0);
      return null !== element && void 0 !== element && element.nodeType ? element : value2;
    } catch (error2) {
      return value2;
    }
  }
  focus() {
    const $root = this.$element();
    const hasFocus = $root.is(":focus") || $root.find(":focus").length > 0;
    if (hasFocus) {
      return;
    }
    if (this.option("focusStateEnabled")) {
      $root.focus();
    } else {
      var _focusableElements$;
      const focusableElements = $root.find("[tabindex]");
      null === (_focusableElements$ = focusableElements[0]) || void 0 === _focusableElements$ || _focusableElements$.focus();
    }
  }
  repaint() {
    this._isNodeReplaced = false;
    this._shouldRaiseContentReady = true;
    this._removeWidget();
    this._refresh();
  }
  _supportedKeys() {
    return _extends({}, this.defaultKeyHandlers, this.customKeyHandlers);
  }
  registerKeyHandler(key, handler) {
    this.customKeyHandlers[key] = handler;
  }
  setAria(name2, value2) {
    this._aria[name2] = value2;
    this._initMarkup();
  }
  _getViewComponentDefaultProps() {
    return this._viewComponent.defaultProps || {};
  }
};
ComponentWrapper.IS_RENOVATED_WIDGET = false;
ComponentWrapper.IS_RENOVATED_WIDGET = true;

// node_modules/devextreme/esm/__internal/core/r1/base_props.js
var BaseWidgetDefaultProps = {
  className: "",
  activeStateEnabled: false,
  disabled: false,
  focusStateEnabled: false,
  hoverStateEnabled: false,
  tabIndex: 0,
  visible: true
};

// node_modules/devextreme/esm/__internal/core/r1/config_context.js
var ConfigContext = createContext(void 0);

// node_modules/devextreme/esm/__internal/core/r1/config_provider.js
var ConfigProviderDefaultProps = {};
var ConfigProvider = class extends BaseInfernoComponent {
  constructor() {
    super(...arguments);
    this.__getterCache = {};
  }
  get config() {
    if (void 0 !== this.__getterCache.config) {
      return this.__getterCache.config;
    }
    return this.__getterCache.config = (() => ({
      rtlEnabled: this.props.rtlEnabled
    }))();
  }
  componentWillUpdate(nextProps) {
    if (this.props.rtlEnabled !== nextProps.rtlEnabled) {
      this.__getterCache.config = void 0;
    }
  }
  getChildContext() {
    return _extends({}, this.context, {
      [ConfigContext.id]: this.config || ConfigContext.defaultValue
    });
  }
  render() {
    return this.props.children;
  }
};
ConfigProvider.defaultProps = ConfigProviderDefaultProps;

// node_modules/devextreme/esm/__internal/core/r1/utils/render_utils.js
var combineClasses = (classesMap) => Object.keys(classesMap).filter((cssClass) => !!cssClass && classesMap[cssClass]).join(" ").split(" ").filter((cssClass, i, filteredClassesMap) => filteredClassesMap.indexOf(cssClass) === i).join(" ");

// node_modules/devextreme/esm/__internal/core/r1/utils/resolve_rtl.js
function resolveRtlEnabled(rtlProp, config3) {
  if (void 0 !== rtlProp) {
    return rtlProp;
  }
  if (void 0 !== (null === config3 || void 0 === config3 ? void 0 : config3.rtlEnabled)) {
    return config3.rtlEnabled;
  }
  return config_default().rtlEnabled;
}
function resolveRtlEnabledDefinition(rtlProp, config3) {
  const isPropDefined = isDefined(rtlProp);
  const onlyGlobalDefined = isDefined(config_default().rtlEnabled) && !isPropDefined && !isDefined(null === config3 || void 0 === config3 ? void 0 : config3.rtlEnabled);
  return isPropDefined && rtlProp !== (null === config3 || void 0 === config3 ? void 0 : config3.rtlEnabled) || onlyGlobalDefined;
}

// node_modules/devextreme/esm/__internal/core/r1/utils/subscribe_to_event.js
function subscribeToEvent(eventName) {
  return (element, handler, eventData2, namespace) => {
    const event = namespace ? addNamespace2(eventName, namespace) : eventName;
    if (handler) {
      m_events_engine_default.on(element, event, eventData2, handler);
      return () => {
        m_events_engine_default.off(element, event, handler);
      };
    }
    return;
  };
}
var subscribeToClickEvent = subscribeToEvent(CLICK_EVENT_NAME);
var subscribeToScrollEvent = subscribeToEvent(m_emitter_gesture_scroll_default.scroll);
var subscribeToScrollInitEvent = subscribeToEvent(m_emitter_gesture_scroll_default.init);
var subscribeToDXScrollStartEvent = subscribeToEvent(m_emitter_gesture_scroll_default.start);
var subscribeToDXScrollMoveEvent = subscribeToEvent(m_emitter_gesture_scroll_default.move);
var subscribeToDXScrollEndEvent = subscribeToEvent(m_emitter_gesture_scroll_default.end);
var subscribeToDXScrollStopEvent = subscribeToEvent(m_emitter_gesture_scroll_default.stop);
var subscribeToDXScrollCancelEvent = subscribeToEvent(m_emitter_gesture_scroll_default.cancel);
var subscribeToDXPointerDownEvent = subscribeToEvent(m_pointer_default.down);
var subscribeToDXPointerUpEvent = subscribeToEvent(m_pointer_default.up);
var subscribeToDXPointerMoveEvent = subscribeToEvent(m_pointer_default.move);
var subscribeToMouseEnterEvent = subscribeToEvent("mouseenter");
var subscribeToMouseLeaveEvent = subscribeToEvent("mouseleave");
var subscribeToKeyDownEvent = subscribeToEvent("keydown");
var subscribeToDxActiveEvent = subscribeToEvent("dxactive");
var subscribeToDxInactiveEvent = subscribeToEvent("dxinactive");
var subscribeToDxHoverStartEvent = subscribeToEvent("dxhoverstart");
var subscribeToDxHoverEndEvent = subscribeToEvent("dxhoverend");
var subscribeToDxFocusInEvent = subscribeToEvent("focusin");
var subscribeToDxFocusOutEvent = subscribeToEvent("focusout");

// node_modules/devextreme/esm/__internal/core/r1/widget.js
var WIDGET_CLASS2 = "dx-widget";
var getAria = (args) => Object.keys(args).reduce((r, key) => {
  if (args[key]) {
    return _extends({}, r, {
      ["role" === key || "id" === key ? key : `aria-${key}`]: String(args[key])
    });
  }
  return r;
}, {});
var WidgetDefaultProps = _extends({}, BaseWidgetDefaultProps, {
  _feedbackHideTimeout: 400,
  _feedbackShowTimeout: 30,
  cssText: "",
  aria: {},
  classes: "",
  name: "",
  addWidgetClass: true
});
var Widget2 = class extends InfernoWrapperComponent {
  constructor(props) {
    super(props);
    this.state = {
      active: false,
      focused: false,
      hovered: false
    };
    this.refs = null;
    this.rootElementRef = createRef();
    this.widgetElementRef = createRef();
    this.setRootElementRef = this.setRootElementRef.bind(this);
    this.activeEffect = this.activeEffect.bind(this);
    this.inactiveEffect = this.inactiveEffect.bind(this);
    this.clickEffect = this.clickEffect.bind(this);
    this.focus = this.focus.bind(this);
    this.blur = this.blur.bind(this);
    this.activate = this.activate.bind(this);
    this.deactivate = this.deactivate.bind(this);
    this.focusInEffect = this.focusInEffect.bind(this);
    this.focusOutEffect = this.focusOutEffect.bind(this);
    this.hoverStartEffect = this.hoverStartEffect.bind(this);
    this.hoverEndEffect = this.hoverEndEffect.bind(this);
    this.keyboardEffect = this.keyboardEffect.bind(this);
    this.resizeEffect = this.resizeEffect.bind(this);
    this.windowResizeEffect = this.windowResizeEffect.bind(this);
    this.visibilityEffect = this.visibilityEffect.bind(this);
    this.checkDeprecation = this.checkDeprecation.bind(this);
    this.applyCssTextEffect = this.applyCssTextEffect.bind(this);
  }
  componentWillUpdate(nextProps, nextState, context2) {
    super.componentWillUpdate(nextProps, nextState, context2);
  }
  getConfig() {
    if (this.context[ConfigContext.id]) {
      return this.context[ConfigContext.id];
    }
    return ConfigContext.defaultValue;
  }
  createEffects() {
    return [new InfernoEffect(this.setRootElementRef, []), new InfernoEffect(this.activeEffect, [this.props._feedbackShowTimeout, this.props.activeStateEnabled, this.props.activeStateUnit, this.props.disabled, this.props.onActive]), new InfernoEffect(this.inactiveEffect, [this.props._feedbackHideTimeout, this.props.activeStateEnabled, this.props.activeStateUnit, this.props.onInactive, this.state.active]), new InfernoEffect(this.clickEffect, [this.props.disabled, this.props.name, this.props.onClick]), new InfernoEffect(this.focusInEffect, [this.props.disabled, this.props.focusStateEnabled, this.props.name, this.props.onFocusIn]), new InfernoEffect(this.focusOutEffect, [this.props.focusStateEnabled, this.props.name, this.props.onFocusOut, this.state.focused]), new InfernoEffect(this.hoverStartEffect, [this.props.activeStateUnit, this.props.disabled, this.props.hoverStateEnabled, this.props.onHoverStart, this.state.active]), new InfernoEffect(this.hoverEndEffect, [this.props.activeStateUnit, this.props.hoverStateEnabled, this.props.onHoverEnd, this.state.hovered]), new InfernoEffect(this.keyboardEffect, [this.props.focusStateEnabled, this.props.onKeyDown]), new InfernoEffect(this.resizeEffect, [this.props.name, this.props.onDimensionChanged]), new InfernoEffect(this.windowResizeEffect, [this.props.onDimensionChanged]), new InfernoEffect(this.visibilityEffect, [this.props.name, this.props.onVisibilityChange]), new InfernoEffect(this.checkDeprecation, [this.props.height, this.props.width]), new InfernoEffect(this.applyCssTextEffect, [this.props.cssText]), createReRenderEffect()];
  }
  updateEffects() {
    var _this$_effects$, _this$_effects$2, _this$_effects$3, _this$_effects$4, _this$_effects$5, _this$_effects$6, _this$_effects$7, _this$_effects$8, _this$_effects$9, _this$_effects$10, _this$_effects$11, _this$_effects$12, _this$_effects$13;
    null === (_this$_effects$ = this._effects[1]) || void 0 === _this$_effects$ || _this$_effects$.update([this.props._feedbackShowTimeout, this.props.activeStateEnabled, this.props.activeStateUnit, this.props.disabled, this.props.onActive]);
    null === (_this$_effects$2 = this._effects[2]) || void 0 === _this$_effects$2 || _this$_effects$2.update([this.props._feedbackHideTimeout, this.props.activeStateEnabled, this.props.activeStateUnit, this.props.onInactive, this.state.active]);
    null === (_this$_effects$3 = this._effects[3]) || void 0 === _this$_effects$3 || _this$_effects$3.update([this.props.disabled, this.props.name, this.props.onClick]);
    null === (_this$_effects$4 = this._effects[4]) || void 0 === _this$_effects$4 || _this$_effects$4.update([this.props.disabled, this.props.focusStateEnabled, this.props.name, this.props.onFocusIn]);
    null === (_this$_effects$5 = this._effects[5]) || void 0 === _this$_effects$5 || _this$_effects$5.update([this.props.focusStateEnabled, this.props.name, this.props.onFocusOut, this.state.focused]);
    null === (_this$_effects$6 = this._effects[6]) || void 0 === _this$_effects$6 || _this$_effects$6.update([this.props.activeStateUnit, this.props.disabled, this.props.hoverStateEnabled, this.props.onHoverStart, this.state.active]);
    null === (_this$_effects$7 = this._effects[7]) || void 0 === _this$_effects$7 || _this$_effects$7.update([this.props.activeStateUnit, this.props.hoverStateEnabled, this.props.onHoverEnd, this.state.hovered]);
    null === (_this$_effects$8 = this._effects[8]) || void 0 === _this$_effects$8 || _this$_effects$8.update([this.props.focusStateEnabled, this.props.onKeyDown]);
    null === (_this$_effects$9 = this._effects[9]) || void 0 === _this$_effects$9 || _this$_effects$9.update([this.props.name, this.props.onDimensionChanged]);
    null === (_this$_effects$10 = this._effects[10]) || void 0 === _this$_effects$10 || _this$_effects$10.update([this.props.onDimensionChanged]);
    null === (_this$_effects$11 = this._effects[11]) || void 0 === _this$_effects$11 || _this$_effects$11.update([this.props.name, this.props.onVisibilityChange]);
    null === (_this$_effects$12 = this._effects[12]) || void 0 === _this$_effects$12 || _this$_effects$12.update([this.props.height, this.props.width]);
    null === (_this$_effects$13 = this._effects[13]) || void 0 === _this$_effects$13 || _this$_effects$13.update([this.props.cssText]);
  }
  setRootElementRef() {
    var _this$widgetElementRe;
    const {
      rootElementRef,
      onRootElementRendered
    } = this.props;
    if (rootElementRef && this.widgetElementRef) {
      rootElementRef.current = this.widgetElementRef.current;
    }
    if (null !== this && void 0 !== this && null !== (_this$widgetElementRe = this.widgetElementRef) && void 0 !== _this$widgetElementRe && _this$widgetElementRe.current) {
      null === onRootElementRendered || void 0 === onRootElementRendered || onRootElementRendered(this.widgetElementRef.current);
    }
  }
  activeEffect() {
    const {
      activeStateEnabled,
      activeStateUnit,
      disabled,
      _feedbackShowTimeout,
      onActive
    } = this.props;
    const selector = activeStateUnit;
    if (activeStateEnabled) {
      if (!disabled) {
        var _this$widgetElementRe2;
        return subscribeToDxActiveEvent(null === (_this$widgetElementRe2 = this.widgetElementRef) || void 0 === _this$widgetElementRe2 ? void 0 : _this$widgetElementRe2.current, (event) => {
          this.setState({
            active: true
          });
          null === onActive || void 0 === onActive || onActive(event);
        }, {
          timeout: _feedbackShowTimeout,
          selector
        }, "UIFeedback");
      }
    }
    return;
  }
  inactiveEffect() {
    const {
      activeStateEnabled,
      activeStateUnit,
      _feedbackHideTimeout,
      onInactive
    } = this.props;
    const selector = activeStateUnit;
    if (activeStateEnabled) {
      var _this$widgetElementRe3;
      return subscribeToDxInactiveEvent(null === (_this$widgetElementRe3 = this.widgetElementRef) || void 0 === _this$widgetElementRe3 ? void 0 : _this$widgetElementRe3.current, (event) => {
        if (this.state.active) {
          this.setState({
            active: false
          });
          null === onInactive || void 0 === onInactive || onInactive(event);
        }
      }, {
        timeout: _feedbackHideTimeout,
        selector
      }, "UIFeedback");
    }
    return;
  }
  clickEffect() {
    const {
      name: name2,
      onClick,
      disabled
    } = this.props;
    const namespace = name2;
    if (onClick && !disabled) {
      var _this$widgetElementRe4;
      dxClick.on(null === (_this$widgetElementRe4 = this.widgetElementRef) || void 0 === _this$widgetElementRe4 ? void 0 : _this$widgetElementRe4.current, onClick, {
        namespace
      });
      return () => {
        var _this$widgetElementRe5;
        return dxClick.off(null === (_this$widgetElementRe5 = this.widgetElementRef) || void 0 === _this$widgetElementRe5 ? void 0 : _this$widgetElementRe5.current, {
          namespace
        });
      };
    }
    return;
  }
  focusInEffect() {
    const {
      disabled,
      focusStateEnabled,
      name: name2,
      onFocusIn
    } = this.props;
    const namespace = `${name2}Focus`;
    if (focusStateEnabled) {
      if (!disabled) {
        var _this$widgetElementRe6;
        return subscribeToDxFocusInEvent(null === (_this$widgetElementRe6 = this.widgetElementRef) || void 0 === _this$widgetElementRe6 ? void 0 : _this$widgetElementRe6.current, (event) => {
          if (!event.isDefaultPrevented()) {
            this.setState({
              focused: true
            });
            null === onFocusIn || void 0 === onFocusIn || onFocusIn(event);
          }
        }, null, namespace);
      }
    }
    return;
  }
  focusOutEffect() {
    const {
      focusStateEnabled,
      name: name2,
      onFocusOut
    } = this.props;
    const namespace = `${name2}Focus`;
    if (focusStateEnabled) {
      var _this$widgetElementRe7;
      return subscribeToDxFocusOutEvent(null === (_this$widgetElementRe7 = this.widgetElementRef) || void 0 === _this$widgetElementRe7 ? void 0 : _this$widgetElementRe7.current, (event) => {
        if (!event.isDefaultPrevented() && this.state.focused) {
          this.setState({
            focused: false
          });
          null === onFocusOut || void 0 === onFocusOut || onFocusOut(event);
        }
      }, null, namespace);
    }
    return;
  }
  hoverStartEffect() {
    const {
      activeStateUnit,
      hoverStateEnabled,
      disabled,
      onHoverStart
    } = this.props;
    const selector = activeStateUnit;
    if (hoverStateEnabled) {
      if (!disabled) {
        var _this$widgetElementRe8;
        return subscribeToDxHoverStartEvent(null === (_this$widgetElementRe8 = this.widgetElementRef) || void 0 === _this$widgetElementRe8 ? void 0 : _this$widgetElementRe8.current, (event) => {
          if (!this.state.active) {
            this.setState({
              hovered: true
            });
          }
          null === onHoverStart || void 0 === onHoverStart || onHoverStart(event);
        }, {
          selector
        }, "UIFeedback");
      }
    }
    return;
  }
  hoverEndEffect() {
    const {
      activeStateUnit,
      hoverStateEnabled,
      onHoverEnd
    } = this.props;
    const selector = activeStateUnit;
    if (hoverStateEnabled) {
      var _this$widgetElementRe9;
      return subscribeToDxHoverEndEvent(null === (_this$widgetElementRe9 = this.widgetElementRef) || void 0 === _this$widgetElementRe9 ? void 0 : _this$widgetElementRe9.current, (event) => {
        if (this.state.hovered) {
          this.setState({
            hovered: false
          });
          null === onHoverEnd || void 0 === onHoverEnd || onHoverEnd(event);
        }
      }, {
        selector
      }, "UIFeedback");
    }
    return;
  }
  keyboardEffect() {
    const {
      onKeyDown,
      focusStateEnabled
    } = this.props;
    if (focusStateEnabled && onKeyDown) {
      var _this$widgetElementRe10, _this$widgetElementRe11;
      const id = keyboard.on(null === (_this$widgetElementRe10 = this.widgetElementRef) || void 0 === _this$widgetElementRe10 ? void 0 : _this$widgetElementRe10.current, null === (_this$widgetElementRe11 = this.widgetElementRef) || void 0 === _this$widgetElementRe11 ? void 0 : _this$widgetElementRe11.current, (e) => onKeyDown(e));
      return () => keyboard.off(id);
    }
    return;
  }
  resizeEffect() {
    const namespace = `${this.props.name}VisibilityChange`;
    const {
      onDimensionChanged
    } = this.props;
    if (onDimensionChanged) {
      var _this$widgetElementRe12;
      resize.on(null === (_this$widgetElementRe12 = this.widgetElementRef) || void 0 === _this$widgetElementRe12 ? void 0 : _this$widgetElementRe12.current, onDimensionChanged, {
        namespace
      });
      return () => {
        var _this$widgetElementRe13;
        return resize.off(null === (_this$widgetElementRe13 = this.widgetElementRef) || void 0 === _this$widgetElementRe13 ? void 0 : _this$widgetElementRe13.current, {
          namespace
        });
      };
    }
    return;
  }
  windowResizeEffect() {
    const {
      onDimensionChanged
    } = this.props;
    if (onDimensionChanged) {
      resize_callbacks_default.add(onDimensionChanged);
      return () => {
        resize_callbacks_default.remove(onDimensionChanged);
      };
    }
    return;
  }
  visibilityEffect() {
    const {
      name: name2,
      onVisibilityChange
    } = this.props;
    const namespace = `${name2}VisibilityChange`;
    if (onVisibilityChange) {
      var _this$widgetElementRe14;
      visibility.on(null === (_this$widgetElementRe14 = this.widgetElementRef) || void 0 === _this$widgetElementRe14 ? void 0 : _this$widgetElementRe14.current, () => onVisibilityChange(true), () => onVisibilityChange(false), {
        namespace
      });
      return () => {
        var _this$widgetElementRe15;
        return visibility.off(null === (_this$widgetElementRe15 = this.widgetElementRef) || void 0 === _this$widgetElementRe15 ? void 0 : _this$widgetElementRe15.current, {
          namespace
        });
      };
    }
    return;
  }
  checkDeprecation() {
    const {
      width,
      height
    } = this.props;
    if (isFunction(width)) {
      errors_default.log("W0017", "width");
    }
    if (isFunction(height)) {
      errors_default.log("W0017", "height");
    }
  }
  applyCssTextEffect() {
    var _this$widgetElementRe16;
    const {
      cssText
    } = this.props;
    if (void 0 !== cssText && "" !== cssText && null !== (_this$widgetElementRe16 = this.widgetElementRef) && void 0 !== _this$widgetElementRe16 && _this$widgetElementRe16.current) {
      this.widgetElementRef.current.style.cssText = cssText;
    }
  }
  getShouldRenderConfigProvider() {
    const {
      rtlEnabled
    } = this.props;
    return resolveRtlEnabledDefinition(rtlEnabled, this.config);
  }
  getRtlEnabled() {
    const {
      rtlEnabled
    } = this.props;
    return resolveRtlEnabled(rtlEnabled, this.config);
  }
  getAttributes() {
    const {
      aria,
      disabled,
      focusStateEnabled,
      visible: visible2
    } = this.props;
    const accessKey = focusStateEnabled && !disabled && this.props.accessKey;
    const props = _extends({}, extend({}, accessKey && {
      accessKey
    }), getAria(_extends({}, aria, {
      disabled,
      hidden: !visible2
    })), extend({}, this.getRestAttributes(this.props)));
    return props;
  }
  getRestAttributes(props) {
    const result2 = _extends({}, props);
    ["_feedbackHideTimeout", "_feedbackShowTimeout", "accessKey", "activeStateEnabled", "activeStateUnit", "addWidgetClass", "aria", "children", "className", "classes", "cssText", "disabled", "focusStateEnabled", "height", "hint", "hoverStateEnabled", "name", "onActive", "onClick", "onDimensionChanged", "onFocusIn", "onFocusOut", "onHoverEnd", "onHoverStart", "onInactive", "onKeyDown", "onRootElementRendered", "onVisibilityChange", "rootElementRef", "rtlEnabled", "tabIndex", "visible", "width"].forEach((exclude) => {
      delete result2[exclude];
    });
    return result2;
  }
  getStyles() {
    const {
      width,
      height
    } = this.props;
    const style = this.props.style || {};
    const computedWidth = normalizeStyleProp("width", isFunction(width) ? width() : width);
    const computedHeight = normalizeStyleProp("height", isFunction(height) ? height() : height);
    return _extends({}, style, {
      height: computedHeight ?? style.height,
      width: computedWidth ?? style.width
    });
  }
  getCssClasses() {
    const {
      classes,
      addWidgetClass,
      className,
      disabled,
      activeStateEnabled,
      focusStateEnabled,
      hoverStateEnabled,
      onVisibilityChange,
      visible: visible2
    } = this.props;
    const isFocusable = !!focusStateEnabled && !disabled;
    const isHoverable = !!hoverStateEnabled && !disabled;
    const canBeActive = !!activeStateEnabled && !disabled;
    const classesMap = {
      [WIDGET_CLASS2]: !!addWidgetClass,
      [String(classes)]: !!classes,
      [String(className)]: !!className,
      "dx-state-disabled": !!disabled,
      "dx-state-invisible": !visible2,
      "dx-state-focused": !!this.state.focused && isFocusable,
      "dx-state-active": !!this.state.active && canBeActive,
      "dx-state-hover": !!this.state.hovered && isHoverable && !this.state.active,
      "dx-rtl": !!this.props.rtlEnabled,
      "dx-visibility-change-handler": !!onVisibilityChange
    };
    return combineClasses(classesMap);
  }
  getTabIndex() {
    const {
      focusStateEnabled,
      disabled,
      tabIndex
    } = this.props;
    const isFocusable = focusStateEnabled && !disabled;
    return isFocusable ? tabIndex : void 0;
  }
  focus() {
    var _this$widgetElementRe17;
    focus.trigger(null === (_this$widgetElementRe17 = this.widgetElementRef) || void 0 === _this$widgetElementRe17 ? void 0 : _this$widgetElementRe17.current);
  }
  blur() {
    var _this$widgetElementRe18, _this$widgetElementRe19;
    const activeElement = dom_adapter_default.getActiveElement(null === (_this$widgetElementRe18 = this.widgetElementRef) || void 0 === _this$widgetElementRe18 ? void 0 : _this$widgetElementRe18.current);
    if ((null === (_this$widgetElementRe19 = this.widgetElementRef) || void 0 === _this$widgetElementRe19 ? void 0 : _this$widgetElementRe19.current) === activeElement) {
      activeElement.blur();
    }
  }
  activate() {
    this.setState({
      active: true
    });
  }
  deactivate() {
    this.setState({
      active: false
    });
  }
  render() {
    const {
      hint,
      children
    } = this.props;
    const widget = normalizeProps(createVNode(1, "div", this.getCssClasses(), children, 0, _extends({}, this.getAttributes(), {
      tabindex: this.getTabIndex(),
      title: hint,
      style: this.getStyles()
    }), null, this.widgetElementRef));
    return this.getShouldRenderConfigProvider() ? createComponentVNode(2, ConfigProvider, {
      rtlEnabled: this.getRtlEnabled(),
      children: widget
    }) : widget;
  }
};
Widget2.defaultProps = WidgetDefaultProps;

// node_modules/devextreme/esm/__internal/core/utils/combine_classes.js
function combineClasses2(classesMap) {
  return Object.keys(classesMap).filter((p2) => classesMap[p2]).join(" ");
}

// node_modules/devextreme/esm/__internal/ui/button/icon.js
var defaultIconProps = {
  position: "left",
  source: ""
};
var Icon = class extends BaseInfernoComponent {
  constructor(props) {
    super(props);
    this.state = {};
  }
  get sourceType() {
    return getImageSourceType(this.props.source);
  }
  get cssClass() {
    return "left" !== this.props.position ? "dx-icon-right" : "";
  }
  get iconClassName() {
    const generalClasses = {
      "dx-icon": true,
      [this.cssClass]: !!this.cssClass
    };
    const {
      source
    } = this.props;
    if ("dxIcon" === this.sourceType) {
      return combineClasses2(_extends({}, generalClasses, {
        [`dx-icon-${source}`]: true
      }));
    }
    if ("fontIcon" === this.sourceType) {
      return combineClasses2(_extends({}, generalClasses, {
        [String(source)]: !!source
      }));
    }
    if ("image" === this.sourceType) {
      return combineClasses2(generalClasses);
    }
    if ("svg" === this.sourceType) {
      return combineClasses2(_extends({}, generalClasses, {
        "dx-svg-icon": true
      }));
    }
    return "";
  }
  render() {
    const {
      iconClassName,
      props,
      sourceType
    } = this;
    const IconTemplate = getTemplate(props.iconTemplate);
    return createFragment(["dxIcon" === sourceType && createVNode(1, "i", iconClassName), "fontIcon" === sourceType && createVNode(1, "i", iconClassName), "image" === sourceType && createVNode(1, "img", iconClassName, null, 1, {
      alt: "",
      src: props.source
    }), IconTemplate && createVNode(1, "i", iconClassName, IconTemplate({}), 0)], 0);
  }
};
Icon.defaultProps = defaultIconProps;

// node_modules/devextreme/esm/__internal/ui/button/ink_ripple.js
var _excluded5 = ["config"];
var defaultInkRippleProps = {
  config: {}
};
var InkRipple = class extends BaseInfernoComponent {
  constructor(props) {
    super(props);
    this.__getterCache = {};
    this.state = {};
    this.hideWave = this.hideWave.bind(this);
    this.showWave = this.showWave.bind(this);
  }
  get getConfig() {
    if (void 0 === this.__getterCache.getConfig) {
      this.__getterCache.getConfig = initConfig(this.props.config);
    }
    return this.__getterCache.getConfig;
  }
  get restAttributes() {
    const _this$props = this.props, restProps = _objectWithoutPropertiesLoose(_this$props, _excluded5);
    return restProps;
  }
  hideWave(opts) {
    hideWave(this.getConfig, opts);
  }
  showWave(opts) {
    showWave(this.getConfig, opts);
  }
  componentWillUpdate(nextProps) {
    if (this.props.config !== nextProps.config) {
      this.__getterCache.getConfig = void 0;
    }
  }
  render() {
    return normalizeProps(createVNode(1, "div", "dx-inkripple", null, 1, _extends({}, this.restAttributes)));
  }
};
InkRipple.defaultProps = defaultInkRippleProps;

// node_modules/devextreme/esm/__internal/ui/button/button.js
var BUTTON_CLASS = "dx-button";
var stylingModes = ["outlined", "text", "contained"];
var buttonComponentProps = ["accessKey", "activeStateEnabled", "className", "disabled", "focusStateEnabled", "height", "hint", "hoverStateEnabled", "icon", "iconPosition", "iconTemplate", "onClick", "onKeyDown", "onSubmit", "pressed", "rtlEnabled", "stylingMode", "tabIndex", "template", "templateData", "text", "type", "useInkRipple", "useSubmitBehavior", "visible", "width"];
var getCssClasses2 = (model) => {
  const {
    icon,
    iconPosition,
    stylingMode,
    text,
    type: type2
  } = model;
  const isValidStylingMode = stylingMode && stylingModes.includes(stylingMode);
  const classesMap = {
    [BUTTON_CLASS]: true,
    [`dx-button-mode-${isValidStylingMode ? stylingMode : "contained"}`]: true,
    [`dx-button-${type2 ?? "normal"}`]: true,
    "dx-button-has-text": !!text,
    "dx-button-has-icon": !!icon,
    "dx-button-icon-right": "left" !== iconPosition
  };
  return combineClasses2(classesMap);
};
var omit = (obj, excludedKeys) => {
  const excludedSet = new Set(excludedKeys);
  return Object.keys(obj).reduce((result2, key) => {
    if (!excludedSet.has(key)) {
      result2[key] = obj[key];
    }
    return result2;
  }, {});
};
var defaultButtonProps = _extends({}, BaseWidgetDefaultProps, {
  activeStateEnabled: true,
  hoverStateEnabled: true,
  icon: "",
  iconPosition: "left",
  stylingMode: "contained",
  text: "",
  type: "normal",
  useInkRipple: false,
  useSubmitBehavior: false,
  templateData: {}
});
var defaultOptionRules = createDefaultOptionRules([{
  device: () => "desktop" === devices_default.real().deviceType && !devices_default.isSimulator(),
  options: {
    focusStateEnabled: true
  }
}, {
  device: () => isMaterial(current()),
  options: {
    useInkRipple: true
  }
}]);
var Button = class extends InfernoWrapperComponent {
  constructor(props) {
    super(props);
    this.contentRef = createRef();
    this.inkRippleRef = createRef();
    this.submitInputRef = createRef();
    this.widgetRef = createRef();
    this.__getterCache = {};
    this.state = {};
    this.focus = this.focus.bind(this);
    this.activate = this.activate.bind(this);
    this.deactivate = this.deactivate.bind(this);
    this.submitEffect = this.submitEffect.bind(this);
    this.onActive = this.onActive.bind(this);
    this.onInactive = this.onInactive.bind(this);
    this.onWidgetClick = this.onWidgetClick.bind(this);
    this.keyDown = this.keyDown.bind(this);
  }
  createEffects() {
    return [new InfernoEffect(this.submitEffect, [this.props.onSubmit, this.props.useSubmitBehavior]), createReRenderEffect()];
  }
  updateEffects() {
    var _this$_effects$;
    null === (_this$_effects$ = this._effects[0]) || void 0 === _this$_effects$ || _this$_effects$.update([this.props.onSubmit, this.props.useSubmitBehavior]);
  }
  submitEffect() {
    const {
      onSubmit,
      useSubmitBehavior
    } = this.props;
    const submitInput = this.submitInputRef.current;
    if (useSubmitBehavior && onSubmit) {
      click.on(submitInput, (event) => onSubmit({
        event,
        submitInput
      }), {
        namespace: "UIFeedback"
      });
      return () => click.off(submitInput, {
        namespace: "UIFeedback"
      });
    }
    return;
  }
  onActive(event) {
    if (this.props.useInkRipple) {
      var _this$inkRippleRef$cu;
      null === (_this$inkRippleRef$cu = this.inkRippleRef.current) || void 0 === _this$inkRippleRef$cu || _this$inkRippleRef$cu.showWave({
        element: this.contentRef.current,
        event
      });
    }
  }
  onInactive(event) {
    if (this.props.useInkRipple) {
      var _this$inkRippleRef$cu2;
      null === (_this$inkRippleRef$cu2 = this.inkRippleRef.current) || void 0 === _this$inkRippleRef$cu2 || _this$inkRippleRef$cu2.hideWave({
        element: this.contentRef.current,
        event
      });
    }
  }
  onWidgetClick(event) {
    const {
      onClick,
      useSubmitBehavior
    } = this.props;
    null === onClick || void 0 === onClick || onClick({
      event
    });
    if (useSubmitBehavior) {
      var _this$submitInputRef$;
      null === (_this$submitInputRef$ = this.submitInputRef.current) || void 0 === _this$submitInputRef$ || _this$submitInputRef$.click();
    }
  }
  keyDown(e) {
    const {
      onKeyDown
    } = this.props;
    const {
      keyName,
      originalEvent,
      which
    } = e;
    const result2 = null === onKeyDown || void 0 === onKeyDown ? void 0 : onKeyDown(e);
    if (null !== result2 && void 0 !== result2 && result2.cancel) {
      return result2;
    }
    if ("space" === keyName || "space" === which || "enter" === keyName || "enter" === which) {
      originalEvent.preventDefault();
      this.onWidgetClick(originalEvent);
    }
    return;
  }
  get aria() {
    const {
      icon,
      text
    } = this.props;
    let label = text ?? "";
    if (!text && icon) {
      const iconSource = getImageSourceType(icon);
      switch (iconSource) {
        case "image": {
          const notURLRegexp = /^(?!(?:https?:\/\/)|(?:ftp:\/\/)|(?:www\.))[^\s]+$/;
          const isPathToImage = !icon.includes("base64") && notURLRegexp.test(icon);
          label = isPathToImage ? icon.replace(/.+\/([^.]+)\..+$/, "$1") : "";
          break;
        }
        case "dxIcon":
          label = message_default.format(camelize2(icon, true)) || icon;
          break;
        case "fontIcon":
          label = icon;
          break;
        case "svg": {
          var _titleRegexp$exec;
          const titleRegexp = /<title>(.*?)<\/title>/;
          label = (null === (_titleRegexp$exec = titleRegexp.exec(icon)) || void 0 === _titleRegexp$exec ? void 0 : _titleRegexp$exec[1]) ?? "";
          break;
        }
      }
    }
    return _extends({
      role: "button"
    }, label ? {
      label
    } : {});
  }
  get cssClasses() {
    return getCssClasses2(this.props);
  }
  get iconSource() {
    return this.props.icon ?? "";
  }
  get inkRippleConfig() {
    if (void 0 === this.__getterCache.inkRippleConfig) {
      const {
        icon,
        text
      } = this.props;
      this.__getterCache.inkRippleConfig = !text && icon ? {
        isCentered: true,
        useHoldAnimation: false,
        waveSizeCoefficient: 1
      } : {};
    }
    return this.__getterCache.inkRippleConfig;
  }
  get buttonTemplateData() {
    const {
      icon,
      text,
      templateData
    } = this.props;
    return _extends({
      icon,
      text
    }, templateData);
  }
  get restAttributes() {
    const excludedKeys = [...buttonComponentProps, "children"];
    return omit(this.props, excludedKeys);
  }
  focus() {
    var _this$widgetRef$curre;
    null === (_this$widgetRef$curre = this.widgetRef.current) || void 0 === _this$widgetRef$curre || _this$widgetRef$curre.focus();
  }
  activate() {
    var _this$widgetRef$curre2;
    null === (_this$widgetRef$curre2 = this.widgetRef.current) || void 0 === _this$widgetRef$curre2 || _this$widgetRef$curre2.activate();
  }
  deactivate() {
    var _this$widgetRef$curre3;
    null === (_this$widgetRef$curre3 = this.widgetRef.current) || void 0 === _this$widgetRef$curre3 || _this$widgetRef$curre3.deactivate();
  }
  componentWillUpdate(nextProps) {
    super.componentWillUpdate();
    if (this.props.icon !== nextProps.icon || this.props.text !== nextProps.text) {
      this.__getterCache.inkRippleConfig = void 0;
    }
  }
  render() {
    const {
      children,
      iconPosition,
      text
    } = this.props;
    const ButtonTemplate = getTemplate(this.props.template);
    const IconTemplate = getTemplate(this.props.iconTemplate);
    const renderText = !this.props.template && !children && "" !== text;
    const isIconLeft = "left" === iconPosition;
    const iconComponent = !ButtonTemplate && !children && (this.iconSource || IconTemplate) && createComponentVNode(2, Icon, {
      source: this.iconSource,
      position: iconPosition,
      iconTemplate: IconTemplate
    });
    return normalizeProps(createComponentVNode(2, Widget2, _extends({
      accessKey: this.props.accessKey,
      activeStateEnabled: this.props.activeStateEnabled,
      aria: this.aria,
      className: this.props.className,
      classes: this.cssClasses,
      disabled: this.props.disabled,
      focusStateEnabled: this.props.focusStateEnabled,
      height: this.props.height,
      hint: this.props.hint,
      hoverStateEnabled: this.props.hoverStateEnabled,
      onActive: this.onActive,
      onClick: this.onWidgetClick,
      onInactive: this.onInactive,
      onKeyDown: this.keyDown,
      rtlEnabled: this.props.rtlEnabled,
      tabIndex: this.props.tabIndex,
      visible: this.props.visible,
      width: this.props.width
    }, this.restAttributes, {
      children: createVNode(1, "div", "dx-button-content", [ButtonTemplate ? ButtonTemplate({
        data: this.buttonTemplateData
      }) : children, isIconLeft && iconComponent, renderText && createVNode(1, "span", "dx-button-text", text, 0), !isIconLeft && iconComponent, this.props.useSubmitBehavior && createVNode(64, "input", "dx-button-submit-input", null, 1, {
        type: "submit",
        tabindex: -1
      }, null, this.submitInputRef), this.props.useInkRipple && createComponentVNode(2, InkRipple, {
        config: this.inkRippleConfig
      }, null, this.inkRippleRef)], 0, null, null, this.contentRef)
    }), null, this.widgetRef));
  }
};
Button.defaultProps = _extends({}, defaultButtonProps, convertRulesToOptions(defaultOptionRules));
var __defaultOptionRules = [];
function defaultOptions(rule) {
  __defaultOptionRules.push(rule);
  Button.defaultProps = Object.create(Object.prototype, Object.assign(Object.getOwnPropertyDescriptors(Button.defaultProps), Object.getOwnPropertyDescriptors(convertRulesToOptions(defaultOptionRules)), Object.getOwnPropertyDescriptors(convertRulesToOptions(__defaultOptionRules))));
}

// node_modules/devextreme/esm/__internal/ui/button/wrapper.js
var Button2 = class extends ComponentWrapper {
  get _validationGroupConfig() {
    return validation_engine_default.getGroupConfig(this._findGroup());
  }
  getDefaultTemplateNames() {
    return ["content"];
  }
  getSupportedKeyNames() {
    return ["space", "enter"];
  }
  getProps() {
    const props = super.getProps();
    props.onClick = (_ref) => {
      let {
        event
      } = _ref;
      this._clickAction({
        event,
        validationGroup: this._validationGroupConfig
      });
    };
    props.onKeyDown = this._wrapKeyDownHandler(props.onKeyDown);
    const iconType = getImageSourceType(props.icon);
    if ("svg" === iconType) {
      props.iconTemplate = this._createTemplateComponent(() => props.icon);
    }
    return props;
  }
  get viewRef() {
    return super.viewRef;
  }
  get _templatesInfo() {
    return {
      template: "content"
    };
  }
  _toggleActiveState(_, value2) {
    if (value2) {
      var _this$viewRef;
      null === (_this$viewRef = this.viewRef) || void 0 === _this$viewRef || _this$viewRef.activate();
    } else {
      var _this$viewRef2;
      null === (_this$viewRef2 = this.viewRef) || void 0 === _this$viewRef2 || _this$viewRef2.deactivate();
    }
  }
  _getSubmitAction() {
    let needValidate = true;
    let validationStatus = "valid";
    return this._createAction((_ref2) => {
      let {
        event,
        submitInput
      } = _ref2;
      if (needValidate) {
        const validationGroup = this._validationGroupConfig;
        if (void 0 !== validationGroup && "" !== validationGroup) {
          const validationResult = validationGroup.validate();
          validationStatus = validationResult.status;
          if ("pending" === validationResult.status) {
            needValidate = false;
            this.option("disabled", true);
            validationResult.complete.then((_ref3) => {
              let {
                status
              } = _ref3;
              this.option("disabled", false);
              validationStatus = status;
              if ("valid" === validationStatus) {
                submitInput.click();
              }
              needValidate = true;
            });
          }
        }
      }
      if ("valid" !== validationStatus) {
        event.preventDefault();
      }
      event.stopPropagation();
    });
  }
  _initializeComponent() {
    super._initializeComponent();
    this._addAction("onSubmit", this._getSubmitAction());
    this._clickAction = this._createClickAction();
  }
  _initMarkup() {
    super._initMarkup();
    const $content = this.$element().find(".dx-button-content").first();
    const $template = $content.children().filter(".dx-template-wrapper");
    const $input = $content.children().filter(".dx-button-submit-input");
    if ($template.length) {
      $template.addClass("dx-button-content");
      $template.append($input);
      $content.replaceWith($template);
    }
  }
  _patchOptionValues(options2) {
    return super._patchOptionValues(_extends({}, options2, {
      templateData: options2._templateData
    }));
  }
  _findGroup() {
    const $element = this.$element();
    const validationGroup = this.option("validationGroup");
    return void 0 !== validationGroup && "" !== validationGroup ? validationGroup : validation_engine_default.findGroup($element, this._modelByElement($element));
  }
  _createClickAction() {
    return this._createActionByOption("onClick", {
      excludeValidators: ["readOnly"]
    });
  }
  _optionChanged(option) {
    if ("onClick" === option.name) {
      this._clickAction = this._createClickAction();
    }
    super._optionChanged(option);
  }
  focus() {
    var _this$viewRef3;
    null === (_this$viewRef3 = this.viewRef) || void 0 === _this$viewRef3 || _this$viewRef3.focus();
  }
  activate() {
    var _this$viewRef4;
    null === (_this$viewRef4 = this.viewRef) || void 0 === _this$viewRef4 || _this$viewRef4.activate();
  }
  deactivate() {
    var _this$viewRef5;
    null === (_this$viewRef5 = this.viewRef) || void 0 === _this$viewRef5 || _this$viewRef5.deactivate();
  }
  _getActionConfigs() {
    return {
      onClick: {
        excludeValidators: ["readOnly"]
      },
      onSubmit: {}
    };
  }
  get _propsInfo() {
    return {
      twoWay: [],
      allowNull: [],
      elements: ["onSubmit"],
      templates: ["template", "iconTemplate"],
      props: buttonComponentProps
    };
  }
  get _viewComponent() {
    return Button;
  }
};
component_registrator_default("dxButton", Button2);
Button2.defaultOptions = defaultOptions;

// node_modules/devextreme/esm/__internal/ui/button/index.js
var button_default = Button2;

// node_modules/devextreme/esm/ui/button.js
var button_default2 = button_default;

// node_modules/devextreme/esm/__internal/ui/text_box/texteditor_button_collection/m_custom.js
var CustomButton = class extends TextEditorButton {
  _attachEvents(instance, $element) {
    const {
      editor
    } = this;
    m_events_engine_default.on($element, HOVERSTART, () => {
      editor.$element().addClass("dx-custom-button-hovered");
    });
    m_events_engine_default.on($element, HOVEREND, () => {
      editor.$element().removeClass("dx-custom-button-hovered");
    });
    m_events_engine_default.on($element, CLICK_EVENT_NAME, (e) => {
      e.stopPropagation();
    });
  }
  _create() {
    const {
      editor
    } = this;
    const $element = renderer_default("<div>");
    this._addToContainer($element);
    const instance = editor._createComponent($element, button_default2, _extends({}, this.options, {
      ignoreParentReadOnly: true,
      disabled: this._isDisabled(),
      integrationOptions: this._prepareIntegrationOptions(editor)
    }));
    return {
      $element,
      instance
    };
  }
  _prepareIntegrationOptions(editor) {
    return _extends({}, editor.option("integrationOptions"), {
      skipTemplates: ["content"]
    });
  }
  update() {
    const isUpdated = super.update();
    if (this.instance) {
      this.instance.option("disabled", this._isDisabled());
    }
    return isUpdated;
  }
  _isVisible() {
    const {
      visible: visible2
    } = this.editor.option();
    return !!visible2;
  }
  _isDisabled() {
    const isDefinedByUser = void 0 !== this.options.disabled;
    if (isDefinedByUser) {
      if (this.instance) {
        return this.instance.option("disabled");
      }
      return this.options.disabled;
    }
    const {
      readOnly
    } = this.editor.option();
    return readOnly;
  }
};

// node_modules/devextreme/esm/__internal/ui/text_box/texteditor_button_collection/m_index.js
function checkButtonInfo(buttonInfo) {
  (() => {
    if (!buttonInfo || "object" !== typeof buttonInfo || Array.isArray(buttonInfo)) {
      throw ui_errors_default.Error("E1053");
    }
  })();
  (() => {
    if (!("name" in buttonInfo)) {
      throw ui_errors_default.Error("E1054");
    }
  })();
  (() => {
    const {
      name: name2
    } = buttonInfo;
    if ("string" !== typeof name2) {
      throw ui_errors_default.Error("E1055");
    }
  })();
  (() => {
    const {
      location
    } = buttonInfo;
    if ("location" in buttonInfo && "after" !== location && "before" !== location) {
      buttonInfo.location = "after";
    }
  })();
}
function checkNamesUniqueness(existingNames, newName) {
  if (existingNames.includes(newName)) {
    throw ui_errors_default.Error("E1055", newName);
  }
  existingNames.push(newName);
}
function isPredefinedButtonName(name2, predefinedButtonsInfo) {
  return !!predefinedButtonsInfo.find((info) => info.name === name2);
}
var TextEditorButtonCollection = class {
  constructor(editor, defaultButtonsInfo) {
    this.buttons = [];
    this.defaultButtonsInfo = defaultButtonsInfo;
    this.editor = editor;
  }
  _compileButtonInfo(buttons) {
    const names = [];
    return buttons.map((button) => {
      const isStringButton = "string" === typeof button;
      if (!isStringButton) {
        checkButtonInfo(button);
      }
      const isDefaultButton = isStringButton || isPredefinedButtonName(button.name, this.defaultButtonsInfo);
      if (isDefaultButton) {
        const defaultButtonInfo = this.defaultButtonsInfo.find((_ref) => {
          let {
            name: name3
          } = _ref;
          return name3 === button || name3 === button.name;
        });
        if (!defaultButtonInfo) {
          throw ui_errors_default.Error("E1056", this.editor.NAME, button);
        }
        checkNamesUniqueness(names, button);
        return defaultButtonInfo;
      }
      const {
        name: name2
      } = button;
      checkNamesUniqueness(names, name2);
      return _extends({}, button, {
        Ctor: CustomButton
      });
    });
  }
  _createButton(buttonsInfo) {
    const {
      Ctor,
      options: options2,
      name: name2
    } = buttonsInfo;
    const button = new Ctor(name2, this.editor, options2);
    this.buttons.push(button);
    return button;
  }
  _renderButtons(buttons, $container, targetLocation) {
    let $buttonsContainer = null;
    const buttonsInfo = buttons ? this._compileButtonInfo(buttons) : this.defaultButtonsInfo;
    buttonsInfo.forEach((buttonInfo) => {
      const {
        location = "after"
      } = buttonInfo;
      if (location === targetLocation) {
        this._createButton(buttonInfo).render((() => {
          $buttonsContainer = $buttonsContainer ?? renderer_default("<div>").addClass("dx-texteditor-buttons-container");
          if ("before" === targetLocation) {
            $container.prepend($buttonsContainer);
          } else {
            $container.append($buttonsContainer);
          }
          return $buttonsContainer;
        })());
      }
    });
    return $buttonsContainer;
  }
  clean() {
    this.buttons.forEach((button) => button.dispose());
    this.buttons = [];
  }
  getButton(buttonName) {
    const button = this.buttons.find((_ref2) => {
      let {
        name: name2
      } = _ref2;
      return name2 === buttonName;
    });
    return null === button || void 0 === button ? void 0 : button.instance;
  }
  renderAfterButtons(buttons, $container) {
    return this._renderButtons(buttons, $container, "after");
  }
  renderBeforeButtons(buttons, $container) {
    return this._renderButtons(buttons, $container, "before");
  }
  updateButtons(names) {
    this.buttons.forEach((button) => {
      if (!names || names.includes(button.name)) {
        button.update();
      }
    });
  }
};

// node_modules/devextreme/esm/__internal/ui/text_box/m_text_editor.base.js
var TEXTEDITOR_CLASS = "dx-texteditor";
var TEXTEDITOR_INPUT_CLASS = "dx-texteditor-input";
var EVENTS_LIST = ["KeyDown", "KeyPress", "KeyUp", "Change", "Cut", "Copy", "Paste", "Input"];
var CONTROL_KEYS = ["tab", "enter", "shift", "control", "alt", "escape", "pageUp", "pageDown", "end", "home", "leftArrow", "upArrow", "rightArrow", "downArrow"];
var TextEditorLabelCreator = TextEditorLabel;
function checkButtonsOptionType(buttons) {
  if (isDefined(buttons) && !Array.isArray(buttons)) {
    throw ui_errors_default.Error("E1053");
  }
}
var TextEditorBase = class extends editor_default {
  ctor(element, options2) {
    if (options2) {
      checkButtonsOptionType(options2.buttons);
    }
    this._buttonCollection = new TextEditorButtonCollection(this, this._getDefaultButtons());
    this._$beforeButtonsContainer = null;
    this._$afterButtonsContainer = null;
    this._labelContainerElement = null;
    super.ctor(element, options2);
  }
  _getDefaultOptions() {
    return _extends({}, super._getDefaultOptions(), {
      buttons: void 0,
      value: "",
      spellcheck: false,
      showClearButton: false,
      valueChangeEvent: "change",
      placeholder: "",
      inputAttr: {},
      onFocusIn: null,
      onFocusOut: null,
      onKeyDown: null,
      onKeyUp: null,
      onChange: null,
      onInput: null,
      onCut: null,
      onCopy: null,
      onPaste: null,
      onEnterKey: null,
      mode: "text",
      hoverStateEnabled: true,
      focusStateEnabled: true,
      text: void 0,
      displayValueFormatter: (value2) => isDefined(value2) && false !== value2 ? value2 : "",
      stylingMode: config_default2().editorStylingMode || "outlined",
      showValidationMark: true,
      label: "",
      labelMode: "static",
      labelMark: ""
    });
  }
  _defaultOptionsRules() {
    return super._defaultOptionsRules().concat([{
      device() {
        const themeName = current();
        return isMaterial(themeName);
      },
      options: {
        labelMode: "floating",
        stylingMode: config_default2().editorStylingMode || "filled"
      }
    }, {
      device() {
        const themeName = current();
        return isFluent(themeName);
      },
      options: {
        labelMode: "outside"
      }
    }]);
  }
  _getDefaultButtons() {
    return [{
      name: "clear",
      Ctor: ClearButton
    }];
  }
  _isClearButtonVisible() {
    return this.option("showClearButton") && !this.option("readOnly");
  }
  _input() {
    return this.$element().find(".dx-texteditor-input").first();
  }
  _isFocused() {
    return focused(this._input()) || super._isFocused();
  }
  _inputWrapper() {
    return this.$element();
  }
  _buttonsContainer() {
    return this._inputWrapper().find(".dx-texteditor-buttons-container").eq(0);
  }
  _isControlKey(key) {
    return CONTROL_KEYS.includes(key);
  }
  _renderStylingMode() {
    super._renderStylingMode();
    const {
      stylingMode
    } = this.option();
    this._updateButtonsStyling(stylingMode);
  }
  _initMarkup() {
    this.$element().addClass("dx-texteditor");
    this._renderInput();
    this._renderButtonContainers();
    this._renderStylingMode();
    this._renderInputType();
    this._renderPlaceholder();
    this._renderProps();
    super._initMarkup();
    this._renderValue();
    this._renderLabel();
  }
  _render() {
    super._render();
    this._refreshValueChangeEvent();
    this._refreshEvents();
    this._renderEnterKeyAction();
    this._renderEmptinessEvent();
  }
  _renderInput() {
    this._$textEditorContainer = renderer_default("<div>").addClass("dx-texteditor-container").appendTo(this.$element());
    this._$textEditorInputContainer = renderer_default("<div>").addClass("dx-texteditor-input-container").appendTo(this._$textEditorContainer);
    this._$textEditorInputContainer.append(this._createInput());
  }
  _getInputContainer() {
    return this._$textEditorInputContainer;
  }
  _renderPendingIndicator() {
    this.$element().addClass("dx-validation-pending");
    const $inputContainer = this._getInputContainer();
    const $indicatorElement = renderer_default("<div>").addClass("dx-pending-indicator").appendTo($inputContainer);
    this._pendingIndicator = this._createComponent($indicatorElement, load_indicator_default);
  }
  _disposePendingIndicator() {
    if (!this._pendingIndicator) {
      return;
    }
    this._pendingIndicator.dispose();
    this._pendingIndicator.$element().remove();
    this._pendingIndicator = null;
    this.$element().removeClass("dx-validation-pending");
  }
  _renderValidationState() {
    super._renderValidationState();
    const isPending2 = "pending" === this.option("validationStatus");
    if (isPending2) {
      if (!this._pendingIndicator) {
        this._renderPendingIndicator();
      }
      this._showValidMark = false;
    } else {
      if ("invalid" === this.option("validationStatus")) {
        this._showValidMark = false;
      }
      if (!this._showValidMark && true === this.option("showValidationMark")) {
        this._showValidMark = "valid" === this.option("validationStatus") && !!this._pendingIndicator;
      }
      this._disposePendingIndicator();
    }
    this._toggleValidMark();
  }
  _getButtonsContainer() {
    return this._$textEditorContainer;
  }
  _renderButtonContainers() {
    const {
      buttons
    } = this.option();
    const $buttonsContainer = this._getButtonsContainer();
    this._$beforeButtonsContainer = this._buttonCollection.renderBeforeButtons(buttons, $buttonsContainer);
    this._$afterButtonsContainer = this._buttonCollection.renderAfterButtons(buttons, $buttonsContainer);
  }
  _cleanButtonContainers() {
    var _this$_$beforeButtons, _this$_$afterButtonsC;
    null === (_this$_$beforeButtons = this._$beforeButtonsContainer) || void 0 === _this$_$beforeButtons || _this$_$beforeButtons.remove();
    null === (_this$_$afterButtonsC = this._$afterButtonsContainer) || void 0 === _this$_$afterButtonsC || _this$_$afterButtonsC.remove();
    this._buttonCollection.clean();
  }
  _clean() {
    this._buttonCollection.clean();
    this._disposePendingIndicator();
    this._unobserveLabelContainerResize();
    this._$beforeButtonsContainer = null;
    this._$afterButtonsContainer = null;
    this._$textEditorContainer = null;
    super._clean();
  }
  _createInput() {
    const $input = renderer_default("<input>");
    this._applyInputAttributes($input, this.option("inputAttr"));
    return $input;
  }
  _setSubmitElementName(name2) {
    const {
      inputAttr
    } = this.option();
    super._setSubmitElementName(name2 || (null === inputAttr || void 0 === inputAttr ? void 0 : inputAttr.name) || "");
  }
  _applyInputAttributes($input) {
    let customAttributes = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    const inputAttributes = extend(this._getDefaultAttributes(), customAttributes);
    $input.attr(inputAttributes).addClass("dx-texteditor-input");
    this._setInputMinHeight($input);
  }
  _setInputMinHeight($input) {
    $input.css("minHeight", this.option("height") ? "0" : "");
  }
  _getPlaceholderAttr() {
    const {
      ios: ios2,
      mac: mac2
    } = devices_default.real();
    const {
      placeholder
    } = this.option();
    const value2 = placeholder || (ios2 || mac2 ? " " : null);
    return value2;
  }
  _getDefaultAttributes() {
    const defaultAttributes = {
      autocomplete: "off",
      placeholder: this._getPlaceholderAttr()
    };
    return defaultAttributes;
  }
  _updateButtons(names) {
    this._buttonCollection.updateButtons(names);
  }
  _updateButtonsStyling(editorStylingMode) {
    each(this.option("buttons"), (_, _ref) => {
      let {
        options: options2,
        name: buttonName
      } = _ref;
      if (options2 && !options2.stylingMode && this.option("visible")) {
        const buttonInstance = this.getButton(buttonName);
        if (null !== buttonInstance && void 0 !== buttonInstance && buttonInstance.option) {
          buttonInstance.option("stylingMode", "underlined" === editorStylingMode ? "text" : "contained");
        }
      }
    });
  }
  _renderValue() {
    const renderInputPromise = this._renderInputValue();
    return renderInputPromise.promise();
  }
  _renderInputValue(value2) {
    value2 = value2 ?? this.option("value");
    const {
      text,
      displayValue,
      displayValueFormatter
    } = this.option();
    let textValue = text;
    if (void 0 !== displayValue && null !== value2) {
      textValue = null === displayValueFormatter || void 0 === displayValueFormatter ? void 0 : displayValueFormatter(displayValue);
    } else if (!isDefined(textValue)) {
      textValue = null === displayValueFormatter || void 0 === displayValueFormatter ? void 0 : displayValueFormatter(value2);
    }
    this.option("text", textValue);
    if (this._input().val() !== (isDefined(textValue) ? textValue : "")) {
      this._renderDisplayText(textValue);
    } else {
      this._toggleEmptinessEventHandler();
    }
    return Deferred().resolve();
  }
  _renderDisplayText(text) {
    this._input().val(text);
    this._toggleEmptinessEventHandler();
  }
  _isValueValid() {
    if (this._input().length) {
      const {
        validity
      } = this._input().get(0);
      if (validity) {
        return validity.valid;
      }
    }
    return true;
  }
  _toggleEmptiness(isEmpty3) {
    this.$element().toggleClass("dx-texteditor-empty", isEmpty3);
    this._togglePlaceholder(isEmpty3);
  }
  _togglePlaceholder(isEmpty3) {
    this.$element().find(".dx-placeholder").eq(0).toggleClass("dx-state-invisible", !isEmpty3);
  }
  _renderProps() {
    this._toggleReadOnlyState();
    this._toggleSpellcheckState();
    this._toggleTabIndex();
  }
  _toggleDisabledState(value2) {
    super._toggleDisabledState(value2);
    const $input = this._input();
    $input.prop("disabled", value2);
  }
  _toggleTabIndex() {
    const $input = this._input();
    const disabled = this.option("disabled");
    const focusStateEnabled = this.option("focusStateEnabled");
    if (disabled || !focusStateEnabled) {
      $input.attr("tabIndex", -1);
    } else {
      $input.removeAttr("tabIndex");
    }
  }
  _toggleReadOnlyState() {
    this._input().prop("readOnly", this._readOnlyPropValue());
    super._toggleReadOnlyState();
  }
  _readOnlyPropValue() {
    const {
      readOnly
    } = this.option();
    return !!readOnly;
  }
  _toggleSpellcheckState() {
    const {
      spellcheck
    } = this.option();
    this._input().prop("spellcheck", spellcheck);
  }
  _unobserveLabelContainerResize() {
    if (this._labelContainerElement) {
      resize_observer_default.unobserve(this._labelContainerElement);
      this._labelContainerElement = null;
    }
  }
  _getLabelContainer() {
    return this._input();
  }
  _getLabelContainerWidth() {
    return getWidth(this._getLabelContainer());
  }
  _getLabelBeforeWidth() {
    const buttonsBeforeWidth = this._$beforeButtonsContainer && getWidth(this._$beforeButtonsContainer);
    return buttonsBeforeWidth ?? 0;
  }
  _updateLabelWidth() {
    this._label.updateBeforeWidth(this._getLabelBeforeWidth());
    this._label.updateMaxWidth(this._getLabelContainerWidth());
  }
  _getFieldElement() {
    return this._getLabelContainer();
  }
  _setFieldAria(force) {
    var _this$_label;
    const inputAttr = this.option("inputAttr");
    const ariaLabel = null === inputAttr || void 0 === inputAttr ? void 0 : inputAttr["aria-label"];
    const labelId = null === (_this$_label = this._label) || void 0 === _this$_label ? void 0 : _this$_label.getId();
    const value2 = ariaLabel ? void 0 : labelId;
    if (value2 || force) {
      const aria = {
        labelledby: value2,
        label: ariaLabel
      };
      this.setAria(aria, this._getFieldElement());
    }
  }
  _renderLabel() {
    this._unobserveLabelContainerResize();
    this._labelContainerElement = renderer_default(this._getLabelContainer()).get(0);
    const {
      label,
      labelMode,
      labelMark,
      rtlEnabled
    } = this.option();
    const labelConfig = {
      onClickHandler: () => {
        this.focus();
      },
      onHoverHandler: (e) => {
        e.stopPropagation();
      },
      onActiveHandler: (e) => {
        e.stopPropagation();
      },
      $editor: this.$element(),
      text: label,
      mark: labelMark,
      mode: labelMode,
      rtlEnabled,
      containsButtonsBefore: !!this._$beforeButtonsContainer,
      getContainerWidth: () => this._getLabelContainerWidth(),
      getBeforeWidth: () => this._getLabelBeforeWidth()
    };
    this._label = new TextEditorLabelCreator(labelConfig);
    this._setFieldAria();
    if (this._labelContainerElement) {
      resize_observer_default.observe(this._labelContainerElement, this._updateLabelWidth.bind(this));
    }
  }
  _renderPlaceholder() {
    this._renderPlaceholderMarkup();
    this._attachPlaceholderEvents();
  }
  _renderPlaceholderMarkup() {
    if (this._$placeholder) {
      this._$placeholder.remove();
      this._$placeholder = null;
    }
    const $input = this._input();
    const placeholder = this.option("placeholder");
    const placeholderAttributes = {
      id: placeholder ? `dx-${new guid_default2()}` : void 0,
      "data-dx_placeholder": placeholder
    };
    const $placeholder = this._$placeholder = renderer_default("<div>").attr(placeholderAttributes);
    $placeholder.insertAfter($input);
    $placeholder.addClass("dx-placeholder");
  }
  _attachPlaceholderEvents() {
    const startEvent = addNamespace2(m_pointer_default.up, this.NAME);
    m_events_engine_default.on(this._$placeholder, startEvent, () => {
      m_events_engine_default.trigger(this._input(), "focus");
    });
    this._toggleEmptinessEventHandler();
  }
  _placeholder() {
    return this._$placeholder ?? renderer_default();
  }
  _clearValueHandler(e) {
    const $input = this._input();
    e.stopPropagation();
    this._saveValueChangeEvent(e);
    this._clearValue();
    if (!this._isFocused()) {
      m_events_engine_default.trigger($input, "focus");
    }
    m_events_engine_default.trigger($input, "input");
  }
  _clearValue() {
    this.clear();
  }
  _renderEvents() {
    const $input = this._input();
    each(EVENTS_LIST, (_, event) => {
      if (this.hasActionSubscription(`on${event}`)) {
        const action = this._createActionByOption(`on${event}`, {
          excludeValidators: ["readOnly"]
        });
        m_events_engine_default.on($input, addNamespace2(event.toLowerCase(), this.NAME), (e) => {
          if (this._disposed) {
            return;
          }
          action({
            event: e
          });
        });
      }
    });
  }
  _refreshEvents() {
    const $input = this._input();
    each(EVENTS_LIST, (_, event) => {
      m_events_engine_default.off($input, addNamespace2(event.toLowerCase(), this.NAME));
    });
    this._renderEvents();
  }
  _keyPressHandler(e) {
    this.option("text", this._input().val());
  }
  _keyDownHandler(e) {
    const $input = this._input();
    const isCtrlEnter = e.ctrlKey && "enter" === normalizeKeyName(e);
    const {
      value: value2
    } = this.option();
    const isNewValue = $input.val() !== value2;
    if (isCtrlEnter && isNewValue) {
      m_events_engine_default.trigger($input, "change");
    }
  }
  _getValueChangeEventOptionName() {
    return "valueChangeEvent";
  }
  _renderValueChangeEvent() {
    const keyPressEvent = addNamespace2(this._renderValueEventName(), `${this.NAME}TextChange`);
    const valueChangeEvent = addNamespace2(this.option(this._getValueChangeEventOptionName()), `${this.NAME}ValueChange`);
    const keyDownEvent = addNamespace2("keydown", `${this.NAME}TextChange`);
    const $input = this._input();
    m_events_engine_default.on($input, keyPressEvent, this._keyPressHandler.bind(this));
    m_events_engine_default.on($input, valueChangeEvent, this._valueChangeEventHandler.bind(this));
    m_events_engine_default.on($input, keyDownEvent, this._keyDownHandler.bind(this));
  }
  _cleanValueChangeEvent() {
    const valueChangeNamespace = `.${this.NAME}ValueChange`;
    const textChangeNamespace = `.${this.NAME}TextChange`;
    m_events_engine_default.off(this._input(), valueChangeNamespace);
    m_events_engine_default.off(this._input(), textChangeNamespace);
  }
  _refreshValueChangeEvent() {
    this._cleanValueChangeEvent();
    this._renderValueChangeEvent();
  }
  _renderValueEventName() {
    return "input change keypress";
  }
  _focusTarget() {
    return this._input();
  }
  _focusEventTarget() {
    return this.element();
  }
  _isInput(element) {
    return element === this._input().get(0);
  }
  _preventNestedFocusEvent(event) {
    if (event.isDefaultPrevented()) {
      return true;
    }
    let shouldPrevent = this._isNestedTarget(event.relatedTarget);
    if ("focusin" === event.type) {
      shouldPrevent = shouldPrevent && this._isNestedTarget(event.target) && !this._isInput(event.target);
    } else if (!shouldPrevent) {
      this._toggleFocusClass(false, this.$element());
    }
    if (shouldPrevent) {
      event.preventDefault();
    }
    return shouldPrevent;
  }
  _isNestedTarget(target) {
    return !!this.$element().find(target).length;
  }
  _focusClassTarget($element) {
    return this.$element();
  }
  _focusInHandler(event) {
    this._preventNestedFocusEvent(event);
    super._focusInHandler(event);
  }
  _focusOutHandler(event) {
    this._preventNestedFocusEvent(event);
    super._focusOutHandler(event);
  }
  _toggleFocusClass(isFocused, $element) {
    super._toggleFocusClass(isFocused, this._focusClassTarget($element));
  }
  _hasFocusClass(element) {
    return super._hasFocusClass(renderer_default(element || this.$element()));
  }
  _renderEmptinessEvent() {
    const $input = this._input();
    m_events_engine_default.on($input, "input blur", this._toggleEmptinessEventHandler.bind(this));
  }
  _toggleEmptinessEventHandler() {
    const text = this._input().val();
    const isEmpty3 = ("" === text || null === text) && this._isValueValid();
    this._toggleEmptiness(isEmpty3);
  }
  _valueChangeEventHandler(e, formattedValue) {
    if (this.option("readOnly")) {
      return;
    }
    this._saveValueChangeEvent(e);
    this.option("value", arguments.length > 1 ? formattedValue : this._input().val());
    this._saveValueChangeEvent(void 0);
  }
  _renderEnterKeyAction() {
    this._enterKeyAction = this._createActionByOption("onEnterKey", {
      excludeValidators: ["readOnly"]
    });
    m_events_engine_default.off(this._input(), "keyup.onEnterKey.dxTextEditor");
    m_events_engine_default.on(this._input(), "keyup.onEnterKey.dxTextEditor", this._enterKeyHandlerUp.bind(this));
  }
  _enterKeyHandlerUp(e) {
    if (this._disposed) {
      return;
    }
    if ("enter" === normalizeKeyName(e)) {
      var _this$_enterKeyAction;
      null === (_this$_enterKeyAction = this._enterKeyAction) || void 0 === _this$_enterKeyAction || _this$_enterKeyAction.call(this, {
        event: e
      });
    }
  }
  _updateValue() {
    this._options.silent("text", null);
    this._renderValue();
  }
  _dispose() {
    this._enterKeyAction = void 0;
    super._dispose();
  }
  _getSubmitElement() {
    return this._input();
  }
  _hasActiveElement() {
    return this._input().is(dom_adapter_default.getActiveElement(this._input()[0]));
  }
  _optionChanged(args) {
    const {
      name: name2,
      fullName,
      value: value2
    } = args;
    const eventName = name2.replace("on", "");
    if (EVENTS_LIST.includes(eventName)) {
      this._refreshEvents();
      return;
    }
    switch (name2) {
      case "valueChangeEvent":
        this._refreshValueChangeEvent();
        this._refreshFocusEvent();
        this._refreshEvents();
        break;
      case "onValueChanged":
        this._createValueChangeAction();
        break;
      case "focusStateEnabled":
        super._optionChanged(args);
        this._toggleTabIndex();
        break;
      case "spellcheck":
        this._toggleSpellcheckState();
        break;
      case "mode":
        this._renderInputType();
        break;
      case "onEnterKey":
        this._renderEnterKeyAction();
        break;
      case "placeholder":
        this._renderPlaceholder();
        this._setFieldAria(true);
        this._input().attr({
          placeholder: this._getPlaceholderAttr()
        });
        break;
      case "label":
        this._label.updateText(value2);
        this._setFieldAria(true);
        break;
      case "labelMark":
        this._label.updateMark(value2);
        break;
      case "labelMode":
        this._label.updateMode(value2);
        this._setFieldAria();
        break;
      case "width":
        super._optionChanged(args);
        this._label.updateMaxWidth(this._getLabelContainerWidth());
        break;
      case "readOnly":
      case "disabled":
        this._updateButtons();
        super._optionChanged(args);
        break;
      case "showClearButton":
        this._updateButtons(["clear"]);
        break;
      case "text":
      case "showValidationMark":
        break;
      case "value":
        this._updateValue();
        super._optionChanged(args);
        break;
      case "inputAttr":
        this._applyInputAttributes(this._input(), this.option(name2));
        break;
      case "stylingMode":
        this._renderStylingMode();
        this._updateLabelWidth();
        break;
      case "buttons": {
        if (fullName === name2) {
          checkButtonsOptionType(value2);
        }
        this._cleanButtonContainers();
        this._renderButtonContainers();
        const {
          stylingMode
        } = this.option();
        this._updateButtonsStyling(stylingMode);
        this._updateLabelWidth();
        this._label.updateContainsButtonsBefore(!!this._$beforeButtonsContainer);
        break;
      }
      case "visible":
        super._optionChanged(args);
        if (value2 && this.option("buttons")) {
          this._cleanButtonContainers();
          this._renderButtonContainers();
          const {
            stylingMode
          } = this.option();
          this._updateButtonsStyling(stylingMode);
        }
        break;
      case "displayValueFormatter":
        this._invalidate();
        break;
      default:
        super._optionChanged(args);
    }
  }
  _renderInputType() {
    this._setInputType(this.option("mode"));
  }
  _setInputType(type2) {
    const input = this._input();
    if ("search" === type2) {
      type2 = "text";
    }
    try {
      input.prop("type", type2);
    } catch (e) {
      input.prop("type", "text");
    }
  }
  getButton(name2) {
    return this._buttonCollection.getButton(name2);
  }
  focus() {
    m_events_engine_default.trigger(this._input(), "focus");
  }
  clear() {
    if (this._showValidMark) {
      this._showValidMark = false;
      this._renderValidationState();
    }
    const defaultOptions4 = this._getDefaultOptions();
    if (this.option("value") === defaultOptions4.value) {
      this._options.silent("text", "");
      this._renderValue();
    } else {
      this.option("value", defaultOptions4.value);
    }
  }
  _resetInputText() {
    this._options.silent("text", this._initialValue);
    this._renderValue();
  }
  _isValueEqualToInitial() {
    const {
      value: value2
    } = this.option();
    const initialValue = this._initialValue;
    return value2 === initialValue;
  }
  _resetToInitialValue() {
    const shouldResetInputText = this._isValueEqualToInitial();
    if (shouldResetInputText) {
      this._resetInputText();
    } else {
      super._resetToInitialValue();
    }
    this._disposePendingIndicator();
    this._showValidMark = false;
    this._toggleValidMark();
  }
  _toggleValidMark() {
    this.$element().toggleClass("dx-valid", !!this._showValidMark);
  }
  reset() {
    let value2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : void 0;
    if (arguments.length) {
      super.reset(value2);
    } else {
      super.reset();
    }
  }
  on(eventName, eventHandler) {
    const result2 = super.on(eventName, eventHandler);
    const event = eventName.charAt(0).toUpperCase() + eventName.substr(1);
    if (EVENTS_LIST.includes(event)) {
      this._refreshEvents();
    }
    return result2;
  }
};
var m_text_editor_base_default = TextEditorBase;

// node_modules/devextreme/esm/__internal/ui/text_box/m_text_editor.mask.rule.js
var BaseMaskRule = class {
  constructor(config3) {
    this._value = " ";
    extend(this, config3);
  }
  next(rule) {
    if (!arguments.length) {
      return this._next;
    }
    this._next = rule;
  }
  _prepareHandlingArgs(args, config3) {
    config3 = config3 || {};
    const handlingProperty = Object.prototype.hasOwnProperty.call(args, "value") ? "value" : "text";
    args[handlingProperty] = config3.str ?? args[handlingProperty];
    args.start = config3.start ?? args.start;
    args.length = config3.length ?? args.length;
    args.index += 1;
    return args;
  }
  first(index2) {
    index2 = index2 || 0;
    return this.next().first(index2 + 1);
  }
  isAccepted(caret3) {
    return false;
  }
  adjustedCaret(caret3, isForwardDirection, char) {
    return isForwardDirection ? this._adjustedForward(caret3, 0, char) : this._adjustedBackward(caret3, 0, char);
  }
  _adjustedForward(caret3, index2, char) {
  }
  _adjustedBackward(caret3, index2, char) {
  }
  isValid(args) {
  }
  reset() {
  }
  clear(args) {
  }
  text() {
  }
  value() {
  }
  rawValue() {
  }
  handle(args) {
  }
};
var EmptyMaskRule = class extends BaseMaskRule {
  next() {
  }
  handle() {
    return 0;
  }
  text() {
    return "";
  }
  value() {
    return "";
  }
  first() {
    return 0;
  }
  rawValue() {
    return "";
  }
  adjustedCaret() {
    return 0;
  }
  isValid() {
    return true;
  }
};
var MaskRule = class extends BaseMaskRule {
  text() {
    return (" " !== this._value ? this._value : this.maskChar) + this.next().text();
  }
  value() {
    return this._value + this.next().value();
  }
  rawValue() {
    return this._value + this.next().rawValue();
  }
  handle(args) {
    const str = Object.prototype.hasOwnProperty.call(args, "value") ? args.value : args.text;
    if (!str || !str.length || !args.length) {
      return 0;
    }
    if (args.start) {
      return this.next().handle(this._prepareHandlingArgs(args, {
        start: args.start - 1
      }));
    }
    const char = str[0];
    const rest = str.substring(1);
    this._tryAcceptChar(char, args);
    return this._accepted() ? this.next().handle(this._prepareHandlingArgs(args, {
      str: rest,
      length: args.length - 1
    })) + 1 : this.handle(this._prepareHandlingArgs(args, {
      str: rest,
      length: args.length - 1
    }));
  }
  clear(args) {
    this._tryAcceptChar(" ", args);
    this.next().clear(this._prepareHandlingArgs(args));
  }
  reset() {
    this._accepted(false);
    this.next().reset();
  }
  _tryAcceptChar(char, args) {
    this._accepted(false);
    if (!this._isAllowed(char, args)) {
      return;
    }
    const acceptedChar = " " === char ? this.maskChar : char;
    args.fullText = args.fullText.substring(0, args.index) + acceptedChar + args.fullText.substring(args.index + 1);
    this._accepted(true);
    this._value = char;
  }
  _accepted(value2) {
    if (!arguments.length) {
      return !!this._isAccepted;
    }
    this._isAccepted = !!value2;
  }
  first(index2) {
    return " " === this._value ? index2 || 0 : super.first(index2);
  }
  _isAllowed(char, args) {
    if (" " === char) {
      return true;
    }
    return this._isValid(char, args);
  }
  _isValid(char, args) {
    const {
      allowedChars
    } = this;
    if (allowedChars instanceof RegExp) {
      return allowedChars.test(char);
    }
    if (isFunction(allowedChars)) {
      return allowedChars(char, args.index, args.fullText);
    }
    if (Array.isArray(allowedChars)) {
      return allowedChars.includes(char);
    }
    return allowedChars === char;
  }
  isAccepted(caret3) {
    return 0 === caret3 ? this._accepted() : this.next().isAccepted(caret3 - 1);
  }
  _adjustedForward(caret3, index2, char) {
    if (index2 >= caret3) {
      return index2;
    }
    return this.next()._adjustedForward(caret3, index2 + 1, char) || index2 + 1;
  }
  _adjustedBackward(caret3, index2) {
    if (index2 >= caret3 - 1) {
      return caret3;
    }
    return this.next()._adjustedBackward(caret3, index2 + 1) || index2 + 1;
  }
  isValid(args) {
    return this._isValid(this._value, args) && this.next().isValid(this._prepareHandlingArgs(args));
  }
};
var StubMaskRule = class extends MaskRule {
  value() {
    return this.next().value();
  }
  handle(args) {
    const hasValueProperty = Object.prototype.hasOwnProperty.call(args, "value");
    const str = hasValueProperty ? args.value : args.text;
    if (!str.length || !args.length) {
      return 0;
    }
    if (args.start || hasValueProperty) {
      return this.next().handle(this._prepareHandlingArgs(args, {
        start: args.start && args.start - 1
      }));
    }
    const char = str[0];
    const rest = str.substring(1);
    this._tryAcceptChar(char);
    const nextArgs = this._isAllowed(char) ? this._prepareHandlingArgs(args, {
      str: rest,
      length: args.length - 1
    }) : args;
    return this.next().handle(nextArgs) + 1;
  }
  clear(args) {
    this._accepted(false);
    this.next().clear(this._prepareHandlingArgs(args));
  }
  _tryAcceptChar(char) {
    this._accepted(this._isValid(char));
  }
  _isValid(char) {
    return char === this.maskChar;
  }
  first(index2) {
    index2 = index2 || 0;
    return this.next().first(index2 + 1);
  }
  _adjustedForward(caret3, index2, char) {
    if (index2 >= caret3 && char === this.maskChar) {
      return index2;
    }
    if (caret3 === index2 + 1 && this._accepted()) {
      return caret3;
    }
    return this.next()._adjustedForward(caret3, index2 + 1, char);
  }
  _adjustedBackward(caret3, index2) {
    if (index2 >= caret3 - 1) {
      return 0;
    }
    return this.next()._adjustedBackward(caret3, index2 + 1);
  }
  isValid(args) {
    return this.next().isValid(this._prepareHandlingArgs(args));
  }
};

// node_modules/devextreme/esm/__internal/ui/text_box/m_text_editor.mask.strategy.js
var BLUR_EVENT = "blur beforedeactivate";
var DELETE_INPUT_TYPES = ["deleteContentBackward", "deleteSoftLineBackward", "deleteContent", "deleteHardLineBackward"];
var HISTORY_INPUT_TYPES = ["historyUndo", "historyRedo"];
var EVENT_NAMES = ["focusIn", "focusOut", "input", "paste", "cut", "drop", "beforeInput"];
function getEmptyString(length) {
  return " ".repeat(length);
}
var MaskStrategy = class {
  constructor(editor) {
    this.editor = editor;
  }
  _editorOption() {
    return this.editor.option(...arguments);
  }
  _editorInput() {
    return this.editor._input();
  }
  _editorCaret(newCaret) {
    if (!newCaret) {
      return this.editor._caret();
    }
    this.editor._caret(newCaret);
  }
  _attachChangeEventHandler() {
    if (!this._editorOption("valueChangeEvent").split(" ").includes("change")) {
      return;
    }
    const $input = this._editorInput();
    const namespace = addNamespace2(BLUR_EVENT, "dxMask");
    m_events_engine_default.on($input, namespace, (e) => {
      this.editor._changeHandler(e);
    });
  }
  _beforeInputHandler() {
    this._previousText = this._editorOption("text");
    this._prevCaret = this._editorCaret();
  }
  _inputHandler(event) {
    const {
      originalEvent
    } = event;
    if (!originalEvent) {
      return;
    }
    const {
      inputType: inputType2
    } = originalEvent;
    if (HISTORY_INPUT_TYPES.includes(inputType2)) {
      this._handleHistoryInputEvent();
    } else if (DELETE_INPUT_TYPES.includes(inputType2)) {
      this._handleBackwardDeleteInputEvent();
    } else {
      const currentCaret = this._editorCaret();
      if (!currentCaret.end) {
        return;
      }
      this._clearSelectedText();
      this._autoFillHandler(originalEvent);
      this._editorCaret(currentCaret);
      this._handleInsertTextInputEvent(originalEvent.data);
    }
    if (this._editorOption("text") === this._previousText) {
      event.stopImmediatePropagation();
    }
  }
  _handleHistoryInputEvent() {
    const caret3 = this._editorCaret();
    this._updateEditorMask({
      start: caret3.start,
      length: caret3.end - caret3.start,
      text: ""
    });
    this._editorCaret(this._prevCaret);
  }
  _handleBackwardDeleteInputEvent() {
    this._clearSelectedText(true);
    const caret3 = this._editorCaret();
    this.editor.setForwardDirection();
    this.editor._adjustCaret();
    const adjustedForwardCaret = this._editorCaret();
    if (adjustedForwardCaret.start !== caret3.start) {
      this.editor.setBackwardDirection();
      this.editor._adjustCaret();
    }
  }
  _clearSelectedText(isDeleteInputEvent) {
    const selectionLength = this._prevCaret && this._prevCaret.end - this._prevCaret.start;
    const length = selectionLength || Number(isDeleteInputEvent);
    const caret3 = this._editorCaret();
    if (!this._isAutoFill()) {
      this.editor.setBackwardDirection();
      this._updateEditorMask({
        start: caret3.start,
        length,
        text: getEmptyString(length)
      });
    }
  }
  _handleInsertTextInputEvent(data17) {
    var _this$_prevCaret;
    const text = data17 ?? "";
    this.editor.setForwardDirection();
    const hasValidChars = this._updateEditorMask({
      start: (null === (_this$_prevCaret = this._prevCaret) || void 0 === _this$_prevCaret ? void 0 : _this$_prevCaret.start) ?? 0,
      length: text.length || 1,
      text
    });
    if (!hasValidChars) {
      this._editorCaret(this._prevCaret);
    }
  }
  _updateEditorMask(args) {
    const textLength = args.text.length;
    const processedCharsCount = this.editor._handleChain(args);
    this.editor._displayMask();
    if (this.editor.isForwardDirection()) {
      const {
        start,
        end
      } = this._editorCaret();
      const correction = processedCharsCount - textLength;
      const hasSkippedStub = processedCharsCount > 1;
      if (hasSkippedStub && 1 === textLength) {
        this._editorCaret({
          start: start + correction,
          end: end + correction
        });
      }
      this.editor._adjustCaret();
    }
    return !!processedCharsCount;
  }
  _focusInHandler() {
    this.editor._showMaskPlaceholder();
    this.editor.setForwardDirection();
    if (!this.editor._isValueEmpty() && this._editorOption("isValid")) {
      this.editor._adjustCaret();
    } else {
      const caret3 = this.editor._maskRulesChain.first();
      this._caretTimeout = setTimeout(() => {
        this._editorCaret({
          start: caret3,
          end: caret3
        });
      }, 0);
    }
  }
  _focusOutHandler(event) {
    this.editor._changeHandler(event);
    if ("onFocus" === this._editorOption("showMaskMode") && this.editor._isValueEmpty()) {
      this._editorOption("text", "");
      this.editor._renderDisplayText("");
    }
  }
  _delHandler(event) {
    const {
      editor
    } = this;
    editor._maskKeyHandler(event, () => {
      if (!editor._hasSelection()) {
        editor._handleKey(" ");
      }
    });
  }
  _cutHandler(event) {
    const caret3 = this._editorCaret();
    const selectedText = this._editorInput().val().substring(caret3.start, caret3.end);
    this.editor._maskKeyHandler(event, () => clipboardText(event, selectedText));
  }
  _dropHandler() {
    this._clearDragTimer();
    this._dragTimer = setTimeout(() => {
      const value2 = this.editor._convertToValue(this._editorInput().val());
      this._editorOption("value", value2);
    });
  }
  _pasteHandler(event) {
    const {
      editor
    } = this;
    if (this._editorOption("disabled")) {
      return;
    }
    const caret3 = this._editorCaret();
    editor._maskKeyHandler(event, () => {
      const pastedText = clipboardText(event);
      const restText = editor._maskRulesChain.text().substring(caret3.end);
      const accepted = editor._handleChain({
        text: pastedText,
        start: caret3.start,
        length: pastedText.length
      });
      const newCaret = caret3.start + accepted;
      editor._handleChain({
        text: restText,
        start: newCaret,
        length: restText.length
      });
      editor._caret({
        start: newCaret,
        end: newCaret
      });
    });
  }
  _autoFillHandler(event) {
    const {
      editor
    } = this;
    const inputVal = this._editorInput().val();
    this._inputHandlerTimer = setTimeout(() => {
      if (this._isAutoFill()) {
        editor._maskKeyHandler(event, () => {
          editor._handleChain({
            text: inputVal,
            start: 0,
            length: inputVal.length
          });
        });
        editor._validateMask();
      }
    });
  }
  _isAutoFill() {
    const $input = this._editorInput();
    if (browser_default.webkit) {
      const input = $input.get(0);
      return (null === input || void 0 === input ? void 0 : input.matches(":-webkit-autofill")) ?? false;
    }
    return false;
  }
  _clearDragTimer() {
    clearTimeout(this._dragTimer);
  }
  _clearTimers() {
    this._clearDragTimer();
    clearTimeout(this._caretTimeout);
    clearTimeout(this._inputHandlerTimer);
  }
  getHandler(handlerName) {
    return (args) => {
      var _this;
      null === (_this = this[`_${handlerName}Handler`]) || void 0 === _this || _this.call(this, args);
    };
  }
  attachEvents() {
    const $input = this._editorInput();
    EVENT_NAMES.forEach((eventName) => {
      const namespace = addNamespace2(eventName.toLowerCase(), "dxMask");
      m_events_engine_default.on($input, namespace, this.getHandler(eventName));
    });
    this._attachChangeEventHandler();
  }
  detachEvents() {
    this._clearTimers();
    m_events_engine_default.off(this._editorInput(), ".dxMask");
  }
  clean() {
    this._clearTimers();
  }
};

// node_modules/devextreme/esm/__internal/ui/text_box/m_utils.caret.js
var {
  ios,
  mac
} = devices_default.real();
var isFocusingOnCaretChange = ios || mac;
var getCaret = (input) => {
  let range;
  try {
    range = {
      start: input.selectionStart,
      end: input.selectionEnd
    };
  } catch (e) {
    range = {
      start: 0,
      end: 0
    };
  }
  return range;
};
var setCaret = (input, position3) => {
  const body = dom_adapter_default.getBody();
  if (!body.contains(input) && !body.contains(input.getRootNode().host)) {
    return;
  }
  try {
    input.selectionStart = position3.start;
    input.selectionEnd = position3.end;
  } catch (e) {
  }
};
var caret = function(input, position3) {
  let force = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : false;
  input = renderer_default(input).get(0);
  if (!isDefined(position3)) {
    return getCaret(input);
  }
  if (!force && isFocusingOnCaretChange && dom_adapter_default.getActiveElement(input) !== input) {
    return;
  }
  setCaret(input, position3);
};
var m_utils_caret_default = caret;

// node_modules/devextreme/esm/__internal/ui/text_box/m_text_editor.mask.js
var caret2 = m_utils_caret_default;
var buildInMaskRules = {
  0: /[0-9]/,
  9: /[0-9\s]/,
  "#": /[-+0-9\s]/,
  L: (char) => isLiteralChar(char),
  l: (char) => isLiteralChar(char) || isSpaceChar(char),
  C: /\S/,
  c: /./,
  A: (char) => isLiteralChar(char) || isNumericChar(char),
  a: (char) => isLiteralChar(char) || isNumericChar(char) || isSpaceChar(char)
};
function isNumericChar(char) {
  return /[0-9]/.test(char);
}
function isLiteralChar(char) {
  const code = char.charCodeAt();
  return code > 64 && code < 91 || code > 96 && code < 123 || code > 127;
}
function isSpaceChar(char) {
  return " " === char;
}
var TextEditorMask = class extends m_text_editor_base_default {
  _getDefaultOptions() {
    return _extends({}, super._getDefaultOptions(), {
      mask: "",
      maskChar: "_",
      maskRules: {},
      maskInvalidMessage: message_default.format("validation-mask"),
      useMaskedValue: false,
      showMaskMode: "always"
    });
  }
  _supportedKeys() {
    const that = this;
    const keyHandlerMap = {
      del: that._maskStrategy.getHandler("del"),
      enter: that._changeHandler
    };
    const result2 = super._supportedKeys();
    each(keyHandlerMap, (key, callback) => {
      const parentHandler = result2[key];
      result2[key] = function(e) {
        that.option("mask") && callback.call(that, e);
        parentHandler && parentHandler(e);
      };
    });
    return result2;
  }
  _getSubmitElement() {
    return !this.option("mask") ? super._getSubmitElement() : this._$hiddenElement;
  }
  _init() {
    super._init();
    this._initMaskStrategy();
  }
  _initMaskStrategy() {
    this._maskStrategy = new MaskStrategy(this);
  }
  _initMarkup() {
    this._renderHiddenElement();
    super._initMarkup();
  }
  _attachMouseWheelEventHandlers() {
    if (!this._hasMouseWheelHandler()) {
      return;
    }
    const input = this._input();
    const eventName = addNamespace2(EVENT_NAME, this.NAME);
    const mouseWheelAction = this._createAction((e) => {
      const {
        event
      } = e;
      if (focused(input) && !isCommandKeyPressed(event)) {
        this._onMouseWheel(event);
        event.preventDefault();
        event.stopPropagation();
      }
    });
    m_events_engine_default.off(input, eventName);
    m_events_engine_default.on(input, eventName, (e) => {
      mouseWheelAction({
        event: e
      });
    });
  }
  _hasMouseWheelHandler() {
    return false;
  }
  _onMouseWheel(e) {
  }
  _useMaskBehavior() {
    return Boolean(this.option("mask"));
  }
  _attachDropEventHandler() {
    const useMaskBehavior = this._useMaskBehavior();
    if (!useMaskBehavior) {
      return;
    }
    const eventName = addNamespace2("drop", this.NAME);
    const input = this._input();
    m_events_engine_default.off(input, eventName);
    m_events_engine_default.on(input, eventName, (e) => e.preventDefault());
  }
  _render() {
    this._attachMouseWheelEventHandlers();
    this._renderMask();
    super._render();
    this._attachDropEventHandler();
  }
  _renderHiddenElement() {
    if (this.option("mask")) {
      this._$hiddenElement = renderer_default("<input>").attr("type", "hidden").appendTo(this._inputWrapper());
    }
  }
  _removeHiddenElement() {
    this._$hiddenElement && this._$hiddenElement.remove();
  }
  _renderMask() {
    this.$element().removeClass("dx-texteditor-masked");
    this._maskRulesChain = null;
    this._maskStrategy.detachEvents();
    if (!this.option("mask")) {
      return;
    }
    this.$element().addClass("dx-texteditor-masked");
    this._maskStrategy.attachEvents();
    this._parseMask();
    this._renderMaskedValue();
  }
  _changeHandler(e) {
    const $input = this._input();
    const inputValue = $input.val();
    if (inputValue === this._changedValue) {
      return;
    }
    this._changedValue = inputValue;
    const changeEvent = createEvent(e, {
      type: "change"
    });
    m_events_engine_default.trigger($input, changeEvent);
  }
  _parseMask() {
    this._maskRules = extend({}, buildInMaskRules, this.option("maskRules"));
    this._maskRulesChain = this._parseMaskRule(0);
  }
  _parseMaskRule(index2) {
    const {
      mask
    } = this.option();
    if (index2 >= mask.length) {
      return new EmptyMaskRule();
    }
    const currentMaskChar = mask[index2];
    const isEscapedChar = "\\" === currentMaskChar;
    const result2 = isEscapedChar ? new StubMaskRule({
      maskChar: mask[index2 + 1]
    }) : this._getMaskRule(currentMaskChar);
    result2.next(this._parseMaskRule(index2 + 1 + isEscapedChar));
    return result2;
  }
  _getMaskRule(pattern) {
    let ruleConfig;
    each(this._maskRules, (rulePattern, allowedChars) => {
      if (rulePattern === pattern) {
        ruleConfig = {
          pattern: rulePattern,
          allowedChars
        };
        return false;
      }
    });
    return isDefined(ruleConfig) ? new MaskRule(extend({
      maskChar: this.option("maskChar") || " "
    }, ruleConfig)) : new StubMaskRule({
      maskChar: pattern
    });
  }
  _renderMaskedValue() {
    if (!this._maskRulesChain) {
      return;
    }
    const value2 = this.option("value") || "";
    this._maskRulesChain.clear(this._normalizeChainArguments());
    const chainArgs = {
      length: value2.length
    };
    chainArgs[this._isMaskedValueMode() ? "text" : "value"] = value2;
    this._handleChain(chainArgs);
    this._displayMask();
  }
  _replaceSelectedText(text, selection2, char) {
    if (void 0 === char) {
      return text;
    }
    const textBefore = text.slice(0, selection2.start);
    const textAfter = text.slice(selection2.end);
    const edited = textBefore + char + textAfter;
    return edited;
  }
  _isMaskedValueMode() {
    return this.option("useMaskedValue");
  }
  _displayMask(caret3) {
    caret3 = caret3 || this._caret();
    this._renderValue();
    this._caret(caret3);
  }
  _isValueEmpty() {
    return isEmpty(this._value);
  }
  _shouldShowMask() {
    const {
      showMaskMode
    } = this.option();
    if ("onFocus" === showMaskMode) {
      return focused(this._input()) || !this._isValueEmpty();
    }
    return true;
  }
  _showMaskPlaceholder() {
    if (this._shouldShowMask()) {
      const text = this._maskRulesChain.text();
      this.option("text", text);
      const {
        showMaskMode
      } = this.option();
      if ("onFocus" === showMaskMode) {
        this._renderDisplayText(text);
      }
    }
  }
  _renderValue() {
    if (this._maskRulesChain) {
      this._showMaskPlaceholder();
      if (this._$hiddenElement) {
        const value2 = this._maskRulesChain.value();
        const submitElementValue = !isEmpty(value2) ? this._getPreparedValue() : "";
        this._$hiddenElement.val(submitElementValue);
      }
    }
    return super._renderValue();
  }
  _getPreparedValue() {
    return this._convertToValue().replace(/\s+$/, "");
  }
  _valueChangeEventHandler(e, value2) {
    if (!this._maskRulesChain) {
      super._valueChangeEventHandler.apply(this, arguments);
      return;
    }
    this._saveValueChangeEvent(e);
    this.option("value", this._getPreparedValue());
  }
  _isControlKeyFired(e) {
    return this._isControlKey(normalizeKeyName(e)) || isCommandKeyPressed(e);
  }
  _handleChain(args) {
    const handledCount = this._maskRulesChain.handle(this._normalizeChainArguments(args));
    this._updateMaskInfo();
    return handledCount;
  }
  _normalizeChainArguments(args) {
    args = args || {};
    args.index = 0;
    args.fullText = this._maskRulesChain.text();
    return args;
  }
  _convertToValue(text) {
    if (this._isMaskedValueMode()) {
      text = this._replaceMaskCharWithEmpty(text || this._textValue || "");
    } else {
      text = text || this._value || "";
    }
    return text;
  }
  _replaceMaskCharWithEmpty(text) {
    const {
      maskChar
    } = this.option();
    return text.replace(new RegExp(maskChar, "g"), " ");
  }
  _maskKeyHandler(e, keyHandler) {
    if (this.option("readOnly")) {
      return;
    }
    this.setForwardDirection();
    e.preventDefault();
    this._handleSelection();
    const previousText = this._input().val();
    const raiseInputEvent = () => {
      if (previousText !== this._input().val()) {
        m_events_engine_default.trigger(this._input(), "input");
      }
    };
    const handled = keyHandler();
    if (handled) {
      handled.then(raiseInputEvent);
    } else {
      this.setForwardDirection();
      this._adjustCaret();
      this._displayMask();
      this._maskRulesChain.reset();
      raiseInputEvent();
    }
  }
  _handleKey(key, direction) {
    this._direction(direction || "forward");
    this._adjustCaret(key);
    this._handleKeyChain(key);
    this._moveCaret();
  }
  _handleSelection() {
    if (!this._hasSelection()) {
      return;
    }
    const caret3 = this._caret();
    const emptyChars = new Array(caret3.end - caret3.start + 1).join(" ");
    this._handleKeyChain(emptyChars);
  }
  _handleKeyChain(chars) {
    const caret3 = this._caret();
    const start = this.isForwardDirection() ? caret3.start : caret3.start - 1;
    const end = this.isForwardDirection() ? caret3.end : caret3.end - 1;
    const length = start === end ? 1 : end - start;
    this._handleChain({
      text: chars,
      start,
      length
    });
  }
  _tryMoveCaretBackward() {
    this.setBackwardDirection();
    const currentCaret = this._caret().start;
    this._adjustCaret();
    return !currentCaret || currentCaret !== this._caret().start;
  }
  _adjustCaret(char) {
    const caretStart = this._caret().start;
    const isForwardDirection = this.isForwardDirection();
    const caret3 = this._maskRulesChain.adjustedCaret(caretStart, isForwardDirection, char);
    this._caret({
      start: caret3,
      end: caret3
    });
  }
  _moveCaret() {
    const currentCaret = this._caret().start;
    const maskRuleIndex = currentCaret + (this.isForwardDirection() ? 0 : -1);
    const caret3 = this._maskRulesChain.isAccepted(maskRuleIndex) ? currentCaret + (this.isForwardDirection() ? 1 : -1) : currentCaret;
    this._caret({
      start: caret3,
      end: caret3
    });
  }
  _caret(position3, force) {
    const $input = this._input();
    if (!$input.length) {
      return;
    }
    if (!arguments.length) {
      return caret2($input);
    }
    caret2($input, position3, force);
  }
  _hasSelection() {
    const caret3 = this._caret();
    return caret3.start !== caret3.end;
  }
  _direction(direction) {
    if (!arguments.length) {
      return this._typingDirection;
    }
    this._typingDirection = direction;
  }
  setForwardDirection() {
    this._direction("forward");
  }
  setBackwardDirection() {
    this._direction("backward");
  }
  isForwardDirection() {
    return "forward" === this._direction();
  }
  _updateMaskInfo() {
    this._textValue = this._maskRulesChain.text();
    this._value = this._maskRulesChain.value();
  }
  _clean() {
    this._maskStrategy && this._maskStrategy.clean();
    super._clean();
  }
  _validateMask() {
    if (!this._maskRulesChain) {
      return;
    }
    const isValid = isEmpty(this.option("value")) || this._maskRulesChain.isValid(this._normalizeChainArguments());
    this.option({
      isValid,
      validationError: isValid ? null : {
        editorSpecific: true,
        message: this.option("maskInvalidMessage")
      }
    });
  }
  _updateHiddenElement() {
    this._removeHiddenElement();
    if (this.option("mask")) {
      this._input().removeAttr("name");
      this._renderHiddenElement();
    }
    const {
      name: name2
    } = this.option();
    this._setSubmitElementName(name2);
  }
  _updateMaskOption() {
    this._updateHiddenElement();
    this._renderMask();
    this._validateMask();
    this._refreshValueChangeEvent();
  }
  _processEmptyMask(mask) {
    if (mask) {
      return;
    }
    const value2 = this.option("value");
    this.option({
      text: value2,
      isValid: true,
      validationError: null
    });
    this.validationRequest.fire({
      value: value2,
      editor: this
    });
    this._renderValue();
  }
  _optionChanged(args) {
    switch (args.name) {
      case "mask":
        this._updateMaskOption();
        this._processEmptyMask(args.value);
        break;
      case "maskChar":
      case "maskRules":
      case "useMaskedValue":
        this._updateMaskOption();
        break;
      case "value":
        this._renderMaskedValue();
        this._validateMask();
        super._optionChanged(args);
        this._changedValue = this._input().val();
        break;
      case "maskInvalidMessage":
        break;
      case "showMaskMode":
        this.option("text", "");
        this._renderValue();
        break;
      default:
        super._optionChanged(args);
    }
  }
  clear() {
    const {
      value: defaultValue
    } = this._getDefaultOptions();
    if (this.option("value") === defaultValue) {
      this._renderMaskedValue();
    }
    super.clear();
  }
};
var m_text_editor_mask_default = TextEditorMask;

// node_modules/devextreme/esm/__internal/ui/text_box/m_text_box.js
var window19 = getWindow();
var ignoreKeys = ["backspace", "tab", "enter", "pageUp", "pageDown", "end", "home", "leftArrow", "rightArrow", "downArrow", "upArrow", "del"];
var TextBox = class extends m_text_editor_mask_default {
  ctor(element, options2) {
    if (options2) {
      this._showClearButton = options2.showClearButton;
    }
    super.ctor(element, options2);
  }
  _getDefaultOptions() {
    return _extends({}, super._getDefaultOptions(), {
      value: "",
      mode: "text",
      maxLength: null
    });
  }
  _initMarkup() {
    this.$element().addClass("dx-textbox");
    super._initMarkup();
    this.setAria("role", "textbox");
  }
  _renderInputType() {
    super._renderInputType();
    this._renderSearchMode();
  }
  _useTemplates() {
    return false;
  }
  _renderProps() {
    super._renderProps();
    this._toggleMaxLengthProp();
  }
  _toggleMaxLengthProp() {
    const maxLength = this._getMaxLength();
    if (maxLength && maxLength > 0) {
      this._input().attr("maxLength", maxLength);
    } else {
      this._input().removeAttr("maxLength");
    }
  }
  _renderSearchMode() {
    const {
      mode
    } = this.option();
    if ("search" === mode) {
      this.$element().addClass("dx-searchbox");
      this._renderSearchIcon();
      if (void 0 === this._showClearButton) {
        const {
          showClearButton
        } = this.option();
        this._showClearButton = showClearButton;
        this.option("showClearButton", true);
      }
    } else {
      this.$element().removeClass("dx-searchbox");
      if (this._$searchIcon) {
        this._$searchIcon.remove();
      }
      this.option("showClearButton", void 0 === this._showClearButton ? this.option("showClearButton") : this._showClearButton);
      delete this._showClearButton;
    }
  }
  _renderSearchIcon() {
    const $searchIcon = renderer_default("<div>").addClass("dx-icon").addClass("dx-icon-search");
    $searchIcon.prependTo(this._input().parent());
    this._$searchIcon = $searchIcon;
  }
  _getLabelContainerWidth() {
    if (this._$searchIcon) {
      const $inputContainer = this._input().parent();
      return getWidth($inputContainer) - this._getLabelBeforeWidth();
    }
    return super._getLabelContainerWidth();
  }
  _getLabelBeforeWidth() {
    let labelBeforeWidth = super._getLabelBeforeWidth();
    if (this._$searchIcon) {
      labelBeforeWidth += getOuterWidth(this._$searchIcon);
    }
    return labelBeforeWidth;
  }
  _optionChanged(args) {
    switch (args.name) {
      case "maxLength":
        this._toggleMaxLengthProp();
        break;
      case "mode":
        super._optionChanged(args);
        this._updateLabelWidth();
        break;
      case "mask":
        super._optionChanged(args);
        this._toggleMaxLengthProp();
        break;
      default:
        super._optionChanged(args);
    }
  }
  _onKeyDownCutOffHandler(e) {
    const actualMaxLength = this._getMaxLength();
    if (actualMaxLength && !e.ctrlKey && !this._hasSelection()) {
      const $input = renderer_default(e.target);
      const key = normalizeKeyName(e);
      this._cutOffExtraChar($input);
      return $input.val().length < actualMaxLength || ignoreKeys.includes(key) || "" !== window19.getSelection().toString();
    }
    return true;
  }
  _onChangeCutOffHandler(e) {
    const $input = renderer_default(e.target);
    if (this.option("maxLength")) {
      this._cutOffExtraChar($input);
    }
  }
  _cutOffExtraChar($input) {
    const actualMaxLength = this._getMaxLength();
    const textInput = $input.val();
    if (actualMaxLength && textInput.length > actualMaxLength) {
      $input.val(textInput.substr(0, actualMaxLength));
    }
  }
  _getMaxLength() {
    const {
      mask,
      maxLength
    } = this.option();
    const isMaskSpecified = !!mask;
    return isMaskSpecified ? null : maxLength;
  }
};
component_registrator_default("dxTextBox", TextBox);
var m_text_box_default = TextBox;

// node_modules/devextreme/esm/ui/text_box/text_box.js
var text_box_default = m_text_box_default;

// node_modules/devextreme/esm/ui/text_box.js
var text_box_default2 = text_box_default;

// node_modules/devextreme/esm/__internal/core/utils/m_stubs.js
function stubComponent(componentName) {
  return class {
    constructor() {
      throw new Error(`Module '${componentName}' not found`);
    }
    static getInstance() {
    }
  };
}

// node_modules/devextreme/esm/__internal/ui/collection/m_search_box_mixin.js
var EditorClass = stubComponent("TextBox");
var m_search_box_mixin_default = {
  _getDefaultOptions() {
    return extend(this.callBase(), {
      searchMode: "",
      searchExpr: null,
      searchValue: "",
      searchEnabled: false,
      searchEditorOptions: {}
    });
  },
  _initMarkup() {
    this._renderSearch();
    this.callBase();
  },
  _renderSearch() {
    const $element = this.$element();
    const searchEnabled = this.option("searchEnabled");
    const searchBoxClassName = this._addWidgetPrefix("search");
    const rootElementClassName = this._addWidgetPrefix("with-search");
    if (!searchEnabled) {
      $element.removeClass(rootElementClassName);
      this._removeSearchBox();
      return;
    }
    const editorOptions = this._getSearchEditorOptions();
    if (this._searchEditor) {
      this._searchEditor.option(editorOptions);
    } else {
      $element.addClass(rootElementClassName);
      this._$searchEditorElement = renderer_default("<div>").addClass(searchBoxClassName).prependTo($element);
      this._searchEditor = this._createComponent(this._$searchEditorElement, EditorClass, editorOptions);
    }
  },
  _removeSearchBox() {
    this._$searchEditorElement && this._$searchEditorElement.remove();
    delete this._$searchEditorElement;
    delete this._searchEditor;
  },
  _getSearchEditorOptions() {
    const that = this;
    const userEditorOptions = that.option("searchEditorOptions");
    const searchText = message_default.format("Search");
    return extend({
      mode: "search",
      placeholder: searchText,
      tabIndex: that.option("tabIndex"),
      value: that.option("searchValue"),
      valueChangeEvent: "input",
      inputAttr: {
        "aria-label": searchText
      },
      onValueChanged(e) {
        const searchTimeout = that.option("searchTimeout");
        that._valueChangeDeferred = Deferred();
        clearTimeout(that._valueChangeTimeout);
        that._valueChangeDeferred.done(function() {
          this.option("searchValue", e.value);
        }.bind(that));
        if (e.event && "input" === e.event.type && searchTimeout) {
          that._valueChangeTimeout = setTimeout(() => {
            that._valueChangeDeferred.resolve();
          }, searchTimeout);
        } else {
          that._valueChangeDeferred.resolve();
        }
      }
    }, userEditorOptions);
  },
  _getAriaTarget() {
    if (this.option("searchEnabled")) {
      return this._itemContainer(true);
    }
    return this.callBase();
  },
  _focusTarget() {
    if (this.option("searchEnabled")) {
      return this._itemContainer(true);
    }
    return this.callBase();
  },
  _updateFocusState(e, isFocused) {
    if (this.option("searchEnabled")) {
      this._toggleFocusClass(isFocused, this.$element());
    }
    this.callBase(e, isFocused);
  },
  getOperationBySearchMode: (searchMode) => "equals" === searchMode ? "=" : searchMode,
  _optionChanged(args) {
    switch (args.name) {
      case "searchEnabled":
      case "searchEditorOptions":
        this._invalidate();
        break;
      case "searchExpr":
      case "searchMode":
      case "searchValue":
        if (!this._dataSource) {
          ui_errors_default.log("W1009");
          return;
        }
        if ("searchMode" === args.name) {
          this._dataSource.searchOperation(this.getOperationBySearchMode(args.value));
        } else {
          this._dataSource[args.name](args.value);
        }
        this._dataSource.load();
        break;
      case "searchTimeout":
        break;
      default:
        this.callBase(args);
    }
  },
  focus() {
    if (!this.option("focusedElement") && this.option("searchEnabled")) {
      this._searchEditor && this._searchEditor.focus();
      return;
    }
    this.callBase();
  },
  _cleanAria() {
    const $element = this.$element();
    this.setAria({
      role: null,
      activedescendant: null
    }, $element);
    $element.attr("tabIndex", null);
  },
  _clean() {
    this.callBase();
    this._cleanAria();
  },
  _refresh() {
    if (this._valueChangeDeferred) {
      this._valueChangeDeferred.resolve();
    }
    this.callBase();
  },
  setEditorClass(value2) {
    EditorClass = value2;
  }
};

// node_modules/devextreme/esm/ui/widget/ui.search_box_mixin.js
var ui_search_box_mixin_default = m_search_box_mixin_default;

// node_modules/devextreme/esm/__internal/ui/hierarchical_collection/m_data_converter.js
var DataConverter = class_default.inherit({
  ctor() {
    this._dataStructure = [];
    this._itemsCount = 0;
    this._visibleItemsCount = 0;
  },
  _indexByKey: {},
  _convertItemsToNodes(items, parentKey) {
    const that = this;
    each(items, (_, item) => {
      const parentId = isDefined(parentKey) ? parentKey : that._getParentId(item);
      const node = that._convertItemToNode(item, parentId);
      that._dataStructure.push(node);
      that._checkForDuplicateId(node.internalFields.key);
      that._indexByKey[node.internalFields.key] = that._dataStructure.length - 1;
      if (that._itemHasChildren(item)) {
        that._convertItemsToNodes(that._dataAccessors.getters.items(item), node.internalFields.key);
      }
    });
  },
  _checkForDuplicateId(key) {
    if (isDefined(this._indexByKey[key])) {
      throw ui_errors_default.Error("E1040", key);
    }
  },
  _getParentId(item) {
    return "plain" === this._dataType ? this._dataAccessors.getters.parentKey(item) : void 0;
  },
  _itemHasChildren(item) {
    if ("plain" === this._dataType) {
      return;
    }
    const items = this._dataAccessors.getters.items(item);
    return items && items.length;
  },
  _getUniqueKey(item) {
    const keyGetter = this._dataAccessors.getters.key;
    const itemKey = keyGetter(item);
    const isCorrectKey = keyGetter && (itemKey || 0 === itemKey) && isPrimitive(itemKey);
    return isCorrectKey ? itemKey : this.getItemsCount();
  },
  _convertItemToNode(item, parentKey) {
    this._itemsCount++;
    false !== item.visible && this._visibleItemsCount++;
    const node = {
      internalFields: {
        disabled: this._dataAccessors.getters.disabled(item, {
          defaultValue: false
        }),
        expanded: this._dataAccessors.getters.expanded(item, {
          defaultValue: false
        }),
        selected: this._dataAccessors.getters.selected(item, {
          defaultValue: false
        }),
        key: this._getUniqueKey(item),
        parentKey: isDefined(parentKey) ? parentKey : this._rootValue,
        item: this._makeObjectFromPrimitive(item),
        childrenKeys: []
      }
    };
    extend(node, item);
    delete node.items;
    return node;
  },
  setChildrenKeys() {
    const that = this;
    each(this._dataStructure, (_, node) => {
      if (node.internalFields.parentKey === that._rootValue) {
        return;
      }
      const parent = that.getParentNode(node);
      parent && parent.internalFields.childrenKeys.push(node.internalFields.key);
    });
  },
  _makeObjectFromPrimitive(item) {
    if (isPrimitive(item)) {
      const key = item;
      item = {};
      this._dataAccessors.setters.key(item, key);
    }
    return item;
  },
  _convertToPublicNode(node, parent) {
    if (!node) {
      return null;
    }
    const publicNode = {
      text: this._dataAccessors.getters.display(node),
      key: node.internalFields.key,
      selected: node.internalFields.selected,
      expanded: node.internalFields.expanded,
      disabled: node.internalFields.disabled,
      parent: parent || null,
      itemData: node.internalFields.item,
      children: [],
      items: []
    };
    if (publicNode.parent) {
      publicNode.parent.children.push(publicNode);
      publicNode.parent.items.push(publicNode);
    }
    return publicNode;
  },
  convertToPublicNodes(data17, parent) {
    if (!data17.length) {
      return [];
    }
    const that = this;
    const publicNodes = [];
    each(data17, (_, node) => {
      node = isPrimitive(node) ? that._getByKey(node) : node;
      const publicNode = that._convertToPublicNode(node, parent);
      publicNode.children = that.convertToPublicNodes(node.internalFields.childrenKeys, publicNode);
      publicNodes.push(publicNode);
      node.internalFields.publicNode = publicNode;
    });
    return publicNodes;
  },
  setDataAccessors(accessors) {
    this._dataAccessors = accessors;
  },
  _getByKey(key) {
    return this._dataStructure[this.getIndexByKey(key)] || null;
  },
  getParentNode(node) {
    return this._getByKey(node.internalFields.parentKey);
  },
  getByKey(data17, key) {
    if (null === key || void 0 === key) {
      return null;
    }
    let result2 = null;
    const that = this;
    return function(data18, key2) {
      each(data18, (_, element) => {
        const currentElementKey = element.internalFields && element.internalFields.key || that._dataAccessors.getters.key(element);
        if (currentElementKey.toString() === key2.toString()) {
          result2 = element;
          return false;
        }
      });
      return result2;
    }(data17, key);
  },
  getItemsCount() {
    return this._itemsCount;
  },
  getVisibleItemsCount() {
    return this._visibleItemsCount;
  },
  updateIndexByKey() {
    const that = this;
    this._indexByKey = {};
    each(this._dataStructure, (index2, node) => {
      that._checkForDuplicateId(node.internalFields.key);
      that._indexByKey[node.internalFields.key] = index2;
    });
  },
  updateChildrenKeys() {
    this._indexByKey = {};
    this.removeChildrenKeys();
    this.updateIndexByKey();
    this.setChildrenKeys();
  },
  removeChildrenKeys() {
    this._indexByKey = {};
    each(this._dataStructure, (index2, node) => {
      node.internalFields.childrenKeys = [];
    });
  },
  getIndexByKey(key) {
    return this._indexByKey[key];
  },
  createPlainStructure(items, rootValue, dataType) {
    this._itemsCount = 0;
    this._visibleItemsCount = 0;
    this._rootValue = rootValue;
    this._dataType = dataType;
    this._indexByKey = {};
    this._convertItemsToNodes(items);
    this.setChildrenKeys();
    return this._dataStructure;
  }
});
var m_data_converter_default = DataConverter;

// node_modules/devextreme/esm/__internal/ui/hierarchical_collection/m_data_adapter.js
var EXPANDED = "expanded";
var SELECTED = "selected";
var DISABLED = "disabled";
ui_search_box_mixin_default.setEditorClass(text_box_default2);
var DataAdapter = class_default.inherit({
  ctor(options2) {
    this.options = {};
    extend(this.options, this._defaultOptions(), options2);
    this.options.dataConverter.setDataAccessors(this.options.dataAccessors);
    this._selectedNodesKeys = [];
    this._expandedNodesKeys = [];
    this._dataStructure = [];
    this._createInternalDataStructure();
    this.getTreeNodes();
  },
  setOption(name2, value2) {
    this.options[name2] = value2;
    if ("recursiveSelection" === name2) {
      this._updateSelection();
    }
  },
  _defaultOptions: () => ({
    dataAccessors: void 0,
    items: [],
    multipleSelection: true,
    recursiveSelection: false,
    recursiveExpansion: false,
    rootValue: 0,
    searchValue: "",
    dataType: "tree",
    searchMode: "contains",
    dataConverter: new m_data_converter_default(),
    onNodeChanged: noop2,
    sort: null
  }),
  _createInternalDataStructure() {
    this._initialDataStructure = this.options.dataConverter.createPlainStructure(this.options.items, this.options.rootValue, this.options.dataType);
    this._dataStructure = this.options.searchValue.length ? this.search(this.options.searchValue) : this._initialDataStructure;
    this.options.dataConverter._dataStructure = this._dataStructure;
    this._updateSelection();
    this._updateExpansion();
  },
  _updateSelection() {
    if (this.options.recursiveSelection) {
      this._setChildrenSelection();
      this._setParentSelection();
    }
    this._selectedNodesKeys = this._updateNodesKeysArray(SELECTED);
  },
  _updateExpansion(key) {
    if (this.options.recursiveExpansion) {
      key ? this._updateOneBranch(key) : this._setParentExpansion();
    }
    this._expandedNodesKeys = this._updateNodesKeysArray(EXPANDED);
  },
  _updateNodesKeysArray(property) {
    const that = this;
    let array = [];
    each(that._getDataBySelectionMode(), (_, node) => {
      if (!that._isNodeVisible(node)) {
        return;
      }
      if (node.internalFields[property]) {
        if (property === EXPANDED || that.options.multipleSelection) {
          array.push(node.internalFields.key);
        } else {
          array.length && that.toggleSelection(array[0], false, true);
          array = [node.internalFields.key];
        }
      }
    });
    return array;
  },
  _getDataBySelectionMode() {
    return this.options.multipleSelection ? this.getData() : this.getFullData();
  },
  _isNodeVisible: (node) => false !== node.internalFields.item.visible,
  _getByKey(data17, key) {
    return data17 === this._dataStructure ? this.options.dataConverter._getByKey(key) : this.options.dataConverter.getByKey(data17, key);
  },
  _setChildrenSelection() {
    const that = this;
    each(this._dataStructure, (_, node) => {
      if (!node.internalFields.childrenKeys.length) {
        return;
      }
      const isSelected = node.internalFields.selected;
      true === isSelected && that._toggleChildrenSelection(node, isSelected);
    });
  },
  _setParentSelection() {
    const that = this;
    each(this._dataStructure, (_, node) => {
      const parent = that.options.dataConverter.getParentNode(node);
      if (parent && node.internalFields.parentKey !== that.options.rootValue) {
        that._iterateParents(node, (parent2) => {
          const newParentState = that._calculateSelectedState(parent2);
          that._setFieldState(parent2, SELECTED, newParentState);
        });
      }
    });
  },
  _setParentExpansion() {
    const that = this;
    each(this._dataStructure, (_, node) => {
      if (!node.internalFields.expanded) {
        return;
      }
      that._updateOneBranch(node.internalFields.key);
    });
  },
  _updateOneBranch(key) {
    const that = this;
    const node = this.getNodeByKey(key);
    that._iterateParents(node, (parent) => {
      that._setFieldState(parent, EXPANDED, true);
    });
  },
  _iterateChildren(node, recursive, callback, processedKeys) {
    if (!isFunction(callback)) {
      return;
    }
    const that = this;
    const nodeKey = node.internalFields.key;
    processedKeys = processedKeys || [];
    if (-1 === processedKeys.indexOf(nodeKey)) {
      processedKeys.push(nodeKey);
      each(node.internalFields.childrenKeys, (_, key) => {
        const child = that.getNodeByKey(key);
        callback(child);
        if (child.internalFields.childrenKeys.length && recursive) {
          that._iterateChildren(child, recursive, callback, processedKeys);
        }
      });
    }
  },
  _iterateParents(node, callback, processedKeys) {
    if (node.internalFields.parentKey === this.options.rootValue || !isFunction(callback)) {
      return;
    }
    processedKeys = processedKeys || [];
    const {
      key
    } = node.internalFields;
    if (-1 === processedKeys.indexOf(key)) {
      processedKeys.push(key);
      const parent = this.options.dataConverter.getParentNode(node);
      if (parent) {
        callback(parent);
        if (parent.internalFields.parentKey !== this.options.rootValue) {
          this._iterateParents(parent, callback, processedKeys);
        }
      }
    }
  },
  _calculateSelectedState(node) {
    const itemsCount = node.internalFields.childrenKeys.length;
    let selectedItemsCount = 0;
    let invisibleItemsCount = 0;
    let result2 = false;
    for (let i = 0; i <= itemsCount - 1; i++) {
      const childNode = this.getNodeByKey(node.internalFields.childrenKeys[i]);
      const isChildInvisible = false === childNode.internalFields.item.visible;
      const childState = childNode.internalFields.selected;
      if (isChildInvisible) {
        invisibleItemsCount++;
        continue;
      }
      if (childState) {
        selectedItemsCount++;
      } else if (void 0 === childState) {
        selectedItemsCount += 0.5;
      }
    }
    if (selectedItemsCount) {
      result2 = selectedItemsCount === itemsCount - invisibleItemsCount ? true : void 0;
    }
    return result2;
  },
  _toggleChildrenSelection(node, state) {
    const that = this;
    this._iterateChildren(node, true, (child) => {
      if (that._isNodeVisible(child)) {
        that._setFieldState(child, SELECTED, state);
      }
    });
  },
  _setFieldState(node, field, state) {
    if (node.internalFields[field] === state) {
      return;
    }
    node.internalFields[field] = state;
    if (node.internalFields.publicNode) {
      node.internalFields.publicNode[field] = state;
    }
    this.options.dataAccessors.setters[field](node.internalFields.item, state);
    this.options.onNodeChanged(node);
  },
  _markChildren(keys) {
    const that = this;
    each(keys, (_, key) => {
      const index2 = that.getIndexByKey(key);
      const node = that.getNodeByKey(key);
      that._dataStructure[index2] = 0;
      node.internalFields.childrenKeys.length && that._markChildren(node.internalFields.childrenKeys);
    });
  },
  _removeNode(key) {
    const node = this.getNodeByKey(key);
    this._dataStructure[this.getIndexByKey(key)] = 0;
    this._markChildren(node.internalFields.childrenKeys);
    const that = this;
    let counter = 0;
    const items = extend([], this._dataStructure);
    each(items, (index2, item) => {
      if (!item) {
        that._dataStructure.splice(index2 - counter, 1);
        counter++;
      }
    });
  },
  _addNode(item) {
    const {
      dataConverter
    } = this.options;
    const node = dataConverter._convertItemToNode(item, this.options.dataAccessors.getters.parentKey(item));
    this._dataStructure = this._dataStructure.concat(node);
    this._initialDataStructure = this._initialDataStructure.concat(node);
    dataConverter._dataStructure = dataConverter._dataStructure.concat(node);
  },
  _updateFields() {
    this.options.dataConverter.updateChildrenKeys();
    this._updateSelection();
    this._updateExpansion();
  },
  getSelectedNodesKeys() {
    return this._selectedNodesKeys;
  },
  getExpandedNodesKeys() {
    return this._expandedNodesKeys;
  },
  getData() {
    return this._dataStructure;
  },
  getFullData() {
    return this._initialDataStructure;
  },
  getNodeByItem(item) {
    let result2 = null;
    each(this._dataStructure, (_, node) => {
      if (node.internalFields.item === item) {
        result2 = node;
        return false;
      }
    });
    return result2;
  },
  getNodesByItems(items) {
    const that = this;
    const nodes = [];
    each(items, (_, item) => {
      const node = that.getNodeByItem(item);
      node && nodes.push(node);
    });
    return nodes;
  },
  getNodeByKey(key, data17) {
    return this._getByKey(data17 || this._getDataBySelectionMode(), key);
  },
  getTreeNodes() {
    return this.options.dataConverter.convertToPublicNodes(this.getRootNodes());
  },
  getItemsCount() {
    return this.options.dataConverter.getItemsCount();
  },
  getVisibleItemsCount() {
    return this.options.dataConverter.getVisibleItemsCount();
  },
  getPublicNode: (node) => node.internalFields.publicNode,
  getRootNodes() {
    return this.getChildrenNodes(this.options.rootValue);
  },
  getChildrenNodes(parentKey) {
    return m_query_default(this._dataStructure, {
      langParams: this.options.langParams
    }).filter(["internalFields.parentKey", parentKey]).toArray();
  },
  getIndexByKey(key) {
    return this.options.dataConverter.getIndexByKey(key);
  },
  addItem(item) {
    this._addNode(item);
    this._updateFields();
  },
  removeItem(key) {
    this._removeNode(key);
    this._updateFields();
  },
  toggleSelection(key, state, selectRecursive) {
    const isSingleModeUnselect = this._isSingleModeUnselect(state);
    const node = this._getByKey(selectRecursive || isSingleModeUnselect ? this._initialDataStructure : this._dataStructure, key);
    this._setFieldState(node, SELECTED, state);
    if (this.options.recursiveSelection && !selectRecursive) {
      state ? this._setChildrenSelection() : this._toggleChildrenSelection(node, state);
      this._setParentSelection();
    }
    this._selectedNodesKeys = this._updateNodesKeysArray(SELECTED);
  },
  _isSingleModeUnselect(selectionState) {
    return !this.options.multipleSelection && !selectionState;
  },
  toggleNodeDisabledState(key, state) {
    const node = this.getNodeByKey(key);
    this._setFieldState(node, DISABLED, state);
  },
  toggleSelectAll(state) {
    if (!isDefined(state)) {
      return;
    }
    const that = this;
    const lastSelectedKey = that._selectedNodesKeys[that._selectedNodesKeys.length - 1];
    const dataStructure = that._isSingleModeUnselect(state) ? this._initialDataStructure : this._dataStructure;
    each(dataStructure, (index2, node) => {
      if (!that._isNodeVisible(node)) {
        return;
      }
      that._setFieldState(node, SELECTED, state);
    });
    that._selectedNodesKeys = that._updateNodesKeysArray(SELECTED);
    if (!state && that.options.selectionRequired) {
      that.toggleSelection(lastSelectedKey, true);
    }
  },
  isAllSelected() {
    if (this.getSelectedNodesKeys().length) {
      return this.getSelectedNodesKeys().length === this.getVisibleItemsCount() ? true : void 0;
    }
    return false;
  },
  toggleExpansion(key, state) {
    const node = this.getNodeByKey(key);
    this._setFieldState(node, EXPANDED, state);
    if (state) {
      this._updateExpansion(key);
    }
    this._expandedNodesKeys = this._updateNodesKeysArray(EXPANDED);
  },
  isFiltered(item) {
    return !this.options.searchValue.length || !!this._filterDataStructure(this.options.searchValue, [item]).length;
  },
  _createCriteria(selector, value2, operation) {
    const searchFilter = [];
    if (!Array.isArray(selector)) {
      return [selector, operation, value2];
    }
    each(selector, (i, item) => {
      searchFilter.push([item, operation, value2], "or");
    });
    searchFilter.pop();
    return searchFilter;
  },
  _filterDataStructure(filterValue, dataStructure) {
    const selector = this.options.searchExpr || this.options.dataAccessors.getters.display;
    const operation = ui_search_box_mixin_default.getOperationBySearchMode(this.options.searchMode);
    const criteria = this._createCriteria(selector, filterValue, operation);
    dataStructure = dataStructure || this._initialDataStructure;
    return m_query_default(dataStructure, {
      langParams: this.options.langParams
    }).filter(criteria).toArray();
  },
  search(searchValue) {
    const that = this;
    let matches = this._filterDataStructure(searchValue);
    const {
      dataConverter
    } = this.options;
    !function lookForParents(matches2, index2) {
      const {
        length
      } = matches2;
      while (index2 < length) {
        const node = matches2[index2];
        if (node.internalFields.parentKey === that.options.rootValue) {
          index2++;
          continue;
        }
        const parent = dataConverter.getParentNode(node);
        if (!parent) {
          ui_errors_default.log("W1007", node.internalFields.parentKey, node.internalFields.key);
          index2++;
          continue;
        }
        if (!parent.internalFields.expanded) {
          that._setFieldState(parent, EXPANDED, true);
        }
        if (matches2.includes(parent)) {
          index2++;
          continue;
        }
        matches2.splice(index2, 0, parent);
        lookForParents(matches2, index2);
      }
    }(matches, 0);
    if (this.options.sort) {
      matches = m_store_helper_default.queryByOptions(m_query_default(matches), {
        sort: this.options.sort,
        langParams: this.options.langParams
      }).toArray();
    }
    dataConverter._indexByKey = {};
    each(matches, (index2, node) => {
      node.internalFields.childrenKeys = [];
      dataConverter._indexByKey[node.internalFields.key] = index2;
    });
    dataConverter._dataStructure = matches;
    dataConverter.setChildrenKeys();
    return dataConverter._dataStructure;
  }
});
var m_data_adapter_default = DataAdapter;

// node_modules/devextreme/esm/__internal/ui/hierarchical_collection/m_hierarchical_collection_widget.js
var HierarchicalCollectionWidget = class extends ui_collection_widget_async_default {
  _getDefaultOptions() {
    return _extends({}, super._getDefaultOptions(), {
      keyExpr: "id",
      displayExpr: "text",
      selectedExpr: "selected",
      disabledExpr: "disabled",
      itemsExpr: "items",
      hoverStateEnabled: true,
      parentIdExpr: "parentId",
      expandedExpr: "expanded"
    });
  }
  _defaultOptionsRules() {
    return super._defaultOptionsRules().concat([{
      device: () => "desktop" === devices_default.real().deviceType && !devices_default.isSimulator(),
      options: {
        focusStateEnabled: true
      }
    }]);
  }
  _init() {
    super._init();
    this._initAccessors();
    this._initDataAdapter();
    this._initDynamicTemplates();
  }
  _initDataSource() {
    var _this$_dataSource;
    super._initDataSource();
    null === (_this$_dataSource = this._dataSource) || void 0 === _this$_dataSource || _this$_dataSource.paginate(false);
  }
  _initDataAdapter() {
    const accessors = this._createDataAdapterAccessors();
    this._dataAdapter = new m_data_adapter_default(extend({
      dataAccessors: {
        getters: accessors.getters,
        setters: accessors.setters
      },
      items: this.option("items")
    }, this._getDataAdapterOptions()));
  }
  _getDataAdapterOptions() {
  }
  _getItemExtraPropNames() {
  }
  _initDynamicTemplates() {
    const fields = ["text", "html", "items", "icon"].concat(this._getItemExtraPropNames());
    this._templateManager.addDefaultTemplates({
      item: new BindableTemplate(this._addContent.bind(this), fields, this.option("integrationOptions.watchMethod"), {
        text: this._displayGetter,
        items: this._itemsGetter
      })
    });
  }
  _addContent($container, itemData) {
    $container.html(itemData.html).append(this._getIconContainer(itemData)).append(this._getTextContainer(itemData));
  }
  _getLinkContainer(iconContainer, textContainer, itemData) {
    const {
      linkAttr,
      url
    } = itemData;
    const linkAttributes = isObject(linkAttr) ? linkAttr : {};
    return renderer_default("<a>").addClass("dx-item-url").attr(_extends({}, linkAttributes, {
      href: url
    })).append(iconContainer).append(textContainer);
  }
  _getIconContainer(itemData) {
    if (!itemData.icon) {
      return;
    }
    const $imageContainer = getImageContainer(itemData.icon);
    if ($imageContainer.is("img")) {
      var _this$NAME;
      const componentName = null !== (_this$NAME = this.NAME) && void 0 !== _this$NAME && _this$NAME.startsWith("dxPrivateComponent") ? "" : `${this.NAME} `;
      $imageContainer.attr("alt", `${componentName}item icon`);
    }
    return $imageContainer;
  }
  _getTextContainer(itemData) {
    return renderer_default("<span>").text(itemData.text);
  }
  _initAccessors() {
    const that = this;
    each(this._getAccessors(), (_, accessor) => {
      that._compileAccessor(accessor);
    });
    this._compileDisplayGetter();
  }
  _getAccessors() {
    return ["key", "selected", "items", "disabled", "parentId", "expanded"];
  }
  _getChildNodes(node) {
    const that = this;
    const arr = [];
    each(node.internalFields.childrenKeys, (_, key) => {
      const childNode = that._dataAdapter.getNodeByKey(key);
      arr.push(childNode);
    });
    return arr;
  }
  _hasChildren(node) {
    return node && node.internalFields.childrenKeys.length;
  }
  _compileAccessor(optionName) {
    const getter = `_${optionName}Getter`;
    const setter = `_${optionName}Setter`;
    const optionExpr = this.option(`${optionName}Expr`);
    if (!optionExpr) {
      this[getter] = noop2;
      this[setter] = noop2;
      return;
    }
    if (isFunction(optionExpr)) {
      this[setter] = function(obj, value2) {
        obj[optionExpr()] = value2;
      };
      this[getter] = function(obj) {
        return obj[optionExpr()];
      };
      return;
    }
    this[getter] = compileGetter(optionExpr);
    this[setter] = compileSetter(optionExpr);
  }
  _createDataAdapterAccessors() {
    const that = this;
    const accessors = {
      getters: {},
      setters: {}
    };
    each(this._getAccessors(), (_, accessor) => {
      const getterName = `_${accessor}Getter`;
      const setterName = `_${accessor}Setter`;
      const newAccessor = "parentId" === accessor ? "parentKey" : accessor;
      accessors.getters[newAccessor] = that[getterName];
      accessors.setters[newAccessor] = that[setterName];
    });
    accessors.getters.display = !this._displayGetter ? (itemData) => itemData.text : this._displayGetter;
    return accessors;
  }
  _initMarkup() {
    super._initMarkup();
    this._addWidgetClass();
  }
  _addWidgetClass() {
    this._focusTarget().addClass(this._widgetClass());
  }
  _widgetClass() {
  }
  _renderItemFrame(index2, itemData, $itemContainer) {
    const $itemFrame = super._renderItemFrame.apply(this, arguments);
    $itemFrame.toggleClass("dx-state-disabled", !!this._disabledGetter(itemData));
    return $itemFrame;
  }
  _optionChanged(args) {
    switch (args.name) {
      case "displayExpr":
      case "keyExpr":
        this._initAccessors();
        this._initDynamicTemplates();
        this.repaint();
        break;
      case "itemsExpr":
      case "selectedExpr":
      case "disabledExpr":
      case "expandedExpr":
      case "parentIdExpr":
        this._initAccessors();
        this._initDataAdapter();
        this.repaint();
        break;
      case "items":
        this._initDataAdapter();
        super._optionChanged(args);
        break;
      default:
        super._optionChanged(args);
    }
  }
};
var m_hierarchical_collection_widget_default = HierarchicalCollectionWidget;

// node_modules/devextreme/esm/__internal/ui/context_menu/m_menu_base.js
var ITEM_CLASS2 = "dx-menu-item";
var DX_ITEM_CONTENT_CLASS = `${ITEM_CLASS2}-content`;
var DX_MENU_SELECTED_ITEM_CLASS = `${ITEM_CLASS2}-selected`;
var DX_MENU_ITEM_WRAPPER_CLASS = `${ITEM_CLASS2}-wrapper`;
var DX_MENU_ITEM_EXPANDED_CLASS = `${ITEM_CLASS2}-expanded`;
var DX_ITEM_HAS_TEXT = `${ITEM_CLASS2}-has-text`;
var DX_ITEM_HAS_ICON = `${ITEM_CLASS2}-has-icon`;
var DX_ITEM_HAS_SUBMENU = `${ITEM_CLASS2}-has-submenu`;
var DX_MENU_ITEM_POPOUT_CLASS = `${ITEM_CLASS2}-popout`;
var DX_MENU_ITEM_POPOUT_CONTAINER_CLASS = `${DX_MENU_ITEM_POPOUT_CLASS}-container`;
var DX_MENU_ITEM_CAPTION_CLASS = `${ITEM_CLASS2}-text`;
var DEFAULT_DELAY = {
  show: 50,
  hide: 300
};
var DX_MENU_ITEM_CAPTION_URL_CLASS = `${DX_MENU_ITEM_CAPTION_CLASS}-with-url`;
var MenuBase = class extends m_hierarchical_collection_widget_default {
  _getDefaultOptions() {
    return extend(super._getDefaultOptions(), {
      items: [],
      cssClass: "",
      activeStateEnabled: true,
      showSubmenuMode: {
        name: "onHover",
        delay: {
          show: 50,
          hide: 300
        }
      },
      animation: {
        show: {
          type: "fade",
          from: 0,
          to: 1,
          duration: 100
        },
        hide: {
          type: "fade",
          from: 1,
          to: 0,
          duration: 100
        }
      },
      selectByClick: false,
      focusOnSelectedItem: false,
      keyExpr: null,
      _itemAttributes: {
        role: "menuitem"
      },
      useInkRipple: false
    });
  }
  _itemDataKey() {
    return "dxMenuItemDataKey";
  }
  _itemClass() {
    return ITEM_CLASS2;
  }
  _setAriaSelectionAttribute($itemElement, isSelected) {
  }
  _selectedItemClass() {
    return DX_MENU_SELECTED_ITEM_CLASS;
  }
  _widgetClass() {
    return "dx-menu-base";
  }
  _focusTarget() {
    return this._itemContainer();
  }
  _clean() {
    this.option("focusedElement", null);
    super._clean();
  }
  _supportedKeys() {
    return extend(super._supportedKeys(), {
      space: () => {
        const $item = renderer_default(this.option("focusedElement"));
        if (!$item.length || !this._isSelectionEnabled()) {
          return;
        }
        this.selectItem($item[0]);
      },
      pageUp: noop2,
      pageDown: noop2
    });
  }
  _isSelectionEnabled() {
    const {
      selectionMode
    } = this.option();
    return "single" === selectionMode;
  }
  _init() {
    super._init();
    this._activeStateUnit = `.${ITEM_CLASS2}`;
    this._renderSelectedItem();
    this._initActions();
  }
  _getLinkContainer(iconContainer, textContainer, itemData) {
    const {
      linkAttr,
      url
    } = itemData;
    null === iconContainer || void 0 === iconContainer || iconContainer.addClass("dx-icon-with-url");
    null === textContainer || void 0 === textContainer || textContainer.addClass(DX_MENU_ITEM_CAPTION_URL_CLASS);
    return super._getLinkContainer(iconContainer, textContainer, {
      linkAttr,
      url
    });
  }
  _addContent($container, itemData) {
    const {
      html,
      url
    } = itemData;
    if (url) {
      $container.html(html);
      const link = this._getLinkContainer(this._getIconContainer(itemData), this._getTextContainer(itemData), itemData);
      $container.append(link);
    } else {
      super._addContent($container, itemData);
    }
    $container.append(this._getPopoutContainer(itemData));
    this._addContentClasses(itemData, $container.parent());
  }
  _getTextContainer(itemData) {
    const {
      text
    } = itemData;
    if (!text) {
      return;
    }
    const $itemContainer = renderer_default("<span>").addClass(DX_MENU_ITEM_CAPTION_CLASS);
    const itemText = isPlainObject(itemData) ? text : String(itemData);
    return $itemContainer.text(itemText);
  }
  _getItemExtraPropNames() {
    return ["url", "linkAttr"];
  }
  _getPopoutContainer(itemData) {
    const {
      items
    } = itemData;
    let $popOutContainer;
    if (null !== items && void 0 !== items && items.length) {
      const $popOutImage = renderer_default("<div>").addClass(DX_MENU_ITEM_POPOUT_CLASS);
      $popOutContainer = renderer_default("<span>").addClass(DX_MENU_ITEM_POPOUT_CONTAINER_CLASS).append($popOutImage);
    }
    return $popOutContainer;
  }
  _getDataAdapterOptions() {
    return {
      rootValue: 0,
      multipleSelection: false,
      recursiveSelection: false,
      recursiveExpansion: false,
      searchValue: ""
    };
  }
  _selectByItem(selectedItem) {
    if (!selectedItem) {
      return;
    }
    const nodeToSelect = this._dataAdapter.getNodeByItem(selectedItem);
    this._dataAdapter.toggleSelection(nodeToSelect.internalFields.key, true);
  }
  _renderSelectedItem() {
    const selectedKeys = this._dataAdapter.getSelectedNodesKeys();
    const selectedKey = selectedKeys.length && selectedKeys[0];
    const selectedItem = this.option("selectedItem");
    if (!selectedKey) {
      this._selectByItem(selectedItem);
      return;
    }
    const node = this._dataAdapter.getNodeByKey(selectedKey);
    if (false === node.selectable) {
      return;
    }
    if (!selectedItem) {
      this.option("selectedItem", node.internalFields.item);
      return;
    }
    if (selectedItem !== node.internalFields.item) {
      this._dataAdapter.toggleSelection(selectedKey, false);
      this._selectByItem(selectedItem);
    }
  }
  _initActions() {
  }
  _initMarkup() {
    super._initMarkup();
    this.option("useInkRipple") && this._renderInkRipple();
  }
  _renderInkRipple() {
    this._inkRipple = render();
  }
  _toggleActiveState($element, value2, e) {
    super._toggleActiveState.apply(this, arguments);
    if (!this._inkRipple) {
      return;
    }
    const config3 = {
      element: $element,
      event: e
    };
    if (value2) {
      this._inkRipple.showWave(config3);
    } else {
      this._inkRipple.hideWave(config3);
    }
  }
  _getShowSubmenuMode() {
    const {
      showSubmenuMode
    } = this.option();
    const showMode = isObject(showSubmenuMode) ? showSubmenuMode.name : showSubmenuMode;
    return this._isDesktopDevice() ? showMode : "onClick";
  }
  _initSelectedItems() {
  }
  _isDesktopDevice() {
    return "desktop" === devices_default.real().deviceType;
  }
  _initEditStrategy() {
    const Strategy = m_menu_base_edit_strategy_default;
    this._editStrategy = new Strategy(this);
  }
  _addCustomCssClass($element) {
    $element.addClass(this.option("cssClass"));
  }
  _itemWrapperSelector() {
    return `.${DX_MENU_ITEM_WRAPPER_CLASS}`;
  }
  _hoverStartHandler(e) {
    const $itemElement = this._getItemElementByEventArgs(e);
    if (!$itemElement || this._isItemDisabled($itemElement)) {
      return;
    }
    e.stopPropagation();
    if ("onHover" === this._getShowSubmenuMode()) {
      const submenuDelay = this._getSubmenuDelay("show");
      if (0 === submenuDelay) {
        this._showSubmenu($itemElement);
      } else {
        clearTimeout(this._showSubmenusTimeout);
        this._showSubmenusTimeout = setTimeout(this._showSubmenu.bind(this, $itemElement), submenuDelay);
      }
    }
  }
  _getAvailableItems($itemElements) {
    return super._getAvailableItems($itemElements).filter(function() {
      return "hidden" !== renderer_default(this).css("visibility");
    });
  }
  _isItemDisabled($item) {
    return this._disabledGetter($item.data(this._itemDataKey()));
  }
  _showSubmenu($itemElement) {
    this._addExpandedClass($itemElement);
  }
  _addExpandedClass(itemElement) {
    renderer_default(itemElement).addClass(DX_MENU_ITEM_EXPANDED_CLASS);
  }
  _getSubmenuDelay(action) {
    const {
      delay
    } = this.option("showSubmenuMode");
    if (!isDefined(delay)) {
      return DEFAULT_DELAY[action];
    }
    return isObject(delay) ? delay[action] : delay;
  }
  _getItemElementByEventArgs(eventArgs) {
    let $target = renderer_default(eventArgs.target);
    if ($target.hasClass(this._itemClass()) || $target.get(0) === eventArgs.currentTarget) {
      return $target;
    }
    while (!$target.hasClass(this._itemClass())) {
      $target = $target.parent();
      if ($target.hasClass("dx-submenu")) {
        return null;
      }
    }
    return $target;
  }
  _hoverEndHandler(event) {
    clearTimeout(this._showSubmenusTimeout);
  }
  _hasSubmenu(node) {
    return null === node || void 0 === node ? void 0 : node.internalFields.childrenKeys.length;
  }
  _renderContentImpl() {
    this._renderItems(this._dataAdapter.getRootNodes());
  }
  _renderItems(nodes, submenuContainer) {
    if (!nodes.length) {
      return;
    }
    this.hasIcons = false;
    const $nodeContainer = this._renderContainer(this.$element(), submenuContainer);
    let firstVisibleIndex = -1;
    let nextGroupFirstIndex = -1;
    each(nodes, (index2, node) => {
      const isVisibleNode = false !== node.visible;
      if (isVisibleNode && firstVisibleIndex < 0) {
        firstVisibleIndex = index2;
      }
      const isBeginGroup = firstVisibleIndex < index2 && (node.beginGroup || index2 === nextGroupFirstIndex);
      if (isBeginGroup) {
        nextGroupFirstIndex = isVisibleNode ? index2 : index2 + 1;
      }
      if (index2 === nextGroupFirstIndex && firstVisibleIndex < index2) {
        this._renderSeparator($nodeContainer);
      }
      this._renderItem(index2, node, $nodeContainer);
    });
    if (!this.hasIcons) {
      $nodeContainer.addClass("dx-menu-no-icons");
    }
  }
  _renderContainer($wrapper, submenuContainer) {
    const $container = renderer_default("<ul>");
    this.setAria("role", "none", $container);
    return $container.appendTo($wrapper).addClass("dx-menu-items-container");
  }
  _createDOMElement($nodeContainer) {
    const $node = renderer_default("<li>");
    this.setAria("role", "none", $node);
    return $node.appendTo($nodeContainer).addClass(DX_MENU_ITEM_WRAPPER_CLASS);
  }
  _renderItem(index2, node, $nodeContainer, $nodeElement) {
    var _items;
    const {
      items = []
    } = this.option();
    const $node = $nodeElement ?? this._createDOMElement($nodeContainer);
    if (null !== (_items = items[index2 + 1]) && void 0 !== _items && _items.beginGroup) {
      $node.addClass("dx-menu-last-group-item");
    }
    const $itemFrame = super._renderItem(index2, node.internalFields.item, $node);
    if (node.internalFields.item === this.option("selectedItem")) {
      $itemFrame.addClass(DX_MENU_SELECTED_ITEM_CLASS);
    }
    $itemFrame.attr("tabIndex", -1);
    if (this._hasSubmenu(node)) {
      this.setAria("haspopup", "true", $itemFrame);
    }
    return $itemFrame;
  }
  _renderItemFrame(index2, itemData, $itemContainer) {
    const $itemFrame = $itemContainer.children(`.${ITEM_CLASS2}`);
    return $itemFrame.length ? $itemFrame : super._renderItemFrame.apply(this, arguments);
  }
  _refreshItem($item, item) {
    const node = this._dataAdapter.getNodeByItem(item);
    const index2 = $item.data(this._itemIndexKey());
    const $nodeContainer = $item.closest("ul");
    const $nodeElement = $item.closest("li");
    this._renderItem(index2, node, $nodeContainer, $nodeElement);
  }
  _addContentClasses(itemData, $itemFrame) {
    const hasText = itemData.text ? !!itemData.text.length : false;
    const hasIcon = !!itemData.icon;
    const hasSubmenu = itemData.items ? !!itemData.items.length : false;
    $itemFrame.toggleClass(DX_ITEM_HAS_TEXT, hasText);
    $itemFrame.toggleClass(DX_ITEM_HAS_ICON, hasIcon);
    if (!this.hasIcons) {
      this.hasIcons = hasIcon;
    }
    $itemFrame.toggleClass(DX_ITEM_HAS_SUBMENU, hasSubmenu);
  }
  _getItemContent($itemFrame) {
    let $itemContent = super._getItemContent($itemFrame);
    if (!$itemContent.length) {
      $itemContent = $itemFrame.children(`.${DX_ITEM_CONTENT_CLASS}`);
    }
    return $itemContent;
  }
  _postprocessRenderItem(args) {
    const $itemElement = renderer_default(args.itemElement);
    const selectedIndex = this._dataAdapter.getSelectedNodesKeys();
    if (!selectedIndex.length || !this._selectedGetter(args.itemData) || !this._isItemSelectable(args.itemData)) {
      this._setAriaSelectionAttribute($itemElement, "false");
      return;
    }
    const node = this._dataAdapter.getNodeByItem(args.itemData);
    if (node.internalFields.key === selectedIndex[0]) {
      $itemElement.addClass(this._selectedItemClass());
      this._setAriaSelectionAttribute($itemElement, "true");
    } else {
      this._setAriaSelectionAttribute($itemElement, "false");
    }
  }
  _isItemSelectable(item) {
    return false !== item.selectable;
  }
  _renderSeparator($itemsContainer) {
    renderer_default("<li>").appendTo($itemsContainer).addClass("dx-menu-separator");
  }
  _itemClickHandler(e) {
    if (e._skipHandling) {
      return;
    }
    const itemClickActionHandler = this._createAction(this._updateSubmenuVisibilityOnClick.bind(this));
    this._itemDXEventHandler(e, "onItemClick", {}, {
      beforeExecute: this._itemClick,
      afterExecute: itemClickActionHandler.bind(this)
    });
    e._skipHandling = true;
  }
  _itemClick(actionArgs) {
    const {
      event,
      itemData
    } = actionArgs.args[0];
    const $itemElement = this._getItemElementByEventArgs(event);
    const link = $itemElement && $itemElement.find(".dx-item-url").get(0);
    if (itemData.url && link) {
      link.click();
    }
  }
  _updateSubmenuVisibilityOnClick(actionArgs) {
    this._updateSelectedItemOnClick(actionArgs);
    if ("onClick" === this._getShowSubmenuMode()) {
      this._addExpandedClass(actionArgs.args[0].itemElement);
    }
  }
  _updateSelectedItemOnClick(actionArgs) {
    const args = actionArgs.args ? actionArgs.args[0] : actionArgs;
    if (!this._isItemSelectAllowed(args.itemData)) {
      return;
    }
    const selectedItemKey = this._dataAdapter.getSelectedNodesKeys();
    const selectedNode = selectedItemKey.length && this._dataAdapter.getNodeByKey(selectedItemKey[0]);
    if (selectedNode) {
      this._toggleItemSelection(selectedNode, false);
    }
    if (!selectedNode || selectedNode.internalFields.item !== args.itemData) {
      this.selectItem(args.itemData);
    } else {
      this._fireSelectionChangeEvent(null, this.option("selectedItem"));
      this._setOptionWithoutOptionChange("selectedItem", null);
    }
  }
  _isItemSelectAllowed(item) {
    const isSelectByClickEnabled = this._isSelectionEnabled() && this.option("selectByClick");
    return !this._isContainerEmpty() && isSelectByClickEnabled && this._isItemSelectable(item) && !this._itemsGetter(item);
  }
  _isContainerEmpty() {
    return this._itemContainer().is(":empty");
  }
  _syncSelectionOptions() {
    return asyncNoop();
  }
  _optionChanged(args) {
    switch (args.name) {
      case "showSubmenuMode":
        break;
      case "selectedItem": {
        const node = this._dataAdapter.getNodeByItem(args.value);
        const selectedKey = this._dataAdapter.getSelectedNodesKeys()[0];
        if (node && node.internalFields.key !== selectedKey) {
          if (false === node.selectable) {
            break;
          }
          if (selectedKey) {
            this._toggleItemSelection(this._dataAdapter.getNodeByKey(selectedKey), false);
          }
          this._toggleItemSelection(node, true);
          this._updateSelectedItems();
        }
        break;
      }
      case "cssClass":
      case "position":
      case "selectByClick":
      case "animation":
      case "useInkRipple":
        this._invalidate();
        break;
      default:
        super._optionChanged(args);
    }
  }
  _toggleItemSelection(node, value2) {
    const itemElement = this._getElementByItem(node.internalFields.item);
    itemElement && renderer_default(itemElement).toggleClass(DX_MENU_SELECTED_ITEM_CLASS);
    this._dataAdapter.toggleSelection(node.internalFields.key, value2);
  }
  _getElementByItem(itemData) {
    let result2;
    each(this._itemElements(), (_, itemElement) => {
      if (renderer_default(itemElement).data(this._itemDataKey()) !== itemData) {
        return true;
      }
      result2 = itemElement;
      return false;
    });
    return result2;
  }
  _updateSelectedItems(oldSelection, newSelection) {
    if (oldSelection || newSelection) {
      this._fireSelectionChangeEvent(newSelection, oldSelection);
    }
  }
  _fireSelectionChangeEvent(addedSelection, removedSelection) {
    this._createActionByOption("onSelectionChanged", {
      excludeValidators: ["disabled", "readOnly"]
    })({
      addedItems: [addedSelection],
      removedItems: [removedSelection]
    });
  }
  selectItem(itemElement) {
    const itemData = itemElement.nodeType ? this._getItemData(itemElement) : itemElement;
    const selectedKey = this._dataAdapter.getSelectedNodesKeys()[0];
    const selectedItem = this.option("selectedItem");
    const node = this._dataAdapter.getNodeByItem(itemData);
    if (node.internalFields.key !== selectedKey) {
      if (selectedKey) {
        this._toggleItemSelection(this._dataAdapter.getNodeByKey(selectedKey), false);
      }
      this._toggleItemSelection(node, true);
      this._updateSelectedItems(selectedItem, itemData);
      this._setOptionWithoutOptionChange("selectedItem", itemData);
    }
  }
  unselectItem(itemElement) {
    const itemData = itemElement.nodeType ? this._getItemData(itemElement) : itemElement;
    const node = this._dataAdapter.getNodeByItem(itemData);
    const selectedItem = this.option("selectedItem");
    if (node.internalFields.selected) {
      this._toggleItemSelection(node, false);
      this._updateSelectedItems(selectedItem, null);
      this._setOptionWithoutOptionChange("selectedItem", null);
    }
  }
};
MenuBase.ItemClass = item_default;
var m_menu_base_default = MenuBase;

// node_modules/devextreme/esm/__internal/ui/context_menu/m_context_menu.js
var DX_MENU_PHONE_CLASS = "dx-menu-phone-overlay";
var ACTIONS = ["onShowing", "onShown", "onSubmenuCreated", "onHiding", "onHidden", "onPositioning", "onLeftFirstItem", "onLeftLastItem", "onCloseRootSubmenu", "onExpandLastSubmenu"];
var LOCAL_SUBMENU_DIRECTIONS = ["up", "down", "first", "last"];
var window20 = getWindow();
var ContextMenu2 = class extends m_menu_base_default {
  getShowEvent(showEventOption) {
    if (isObject(showEventOption)) {
      if (null !== showEventOption.name) {
        return showEventOption.name ?? "dxcontextmenu";
      }
    } else {
      return showEventOption;
    }
    return null;
  }
  getShowDelay(showEventOption) {
    return isObject(showEventOption) && showEventOption.delay;
  }
  _getDefaultOptions() {
    return extend(super._getDefaultOptions(), {
      showEvent: "dxcontextmenu",
      hideOnOutsideClick: true,
      position: {
        at: "top left",
        my: "top left"
      },
      onShowing: null,
      onShown: null,
      onSubmenuCreated: null,
      onHiding: null,
      onHidden: null,
      onPositioning: null,
      submenuDirection: "auto",
      visible: false,
      target: void 0,
      onLeftFirstItem: null,
      onLeftLastItem: null,
      onCloseRootSubmenu: null,
      onExpandLastSubmenu: null,
      hideOnParentScroll: true,
      visualContainer: window20
    });
  }
  _defaultOptionsRules() {
    return super._defaultOptionsRules().concat([{
      device: () => !hasWindow(),
      options: {
        animation: null
      }
    }]);
  }
  _initActions() {
    this._actions = {};
    each(ACTIONS, (index2, action) => {
      this._actions[action] = this._createActionByOption(action) || noop2;
    });
  }
  _setOptionsByReference() {
    super._setOptionsByReference();
    extend(this._optionsByReference, {
      animation: true,
      selectedItem: true
    });
  }
  _focusInHandler() {
  }
  _itemContainer() {
    return this._overlay ? this._overlay.$content() : renderer_default();
  }
  _eventBindingTarget() {
    return this._itemContainer();
  }
  itemsContainer() {
    return this._overlay ? this._overlay.$content() : void 0;
  }
  _supportedKeys() {
    return extend(super._supportedKeys(), {
      space: () => {
        const $item = renderer_default(this.option("focusedElement"));
        this.hide();
        if (!$item.length || !this._isSelectionEnabled()) {
          return;
        }
        this.selectItem($item[0]);
      },
      escape: this.hide
    });
  }
  _getActiveItem(last) {
    const $availableItems = this._getAvailableItems();
    const $focusedItem = $availableItems.filter(".dx-state-focused");
    const $hoveredItem = $availableItems.filter(".dx-state-hover");
    const $hoveredItemContainer = $hoveredItem.closest(".dx-menu-items-container");
    if ($hoveredItemContainer.find(".dx-menu-item").index($focusedItem) >= 0) {
      return $focusedItem;
    }
    if ($hoveredItem.length) {
      return $hoveredItem;
    }
    return super._getActiveItem();
  }
  _moveFocus(location) {
    const $items = this._getItemsByLocation(location);
    const $oldTarget = this._getActiveItem(true);
    const $hoveredItem = this.itemsContainer().find(".dx-state-hover");
    const $focusedItem = renderer_default(this.option("focusedElement"));
    const $activeItemHighlighted = !!($focusedItem.length || $hoveredItem.length);
    let $newTarget;
    switch (location) {
      case "up":
        $newTarget = $activeItemHighlighted ? this._prevItem($items) : $oldTarget;
        this._setFocusedElement($newTarget);
        if ($oldTarget.is($items.first())) {
          this._actions.onLeftFirstItem($oldTarget);
        }
        break;
      case "down":
        $newTarget = $activeItemHighlighted ? this._nextItem($items) : $oldTarget;
        this._setFocusedElement($newTarget);
        if ($oldTarget.is($items.last())) {
          this._actions.onLeftLastItem($oldTarget);
        }
        break;
      case "right":
        $newTarget = this.option("rtlEnabled") ? this._hideSubmenuHandler() : this._expandSubmenuHandler($items, location);
        this._setFocusedElement($newTarget);
        break;
      case "left":
        $newTarget = this.option("rtlEnabled") ? this._expandSubmenuHandler($items, location) : this._hideSubmenuHandler();
        this._setFocusedElement($newTarget);
        break;
      case "first":
        $newTarget = $items.first();
        this._setFocusedElement($newTarget);
        break;
      case "last":
        $newTarget = $items.last();
        this._setFocusedElement($newTarget);
        break;
      default:
        return super._moveFocus(location);
    }
  }
  _setFocusedElement($element) {
    if ($element && 0 !== $element.length) {
      this.option("focusedElement", getPublicElement($element));
      this._scrollToElement($element);
    }
  }
  _scrollToElement($element) {
    const $scrollableElement = $element.closest(".dx-scrollable");
    const scrollableInstance = $scrollableElement.dxScrollable("instance");
    null === scrollableInstance || void 0 === scrollableInstance || scrollableInstance.scrollToElement($element);
  }
  _getItemsByLocation(location) {
    const $activeItem = this._getActiveItem(true);
    let $items;
    if (LOCAL_SUBMENU_DIRECTIONS.includes(location)) {
      $items = $activeItem.closest(".dx-menu-items-container").children().children();
    }
    $items = this._getAvailableItems($items);
    return $items;
  }
  _getAriaTarget() {
    return this.$element();
  }
  _refreshActiveDescendant() {
    if (isDefined(this._overlay)) {
      const $target = this._overlay.$content();
      super._refreshActiveDescendant($target);
    }
  }
  _hideSubmenuHandler() {
    const $curItem = this._getActiveItem(true);
    const $parentItem = $curItem.parents(".dx-menu-item-expanded").first();
    if ($parentItem.length) {
      this._hideSubmenusOnSameLevel($parentItem);
      this._hideSubmenu($curItem.closest(".dx-submenu"));
      return $parentItem;
    }
    this._actions.onCloseRootSubmenu($curItem);
  }
  _expandSubmenuHandler($items, location) {
    const $curItem = this._getActiveItem(true);
    const itemData = this._getItemData($curItem);
    const node = this._dataAdapter.getNodeByItem(itemData);
    const isItemHasSubmenu = this._hasSubmenu(node);
    const $submenu = $curItem.children(".dx-submenu");
    if (isItemHasSubmenu && !$curItem.hasClass("dx-state-disabled")) {
      if (!$submenu.length || "hidden" === $submenu.css("visibility")) {
        this._showSubmenu($curItem);
      }
      return this._nextItem(this._getItemsByLocation(location));
    }
    this._actions.onExpandLastSubmenu($curItem);
    return;
  }
  _clean() {
    if (this._overlay) {
      this._overlay.$element().remove();
      this._overlay = null;
    }
    this._detachShowContextMenuEvents(this._getTarget());
    this._shownSubmenus = [];
    super._clean();
  }
  _initMarkup() {
    this.$element().addClass("dx-has-context-menu");
    this._eventNamespace = `${this.NAME}${new guid_default2()}`;
    super._initMarkup();
  }
  _render() {
    super._render();
    this._renderVisibility(this.option("visible"));
    this._addWidgetClass();
  }
  _isTargetOutOfComponent(relatedTarget) {
    const isInsideContextMenu = 0 !== renderer_default(relatedTarget).closest(".dx-context-menu").length;
    return !isInsideContextMenu;
  }
  _focusOutHandler(e) {
    const {
      relatedTarget
    } = e;
    if (relatedTarget) {
      const isTargetOutside = this._isTargetOutOfComponent(relatedTarget);
      if (isTargetOutside) {
        this.hide();
      }
    }
    super._focusOutHandler(e);
  }
  _renderContentImpl() {
    this._detachShowContextMenuEvents(this._getTarget());
    this._showContextMenuEventHandler = this._createShowContextMenuEventHandler();
    this._attachShowContextMenuEvents();
  }
  _attachKeyboardEvents() {
    !this._keyboardListenerId && this._focusTarget().length && super._attachKeyboardEvents();
  }
  _renderContextMenuOverlay() {
    if (this._overlay) {
      return;
    }
    const overlayOptions = this._getOverlayOptions();
    this._overlay = this._createComponent(renderer_default("<div>").appendTo(this._$element), ui_overlay_default, overlayOptions);
    const $overlayContent = this._overlay.$content();
    $overlayContent.addClass("dx-context-menu");
    this._addCustomCssClass($overlayContent);
    this._addPlatformDependentClass($overlayContent);
    this._attachContextMenuEvent();
  }
  preventShowingDefaultContextMenuAboveOverlay() {
    const $itemContainer = this._itemContainer();
    const eventName = addNamespace2(name, this._eventNamespace);
    m_events_engine_default.off($itemContainer, eventName, ".dx-submenu");
    m_events_engine_default.on($itemContainer, eventName, ".dx-submenu", (e) => {
      e.stopPropagation();
      e.preventDefault();
      m_events_engine_default.off($itemContainer, eventName, ".dx-submenu");
    });
  }
  _itemContextMenuHandler(e) {
    super._itemContextMenuHandler(e);
    e.stopPropagation();
  }
  _addPlatformDependentClass($element) {
    if (devices_default.current().phone) {
      $element.addClass(DX_MENU_PHONE_CLASS);
    }
  }
  _createShowContextMenuEventHandler() {
    const showContextMenuAction = this._createAction((e) => {
      const {
        showEvent
      } = this.option();
      const delay = this.getShowDelay(showEvent);
      if (delay) {
        setTimeout(() => this._show(e.event), delay);
      } else {
        this._show(e.event);
      }
    }, {
      validatingTargetName: "target"
    });
    return (e) => showContextMenuAction({
      event: e,
      target: renderer_default(e.currentTarget)
    });
  }
  _detachShowContextMenuEvents(target, event) {
    const {
      showEvent: showEventOption
    } = this.option();
    const showEvent = this.getShowEvent(event ?? showEventOption);
    if (!showEvent) {
      return;
    }
    const isSelector = isString(target);
    const eventName = addNamespace2(showEvent, this._eventNamespace);
    if (isSelector) {
      m_events_engine_default.off(dom_adapter_default.getDocument(), eventName, target, this._showContextMenuEventHandler);
    } else {
      m_events_engine_default.off(renderer_default(target), eventName, this._showContextMenuEventHandler);
    }
  }
  _attachShowContextMenuEvents() {
    const {
      showEvent: showEventOption,
      disabled
    } = this.option();
    const showEvent = this.getShowEvent(showEventOption);
    if (!showEvent || disabled) {
      return;
    }
    const target = this._getTarget();
    const isSelector = isString(target);
    const eventName = addNamespace2(showEvent, this._eventNamespace);
    if (isSelector) {
      m_events_engine_default.on(dom_adapter_default.getDocument(), eventName, target, this._showContextMenuEventHandler);
    } else {
      m_events_engine_default.on(target, eventName, this._showContextMenuEventHandler);
    }
  }
  _hoverEndHandler(e) {
    super._hoverEndHandler(e);
    e.stopPropagation();
  }
  _renderDimensions() {
  }
  _renderContainer($wrapper, submenuContainer) {
    const $holder = submenuContainer || this._itemContainer();
    $wrapper = renderer_default("<div>");
    $wrapper.appendTo($holder).addClass("dx-submenu").css("visibility", submenuContainer ? "hidden" : "visible");
    if (!$wrapper.parent().hasClass("dx-overlay-content")) {
      this._addCustomCssClass($wrapper);
    }
    const $itemsContainer = super._renderContainer($wrapper);
    if (submenuContainer) {
      return $itemsContainer;
    }
    if (this.option("width")) {
      return $itemsContainer.css("minWidth", this.option("width"));
    }
    if (this.option("height")) {
      return $itemsContainer.css("minHeight", this.option("height"));
    }
    return $itemsContainer;
  }
  _renderSubmenuItems(node, $itemFrame) {
    this._renderItems(this._getChildNodes(node), $itemFrame);
    const $submenu = $itemFrame.children(".dx-submenu");
    this._actions.onSubmenuCreated({
      itemElement: getPublicElement($itemFrame),
      itemData: node.internalFields.item,
      submenuElement: getPublicElement($submenu)
    });
    this._initScrollable($submenu);
    this.setAria({
      role: "menu"
    }, $submenu);
  }
  _getOverlayOptions() {
    const position3 = this.option("position");
    const overlayOptions = {
      focusStateEnabled: this.option("focusStateEnabled"),
      animation: this.option("animation"),
      innerOverlay: true,
      hideOnOutsideClick: (e) => this._hideOnOutsideClickHandler(e),
      propagateOutsideClick: true,
      hideOnParentScroll: this.option("hideOnParentScroll"),
      deferRendering: false,
      container: this.option("overlayContainer"),
      position: {
        at: position3.at,
        my: position3.my,
        of: this._getTarget(),
        collision: "flipfit",
        boundary: this.option("visualContainer"),
        boundaryOffset: this.option("boundaryOffset")
      },
      shading: false,
      showTitle: false,
      height: "auto",
      width: "auto",
      onShown: this._overlayShownActionHandler.bind(this),
      onHiding: this._overlayHidingActionHandler.bind(this),
      onHidden: this._overlayHiddenActionHandler.bind(this),
      visualContainer: this.option("visualContainer")
    };
    return overlayOptions;
  }
  _overlayShownActionHandler(arg) {
    this._actions.onShown(arg);
  }
  _overlayHidingActionHandler(arg) {
    this._actions.onHiding(arg);
    if (!arg.cancel) {
      this._hideAllShownSubmenus();
      this._setOptionWithoutOptionChange("visible", false);
    }
  }
  _overlayHiddenActionHandler(arg) {
    this._actions.onHidden(arg);
  }
  _shouldHideOnOutsideClick(e) {
    const hideOnOutsideClick = this.option("hideOnOutsideClick");
    if (isFunction(hideOnOutsideClick)) {
      return hideOnOutsideClick(e);
    }
    return hideOnOutsideClick;
  }
  _hideOnOutsideClickHandler(e) {
    if (!this._shouldHideOnOutsideClick(e)) {
      return false;
    }
    if (dom_adapter_default.isDocument(e.target)) {
      return true;
    }
    const $activeItemContainer = this._getActiveItemsContainer(e.target);
    const $itemContainers = this._getItemsContainers();
    const $clickedItem = this._searchActiveItem(e.target);
    const $rootItem = this.$element().parents(".dx-menu-item");
    const isRootItemClicked = $clickedItem[0] === $rootItem[0] && $clickedItem.length && $rootItem.length;
    const isInnerOverlayClicked = this._isIncludeOverlay($activeItemContainer, $itemContainers) && $clickedItem.length;
    if (isInnerOverlayClicked || isRootItemClicked) {
      if ("onClick" === this._getShowSubmenuMode()) {
        this._hideAllShownChildSubmenus($clickedItem);
      }
      return false;
    }
    return true;
  }
  _getActiveItemsContainer(target) {
    return renderer_default(target).closest(".dx-menu-items-container");
  }
  _getItemsContainers() {
    return this._overlay.$content().find(".dx-menu-items-container");
  }
  _searchActiveItem(target) {
    return renderer_default(target).closest(".dx-menu-item").eq(0);
  }
  _isIncludeOverlay($activeOverlay, $allOverlays) {
    let isSame = false;
    each($allOverlays, (index2, $overlay) => {
      if ($activeOverlay.is($overlay) && !isSame) {
        isSame = true;
      }
    });
    return isSame;
  }
  _hideAllShownChildSubmenus($clickedItem) {
    const $submenuElements = $clickedItem.find(".dx-submenu");
    const shownSubmenus = extend([], this._shownSubmenus);
    if ($submenuElements.length > 0) {
      each(shownSubmenus, (index2, $submenu) => {
        const $context = this._searchActiveItem($submenu.context).parent();
        if ($context.parent().is($clickedItem.parent().parent()) && !$context.is($clickedItem.parent())) {
          this._hideSubmenu($submenu);
        }
      });
    }
  }
  _initScrollable($container) {
    this._createComponent($container, ui_scrollable_default, {
      useKeyboard: false,
      _onVisibilityChanged: (scrollable) => {
        scrollable.scrollTo(0);
      }
    });
  }
  _setSubMenuHeight($submenu, anchor, isNestedSubmenu) {
    const $itemsContainer = $submenu.find(".dx-menu-items-container");
    const contentHeight = getOuterHeight($itemsContainer);
    const maxHeight = this._getMaxHeight(anchor, !isNestedSubmenu);
    const menuHeight = Math.min(contentHeight, maxHeight);
    $submenu.css("height", isNestedSubmenu ? menuHeight : "100%");
  }
  _getMaxHeight(anchor) {
    let considerAnchorHeight = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : true;
    const windowHeight = getOuterHeight(window20);
    const isAnchorRenderer = isRenderer(anchor);
    const document2 = dom_adapter_default.getDocument();
    const isAnchorDocument = anchor.length && anchor[0] === document2;
    if (!isAnchorRenderer || isAnchorDocument) {
      return windowHeight;
    }
    const offsetTop = anchor[0].getBoundingClientRect().top;
    const anchorHeight = getOuterHeight(anchor);
    const availableHeight = considerAnchorHeight ? Math.max(offsetTop, windowHeight - offsetTop - anchorHeight) : Math.max(offsetTop + anchorHeight, windowHeight - offsetTop);
    return availableHeight - 10;
  }
  _dimensionChanged() {
    if (!this._shownSubmenus) {
      return;
    }
    this._shownSubmenus.forEach(($submenu) => {
      const $item = $submenu.closest(".dx-menu-item");
      this._setSubMenuHeight($submenu, $item, true);
      this._scrollToElement($item);
      const submenuPosition = this._getSubmenuPosition($item);
      position_default.setup($submenu, submenuPosition);
    });
  }
  _getSubmenuBorderWidth() {
    return isGeneric(current()) ? 1 : 0;
  }
  _showSubmenu($item) {
    const node = this._dataAdapter.getNodeByItem(this._getItemData($item));
    this._hideSubmenusOnSameLevel($item);
    if (!this._hasSubmenu(node)) {
      return;
    }
    let $submenu = $item.children(".dx-submenu");
    const isSubmenuRendered = $submenu.length;
    super._showSubmenu($item);
    if (!isSubmenuRendered) {
      this._renderSubmenuItems(node, $item);
      $submenu = $item.children(".dx-submenu");
    }
    this._planPostRenderActions($submenu);
  }
  _setSubmenuVisible($submenu) {
    if (!$submenu) {
      return;
    }
    const $item = null === $submenu || void 0 === $submenu ? void 0 : $submenu.closest(".dx-menu-item");
    this._setSubMenuHeight($submenu, $item, true);
    if (!this._isSubmenuVisible($submenu) && $item) {
      this._drawSubmenu($item);
    }
  }
  _hideSubmenusOnSameLevel($item) {
    const $expandedItems = $item.parent(".dx-menu-item-wrapper").siblings().find(".dx-menu-item-expanded");
    if ($expandedItems.length) {
      $expandedItems.removeClass("dx-menu-item-expanded");
      this._hideSubmenu($expandedItems.find(".dx-submenu"));
    }
  }
  _hideSubmenuGroup($submenu) {
    if (this._isSubmenuVisible($submenu)) {
      this._hideSubmenuCore($submenu);
    }
  }
  _isSubmenuVisible($submenu) {
    return "visible" === $submenu.css("visibility");
  }
  _drawSubmenu($itemElement) {
    var _this$_overlay;
    const animation3 = this.option("animation") ? this.option("animation").show : {};
    const $submenu = $itemElement.children(".dx-submenu");
    const submenuPosition = this._getSubmenuPosition($itemElement);
    if (null !== (_this$_overlay = this._overlay) && void 0 !== _this$_overlay && _this$_overlay.option("visible")) {
      if (!isDefined(this._shownSubmenus)) {
        this._shownSubmenus = [];
      }
      if (!this._shownSubmenus.includes($submenu)) {
        this._shownSubmenus.push($submenu);
      }
      if (animation3) {
        fx_default.stop($submenu);
      }
      position_default.setup($submenu, submenuPosition);
      if (animation3) {
        if (isPlainObject(animation3.to)) {
          animation3.to.position = submenuPosition;
        }
        this._animate($submenu, animation3);
      }
      $submenu.css("visibility", "visible");
    }
  }
  _animate($container, options2) {
    fx_default.animate($container, options2);
  }
  _getSubmenuPosition($rootItem) {
    const submenuDirection = this.option("submenuDirection").toLowerCase();
    const $rootItemWrapper = $rootItem.parent(".dx-menu-item-wrapper");
    const position3 = {
      collision: "flip",
      of: $rootItemWrapper,
      offset: {
        h: 0,
        v: -1
      }
    };
    switch (submenuDirection) {
      case "left":
        position3.at = "left top";
        position3.my = "right top";
        break;
      case "right":
        position3.at = "right top";
        position3.my = "left top";
        break;
      default:
        if (this.option("rtlEnabled")) {
          position3.at = "left top";
          position3.my = "right top";
        } else {
          position3.at = "right top";
          position3.my = "left top";
        }
    }
    return position3;
  }
  _updateSubmenuVisibilityOnClick(actionArgs) {
    if (!actionArgs.args.length) {
      return;
    }
    const {
      itemData
    } = actionArgs.args[0];
    const node = this._dataAdapter.getNodeByItem(itemData);
    if (!node) {
      return;
    }
    const $itemElement = renderer_default(actionArgs.args[0].itemElement);
    let $submenu = $itemElement.find(".dx-submenu");
    const shouldRenderSubmenu = this._hasSubmenu(node) && !$submenu.length;
    if (shouldRenderSubmenu) {
      this._renderSubmenuItems(node, $itemElement);
      $submenu = $itemElement.find(".dx-submenu");
    }
    if ($itemElement.context === $submenu.context && "visible" === $submenu.css("visibility")) {
      return;
    }
    this._updateSelectedItemOnClick(actionArgs);
    const notCloseMenuOnItemClick = itemData && false === itemData.closeMenuOnClick;
    if (!itemData || itemData.disabled || notCloseMenuOnItemClick) {
      return;
    }
    if (0 === $submenu.length) {
      var _this$_overlay2;
      const $prevSubmenu = renderer_default($itemElement.parents(".dx-submenu")[0]);
      this._hideSubmenu($prevSubmenu);
      if (!actionArgs.canceled && null !== (_this$_overlay2 = this._overlay) && void 0 !== _this$_overlay2 && _this$_overlay2.option("visible")) {
        this.option("visible", false);
      }
    } else {
      if (this._shownSubmenus && this._shownSubmenus.length > 0) {
        if (this._shownSubmenus[0].is($submenu)) {
          this._hideSubmenu($submenu);
        }
      }
      this._showSubmenu($itemElement);
    }
  }
  _hideSubmenu($curSubmenu) {
    const shownSubmenus = extend([], this._shownSubmenus);
    each(shownSubmenus, (index2, $submenu) => {
      if ($curSubmenu.is($submenu) || contains2($curSubmenu[0], $submenu[0])) {
        $submenu.parent().removeClass("dx-menu-item-expanded");
        this._hideSubmenuCore($submenu);
      }
    });
  }
  _hideSubmenuCore($submenu) {
    const index2 = this._shownSubmenus.indexOf($submenu);
    const animation3 = this.option("animation") ? this.option("animation").hide : null;
    if (index2 >= 0) {
      this._shownSubmenus.splice(index2, 1);
    }
    this._stopAnimate($submenu);
    animation3 && this._animate($submenu, animation3);
    $submenu.css("visibility", "hidden");
    const scrollableInstance = $submenu.dxScrollable("instance");
    scrollableInstance.scrollTo(0);
    this.option("focusedElement", null);
  }
  _stopAnimate($container) {
    fx_default.stop($container, true);
  }
  _hideAllShownSubmenus() {
    const shownSubmenus = extend([], this._shownSubmenus);
    const $expandedItems = this._overlay.$content().find(".dx-menu-item-expanded");
    $expandedItems.removeClass("dx-menu-item-expanded");
    each(shownSubmenus, (_, $submenu) => {
      this._hideSubmenu($submenu);
    });
  }
  _visibilityChanged(visible2) {
    if (visible2) {
      this._renderContentImpl();
    }
  }
  _optionChanged(args) {
    const {
      name: name2,
      value: value2,
      previousValue
    } = args;
    if (ACTIONS.includes(name2)) {
      this._initActions();
      return;
    }
    switch (name2) {
      case "visible":
        this._renderVisibility(value2);
        break;
      case "disabled":
      case "position":
      case "submenuDirection":
        this._invalidate();
        break;
      case "showEvent":
        if (previousValue) {
          this._detachShowContextMenuEvents(this._getTarget(), previousValue);
        }
        this._invalidate();
        break;
      case "target":
        if (previousValue) {
          this._detachShowContextMenuEvents(previousValue);
        }
        this._invalidate();
        break;
      case "hideOnOutsideClick":
      case "hideOnParentScroll":
      case "visualContainer":
        break;
      default:
        super._optionChanged(args);
    }
  }
  _renderVisibility(showing) {
    return showing ? this._show() : this._hide();
  }
  _toggleVisibility() {
  }
  _show(event) {
    const args = {
      jQEvent: event
    };
    let promise = Deferred().reject().promise();
    this._actions.onShowing(args);
    if (args.cancel) {
      return promise;
    }
    const position3 = this._positionContextMenu(event);
    if (position3) {
      var _event$originalEvent;
      if (!this._overlay) {
        this._renderContextMenuOverlay();
        this._overlay.$content().addClass(this._widgetClass());
        this._renderFocusState();
        this._attachHoverEvents();
        this._attachClickEvent();
        this._renderItems(this._dataAdapter.getRootNodes());
      }
      const $subMenu = renderer_default(this._overlay.content()).children(".dx-submenu");
      this._setOptionWithoutOptionChange("visible", true);
      this._overlay.option({
        height: () => this._getMaxHeight(position3.of),
        maxHeight: () => {
          const $content = $subMenu.find(".dx-menu-items-container");
          const borderWidth = this._getSubmenuBorderWidth();
          return getOuterHeight($content) + 2 * borderWidth;
        },
        position: position3
      });
      if ($subMenu.length) {
        this._setSubMenuHeight($subMenu, position3.of, false);
      }
      promise = this._overlay.show();
      null === event || void 0 === event || event.stopPropagation();
      this._setAriaAttributes();
      if ((null === event || void 0 === event || null === (_event$originalEvent = event.originalEvent) || void 0 === _event$originalEvent ? void 0 : _event$originalEvent.type) === m_hold_default.name) {
        this.preventShowingDefaultContextMenuAboveOverlay();
      }
    }
    return promise;
  }
  _renderItems(nodes, submenuContainer) {
    super._renderItems(nodes, submenuContainer);
    const $submenu = renderer_default(this._overlay.content()).children(".dx-submenu");
    if ($submenu.length) {
      this._initScrollable($submenu);
    }
  }
  _setAriaAttributes() {
    this._overlayContentId = `dx-${new guid_default2()}`;
    this.setAria("owns", this._overlayContentId);
    this.setAria({
      id: this._overlayContentId,
      role: "menu"
    }, this._overlay.$content());
  }
  _cleanAriaAttributes() {
    this._overlay && this.setAria("id", null, this._overlay.$content());
    this.setAria("owns", void 0);
  }
  _getTarget() {
    return this.option("target") || this.option("position").of || renderer_default(dom_adapter_default.getDocument());
  }
  _getContextMenuPosition() {
    return extend({}, this.option("position"), {
      of: this._getTarget()
    });
  }
  _positionContextMenu(jQEvent) {
    let position3 = this._getContextMenuPosition();
    const isInitialPosition = this._isInitialOptionValue("position");
    const positioningAction = this._createActionByOption("onPositioning");
    if (null !== jQEvent && void 0 !== jQEvent && jQEvent.preventDefault && isInitialPosition) {
      position3.of = jQEvent;
    }
    const actionArgs = {
      position: position3,
      event: jQEvent
    };
    positioningAction(actionArgs);
    if (actionArgs.cancel) {
      position3 = null;
    } else if (actionArgs.event) {
      actionArgs.event.cancel = true;
      jQEvent.preventDefault();
    }
    return position3;
  }
  _refresh() {
    if (!hasWindow()) {
      super._refresh();
    } else if (this._overlay) {
      const lastPosition = this._overlay.option("position");
      super._refresh();
      this._overlay && this._overlay.option("position", lastPosition);
    } else {
      super._refresh();
    }
  }
  _hide() {
    let promise;
    if (this._overlay) {
      promise = this._overlay.hide();
      this._setOptionWithoutOptionChange("visible", false);
    }
    this._cleanAriaAttributes();
    this.option("focusedElement", null);
    return promise || Deferred().reject().promise();
  }
  toggle(showing) {
    const visible2 = this.option("visible");
    showing = void 0 === showing ? !visible2 : showing;
    return this._renderVisibility(showing);
  }
  show() {
    return this.toggle(true);
  }
  hide() {
    return this.toggle(false);
  }
  _postProcessRenderItems($submenu) {
    this._setSubmenuVisible($submenu);
  }
};
component_registrator_default("dxContextMenu", ContextMenu2);
var m_context_menu_default = ContextMenu2;

// node_modules/devextreme/esm/ui/context_menu.js
var context_menu_default = m_context_menu_default;

// node_modules/devextreme/esm/__internal/grids/grid_core/context_menu/m_context_menu.js
var CONTEXT_MENU = "dx-context-menu";
var viewName = {
  columnHeadersView: "header",
  rowsView: "content",
  footerView: "footer",
  headerPanel: "toolbar"
};
var VIEW_NAMES = ["columnHeadersView", "rowsView", "footerView", "headerPanel"];
var ContextMenuController = class extends m_modules_default.ViewController {
  init() {
    this.createAction("onContextMenuPreparing");
  }
  getContextMenuItems(dxEvent) {
    if (!dxEvent) {
      return false;
    }
    const that = this;
    const $targetElement = renderer_default(dxEvent.target);
    let menuItems;
    each(VIEW_NAMES, function() {
      const view = that.getView(this);
      if (!view) {
        return;
      }
      const $viewElement = view.element();
      const isTargetElementInsideView = (null === $viewElement || void 0 === $viewElement ? void 0 : $viewElement.is($targetElement)) || (null === $viewElement || void 0 === $viewElement ? void 0 : $viewElement.find($targetElement).length);
      if (isTargetElementInsideView) {
        var _$targetCellElement$, _rowOptions$cells, _view$getContextMenuI;
        const isGroupRow3 = $targetElement.hasClass("dx-group-row");
        const $targetCellElement = isGroupRow3 ? $targetElement.find(".dx-group-cell").first() : $targetElement.closest(".dx-row > td, .dx-row > tr");
        const $targetRowElement = $targetCellElement.parent();
        const rowIndex = view.getRowIndex($targetRowElement);
        const columnIndex = null === (_$targetCellElement$ = $targetCellElement[0]) || void 0 === _$targetCellElement$ ? void 0 : _$targetCellElement$.cellIndex;
        const rowOptions = $targetRowElement.data("options");
        const options2 = {
          event: dxEvent,
          targetElement: getPublicElement($targetElement),
          target: viewName[this],
          rowIndex,
          row: view._getRows()[rowIndex],
          columnIndex,
          column: null === rowOptions || void 0 === rowOptions || null === (_rowOptions$cells = rowOptions.cells) || void 0 === _rowOptions$cells || null === (_rowOptions$cells = _rowOptions$cells[columnIndex]) || void 0 === _rowOptions$cells ? void 0 : _rowOptions$cells.column
        };
        options2.items = null === (_view$getContextMenuI = view.getContextMenuItems) || void 0 === _view$getContextMenuI ? void 0 : _view$getContextMenuI.call(view, options2);
        that.executeAction("onContextMenuPreparing", options2);
        that._contextMenuPrepared(options2);
        menuItems = options2.items;
        if (menuItems) {
          return false;
        }
      }
      return;
    });
    return menuItems;
  }
  _contextMenuPrepared(options2) {
  }
};
var ContextMenuView = class extends m_modules_default.View {
  init() {
    super.init();
    this._contextMenuController = this.getController("contextMenu");
  }
  _renderCore() {
    const $element = this.element().addClass(CONTEXT_MENU);
    this.setAria("role", "presentation", $element);
    this._createComponent($element, context_menu_default, {
      onPositioning: (actionArgs) => {
        const {
          event
        } = actionArgs;
        const contextMenuInstance = actionArgs.component;
        const items = this._contextMenuController.getContextMenuItems(event);
        if (items) {
          contextMenuInstance.option("items", items);
          event.stopPropagation();
        } else {
          actionArgs.cancel = true;
        }
      },
      onItemClick(params) {
        var _params$itemData, _params$itemData$onIt;
        null === (_params$itemData = params.itemData) || void 0 === _params$itemData || null === (_params$itemData$onIt = _params$itemData.onItemClick) || void 0 === _params$itemData$onIt || _params$itemData$onIt.call(_params$itemData, params);
      },
      cssClass: this.getWidgetContainerClass(),
      target: this.component.$element()
    });
  }
};
var contextMenuModule = {
  defaultOptions: () => ({
    onContextMenuPreparing: null
  }),
  controllers: {
    contextMenu: ContextMenuController
  },
  views: {
    contextMenuView: ContextMenuView
  }
};

// node_modules/devextreme/esm/__internal/grids/data_grid/module_not_extended/context_menu.js
m_core_default.registerModule("contextMenu", contextMenuModule);

// node_modules/devextreme/esm/__internal/grids/grid_core/error_handling/m_error_handling.js
var ErrorHandlingController = class extends m_modules_default.ViewController {
  init() {
    this._resizingController = this.getController("resizing");
    this._columnsController = this.getController("columns");
    this._columnHeadersView = this.getView("columnHeadersView");
    this._rowsView = this.getView("rowsView");
  }
  _createErrorRow(error2, $tableElements) {
    let $errorRow;
    let $closeButton;
    const $errorMessage = this._renderErrorMessage(error2);
    if ($tableElements) {
      $errorRow = renderer_default("<tr>").attr("role", "row").addClass("dx-error-row");
      $closeButton = renderer_default("<div>").addClass("dx-closebutton").addClass(this.addWidgetPrefix("action"));
      m_events_engine_default.on($closeButton, CLICK_EVENT_NAME, this.createAction((args) => {
        var _this$_resizingContro, _this$_resizingContro2;
        const e = args.event;
        let $errorRow2;
        const errorRowIndex = renderer_default(e.currentTarget).closest(".dx-error-row").index();
        e.stopPropagation();
        each($tableElements, (_, tableElement) => {
          $errorRow2 = renderer_default(tableElement).children("tbody").children("tr").eq(errorRowIndex);
          this.removeErrorRow($errorRow2);
        });
        null === (_this$_resizingContro = this._resizingController) || void 0 === _this$_resizingContro || null === (_this$_resizingContro2 = _this$_resizingContro.fireContentReadyAction) || void 0 === _this$_resizingContro2 || _this$_resizingContro2.call(_this$_resizingContro);
      }));
      renderer_default("<td>").attr({
        colSpan: this._columnsController.getVisibleColumns().length,
        role: "gridcell"
      }).prepend($closeButton).append($errorMessage).appendTo($errorRow);
      return $errorRow;
    }
    return $errorMessage;
  }
  _renderErrorMessage(error2) {
    const message = error2.url ? error2.message.replace(error2.url, "") : error2.message || error2;
    const $message = renderer_default("<div>").attr("role", "alert").attr("aria-roledescription", message_default.format("dxDataGrid-ariaError")).addClass("dx-error-message").text(message);
    if (error2.url) {
      renderer_default("<a>").attr("href", error2.url).text(error2.url).appendTo($message);
    }
    return $message;
  }
  renderErrorRow(error2, rowIndex, $popupContent) {
    var _this$_resizingContro3, _this$_resizingContro4;
    const that = this;
    let $errorMessageElement;
    let $firstErrorRow;
    if ($popupContent) {
      $popupContent.find(".dx-error-message").remove();
      $errorMessageElement = that._createErrorRow(error2);
      $popupContent.prepend($errorMessageElement);
      return $errorMessageElement;
    }
    const viewElement = rowIndex >= 0 || !that._columnHeadersView.isVisible() ? that._rowsView : that._columnHeadersView;
    const $tableElements = viewElement.getTableElements();
    each($tableElements, (_, tableElement) => {
      $errorMessageElement = that._createErrorRow(error2, $tableElements);
      $firstErrorRow = $firstErrorRow || $errorMessageElement;
      if (rowIndex >= 0) {
        const $row = viewElement._getRowElements(renderer_default(tableElement)).eq(rowIndex);
        that.removeErrorRow($row.next());
        $errorMessageElement.insertAfter($row);
      } else {
        const $tbody = renderer_default(tableElement).children("tbody");
        const rowElements = $tbody.children("tr");
        if (that._columnHeadersView.isVisible()) {
          that.removeErrorRow(rowElements.last());
          renderer_default(tableElement).append($errorMessageElement);
        } else {
          that.removeErrorRow(rowElements.first());
          $tbody.first().prepend($errorMessageElement);
        }
      }
    });
    null === (_this$_resizingContro3 = this._resizingController) || void 0 === _this$_resizingContro3 || null === (_this$_resizingContro4 = _this$_resizingContro3.fireContentReadyAction) || void 0 === _this$_resizingContro4 || _this$_resizingContro4.call(_this$_resizingContro3);
    return $firstErrorRow;
  }
  removeErrorRow($row) {
    if (!$row) {
      const $columnHeaders = this._columnHeadersView && this._columnHeadersView.element();
      $row = $columnHeaders && $columnHeaders.find(".dx-error-row");
      if (!$row || !$row.length) {
        const $rowsViewElement = this._rowsView.element();
        $row = $rowsViewElement && $rowsViewElement.find(".dx-error-row");
      }
    }
    $row && $row.hasClass("dx-error-row") && $row.remove();
  }
  optionChanged(args) {
    if ("errorRowEnabled" === args.name) {
      args.handled = true;
    } else {
      super.optionChanged(args);
    }
  }
};
var data2 = (Base) => class extends Base {
  init() {
    super.init();
    this.dataErrorOccurred.add((error2, $popupContent) => {
      if (this.option("errorRowEnabled")) {
        this._errorHandlingController.renderErrorRow(error2, void 0, $popupContent);
      }
    });
    this.changed.add((e) => {
      if (e && "loadError" === e.changeType) {
        return;
      }
      if (this._editingController && !this._editingController.hasChanges()) {
        var _this$_errorHandlingC, _this$_errorHandlingC2;
        null === (_this$_errorHandlingC = this._errorHandlingController) || void 0 === _this$_errorHandlingC || null === (_this$_errorHandlingC2 = _this$_errorHandlingC.removeErrorRow) || void 0 === _this$_errorHandlingC2 || _this$_errorHandlingC2.call(_this$_errorHandlingC);
      }
    });
  }
};
var errorHandlingModule = {
  defaultOptions: () => ({
    errorRowEnabled: true
  }),
  controllers: {
    errorHandling: ErrorHandlingController
  },
  extenders: {
    controllers: {
      data: data2
    }
  }
};

// node_modules/devextreme/esm/__internal/grids/data_grid/module_not_extended/error_handling.js
m_core_default.registerModule("errorHandling", errorHandlingModule);

// node_modules/devextreme/esm/__internal/grids/grid_core/views/a11y_status_container_component.js
var CLASSES4 = {
  container: "dx-gridbase-a11y-status-container"
};
var A11yStatusContainerComponent = (_ref) => {
  let {
    statusText
  } = _ref;
  return renderer_default("<div>").text(statusText ?? "").addClass(CLASSES4.container).attr("role", "status");
};

// node_modules/devextreme/esm/__internal/grids/grid_core/views/m_grid_view.js
var VIEW_NAMES2 = ["columnsSeparatorView", "blockSeparatorView", "trackerView", "headerPanel", "columnHeadersView", "rowsView", "footerView", "columnChooserView", "filterPanelView", "pagerView", "draggingHeaderView", "contextMenuView", "errorView", "headerFilterView", "filterBuilderView"];
var E2E_ATTRIBUTES = {
  a11yStatusContainer: "e2e-a11y-general-status-container"
};
var isPercentWidth = function(width) {
  return isString(width) && width.endsWith("%");
};
var isPixelWidth = function(width) {
  return isString(width) && width.endsWith("px");
};
var calculateFreeWidth = function(that, widths) {
  const contentWidth = that._rowsView.contentWidth();
  const totalWidth = that._getTotalWidth(widths, contentWidth);
  return contentWidth - totalWidth;
};
var calculateFreeWidthWithCurrentMinWidth = function(that, columnIndex, currentMinWidth, widths) {
  return calculateFreeWidth(that, widths.map((width, index2) => index2 === columnIndex ? currentMinWidth : width));
};
var restoreFocus2 = function(focusedElement, selectionRange) {
  hiddenFocus(focusedElement, true);
  m_utils_default.setSelectionRange(focusedElement, selectionRange);
};
var ResizingController = class extends m_modules_default.ViewController {
  callbackNames() {
    return ["resizeCompleted"];
  }
  init() {
    this._prevContentMinHeight = null;
    this._dataController = this.getController("data");
    this._columnsController = this.getController("columns");
    this._columnHeadersView = this.getView("columnHeadersView");
    this._adaptiveColumnsController = this.getController("adaptiveColumns");
    this._editorFactoryController = this.getController("editorFactory");
    this._footerView = this.getView("footerView");
    this._rowsView = this.getView("rowsView");
    this._gridView = this.getView("gridView");
  }
  _initPostRenderHandlers() {
    if (!this._refreshSizesHandler) {
      this._refreshSizesHandler = (e) => {
        let resizeDeferred = new Deferred().resolve(null);
        const changeType = null === e || void 0 === e ? void 0 : e.changeType;
        const isDelayed = null === e || void 0 === e ? void 0 : e.isDelayed;
        const needFireContentReady = changeType && "updateSelection" !== changeType && "updateFocusedRow" !== changeType && "pageIndex" !== changeType && !isDelayed;
        this._dataController.changed.remove(this._refreshSizesHandler);
        if (this._checkSize()) {
          resizeDeferred = this._refreshSizes(e);
        }
        if (needFireContentReady) {
          when(resizeDeferred).done(() => {
            this._setAriaLabel(e);
            this.fireContentReadyAction();
          });
        }
      };
      this._dataController.changed.add(() => {
        this._dataController.changed.add(this._refreshSizesHandler);
      });
    }
  }
  _refreshSizes(e) {
    let resizeDeferred = new Deferred().resolve(null);
    const changeType = null === e || void 0 === e ? void 0 : e.changeType;
    const isDelayed = null === e || void 0 === e ? void 0 : e.isDelayed;
    const items = this._dataController.items();
    if (!e || "refresh" === changeType || "prepend" === changeType || "append" === changeType) {
      if (!isDelayed) {
        resizeDeferred = this.resize();
      }
    } else if ("update" === changeType) {
      var _e$changeTypes;
      if (0 === (null === (_e$changeTypes = e.changeTypes) || void 0 === _e$changeTypes ? void 0 : _e$changeTypes.length)) {
        return resizeDeferred;
      }
      if ((items.length > 1 || "insert" !== e.changeTypes[0]) && !(0 === items.length && "remove" === e.changeTypes[0]) && !e.needUpdateDimensions) {
        resizeDeferred = new Deferred();
        this._waitAsyncTemplates().done(() => {
          deferUpdate(() => deferRender(() => deferUpdate(() => {
            this._setScrollerSpacing();
            this._rowsView.resize();
            resizeDeferred.resolve();
          })));
        }).fail(resizeDeferred.reject);
      } else {
        resizeDeferred = this.resize();
      }
    }
    return resizeDeferred;
  }
  fireContentReadyAction() {
    this.component._fireContentReadyAction();
  }
  _getWidgetAriaLabel() {
    return "dxDataGrid-ariaDataGrid";
  }
  _setAriaLabel(e) {
    var _this$_columnsControl;
    let widgetStatusText = "";
    let labelParts = [];
    const columnCount = (null === (_this$_columnsControl = this._columnsController) || void 0 === _this$_columnsControl || null === (_this$_columnsControl = _this$_columnsControl._columns) || void 0 === _this$_columnsControl ? void 0 : _this$_columnsControl.filter((_ref) => {
      let {
        visible: visible2
      } = _ref;
      return !!visible2;
    }).length) ?? 0;
    const totalItemsCount = Math.max(0, this._dataController.totalItemsCount());
    const widgetAriaLabel = this._getWidgetAriaLabel();
    widgetStatusText = message_default.format(widgetAriaLabel, totalItemsCount, columnCount);
    const expandableWidgetAriaLabel = message_default.format(this._expandableWidgetAriaId);
    labelParts = [widgetStatusText];
    if (expandableWidgetAriaLabel) {
      labelParts.push(expandableWidgetAriaLabel);
    }
    const $ariaLabelElement = this.component.$element().children(".dx-gridbase-container");
    this.component.setAria("label", labelParts.join(". "), $ariaLabelElement);
    if (!(null !== e && void 0 !== e && e.isFirstRender)) {
      this._gridView.setWidgetA11yStatusText(widgetStatusText);
    }
  }
  _getBestFitWidths() {
    var _widths;
    const rowsView18 = this._rowsView;
    const columnHeadersView10 = this._columnHeadersView;
    let widths = rowsView18.getColumnWidths();
    if (!(null !== (_widths = widths) && void 0 !== _widths && _widths.length)) {
      var _rowsView$getTableEle;
      const headersTableElement = columnHeadersView10.getTableElement();
      columnHeadersView10.setTableElement(null === (_rowsView$getTableEle = rowsView18.getTableElement()) || void 0 === _rowsView$getTableEle ? void 0 : _rowsView$getTableEle.children(".dx-header"));
      widths = columnHeadersView10.getColumnWidths();
      columnHeadersView10.setTableElement(headersTableElement);
    }
    return widths;
  }
  _setVisibleWidths(visibleColumns, widths) {
    const columnsController = this._columnsController;
    columnsController.beginUpdate();
    each(visibleColumns, (index2, column) => {
      const columnId = columnsController.getColumnId(column);
      columnsController.columnOption(columnId, "visibleWidth", widths[index2]);
    });
    columnsController.endUpdate();
  }
  _toggleBestFitModeForView(view, className, isBestFit) {
    if (!view || !view.isVisible()) {
      return;
    }
    const $rowsTables = this._rowsView.getTableElements();
    const $viewTables = view.getTableElements();
    each($rowsTables, (index2, tableElement) => {
      let $tableBody;
      const $rowsTable = renderer_default(tableElement);
      const $viewTable = $viewTables.eq(index2);
      if ($viewTable && $viewTable.length) {
        if (isBestFit) {
          $tableBody = $viewTable.children("tbody").appendTo($rowsTable);
        } else {
          $tableBody = $rowsTable.children(`.${className}`).appendTo($viewTable);
        }
        $tableBody.toggleClass(className, isBestFit);
        $tableBody.toggleClass(this.addWidgetPrefix("best-fit"), isBestFit);
      }
    });
  }
  _toggleBestFitMode(isBestFit) {
    const $rowsTable = this._rowsView.getTableElement();
    const $rowsFixedTable = this._rowsView.getTableElements().eq(1);
    if (!$rowsTable) {
      return;
    }
    $rowsTable.css("tableLayout", isBestFit ? "auto" : "fixed");
    $rowsTable.children("colgroup").css("display", isBestFit ? "none" : "");
    each($rowsFixedTable.find("tr.dx-group-row"), (idx, item) => {
      renderer_default(item).css("display", isBestFit ? "none" : "");
    });
    $rowsFixedTable.toggleClass(this.addWidgetPrefix("table-fixed"), !isBestFit);
    this._toggleBestFitModeForView(this._columnHeadersView, "dx-header", isBestFit);
    this._toggleBestFitModeForView(this._footerView, "dx-footer", isBestFit);
    if (this._needStretch()) {
      $rowsTable.get(0).style.width = isBestFit ? "auto" : "";
    }
  }
  _toggleContentMinHeight(value2) {
    const scrollable = this._rowsView.getScrollable();
    const $contentElement = this._rowsView._findContentElement();
    if (false === (null === scrollable || void 0 === scrollable ? void 0 : scrollable.option("useNative"))) {
      if (true === value2) {
        this._prevContentMinHeight = $contentElement.get(0).style.minHeight;
      }
      if (isDefined(this._prevContentMinHeight)) {
        $contentElement.css({
          minHeight: value2 ? m_utils_default.getContentHeightLimit(browser_default) : this._prevContentMinHeight
        });
      }
    }
  }
  _synchronizeColumns() {
    const columnsController = this._columnsController;
    const visibleColumns = columnsController.getVisibleColumns();
    const columnAutoWidth = this.option("columnAutoWidth");
    const wordWrapEnabled = this.option("wordWrapEnabled");
    const hasUndefinedColumnWidth = visibleColumns.some((column) => !isDefined(column.width));
    let needBestFit = this._needBestFit();
    let hasMinWidth = false;
    let resetBestFitMode;
    let isColumnWidthsCorrected = false;
    let resultWidths = [];
    let focusedElement;
    let selectionRange;
    !needBestFit && each(visibleColumns, (index2, column) => {
      if ("auto" === column.width) {
        needBestFit = true;
        return false;
      }
      return;
    });
    each(visibleColumns, (index2, column) => {
      if (column.minWidth) {
        hasMinWidth = true;
        return false;
      }
      return;
    });
    this._setVisibleWidths(visibleColumns, []);
    const $element = this.component.$element();
    if (needBestFit) {
      focusedElement = dom_adapter_default.getActiveElement($element.get(0));
      selectionRange = m_utils_default.getSelectionRange(focusedElement);
      this._toggleBestFitMode(true);
      resetBestFitMode = true;
    }
    this._toggleContentMinHeight(wordWrapEnabled);
    if ($element && $element.get(0) && this._maxWidth) {
      delete this._maxWidth;
      $element[0].style.maxWidth = "";
    }
    deferUpdate(() => {
      if (needBestFit) {
        resultWidths = this._getBestFitWidths();
        each(visibleColumns, (index2, column) => {
          const columnId = columnsController.getColumnId(column);
          columnsController.columnOption(columnId, "bestFitWidth", resultWidths[index2], true);
        });
      } else if (hasMinWidth) {
        resultWidths = this._getBestFitWidths();
      }
      each(visibleColumns, function(index2) {
        const {
          width
        } = this;
        if ("auto" !== width) {
          if (isDefined(width)) {
            resultWidths[index2] = isNumeric(width) || isPixelWidth(width) ? parseFloat(width) : width;
          } else if (!columnAutoWidth) {
            resultWidths[index2] = void 0;
          }
        }
      });
      if (resetBestFitMode) {
        this._toggleBestFitMode(false);
        resetBestFitMode = false;
        if (focusedElement && focusedElement !== dom_adapter_default.getActiveElement()) {
          const isFocusOutsideWindow = getBoundingRect(focusedElement).bottom < 0;
          if (!isFocusOutsideWindow) {
            restoreFocus2(focusedElement, selectionRange);
          }
        }
      }
      isColumnWidthsCorrected = this._correctColumnWidths(resultWidths, visibleColumns);
      if (columnAutoWidth) {
        !function() {
          let expandColumnWidth;
          each(visibleColumns, (index2, column) => {
            if ("groupExpand" === column.type) {
              expandColumnWidth = resultWidths[index2];
            }
          });
          each(visibleColumns, (index2, column) => {
            if ("groupExpand" === column.type && expandColumnWidth) {
              resultWidths[index2] = expandColumnWidth;
            }
          });
        }();
        if (this._needStretch()) {
          this._processStretch(resultWidths, visibleColumns);
        }
      }
      deferRender(() => {
        if (needBestFit || isColumnWidthsCorrected || hasUndefinedColumnWidth) {
          this._setVisibleWidths(visibleColumns, resultWidths);
        }
        if (wordWrapEnabled) {
          this._toggleContentMinHeight(false);
        }
      });
    });
  }
  _needBestFit() {
    return this.option("columnAutoWidth");
  }
  _needStretch() {
    return this._columnsController.getVisibleColumns().some((c) => "auto" === c.width && !c.command);
  }
  _getAverageColumnsWidth(resultWidths) {
    const freeWidth = calculateFreeWidth(this, resultWidths);
    const columnCountWithoutWidth = resultWidths.filter((width) => void 0 === width).length;
    return freeWidth / columnCountWithoutWidth;
  }
  _correctColumnWidths(resultWidths, visibleColumns) {
    const that = this;
    let i;
    let hasPercentWidth = false;
    let hasAutoWidth = false;
    let isColumnWidthsCorrected = false;
    const $element = that.component.$element();
    const hasWidth = that._hasWidth;
    for (i = 0; i < visibleColumns.length; i++) {
      const index2 = i;
      const column = visibleColumns[index2];
      const isHiddenColumn = "adaptiveHidden" === resultWidths[index2];
      let width = resultWidths[index2];
      const {
        minWidth
      } = column;
      if (minWidth) {
        if (void 0 === width) {
          const averageColumnsWidth = that._getAverageColumnsWidth(resultWidths);
          width = averageColumnsWidth;
        } else if (isPercentWidth(width)) {
          const freeWidth = calculateFreeWidthWithCurrentMinWidth(that, index2, minWidth, resultWidths);
          if (freeWidth < 0) {
            width = -1;
          }
        }
      }
      const realColumnWidth = that._getRealColumnWidth(index2, resultWidths.map((columnWidth, columnIndex) => index2 === columnIndex ? width : columnWidth));
      if (minWidth && !isHiddenColumn && realColumnWidth < minWidth) {
        resultWidths[index2] = minWidth;
        isColumnWidthsCorrected = true;
        i = -1;
      }
      if (!isDefined(column.width)) {
        hasAutoWidth = true;
      }
      if (isPercentWidth(column.width)) {
        hasPercentWidth = true;
      }
    }
    if (!hasAutoWidth && resultWidths.length) {
      const $rowsViewElement = that._rowsView.element();
      const contentWidth = that._rowsView.contentWidth();
      const scrollbarWidth2 = that._rowsView.getScrollbarWidth();
      const totalWidth = that._getTotalWidth(resultWidths, contentWidth);
      if (totalWidth < contentWidth) {
        const lastColumnIndex = m_utils_default.getLastResizableColumnIndex(visibleColumns, resultWidths);
        if (lastColumnIndex >= 0) {
          resultWidths[lastColumnIndex] = "auto";
          isColumnWidthsCorrected = true;
          if (false === hasWidth && !hasPercentWidth) {
            const borderWidth = m_utils_default.getComponentBorderWidth(this, $rowsViewElement);
            that._maxWidth = totalWidth + scrollbarWidth2 + borderWidth;
            $element.css("maxWidth", that._maxWidth);
          }
        }
      }
    }
    return isColumnWidthsCorrected;
  }
  _processStretch(resultSizes, visibleColumns) {
    const groupSize = this._rowsView.contentWidth();
    const tableSize = this._getTotalWidth(resultSizes, groupSize);
    const unusedIndexes = {
      length: 0
    };
    if (!resultSizes.length) {
      return;
    }
    each(visibleColumns, function(index2) {
      if (this.width || "adaptiveHidden" === resultSizes[index2]) {
        unusedIndexes[index2] = true;
        unusedIndexes.length++;
      }
    });
    const diff = groupSize - tableSize;
    const diffElement = Math.floor(diff / (resultSizes.length - unusedIndexes.length));
    let onePixelElementsCount = diff - diffElement * (resultSizes.length - unusedIndexes.length);
    if (diff >= 0) {
      for (let i = 0; i < resultSizes.length; i++) {
        if (unusedIndexes[i]) {
          continue;
        }
        resultSizes[i] += diffElement;
        if (onePixelElementsCount > 0) {
          if (onePixelElementsCount < 1) {
            resultSizes[i] += onePixelElementsCount;
            onePixelElementsCount = 0;
          } else {
            resultSizes[i]++;
            onePixelElementsCount--;
          }
        }
      }
    }
  }
  _getRealColumnWidth(columnIndex, columnWidths, groupWidth) {
    let ratio = 1;
    const width = columnWidths[columnIndex];
    if (!isPercentWidth(width)) {
      return parseFloat(width);
    }
    const percentTotalWidth = columnWidths.reduce((sum, width2, index2) => {
      if (!isPercentWidth(width2)) {
        return sum;
      }
      return sum + parseFloat(width2);
    }, 0);
    const pixelTotalWidth = columnWidths.reduce((sum, width2) => {
      if (!width2 || "adaptiveHidden" === width2 || isPercentWidth(width2)) {
        return sum;
      }
      return sum + parseFloat(width2);
    }, 0);
    groupWidth = groupWidth || this._rowsView.contentWidth();
    const freeSpace = groupWidth - pixelTotalWidth;
    const percentTotalWidthInPixel = percentTotalWidth * groupWidth / 100;
    if (pixelTotalWidth > 0 && percentTotalWidthInPixel + pixelTotalWidth >= groupWidth) {
      ratio = percentTotalWidthInPixel > freeSpace ? freeSpace / percentTotalWidthInPixel : 1;
    }
    return parseFloat(width) * groupWidth * ratio / 100;
  }
  _getTotalWidth(widths, groupWidth) {
    let result2 = 0;
    for (let i = 0; i < widths.length; i++) {
      const width = widths[i];
      if (width && "adaptiveHidden" !== width) {
        result2 += this._getRealColumnWidth(i, widths, groupWidth);
      }
    }
    return Math.ceil(result2);
  }
  _getGroupElement() {
    return this.component.$element().children().get(0);
  }
  updateSize(rootElement) {
    const that = this;
    const $rootElement = renderer_default(rootElement);
    const importantMarginClass = that.addWidgetPrefix("important-margin");
    if (void 0 === that._hasHeight && $rootElement && $rootElement.is(":visible") && getWidth($rootElement)) {
      const $groupElement = $rootElement.children(`.${that.getWidgetContainerClass()}`);
      if ($groupElement.length) {
        $groupElement.detach();
      }
      that._hasHeight = !!getHeight($rootElement);
      const width = getWidth($rootElement);
      $rootElement.addClass(importantMarginClass);
      that._hasWidth = getWidth($rootElement) === width;
      $rootElement.removeClass(importantMarginClass);
      if ($groupElement.length) {
        $groupElement.appendTo($rootElement);
      }
    }
  }
  publicMethods() {
    return ["resize", "updateDimensions"];
  }
  _waitAsyncTemplates() {
    var _this$_columnHeadersV, _this$_rowsView, _this$_footerView;
    return when(null === (_this$_columnHeadersV = this._columnHeadersView) || void 0 === _this$_columnHeadersV ? void 0 : _this$_columnHeadersV.waitAsyncTemplates(true), null === (_this$_rowsView = this._rowsView) || void 0 === _this$_rowsView ? void 0 : _this$_rowsView.waitAsyncTemplates(true), null === (_this$_footerView = this._footerView) || void 0 === _this$_footerView ? void 0 : _this$_footerView.waitAsyncTemplates(true));
  }
  resize() {
    if (this.component._requireResize) {
      return new Deferred().resolve();
    }
    const d = new Deferred();
    this._waitAsyncTemplates().done(() => {
      when(this.updateDimensions()).done(d.resolve).fail(d.reject);
    }).fail(d.reject);
    return d.promise().done(() => {
      this.resizeCompleted.fire();
    });
  }
  updateDimensions(checkSize) {
    const that = this;
    that._initPostRenderHandlers();
    if (!that._checkSize(checkSize)) {
      return;
    }
    const prevResult = that._resizeDeferred;
    const result2 = that._resizeDeferred = new Deferred();
    when(prevResult).always(() => {
      deferRender(() => {
        if (that._dataController.isLoaded()) {
          that._synchronizeColumns();
        }
        that._resetGroupElementHeight();
        deferUpdate(() => {
          deferRender(() => {
            deferUpdate(() => {
              that._updateDimensionsCore();
            });
          });
        });
      }).done(result2.resolve).fail(result2.reject);
    });
    return result2.promise();
  }
  _resetGroupElementHeight() {
    const groupElement = this._getGroupElement();
    const scrollable = this._rowsView.getScrollable();
    if (groupElement && groupElement.style.height && (!scrollable || !scrollable.scrollTop())) {
      groupElement.style.height = "";
    }
  }
  _checkSize(checkSize) {
    const $rootElement = this.component.$element();
    const isWidgetVisible = $rootElement.is(":visible");
    const isGridSizeChanged = this._lastWidth !== getWidth($rootElement) || this._lastHeight !== getHeight($rootElement) || this._devicePixelRatio !== getWindow().devicePixelRatio;
    return isWidgetVisible && (!checkSize || isGridSizeChanged);
  }
  _setScrollerSpacingCore() {
    const that = this;
    const vScrollbarWidth = that._rowsView.getScrollbarWidth();
    const hScrollbarWidth = that._rowsView.getScrollbarWidth(true);
    deferRender(() => {
      that._columnHeadersView && that._columnHeadersView.setScrollerSpacing(vScrollbarWidth);
      that._footerView && that._footerView.setScrollerSpacing(vScrollbarWidth);
      that._rowsView.setScrollerSpacing(vScrollbarWidth, hScrollbarWidth);
    });
  }
  _setScrollerSpacing() {
    const scrollable = this._rowsView.getScrollable();
    const isNativeScrolling = true === this.option("scrolling.useNative");
    if (!scrollable || isNativeScrolling) {
      deferRender(() => {
        deferUpdate(() => {
          this._setScrollerSpacingCore();
        });
      });
    } else {
      this._setScrollerSpacingCore();
    }
  }
  _setAriaOwns() {
    var _this$_columnHeadersV2, _this$_footerView2, _this$_rowsView2;
    const headerTable = null === (_this$_columnHeadersV2 = this._columnHeadersView) || void 0 === _this$_columnHeadersV2 ? void 0 : _this$_columnHeadersV2.getTableElement();
    const footerTable = null === (_this$_footerView2 = this._footerView) || void 0 === _this$_footerView2 ? void 0 : _this$_footerView2.getTableElement();
    null === (_this$_rowsView2 = this._rowsView) || void 0 === _this$_rowsView2 || _this$_rowsView2.setAriaOwns(null === headerTable || void 0 === headerTable ? void 0 : headerTable.attr("id"), null === footerTable || void 0 === footerTable ? void 0 : footerTable.attr("id"));
  }
  _updateDimensionsCore() {
    const that = this;
    const dataController2 = that._dataController;
    const rowsView18 = that._rowsView;
    const $rootElement = that.component.$element();
    const groupElement = this._getGroupElement();
    const rootElementHeight = getHeight($rootElement);
    const height = that.option("height") ?? $rootElement.get(0).style.height;
    const isHeightSpecified = !!height && "auto" !== height;
    const maxHeight = parseInt($rootElement.css("maxHeight"));
    const maxHeightHappened = maxHeight && rootElementHeight >= maxHeight;
    const isMaxHeightApplied = groupElement && groupElement.scrollHeight === groupElement.offsetHeight;
    that.updateSize($rootElement);
    deferRender(() => {
      const hasHeight = that._hasHeight || !!maxHeight || isHeightSpecified;
      rowsView18.hasHeight(hasHeight);
      this._setAriaOwns();
      if (maxHeightHappened && !isMaxHeightApplied) {
        renderer_default(groupElement).css("height", maxHeight);
      }
      if (!dataController2.isLoaded()) {
        rowsView18.setLoading(dataController2.isLoading());
        return;
      }
      deferUpdate(() => {
        that._updateLastSizes($rootElement);
        that._setScrollerSpacing();
        each(VIEW_NAMES2, (index2, viewName2) => {
          const view = that.getView(viewName2);
          if (view) {
            view.resize();
          }
        });
        this._editorFactoryController && this._editorFactoryController.resize();
      });
    });
  }
  _updateLastSizes($rootElement) {
    this._lastWidth = getWidth($rootElement);
    this._lastHeight = getHeight($rootElement);
    this._devicePixelRatio = getWindow().devicePixelRatio;
  }
  optionChanged(args) {
    switch (args.name) {
      case "width":
      case "height":
        this.component._renderDimensions();
        this.resize();
      case "renderAsync":
        args.handled = true;
        return;
      default:
        super.optionChanged(args);
    }
  }
  resetLastResizeTime() {
  }
};
var SynchronizeScrollingController = class extends m_modules_default.ViewController {
  _scrollChangedHandler(views, pos, viewName2) {
    for (let j = 0; j < views.length; j++) {
      if (views[j] && views[j].name !== viewName2) {
        views[j].scrollTo({
          left: pos.left,
          top: pos.top
        });
      }
    }
  }
  init() {
    const views = [this.getView("columnHeadersView"), this.getView("footerView"), this.getView("rowsView")];
    for (let i = 0; i < views.length; i++) {
      const view = views[i];
      if (view) {
        view.scrollChanged.add(this._scrollChangedHandler.bind(this, views));
      }
    }
  }
};
var GridView = class extends m_modules_default.View {
  init() {
    this._resizingController = this.getController("resizing");
    this._dataController = this.getController("data");
  }
  _endUpdateCore() {
    if (this.component._requireResize) {
      this.component._requireResize = false;
      this._resizingController.resize();
    }
  }
  getView(name2) {
    return this.component._views[name2];
  }
  element() {
    return this._groupElement;
  }
  optionChanged(args) {
    const that = this;
    if (isDefined(that._groupElement) && "showBorders" === args.name) {
      that._groupElement.toggleClass(that.addWidgetPrefix("borders"), !!args.value);
      args.handled = true;
    } else {
      super.optionChanged(args);
    }
  }
  _renderViews($groupElement) {
    const that = this;
    each(VIEW_NAMES2, (index2, viewName2) => {
      const view = that.getView(viewName2);
      if (view) {
        view.render($groupElement);
      }
    });
  }
  _getTableRoleName() {
    return "group";
  }
  render($rootElement) {
    const isFirstRender = !this._groupElement;
    const $groupElement = this._groupElement || renderer_default("<div>").addClass(this.getWidgetContainerClass());
    $groupElement.addClass("dx-gridbase-container");
    $groupElement.toggleClass(this.addWidgetPrefix("borders"), !!this.option("showBorders"));
    this.setAria("role", "presentation", $rootElement);
    this.component.setAria("role", this._getTableRoleName(), $groupElement);
    this._rootElement = $rootElement || this._rootElement;
    if (isFirstRender) {
      this._groupElement = $groupElement;
      hasWindow() && this._resizingController.updateSize($rootElement);
      $groupElement.appendTo($rootElement);
    }
    if (!this._a11yGeneralStatusElement) {
      this._a11yGeneralStatusElement = A11yStatusContainerComponent({});
      this._a11yGeneralStatusElement.attr(E2E_ATTRIBUTES.a11yStatusContainer, "true");
      $groupElement.append(this._a11yGeneralStatusElement);
    }
    this._renderViews($groupElement);
  }
  update() {
    const that = this;
    const $rootElement = that._rootElement;
    const $groupElement = that._groupElement;
    if ($rootElement && $groupElement) {
      this._resizingController.resize();
      if (that._dataController.isLoaded()) {
        that._resizingController.fireContentReadyAction();
      }
    }
  }
  setWidgetA11yStatusText(statusText) {
    var _this$_a11yGeneralSta;
    null === (_this$_a11yGeneralSta = this._a11yGeneralStatusElement) || void 0 === _this$_a11yGeneralSta || _this$_a11yGeneralSta.text(statusText);
  }
};
var gridViewModule = {
  defaultOptions: () => ({
    showBorders: false,
    renderAsync: false
  }),
  controllers: {
    resizing: ResizingController,
    synchronizeScrolling: SynchronizeScrollingController
  },
  views: {
    gridView: GridView
  },
  VIEW_NAMES: VIEW_NAMES2
};

// node_modules/devextreme/esm/__internal/grids/data_grid/module_not_extended/grid_view.js
m_core_default.registerModule("gridView", gridViewModule);

// node_modules/devextreme/esm/__internal/ui/toolbar/m_constants.js
var TOOLBAR_CLASS = "dx-toolbar";

// node_modules/devextreme/esm/__internal/ui/toolbar/m_toolbar.base.js
var TOOLBAR_ITEM_DATA_KEY = "dxToolbarItemDataKey";
var ToolbarBase = class extends m_collection_widget_async_default {
  _getSynchronizableOptionsForCreateComponent() {
    return super._getSynchronizableOptionsForCreateComponent().filter((item) => "disabled" !== item);
  }
  _initTemplates() {
    super._initTemplates();
    const template = new BindableTemplate(($container, data17, rawModel) => {
      if (isPlainObject(data17)) {
        const {
          text,
          html,
          widget
        } = data17;
        if (text) {
          $container.text(text).wrapInner("<div>");
        }
        if (html) {
          $container.html(html);
        }
        if ("dxDropDownButton" === widget) {
          data17.options = data17.options ?? {};
          if (!isDefined(data17.options.stylingMode)) {
            data17.options.stylingMode = this.option("useFlatButtons") ? "text" : "contained";
          }
        }
        if ("dxButton" === widget) {
          if (this.option("useFlatButtons")) {
            data17.options = data17.options ?? {};
            data17.options.stylingMode = data17.options.stylingMode ?? "text";
          }
          if (this.option("useDefaultButtons")) {
            data17.options = data17.options ?? {};
            data17.options.type = data17.options.type ?? "default";
          }
        }
      } else {
        $container.text(String(data17));
      }
      this._getTemplate("dx-polymorph-widget").render({
        container: $container,
        model: rawModel,
        parent: this
      });
    }, ["text", "html", "widget", "options"], this.option("integrationOptions.watchMethod"));
    this._templateManager.addDefaultTemplates({
      item: template,
      menuItem: template
    });
  }
  _getDefaultOptions() {
    return _extends({}, super._getDefaultOptions(), {
      renderAs: "topToolbar",
      grouped: false,
      useFlatButtons: false,
      useDefaultButtons: false
    });
  }
  _defaultOptionsRules() {
    return super._defaultOptionsRules().concat([{
      device: () => isMaterialBased(),
      options: {
        useFlatButtons: true
      }
    }]);
  }
  _itemContainer() {
    return this._$toolbarItemsContainer.find([".dx-toolbar-before", ".dx-toolbar-center", ".dx-toolbar-after"].join(","));
  }
  _itemClass() {
    return "dx-toolbar-item";
  }
  _itemDataKey() {
    return TOOLBAR_ITEM_DATA_KEY;
  }
  _dimensionChanged(dimension) {
    if (this._disposed) {
      return;
    }
    this._arrangeItems();
    this._applyCompactMode();
  }
  _initMarkup() {
    this._renderToolbar();
    this._renderSections();
    super._initMarkup();
  }
  _render() {
    super._render();
    this._updateDimensionsInMaterial();
  }
  _postProcessRenderItems() {
    this._arrangeItems();
  }
  _renderToolbar() {
    this.$element().addClass(TOOLBAR_CLASS);
    this._$toolbarItemsContainer = renderer_default("<div>").addClass("dx-toolbar-items-container").appendTo(this.$element());
    this.setAria("role", "toolbar");
  }
  _renderSections() {
    const $container = this._$toolbarItemsContainer;
    each(["before", "center", "after"], (_, section) => {
      const sectionClass = `dx-toolbar-${section}`;
      const $section = $container.find(`.${sectionClass}`);
      if (!$section.length) {
        this[`_$${section}Section`] = renderer_default("<div>").addClass(sectionClass).attr("role", "presentation").appendTo($container);
      }
    });
  }
  _arrangeItems(width) {
    var _this$_$beforeSection, _this$_$afterSection;
    const elementWidth = width ?? getWidth(this.$element());
    this._$centerSection.css({
      margin: "0 auto",
      float: "none"
    });
    const beforeRect = getBoundingRect(null === (_this$_$beforeSection = this._$beforeSection) || void 0 === _this$_$beforeSection ? void 0 : _this$_$beforeSection.get(0));
    const afterRect = getBoundingRect(null === (_this$_$afterSection = this._$afterSection) || void 0 === _this$_$afterSection ? void 0 : _this$_$afterSection.get(0));
    this._alignCenterSection(beforeRect, afterRect, elementWidth);
    const $label = this._$toolbarItemsContainer.find(".dx-toolbar-label").eq(0);
    const $section = $label.parent();
    if (!$label.length) {
      return;
    }
    const labelOffset = beforeRect.width ? beforeRect.width : $label.position().left;
    const widthBeforeSection = $section.hasClass("dx-toolbar-before") ? 0 : labelOffset;
    const widthAfterSection = $section.hasClass("dx-toolbar-after") ? 0 : afterRect.width;
    let elemsAtSectionWidth = 0;
    $section.children().not(".dx-toolbar-label").each((index2, element) => {
      elemsAtSectionWidth += getOuterWidth(element);
    });
    const freeSpace = elementWidth - elemsAtSectionWidth;
    const sectionMaxWidth = Math.max(freeSpace - widthBeforeSection - widthAfterSection, 0);
    if ($section.hasClass("dx-toolbar-before")) {
      this._alignSection(this._$beforeSection, sectionMaxWidth);
    } else {
      const labelPaddings = getOuterWidth($label) - getWidth($label);
      $label.css("maxWidth", sectionMaxWidth - labelPaddings);
    }
  }
  _alignCenterSection(beforeRect, afterRect, elementWidth) {
    var _this$_$centerSection;
    this._alignSection(this._$centerSection, elementWidth - beforeRect.width - afterRect.width);
    const isRTL = this.option("rtlEnabled");
    const leftRect = isRTL ? afterRect : beforeRect;
    const rightRect = isRTL ? beforeRect : afterRect;
    const centerRect = getBoundingRect(null === (_this$_$centerSection = this._$centerSection) || void 0 === _this$_$centerSection ? void 0 : _this$_$centerSection.get(0));
    if (leftRect.right > centerRect.left || centerRect.right > rightRect.left) {
      this._$centerSection.css({
        marginLeft: leftRect.width,
        marginRight: rightRect.width,
        float: leftRect.width > rightRect.width ? "none" : "right"
      });
    }
  }
  _alignSection($section, maxWidth) {
    const $labels = $section.find(".dx-toolbar-label");
    let labels = $labels.toArray();
    maxWidth -= this._getCurrentLabelsPaddings(labels);
    const currentWidth = this._getCurrentLabelsWidth(labels);
    const difference = Math.abs(currentWidth - maxWidth);
    if (maxWidth < currentWidth) {
      labels = labels.reverse();
      this._alignSectionLabels(labels, difference, false);
    } else {
      this._alignSectionLabels(labels, difference, true);
    }
  }
  _alignSectionLabels(labels, difference, expanding) {
    const getRealLabelWidth = function(label) {
      return getBoundingRect(label).width;
    };
    for (let i = 0; i < labels.length; i++) {
      const $label = renderer_default(labels[i]);
      const currentLabelWidth = Math.ceil(getRealLabelWidth(labels[i]));
      let labelMaxWidth;
      if (expanding) {
        $label.css("maxWidth", "inherit");
      }
      const possibleLabelWidth = Math.ceil(expanding ? getRealLabelWidth(labels[i]) : currentLabelWidth);
      if (possibleLabelWidth < difference) {
        labelMaxWidth = expanding ? possibleLabelWidth : 0;
        difference -= possibleLabelWidth;
      } else {
        labelMaxWidth = expanding ? currentLabelWidth + difference : currentLabelWidth - difference;
        $label.css("maxWidth", labelMaxWidth);
        break;
      }
      $label.css("maxWidth", labelMaxWidth);
    }
  }
  _applyCompactMode() {
    const $element = renderer_default(this.element());
    $element.removeClass("dx-toolbar-compact");
    if (this.option("compactMode") && this._getSummaryItemsSize("width", this._itemElements(), true) > getWidth($element)) {
      $element.addClass("dx-toolbar-compact");
    }
  }
  _getCurrentLabelsWidth(labels) {
    let width = 0;
    labels.forEach((label) => {
      width += getOuterWidth(label);
    });
    return width;
  }
  _getCurrentLabelsPaddings(labels) {
    let padding = 0;
    labels.forEach((label) => {
      padding += getOuterWidth(label) - getWidth(label);
    });
    return padding;
  }
  _renderItem(index2, item, itemContainer, $after) {
    const location = item.location ?? "center";
    const container = itemContainer ?? this[`_$${location}Section`];
    const itemHasText = !!(item.text ?? item.html);
    const itemElement = super._renderItem(index2, item, container, $after);
    itemElement.toggleClass("dx-toolbar-button", !itemHasText).toggleClass("dx-toolbar-label", itemHasText).addClass(item.cssClass);
    return itemElement;
  }
  _renderGroupedItems() {
    each(this.option("items"), (groupIndex, group) => {
      const groupItems = group.items;
      const $container = renderer_default("<div>").addClass("dx-toolbar-group");
      const location = group.location ?? "center";
      if (!groupItems || !groupItems.length) {
        return;
      }
      each(groupItems, (itemIndex, item) => {
        this._renderItem(itemIndex, item, $container, null);
      });
      this._$toolbarItemsContainer.find(`.dx-toolbar-${location}`).append($container);
    });
  }
  _renderItems(items) {
    const grouped = this.option("grouped") && items.length && items[0].items;
    grouped ? this._renderGroupedItems() : super._renderItems(items);
  }
  _getToolbarItems() {
    return this.option("items") ?? [];
  }
  _renderContentImpl() {
    const items = this._getToolbarItems();
    this.$element().toggleClass("dx-toolbar-mini", 0 === items.length);
    if (this._renderedItemsCount) {
      this._renderItems(items.slice(this._renderedItemsCount));
    } else {
      this._renderItems(items);
    }
    this._applyCompactMode();
  }
  _renderEmptyMessage() {
  }
  _clean() {
    this._$toolbarItemsContainer.children().empty();
    this.$element().empty();
    delete this._$beforeSection;
    delete this._$centerSection;
    delete this._$afterSection;
  }
  _visibilityChanged(visible2) {
    if (visible2) {
      this._arrangeItems();
    }
  }
  _isVisible() {
    return getWidth(this.$element()) > 0 && getHeight(this.$element()) > 0;
  }
  _getIndexByItem(item) {
    return this._getToolbarItems().indexOf(item);
  }
  _itemOptionChanged(item, property, value2, prevValue) {
    super._itemOptionChanged(item, property, value2, prevValue);
    this._arrangeItems();
  }
  _optionChanged(args) {
    const {
      name: name2
    } = args;
    switch (name2) {
      case "width":
        super._optionChanged(args);
        this._dimensionChanged();
        break;
      case "renderAs":
      case "useFlatButtons":
      case "useDefaultButtons":
        this._invalidate();
        break;
      case "compactMode":
        this._applyCompactMode();
        break;
      case "grouped":
        break;
      default:
        super._optionChanged(args);
    }
  }
  _dispose() {
    super._dispose();
    clearTimeout(this._waitParentAnimationTimeout);
  }
  _updateDimensionsInMaterial() {
    if (isMaterial()) {
      const _waitParentAnimationFinished = () => new Promise((resolve) => {
        const check = () => {
          let readyToResolve = true;
          this.$element().parents().each((_, parent) => {
            if (fx_default.isAnimating(renderer_default(parent))) {
              readyToResolve = false;
              return false;
            }
          });
          if (readyToResolve) {
            resolve();
          }
          return readyToResolve;
        };
        const runCheck = () => {
          clearTimeout(this._waitParentAnimationTimeout);
          this._waitParentAnimationTimeout = setTimeout(() => check() || runCheck(), 15);
        };
        runCheck();
      });
      const _checkWebFontForLabelsLoaded = () => {
        const $labels = this.$element().find(".dx-toolbar-label");
        const promises = [];
        $labels.each((_, label) => {
          const text = renderer_default(label).text();
          const fontWeight = renderer_default(label).css("fontWeight");
          promises.push(waitWebFont(text, fontWeight));
        });
        return Promise.all(promises);
      };
      Promise.all([_waitParentAnimationFinished(), _checkWebFontForLabelsLoaded()]).then(() => {
        this._dimensionChanged();
      });
    }
  }
};
component_registrator_default("dxToolbarBase", ToolbarBase);
var m_toolbar_base_default = ToolbarBase;

// node_modules/devextreme/esm/__internal/ui/toolbar/m_toolbar.utils.js
var TOOLBAR_ITEMS = ["dxAutocomplete", "dxButton", "dxCheckBox", "dxDateBox", "dxMenu", "dxSelectBox", "dxTabs", "dxTextBox", "dxButtonGroup", "dxDropDownButton"];
var getItemInstance = function($element) {
  const itemData = $element.data && $element.data();
  const dxComponents = itemData && itemData.dxComponents;
  const widgetName = dxComponents && dxComponents[0];
  return widgetName && itemData[widgetName];
};
function toggleItemFocusableElementTabIndex(context2, item) {
  var _itemData$options;
  if (!context2) {
    return;
  }
  const $item = context2._findItemElementByItem(item);
  if (!$item.length) {
    return;
  }
  const itemData = context2._getItemData($item);
  const isItemNotFocusable = !!(null !== (_itemData$options = itemData.options) && void 0 !== _itemData$options && _itemData$options.disabled || itemData.disabled || context2.option("disabled"));
  const {
    widget
  } = itemData;
  if (widget && TOOLBAR_ITEMS.includes(widget)) {
    const $widget = $item.find(widget.toLowerCase().replace("dx", ".dx-"));
    if ($widget.length) {
      var _itemInstance$_focusT, _itemData$options2;
      const itemInstance = getItemInstance($widget);
      if (!itemInstance) {
        return;
      }
      let $focusTarget = null === (_itemInstance$_focusT = itemInstance._focusTarget) || void 0 === _itemInstance$_focusT ? void 0 : _itemInstance$_focusT.call(itemInstance);
      if ("dxDropDownButton" === widget) {
        $focusTarget = $focusTarget && $focusTarget.find(".dx-buttongroup");
      } else {
        $focusTarget = $focusTarget ?? renderer_default(itemInstance.element());
      }
      const tabIndex = null === (_itemData$options2 = itemData.options) || void 0 === _itemData$options2 ? void 0 : _itemData$options2.tabIndex;
      if (isItemNotFocusable) {
        $focusTarget.attr("tabIndex", -1);
      } else {
        $focusTarget.attr("tabIndex", tabIndex ?? 0);
      }
    }
  }
}

// node_modules/devextreme/esm/__internal/ui/toolbar/strategy/m_toolbar.multiline.js
var MultiLineStrategy = class {
  constructor(toolbar) {
    this._toolbar = toolbar;
  }
  _initMarkup() {
  }
  _updateMenuVisibility() {
  }
  _renderMenuItems() {
  }
  _renderItem() {
  }
  _getMenuItems() {
  }
  _getToolbarItems() {
    return this._toolbar.option("items") ?? [];
  }
  _getItemsWidth() {
    return this._toolbar._getSummaryItemsSize("width", this._toolbar._itemElements(), true);
  }
  _arrangeItems() {
    const $label = this._toolbar._$toolbarItemsContainer.find(".dx-toolbar-label").eq(0);
    if (!$label.length) {
      return;
    }
    const elementWidth = getWidth(this._toolbar.$element());
    const labelPaddings = getOuterWidth($label) - getWidth($label);
    $label.css("maxWidth", elementWidth - labelPaddings);
  }
  _hideOverflowItems() {
  }
  _dimensionChanged() {
  }
  _itemOptionChanged() {
  }
  _optionChanged() {
  }
};

// node_modules/devextreme/esm/__internal/ui/resizable/m_resizable.js
var RESIZABLE = "dxResizable";
var DRAGSTART_START_EVENT_NAME = addNamespace2(DRAG_START_EVENT, RESIZABLE);
var DRAGSTART_EVENT_NAME = addNamespace2(DRAG_EVENT, RESIZABLE);
var DRAGSTART_END_EVENT_NAME = addNamespace2(DRAG_END_EVENT, RESIZABLE);
var SIDE_BORDER_WIDTH_STYLES = {
  left: "borderLeftWidth",
  top: "borderTopWidth",
  right: "borderRightWidth",
  bottom: "borderBottomWidth"
};
var Resizable = class extends dom_component_default {
  _getDefaultOptions() {
    return _extends({}, super._getDefaultOptions(), {
      handles: "all",
      step: "1",
      stepPrecision: "simple",
      minWidth: 30,
      maxWidth: 1 / 0,
      minHeight: 30,
      maxHeight: 1 / 0,
      onResizeStart: null,
      onResize: null,
      onResizeEnd: null,
      roundStepValue: true,
      keepAspectRatio: true
    });
  }
  _init() {
    super._init();
    this.$element().addClass("dx-resizable");
  }
  _initMarkup() {
    super._initMarkup();
    this._renderHandles();
  }
  _render() {
    super._render();
    this._renderActions();
  }
  _renderActions() {
    this._resizeStartAction = this._createActionByOption("onResizeStart");
    this._resizeEndAction = this._createActionByOption("onResizeEnd");
    this._resizeAction = this._createActionByOption("onResize");
  }
  _renderHandles() {
    this._handles = [];
    const {
      handles
    } = this.option();
    if ("none" === handles || !handles) {
      return;
    }
    const directions = "all" === handles ? ["top", "bottom", "left", "right"] : handles.split(" ");
    const activeHandlesMap = {};
    each(directions, (index2, handleName) => {
      activeHandlesMap[handleName] = true;
      this._renderHandle(handleName);
    });
    activeHandlesMap.bottom && activeHandlesMap.right && this._renderHandle("corner-bottom-right");
    activeHandlesMap.bottom && activeHandlesMap.left && this._renderHandle("corner-bottom-left");
    activeHandlesMap.top && activeHandlesMap.right && this._renderHandle("corner-top-right");
    activeHandlesMap.top && activeHandlesMap.left && this._renderHandle("corner-top-left");
    this._attachEventHandlers();
  }
  _renderHandle(handleName) {
    const $handle = renderer_default("<div>").addClass("dx-resizable-handle").addClass(`dx-resizable-handle-${handleName}`).appendTo(this.$element());
    this._handles.push($handle);
  }
  _attachEventHandlers() {
    if (this.option("disabled")) {
      return;
    }
    const handlers = {};
    handlers[DRAGSTART_START_EVENT_NAME] = this._dragStartHandler.bind(this);
    handlers[DRAGSTART_EVENT_NAME] = this._dragHandler.bind(this);
    handlers[DRAGSTART_END_EVENT_NAME] = this._dragEndHandler.bind(this);
    this._handles.forEach((handleElement) => {
      m_events_engine_default.on(handleElement, handlers, {
        direction: "both",
        immediate: true
      });
    });
  }
  _detachEventHandlers() {
    this._handles.forEach((handleElement) => {
      m_events_engine_default.off(handleElement);
    });
  }
  _toggleEventHandlers(shouldAttachEvents) {
    shouldAttachEvents ? this._attachEventHandlers() : this._detachEventHandlers();
  }
  _getElementSize() {
    const $element = this.$element();
    return "border-box" === $element.css("boxSizing") ? {
      width: getOuterWidth($element),
      height: getOuterHeight($element)
    } : {
      width: getWidth($element),
      height: getHeight($element)
    };
  }
  _dragStartHandler(e) {
    var _this$_resizeStartAct;
    const $element = this.$element();
    if ($element.is(".dx-state-disabled, .dx-state-disabled *")) {
      e.cancel = true;
      return;
    }
    this._toggleResizingClass(true);
    this._movingSides = this._getMovingSides(e);
    this._elementLocation = locate($element);
    this._elementSize = this._getElementSize();
    this._renderDragOffsets(e);
    null === (_this$_resizeStartAct = this._resizeStartAction) || void 0 === _this$_resizeStartAct || _this$_resizeStartAct.call(this, {
      event: e,
      width: this._elementSize.width,
      height: this._elementSize.height,
      handles: this._movingSides
    });
    e.targetElements = null;
  }
  _toggleResizingClass(value2) {
    this.$element().toggleClass("dx-resizable-resizing", value2);
  }
  _renderDragOffsets(e) {
    const area = this._getArea();
    if (!area) {
      return;
    }
    const $handle = renderer_default(e.target).closest(".dx-resizable-handle");
    const handleWidth = getOuterWidth($handle);
    const handleHeight = getOuterHeight($handle);
    const handleOffset = $handle.offset();
    const areaOffset = area.offset;
    const scrollOffset = this._getAreaScrollOffset();
    e.maxLeftOffset = this._leftMaxOffset = handleOffset.left - areaOffset.left - scrollOffset.scrollX;
    e.maxRightOffset = this._rightMaxOffset = areaOffset.left + area.width - handleOffset.left - handleWidth + scrollOffset.scrollX;
    e.maxTopOffset = this._topMaxOffset = handleOffset.top - areaOffset.top - scrollOffset.scrollY;
    e.maxBottomOffset = this._bottomMaxOffset = areaOffset.top + area.height - handleOffset.top - handleHeight + scrollOffset.scrollY;
  }
  _getBorderWidth($element, direction) {
    if (isWindow($element.get(0))) {
      return 0;
    }
    const borderWidth = $element.css(SIDE_BORDER_WIDTH_STYLES[direction]);
    return parseInt(borderWidth) || 0;
  }
  _proportionate(direction, value2) {
    const size = this._elementSize;
    const factor = "x" === direction ? size.width / size.height : size.height / size.width;
    return value2 * factor;
  }
  _getProportionalDelta(_ref) {
    let {
      x,
      y
    } = _ref;
    const proportionalY = this._proportionate("y", x);
    if (proportionalY >= y) {
      return {
        x,
        y: proportionalY
      };
    }
    const proportionalX = this._proportionate("x", y);
    if (proportionalX >= x) {
      return {
        x: proportionalX,
        y
      };
    }
    return {
      x: 0,
      y: 0
    };
  }
  _getDirectionName(axis) {
    const sides = this._movingSides;
    if ("x" === axis) {
      return sides.left ? "left" : "right";
    }
    return sides.top ? "top" : "bottom";
  }
  _fitIntoArea(axis, value2) {
    const directionName = this._getDirectionName(axis);
    return Math.min(value2, this[`_${directionName}MaxOffset`] ?? 1 / 0);
  }
  _fitDeltaProportionally(delta) {
    let fittedDelta = _extends({}, delta);
    const size = this._elementSize;
    const {
      minWidth,
      minHeight,
      maxWidth,
      maxHeight
    } = this.option();
    const getWidth2 = () => size.width + fittedDelta.x;
    const getHeight2 = () => size.height + fittedDelta.y;
    const isInArea = (axis) => fittedDelta[axis] === this._fitIntoArea(axis, fittedDelta[axis]);
    const isFittedX = () => inRange(getWidth2(), minWidth, maxWidth) && isInArea("x");
    const isFittedY = () => inRange(getHeight2(), minHeight, maxHeight) && isInArea("y");
    if (!isFittedX()) {
      const x = this._fitIntoArea("x", fitIntoRange(getWidth2(), minWidth, maxWidth) - size.width);
      fittedDelta = {
        x,
        y: this._proportionate("y", x)
      };
    }
    if (!isFittedY()) {
      const y = this._fitIntoArea("y", fitIntoRange(getHeight2(), minHeight, maxHeight) - size.height);
      fittedDelta = {
        x: this._proportionate("x", y),
        y
      };
    }
    return isFittedX() && isFittedY() ? fittedDelta : {
      x: 0,
      y: 0
    };
  }
  _fitDelta(_ref2) {
    let {
      x,
      y
    } = _ref2;
    const size = this._elementSize;
    const {
      minWidth,
      minHeight,
      maxWidth,
      maxHeight
    } = this.option();
    return {
      x: fitIntoRange(size.width + x, minWidth, maxWidth) - size.width,
      y: fitIntoRange(size.height + y, minHeight, maxHeight) - size.height
    };
  }
  _getDeltaByOffset(offset2) {
    const sides = this._movingSides;
    const shouldKeepAspectRatio = this._isCornerHandler(sides) && this.option("keepAspectRatio");
    let delta = {
      x: offset2.x * (sides.left ? -1 : 1),
      y: offset2.y * (sides.top ? -1 : 1)
    };
    if (shouldKeepAspectRatio) {
      const proportionalDelta = this._getProportionalDelta(delta);
      const fittedProportionalDelta = this._fitDeltaProportionally(proportionalDelta);
      delta = fittedProportionalDelta;
    } else {
      const fittedDelta = this._fitDelta(delta);
      const roundedFittedDelta = this._roundByStep(fittedDelta);
      delta = roundedFittedDelta;
    }
    return delta;
  }
  _updatePosition(delta, _ref3) {
    let {
      width,
      height
    } = _ref3;
    const location = this._elementLocation;
    const sides = this._movingSides;
    const $element = this.$element();
    const elementRect = this._getElementSize();
    const offsetTop = delta.y * (sides.top ? -1 : 1) - ((elementRect.height || height) - height);
    const offsetLeft = delta.x * (sides.left ? -1 : 1) - ((elementRect.width || width) - width);
    move($element, {
      top: location.top + (sides.top ? offsetTop : 0),
      left: location.left + (sides.left ? offsetLeft : 0)
    });
  }
  _dragHandler(e) {
    const offset2 = this._getOffset(e);
    const delta = this._getDeltaByOffset(offset2);
    const dimensions = this._updateDimensions(delta);
    this._updatePosition(delta, dimensions);
    this._triggerResizeAction(e, dimensions);
  }
  _updateDimensions(delta) {
    const isAbsoluteSize = (size2) => "px" === size2.substring(size2.length - 2);
    const {
      stepPrecision
    } = this.option();
    const isStepPrecisionStrict = "strict" === stepPrecision;
    const size = this._elementSize;
    const width = size.width + delta.x;
    const height = size.height + delta.y;
    const elementStyle = this.$element().get(0).style;
    const shouldRenderWidth = delta.x || isStepPrecisionStrict || isAbsoluteSize(elementStyle.width);
    const shouldRenderHeight = delta.y || isStepPrecisionStrict || isAbsoluteSize(elementStyle.height);
    if (shouldRenderWidth) {
      this.option({
        width
      });
    }
    if (shouldRenderHeight) {
      this.option({
        height
      });
    }
    return {
      width: shouldRenderWidth ? width : size.width,
      height: shouldRenderHeight ? height : size.height
    };
  }
  _triggerResizeAction(e, _ref4) {
    var _this$_resizeAction;
    let {
      width,
      height
    } = _ref4;
    null === (_this$_resizeAction = this._resizeAction) || void 0 === _this$_resizeAction || _this$_resizeAction.call(this, {
      event: e,
      width: this.option("width") || width,
      height: this.option("height") || height,
      handles: this._movingSides
    });
    triggerResizeEvent2(this.$element());
  }
  _isCornerHandler(sides) {
    return 0 === Object.values(sides).reduce((xor, value2) => xor ^ value2, 0);
  }
  _getOffset(e) {
    const {
      offset: offset2
    } = e;
    const sides = this._movingSides;
    if (!sides.left && !sides.right) {
      offset2.x = 0;
    }
    if (!sides.top && !sides.bottom) {
      offset2.y = 0;
    }
    return offset2;
  }
  _roundByStep(delta) {
    const {
      stepPrecision
    } = this.option();
    return "strict" === stepPrecision ? this._roundStrict(delta) : this._roundNotStrict(delta);
  }
  _getSteps() {
    return pairToObject(this.option("step"), !this.option("roundStepValue"));
  }
  _roundNotStrict(delta) {
    const steps = this._getSteps();
    return {
      x: delta.x - delta.x % steps.h,
      y: delta.y - delta.y % steps.v
    };
  }
  _roundStrict(delta) {
    const sides = this._movingSides;
    const offset2 = {
      x: delta.x * (sides.left ? -1 : 1),
      y: delta.y * (sides.top ? -1 : 1)
    };
    const steps = this._getSteps();
    const location = this._elementLocation;
    const size = this._elementSize;
    const xPos = sides.left ? location.left : location.left + size.width;
    const yPos = sides.top ? location.top : location.top + size.height;
    const newXShift = (xPos + offset2.x) % steps.h;
    const newYShift = (yPos + offset2.y) % steps.v;
    const sign2 = Math.sign || ((x) => {
      x = +x;
      if (0 === x || isNaN(x)) {
        return x;
      }
      return x > 0 ? 1 : -1;
    });
    const separatorOffset = (steps2, offset3) => (1 + 0.2 * sign2(offset3)) % 1 * steps2;
    const isSmallOffset = (offset3, steps2) => Math.abs(offset3) < 0.2 * steps2;
    let newOffsetX = offset2.x - newXShift;
    let newOffsetY = offset2.y - newYShift;
    if (newXShift > separatorOffset(steps.h, offset2.x)) {
      newOffsetX += steps.h;
    }
    if (newYShift > separatorOffset(steps.v, offset2.y)) {
      newOffsetY += steps.v;
    }
    const roundedOffset_x = (sides.left || sides.right) && !isSmallOffset(offset2.x, steps.h) ? newOffsetX : 0, roundedOffset_y = (sides.top || sides.bottom) && !isSmallOffset(offset2.y, steps.v) ? newOffsetY : 0;
    return {
      x: roundedOffset_x * (sides.left ? -1 : 1),
      y: roundedOffset_y * (sides.top ? -1 : 1)
    };
  }
  _getMovingSides(e) {
    const $target = renderer_default(e.target);
    const hasCornerTopLeftClass = $target.hasClass("dx-resizable-handle-corner-top-left");
    const hasCornerTopRightClass = $target.hasClass("dx-resizable-handle-corner-top-right");
    const hasCornerBottomLeftClass = $target.hasClass("dx-resizable-handle-corner-bottom-left");
    const hasCornerBottomRightClass = $target.hasClass("dx-resizable-handle-corner-bottom-right");
    return {
      top: $target.hasClass("dx-resizable-handle-top") || hasCornerTopLeftClass || hasCornerTopRightClass,
      left: $target.hasClass("dx-resizable-handle-left") || hasCornerTopLeftClass || hasCornerBottomLeftClass,
      bottom: $target.hasClass("dx-resizable-handle-bottom") || hasCornerBottomLeftClass || hasCornerBottomRightClass,
      right: $target.hasClass("dx-resizable-handle-right") || hasCornerTopRightClass || hasCornerBottomRightClass
    };
  }
  _getArea() {
    let area = this.option("area");
    if (isFunction(area)) {
      area = area.call(this);
    }
    if (isPlainObject(area)) {
      return this._getAreaFromObject(area);
    }
    return this._getAreaFromElement(area);
  }
  _getAreaScrollOffset() {
    const area = this.option("area");
    const isElement = !isFunction(area) && !isPlainObject(area);
    const scrollOffset = {
      scrollY: 0,
      scrollX: 0
    };
    if (isElement) {
      const areaElement = renderer_default(area)[0];
      if (isWindow(areaElement)) {
        scrollOffset.scrollX = areaElement.pageXOffset;
        scrollOffset.scrollY = areaElement.pageYOffset;
      }
    }
    return scrollOffset;
  }
  _getAreaFromObject(area) {
    const result2 = {
      width: area.right - area.left,
      height: area.bottom - area.top,
      offset: {
        left: area.left,
        top: area.top
      }
    };
    this._correctAreaGeometry(result2);
    return result2;
  }
  _getAreaFromElement(area) {
    const $area = renderer_default(area);
    let result2;
    if ($area.length) {
      result2 = {
        width: getInnerWidth($area),
        height: getInnerHeight($area),
        offset: extend({
          top: 0,
          left: 0
        }, isWindow($area[0]) ? {} : $area.offset())
      };
      this._correctAreaGeometry(result2, $area);
    }
    return result2;
  }
  _correctAreaGeometry(result2, $area) {
    const areaBorderLeft = $area ? this._getBorderWidth($area, "left") : 0;
    const areaBorderTop = $area ? this._getBorderWidth($area, "top") : 0;
    result2.offset.left += areaBorderLeft + this._getBorderWidth(this.$element(), "left");
    result2.offset.top += areaBorderTop + this._getBorderWidth(this.$element(), "top");
    result2.width -= getOuterWidth(this.$element()) - getInnerWidth(this.$element());
    result2.height -= getOuterHeight(this.$element()) - getInnerHeight(this.$element());
  }
  _dragEndHandler(e) {
    var _this$_resizeEndActio;
    const $element = this.$element();
    null === (_this$_resizeEndActio = this._resizeEndAction) || void 0 === _this$_resizeEndActio || _this$_resizeEndActio.call(this, {
      event: e,
      width: getOuterWidth($element),
      height: getOuterHeight($element),
      handles: this._movingSides
    });
    this._toggleResizingClass(false);
  }
  _renderWidth(width) {
    this.option("width", fitIntoRange(width, this.option("minWidth"), this.option("maxWidth")));
  }
  _renderHeight(height) {
    this.option("height", fitIntoRange(height, this.option("minHeight"), this.option("maxHeight")));
  }
  _optionChanged(args) {
    switch (args.name) {
      case "disabled":
        this._toggleEventHandlers(!args.value);
        super._optionChanged(args);
        break;
      case "handles":
        this._invalidate();
        break;
      case "minWidth":
      case "maxWidth":
        hasWindow() && this._renderWidth(getOuterWidth(this.$element()));
        break;
      case "minHeight":
      case "maxHeight":
        hasWindow() && this._renderHeight(getOuterHeight(this.$element()));
        break;
      case "onResize":
      case "onResizeStart":
      case "onResizeEnd":
        this._renderActions();
        break;
      case "area":
      case "stepPrecision":
      case "step":
      case "roundStepValue":
      case "keepAspectRatio":
        break;
      default:
        super._optionChanged(args);
    }
  }
  _clean() {
    this.$element().find(".dx-resizable-handle").remove();
  }
  _useTemplates() {
    return false;
  }
};
component_registrator_default(RESIZABLE, Resizable);
var m_resizable_default = Resizable;

// node_modules/devextreme/esm/ui/resizable.js
var resizable_default = m_resizable_default;

// node_modules/devextreme/esm/__internal/ui/popup/m_popup_drag.js
var PopupDrag = class {
  constructor(config3) {
    this.init(config3);
  }
  init(_ref) {
    let {
      dragEnabled,
      handle,
      draggableElement,
      positionController
    } = _ref;
    this._positionController = positionController;
    this._draggableElement = draggableElement;
    this._handle = handle;
    this._dragEnabled = dragEnabled;
    this.unsubscribe();
    if (!dragEnabled) {
      return;
    }
    this.subscribe();
  }
  moveDown(e) {
    this._moveTo(5, 0, e);
  }
  moveUp(e) {
    this._moveTo(-5, 0, e);
  }
  moveLeft(e) {
    this._moveTo(0, -5, e);
  }
  moveRight(e) {
    this._moveTo(0, 5, e);
  }
  subscribe() {
    const eventNames = this._getEventNames();
    m_events_engine_default.on(this._handle, eventNames.startEventName, (e) => {
      this._dragStartHandler(e);
    });
    m_events_engine_default.on(this._handle, eventNames.updateEventName, (e) => {
      this._dragUpdateHandler(e);
    });
    m_events_engine_default.on(this._handle, eventNames.endEventName, (e) => {
      this._dragEndHandler(e);
    });
  }
  unsubscribe() {
    const eventNames = this._getEventNames();
    m_events_engine_default.off(this._handle, eventNames.startEventName);
    m_events_engine_default.off(this._handle, eventNames.updateEventName);
    m_events_engine_default.off(this._handle, eventNames.endEventName);
  }
  _getEventNames() {
    const startEventName = addNamespace2(DRAG_START_EVENT, "overlayDrag");
    const updateEventName = addNamespace2(DRAG_EVENT, "overlayDrag");
    const endEventName = addNamespace2(DRAG_END_EVENT, "overlayDrag");
    return {
      startEventName,
      updateEventName,
      endEventName
    };
  }
  _dragStartHandler(e) {
    const allowedOffsets = this._getAllowedOffsets();
    this._prevOffset = {
      x: 0,
      y: 0
    };
    e.targetElements = [];
    e.maxTopOffset = allowedOffsets.top;
    e.maxBottomOffset = allowedOffsets.bottom;
    e.maxLeftOffset = allowedOffsets.left;
    e.maxRightOffset = allowedOffsets.right;
  }
  _dragUpdateHandler(e) {
    const targetOffset = {
      top: e.offset.y - this._prevOffset.y,
      left: e.offset.x - this._prevOffset.x
    };
    this._moveByOffset(targetOffset);
    this._prevOffset = e.offset;
  }
  _dragEndHandler(event) {
    this._positionController.dragHandled();
    this._positionController.detectVisualPositionChange(event);
  }
  _moveTo(top, left, e) {
    if (!this._dragEnabled) {
      return;
    }
    e.preventDefault();
    e.stopPropagation();
    const offset2 = this._fitOffsetIntoAllowedRange(top, left);
    this._moveByOffset(offset2);
    this._dragEndHandler(e);
  }
  _fitOffsetIntoAllowedRange(top, left) {
    const allowedOffsets = this._getAllowedOffsets();
    return {
      top: fitIntoRange(top, -allowedOffsets.top, allowedOffsets.bottom),
      left: fitIntoRange(left, -allowedOffsets.left, allowedOffsets.right)
    };
  }
  _getContainerDimensions() {
    const document2 = dom_adapter_default.getDocument();
    const container = this._positionController.$dragResizeContainer.get(0);
    let containerWidth = getOuterWidth(container);
    let containerHeight = getOuterHeight(container);
    if (isWindow(container)) {
      containerHeight = Math.max(document2.body.clientHeight, containerHeight);
      containerWidth = Math.max(document2.body.clientWidth, containerWidth);
    }
    return {
      width: containerWidth,
      height: containerHeight
    };
  }
  _getContainerPosition() {
    const container = this._positionController.$dragResizeContainer.get(0);
    return isWindow(container) ? {
      top: 0,
      left: 0
    } : getOffset(container);
  }
  _getElementPosition() {
    return getOffset(this._draggableElement);
  }
  _getInnerDelta() {
    const containerDimensions = this._getContainerDimensions();
    const elementDimensions = this._getElementDimensions();
    return {
      x: containerDimensions.width - elementDimensions.width,
      y: containerDimensions.height - elementDimensions.height
    };
  }
  _getOuterDelta() {
    const {
      width,
      height
    } = this._getElementDimensions();
    const {
      outsideDragFactor
    } = this._positionController;
    return {
      x: width * outsideDragFactor,
      y: height * outsideDragFactor
    };
  }
  _getFullDelta() {
    const fullDelta = this._getInnerDelta();
    const outerDelta = this._getOuterDelta();
    return {
      x: fullDelta.x + outerDelta.x,
      y: fullDelta.y + outerDelta.y
    };
  }
  _getElementDimensions() {
    return {
      width: this._draggableElement.offsetWidth,
      height: this._draggableElement.offsetHeight
    };
  }
  _getAllowedOffsets() {
    const fullDelta = this._getFullDelta();
    const isDragAllowed = fullDelta.y >= 0 && fullDelta.x >= 0;
    if (!isDragAllowed) {
      return {
        top: 0,
        bottom: 0,
        left: 0,
        right: 0
      };
    }
    const elementPosition = this._getElementPosition();
    const containerPosition = this._getContainerPosition();
    const outerDelta = this._getOuterDelta();
    return {
      top: elementPosition.top - containerPosition.top + outerDelta.y,
      bottom: -elementPosition.top + containerPosition.top + fullDelta.y,
      left: elementPosition.left - containerPosition.left + outerDelta.x,
      right: -elementPosition.left + containerPosition.left + fullDelta.x
    };
  }
  _moveByOffset(offset2) {
    const currentPosition = locate(this._draggableElement);
    const newPosition = {
      left: currentPosition.left + offset2.left,
      top: currentPosition.top + offset2.top
    };
    move(this._draggableElement, newPosition);
  }
};
var m_popup_drag_default = PopupDrag;

// node_modules/devextreme/esm/__internal/ui/popup/m_popup_overflow_manager.js
var overflowManagerMock = {
  setOverflow: noop2,
  restoreOverflow: noop2
};
var createBodyOverflowManager = () => {
  if (!m_window_default.hasWindow()) {
    return overflowManagerMock;
  }
  const window31 = m_window_default.getWindow();
  const {
    documentElement
  } = dom_adapter_default.getDocument();
  const body = dom_adapter_default.getBody();
  const isIosDevice = "ios" === devices_default.real().platform;
  const prevSettings = {
    overflow: null,
    overflowX: null,
    overflowY: null,
    paddingRight: null,
    position: null,
    top: null,
    left: null
  };
  return {
    setOverflow: isIosDevice ? () => {
      if (isDefined(prevSettings.position) || "fixed" === body.style.position) {
        return;
      }
      const {
        scrollY,
        scrollX
      } = window31;
      prevSettings.position = body.style.position;
      prevSettings.top = body.style.top;
      prevSettings.left = body.style.left;
      body.style.setProperty("position", "fixed");
      body.style.setProperty("top", -scrollY + "px");
      body.style.setProperty("left", -scrollX + "px");
    } : () => {
      (() => {
        const scrollBarWidth = window31.innerWidth - documentElement.clientWidth;
        if (prevSettings.paddingRight || scrollBarWidth <= 0) {
          return;
        }
        const paddingRight = window31.getComputedStyle(body).getPropertyValue("padding-right");
        const computedBodyPaddingRight = parseInt(paddingRight, 10);
        prevSettings.paddingRight = computedBodyPaddingRight;
        body.style.setProperty("padding-right", `${computedBodyPaddingRight + scrollBarWidth}px`);
      })();
      if (prevSettings.overflow || "hidden" === body.style.overflow) {
        return;
      }
      prevSettings.overflow = body.style.overflow;
      prevSettings.overflowX = body.style.overflowX;
      prevSettings.overflowY = body.style.overflowY;
      body.style.setProperty("overflow", "hidden");
    },
    restoreOverflow: isIosDevice ? () => {
      if (!isDefined(prevSettings.position)) {
        return;
      }
      const scrollY = -parseInt(body.style.top, 10);
      const scrollX = -parseInt(body.style.left, 10);
      ["position", "top", "left"].forEach((property) => {
        if (prevSettings[property]) {
          body.style.setProperty(property, prevSettings[property]);
        } else {
          body.style.removeProperty(property);
        }
      });
      window31.scrollTo(scrollX, scrollY);
      prevSettings.position = null;
    } : () => {
      (() => {
        if (!isDefined(prevSettings.paddingRight)) {
          return;
        }
        if (prevSettings.paddingRight) {
          body.style.setProperty("padding-right", `${prevSettings.paddingRight}px`);
        } else {
          body.style.removeProperty("padding-right");
        }
        prevSettings.paddingRight = null;
      })();
      ["overflow", "overflowX", "overflowY"].forEach((property) => {
        if (!isDefined(prevSettings[property])) {
          return;
        }
        const propertyInKebabCase = property.replace(/(X)|(Y)/, (symbol) => `-${symbol.toLowerCase()}`);
        if (prevSettings[property]) {
          body.style.setProperty(propertyInKebabCase, prevSettings[property]);
        } else {
          body.style.removeProperty(propertyInKebabCase);
        }
        prevSettings[property] = null;
      });
    }
  };
};

// node_modules/devextreme/esm/__internal/ui/popup/m_popup_position_controller.js
var _excluded6 = ["fullScreen", "forceApplyBindings", "dragOutsideBoundary", "dragAndResizeArea", "outsideDragFactor"];
var window21 = m_window_default.getWindow();
var PopupPositionController = class extends OverlayPositionController {
  constructor(_ref) {
    let {
      fullScreen,
      forceApplyBindings,
      dragOutsideBoundary,
      dragAndResizeArea,
      outsideDragFactor
    } = _ref, args = _objectWithoutPropertiesLoose(_ref, _excluded6);
    super(args);
    this._props = _extends({}, this._props, {
      fullScreen,
      forceApplyBindings,
      dragOutsideBoundary,
      dragAndResizeArea,
      outsideDragFactor
    });
    this._$dragResizeContainer = void 0;
    this._updateDragResizeContainer();
  }
  set fullScreen(fullScreen) {
    this._props.fullScreen = fullScreen;
    if (fullScreen) {
      this._fullScreenEnabled();
    } else {
      this._fullScreenDisabled();
    }
  }
  get $dragResizeContainer() {
    return this._$dragResizeContainer;
  }
  get outsideDragFactor() {
    if (this._props.dragOutsideBoundary) {
      return 1;
    }
    return this._props.outsideDragFactor;
  }
  set dragAndResizeArea(dragAndResizeArea) {
    this._props.dragAndResizeArea = dragAndResizeArea;
    this._updateDragResizeContainer();
  }
  set dragOutsideBoundary(dragOutsideBoundary) {
    this._props.dragOutsideBoundary = dragOutsideBoundary;
    this._updateDragResizeContainer();
  }
  set outsideDragFactor(outsideDragFactor) {
    this._props.outsideDragFactor = outsideDragFactor;
  }
  updateContainer(containerProp) {
    super.updateContainer(containerProp);
    this._updateDragResizeContainer();
  }
  dragHandled() {
    this.restorePositionOnNextRender(false);
  }
  resizeHandled() {
    this.restorePositionOnNextRender(false);
  }
  positionContent() {
    if (this._props.fullScreen) {
      move(this._$content, {
        top: 0,
        left: 0
      });
      this.detectVisualPositionChange();
    } else {
      var _this$_props$forceApp, _this$_props;
      null === (_this$_props$forceApp = (_this$_props = this._props).forceApplyBindings) || void 0 === _this$_props$forceApp || _this$_props$forceApp.call(_this$_props);
      super.positionContent();
    }
  }
  _normalizePosition(positionProp) {
    const normalizedPosition = super._normalizePosition(positionProp);
    if (this._props.fullScreen) {
      normalizedPosition.of = "window";
    }
    return normalizedPosition;
  }
  _updateDragResizeContainer() {
    this._$dragResizeContainer = this._getDragResizeContainer();
  }
  _getDragResizeContainer() {
    if (this._props.dragOutsideBoundary) {
      return renderer_default(window21);
    }
    if (this._props.dragAndResizeArea) {
      return renderer_default(this._props.dragAndResizeArea);
    }
    const isContainerDefined = originalViewPort().get(0) || this._props.container;
    return isContainerDefined ? this._$markupContainer : renderer_default(window21);
  }
  _getVisualContainer() {
    if (this._props.fullScreen) {
      return renderer_default(window21);
    }
    return super._getVisualContainer();
  }
  _fullScreenEnabled() {
    this.restorePositionOnNextRender(false);
  }
  _fullScreenDisabled() {
    this.restorePositionOnNextRender(true);
  }
};

// node_modules/devextreme/esm/__internal/ui/popup/m_popup.js
var window22 = m_window_default.getWindow();
var ALLOWED_TOOLBAR_ITEM_ALIASES = ["cancel", "clear", "done"];
var HEIGHT_STRATEGIES = {
  static: "",
  inherit: "dx-popup-inherit-height",
  flex: "dx-popup-flex-height"
};
var getButtonPlace = (name2) => {
  const device = devices_default.current();
  const {
    platform
  } = device;
  let toolbar = "bottom";
  let location = "before";
  if ("ios" === platform) {
    switch (name2) {
      case "cancel":
        toolbar = "top";
        break;
      case "clear":
        toolbar = "top";
        location = "after";
        break;
      case "done":
        location = "after";
    }
  } else if ("android" === platform) {
    switch (name2) {
      case "cancel":
      case "done":
        location = "after";
    }
  }
  return {
    toolbar,
    location
  };
};
var Popup = class extends m_overlay_default {
  _supportedKeys() {
    return _extends({}, super._supportedKeys(), {
      upArrow: (e) => {
        var _this$_drag;
        null === (_this$_drag = this._drag) || void 0 === _this$_drag || _this$_drag.moveUp(e);
      },
      downArrow: (e) => {
        var _this$_drag2;
        null === (_this$_drag2 = this._drag) || void 0 === _this$_drag2 || _this$_drag2.moveDown(e);
      },
      leftArrow: (e) => {
        var _this$_drag3;
        null === (_this$_drag3 = this._drag) || void 0 === _this$_drag3 || _this$_drag3.moveLeft(e);
      },
      rightArrow: (e) => {
        var _this$_drag4;
        null === (_this$_drag4 = this._drag) || void 0 === _this$_drag4 || _this$_drag4.moveRight(e);
      }
    });
  }
  _getDefaultOptions() {
    return _extends({}, super._getDefaultOptions(), {
      fullScreen: false,
      title: "",
      showTitle: true,
      titleTemplate: "title",
      onTitleRendered: null,
      dragOutsideBoundary: false,
      dragEnabled: false,
      enableBodyScroll: true,
      outsideDragFactor: 0,
      onResizeStart: null,
      onResize: null,
      onResizeEnd: null,
      resizeEnabled: false,
      toolbarItems: [],
      showCloseButton: false,
      bottomTemplate: "bottom",
      useDefaultToolbarButtons: false,
      useFlatToolbarButtons: false,
      autoResizeEnabled: true
    });
  }
  _defaultOptionsRules() {
    return super._defaultOptionsRules().concat([{
      device: {
        platform: "ios"
      },
      options: {
        animation: this._iosAnimation
      }
    }, {
      device: {
        platform: "android"
      },
      options: {
        animation: this._androidAnimation
      }
    }, {
      device: {
        platform: "generic"
      },
      options: {
        showCloseButton: true
      }
    }, {
      device: (device) => "desktop" === devices_default.real().deviceType && "generic" === device.platform,
      options: {
        dragEnabled: true
      }
    }, {
      device: () => "desktop" === devices_default.real().deviceType && !devices_default.isSimulator(),
      options: {
        focusStateEnabled: true
      }
    }, {
      device: () => isMaterialBased(),
      options: {
        useFlatToolbarButtons: true
      }
    }, {
      device: () => isMaterial(),
      options: {
        useDefaultToolbarButtons: true,
        showCloseButton: false
      }
    }]);
  }
  _iosAnimation() {
    return {
      show: {
        type: "slide",
        duration: 400,
        from: {
          position: {
            my: "top",
            at: "bottom"
          }
        },
        to: {
          position: {
            my: "center",
            at: "center"
          }
        }
      },
      hide: {
        type: "slide",
        duration: 400,
        from: {
          opacity: 1,
          position: {
            my: "center",
            at: "center"
          }
        },
        to: {
          opacity: 1,
          position: {
            my: "top",
            at: "bottom"
          }
        }
      }
    };
  }
  _androidAnimation() {
    return this.option("fullScreen") ? {
      show: {
        type: "slide",
        duration: 300,
        from: {
          top: "30%",
          opacity: 0
        },
        to: {
          top: 0,
          opacity: 1
        }
      },
      hide: {
        type: "slide",
        duration: 300,
        from: {
          top: 0,
          opacity: 1
        },
        to: {
          top: "30%",
          opacity: 0
        }
      }
    } : {
      show: {
        type: "fade",
        duration: 400,
        from: 0,
        to: 1
      },
      hide: {
        type: "fade",
        duration: 400,
        from: 1,
        to: 0
      }
    };
  }
  _init() {
    const {
      _wrapperClassExternal: popupWrapperClassExternal
    } = this.option();
    const popupWrapperClasses = popupWrapperClassExternal ? `dx-popup-wrapper ${popupWrapperClassExternal}` : "dx-popup-wrapper";
    super._init();
    this._createBodyOverflowManager();
    this._updateResizeCallbackSkipCondition();
    this.$element().addClass("dx-popup");
    this.$wrapper().addClass(popupWrapperClasses);
    this._$popupContent = this._$content.wrapInner(renderer_default("<div>").addClass("dx-popup-content")).children().eq(0);
    this._toggleContentScrollClass();
    this.$overlayContent().attr("role", "dialog");
  }
  _render() {
    const isFullscreen = this.option("fullScreen");
    this._toggleFullScreenClass(isFullscreen);
    super._render();
  }
  _createBodyOverflowManager() {
    this._bodyOverflowManager = createBodyOverflowManager();
  }
  _toggleFullScreenClass(value2) {
    this.$overlayContent().toggleClass("dx-popup-fullscreen", value2).toggleClass("dx-popup-normal", !value2);
  }
  _initTemplates() {
    super._initTemplates();
    this._templateManager.addDefaultTemplates({
      title: new EmptyTemplate(),
      bottom: new EmptyTemplate()
    });
  }
  _getActionsList() {
    return super._getActionsList().concat(["onResizeStart", "onResize", "onResizeEnd"]);
  }
  _contentResizeHandler(entry) {
    if (!this._shouldSkipContentResize(entry)) {
      this._renderGeometry({
        shouldOnlyReposition: true
      });
    }
  }
  _doesShowAnimationChangeDimensions() {
    const animation3 = this.option("animation");
    return ["to", "from"].some((prop) => {
      var _animation$show;
      const config3 = null === animation3 || void 0 === animation3 || null === (_animation$show = animation3.show) || void 0 === _animation$show ? void 0 : _animation$show[prop];
      return isObject(config3) && ("width" in config3 || "height" in config3);
    });
  }
  _updateResizeCallbackSkipCondition() {
    const doesShowAnimationChangeDimensions = this._doesShowAnimationChangeDimensions();
    this._shouldSkipContentResize = (entry) => doesShowAnimationChangeDimensions && this._showAnimationProcessing || this._areContentDimensionsRendered(entry);
  }
  _observeContentResize(shouldObserve) {
    if (!this.option("useResizeObserver")) {
      return;
    }
    const contentElement = this._$content.get(0);
    if (shouldObserve) {
      resize_observer_default.observe(contentElement, (entry) => {
        this._contentResizeHandler(entry);
      });
    } else {
      resize_observer_default.unobserve(contentElement);
    }
  }
  _areContentDimensionsRendered(entry) {
    var _entry$contentBoxSize, _this$_renderedDimens3, _this$_renderedDimens4;
    const contentBox = null === (_entry$contentBoxSize = entry.contentBoxSize) || void 0 === _entry$contentBoxSize ? void 0 : _entry$contentBoxSize[0];
    if (contentBox) {
      var _this$_renderedDimens, _this$_renderedDimens2;
      return parseInt(contentBox.inlineSize, 10) === (null === (_this$_renderedDimens = this._renderedDimensions) || void 0 === _this$_renderedDimens ? void 0 : _this$_renderedDimens.width) && parseInt(contentBox.blockSize, 10) === (null === (_this$_renderedDimens2 = this._renderedDimensions) || void 0 === _this$_renderedDimens2 ? void 0 : _this$_renderedDimens2.height);
    }
    const {
      contentRect
    } = entry;
    return parseInt(contentRect.width, 10) === (null === (_this$_renderedDimens3 = this._renderedDimensions) || void 0 === _this$_renderedDimens3 ? void 0 : _this$_renderedDimens3.width) && parseInt(contentRect.height, 10) === (null === (_this$_renderedDimens4 = this._renderedDimensions) || void 0 === _this$_renderedDimens4 ? void 0 : _this$_renderedDimens4.height);
  }
  _renderContent() {
    super._renderContent();
    this._observeContentResize(true);
  }
  _renderContentImpl() {
    this._renderTitle();
    super._renderContentImpl();
    this._renderResize();
    this._renderBottom();
  }
  _renderTitle() {
    const items = this._getToolbarItems("top");
    const {
      title,
      showTitle
    } = this.option();
    if (showTitle && !!title) {
      items.unshift({
        location: devices_default.current().ios ? "center" : "before",
        text: title
      });
    }
    if (showTitle || items.length > 0) {
      if (this._$title) {
        this._$title.remove();
      }
      const $title = renderer_default("<div>").addClass("dx-popup-title").insertBefore(this.$content());
      this._$title = this._renderTemplateByType("titleTemplate", items, $title).addClass("dx-popup-title");
      this._renderDrag();
      this._executeTitleRenderAction(this._$title);
      this._$title.toggleClass("dx-has-close-button", this._hasCloseButton());
    } else if (this._$title) {
      this._$title.detach();
    }
    this._toggleAriaLabel();
  }
  _toggleAriaLabel() {
    var _this$_$title;
    const {
      title,
      showTitle
    } = this.option();
    const shouldSetAriaLabel = showTitle && !!title;
    const titleId = shouldSetAriaLabel ? new guid_default2() : null;
    null === (_this$_$title = this._$title) || void 0 === _this$_$title || _this$_$title.find(".dx-toolbar-label").eq(0).attr("id", titleId);
    this.$overlayContent().attr("aria-labelledby", titleId);
  }
  _renderTemplateByType(optionName, data17, $container, additionalToolbarOptions) {
    const {
      rtlEnabled,
      useDefaultToolbarButtons,
      useFlatToolbarButtons,
      disabled
    } = this.option();
    const template = this._getTemplateByOption(optionName);
    const toolbarTemplate = template instanceof EmptyTemplate;
    if (toolbarTemplate) {
      const integrationOptions = extend({}, this.option("integrationOptions"), {
        skipTemplates: ["content", "title"]
      });
      const toolbarOptions = extend(additionalToolbarOptions, {
        items: data17,
        rtlEnabled,
        useDefaultButtons: useDefaultToolbarButtons,
        useFlatButtons: useFlatToolbarButtons,
        disabled,
        integrationOptions
      });
      this._getTemplate("dx-polymorph-widget").render({
        container: $container,
        model: {
          widget: this._getToolbarName(),
          options: toolbarOptions
        }
      });
      const $toolbar = $container.children("div");
      $container.replaceWith($toolbar);
      return $toolbar;
    }
    const $result = renderer_default(template.render({
      container: getPublicElement($container)
    }));
    if ($result.hasClass("dx-template-wrapper")) {
      $container.replaceWith($result);
      $container = $result;
    }
    return $container;
  }
  _getToolbarName() {
    return "dxToolbarBase";
  }
  _renderVisibilityAnimate(visible2) {
    return super._renderVisibilityAnimate(visible2);
  }
  _hide() {
    this._observeContentResize(false);
    return super._hide();
  }
  _executeTitleRenderAction($titleElement) {
    this._getTitleRenderAction()({
      titleElement: getPublicElement($titleElement)
    });
  }
  _getTitleRenderAction() {
    return this._titleRenderAction || this._createTitleRenderAction();
  }
  _createTitleRenderAction() {
    return this._titleRenderAction = this._createActionByOption("onTitleRendered", {
      element: this.element(),
      excludeValidators: ["disabled", "readOnly"]
    });
  }
  _getCloseButton() {
    return {
      toolbar: "top",
      location: "after",
      template: this._getCloseButtonRenderer()
    };
  }
  _getCloseButtonRenderer() {
    return (_, __, container) => {
      const $button = renderer_default("<div>").addClass("dx-closebutton");
      this._createComponent($button, button_default2, {
        icon: "close",
        onClick: this._createToolbarItemAction(void 0),
        stylingMode: "text",
        integrationOptions: {}
      });
      renderer_default(container).append($button);
    };
  }
  _getToolbarItems(toolbar) {
    const toolbarItems = this.option("toolbarItems");
    const toolbarsItems = [];
    this._toolbarItemClasses = [];
    const currentPlatform = devices_default.current().platform;
    let index2 = 0;
    each(toolbarItems, (_, data17) => {
      const isShortcut = isDefined(data17.shortcut);
      const item = isShortcut ? getButtonPlace(data17.shortcut) : data17;
      if (isShortcut && "ios" === currentPlatform && index2 < 2) {
        item.toolbar = "top";
        index2++;
      }
      item.toolbar = data17.toolbar || item.toolbar || "top";
      if (item && item.toolbar === toolbar) {
        if (isShortcut) {
          extend(item, {
            location: data17.location
          }, this._getToolbarItemByAlias(data17));
        }
        const isLTROrder = "generic" === currentPlatform;
        if ("done" === data17.shortcut && isLTROrder || "cancel" === data17.shortcut && !isLTROrder) {
          toolbarsItems.unshift(item);
        } else {
          toolbarsItems.push(item);
        }
      }
    });
    if ("top" === toolbar && this._hasCloseButton()) {
      toolbarsItems.push(this._getCloseButton());
    }
    return toolbarsItems;
  }
  _hasCloseButton() {
    const {
      showCloseButton,
      showTitle
    } = this.option();
    return showCloseButton && showTitle;
  }
  _getLocalizationKey(itemType) {
    return "done" === itemType.toLowerCase() ? "OK" : camelize2(itemType, true);
  }
  _getToolbarButtonStylingMode(shortcut) {
    if (isFluent()) {
      return "done" === shortcut ? "contained" : "outlined";
    }
    return this.option("useFlatToolbarButtons") ? "text" : "contained";
  }
  _getToolbarButtonType(shortcut) {
    if (isFluent() && "done" === shortcut || this.option("useDefaultToolbarButtons")) {
      return "default";
    }
    return "normal";
  }
  _getToolbarItemByAlias(data17) {
    const that = this;
    const itemType = data17.shortcut;
    if (!ALLOWED_TOOLBAR_ITEM_ALIASES.includes(itemType)) {
      return false;
    }
    const itemConfig = extend({
      text: message_default.format(this._getLocalizationKey(itemType)),
      onClick: this._createToolbarItemAction(data17.onClick),
      integrationOptions: {},
      type: this._getToolbarButtonType(itemType),
      stylingMode: this._getToolbarButtonStylingMode(itemType)
    }, data17.options || {});
    const itemClass = `dx-popup-${itemType}`;
    this._toolbarItemClasses.push(itemClass);
    return {
      template(_, __, container) {
        const $toolbarItem = renderer_default("<div>").addClass(itemClass).appendTo(container);
        that._createComponent($toolbarItem, button_default2, itemConfig);
      }
    };
  }
  _createToolbarItemAction(clickAction) {
    return this._createAction(clickAction, {
      afterExecute(e) {
        e.component.hide();
      }
    });
  }
  _renderBottom() {
    const items = this._getToolbarItems("bottom");
    if (items.length) {
      var _this$_$bottom;
      null === (_this$_$bottom = this._$bottom) || void 0 === _this$_$bottom || _this$_$bottom.remove();
      const $bottom = renderer_default("<div>").addClass("dx-popup-bottom").insertAfter(this.$content());
      this._$bottom = this._renderTemplateByType("bottomTemplate", items, $bottom, {
        compactMode: true
      }).addClass("dx-popup-bottom");
      this._toggleClasses();
    } else {
      var _this$_$bottom2;
      null === (_this$_$bottom2 = this._$bottom) || void 0 === _this$_$bottom2 || _this$_$bottom2.detach();
    }
  }
  _toggleDisabledState(value2) {
    super._toggleDisabledState(...arguments);
    this.$content().toggleClass("dx-state-disabled", Boolean(value2));
  }
  _toggleClasses() {
    const aliases = ALLOWED_TOOLBAR_ITEM_ALIASES;
    each(aliases, (_, alias) => {
      const className = `dx-popup-${alias}`;
      if (this._toolbarItemClasses.includes(className)) {
        var _this$_$bottom3;
        this.$wrapper().addClass(`${className}-visible`);
        null === (_this$_$bottom3 = this._$bottom) || void 0 === _this$_$bottom3 || _this$_$bottom3.addClass(className);
      } else {
        var _this$_$bottom4;
        this.$wrapper().removeClass(`${className}-visible`);
        null === (_this$_$bottom4 = this._$bottom) || void 0 === _this$_$bottom4 || _this$_$bottom4.removeClass(className);
      }
    });
  }
  _toggleFocusClass(isFocused, $element) {
    super._toggleFocusClass(isFocused, $element);
    if (isFocused && !isLastZIndexInStack(this._zIndex)) {
      const zIndex = create(this._zIndexInitValue());
      remove2(this._zIndex);
      this._zIndex = zIndex;
      this._$wrapper.css("zIndex", zIndex);
      this._$content.css("zIndex", zIndex);
    }
  }
  _toggleContentScrollClass() {
    const isNativeScrollingEnabled = !this.option("preventScrollEvents");
    this.$content().toggleClass("dx-popup-content-scrollable", isNativeScrollingEnabled);
  }
  _getPositionControllerConfig() {
    const {
      fullScreen,
      forceApplyBindings,
      dragOutsideBoundary,
      dragAndResizeArea,
      outsideDragFactor
    } = this.option();
    return _extends({}, super._getPositionControllerConfig(), {
      fullScreen,
      forceApplyBindings,
      dragOutsideBoundary,
      dragAndResizeArea,
      outsideDragFactor
    });
  }
  _initPositionController() {
    this._positionController = new PopupPositionController(this._getPositionControllerConfig());
  }
  _getDragTarget() {
    return this.topToolbar();
  }
  _renderGeometry(options2) {
    const {
      visible: visible2,
      useResizeObserver
    } = this.option();
    if (visible2 && m_window_default.hasWindow()) {
      const isAnimated = this._showAnimationProcessing;
      const shouldRepeatAnimation = isAnimated && !(null !== options2 && void 0 !== options2 && options2.forceStopAnimation) && useResizeObserver;
      this._isAnimationPaused = shouldRepeatAnimation || void 0;
      this._stopAnimation();
      if (null !== options2 && void 0 !== options2 && options2.shouldOnlyReposition) {
        this._renderPosition(false);
      } else {
        this._renderGeometryImpl(null === options2 || void 0 === options2 ? void 0 : options2.isDimensionChange);
      }
      if (shouldRepeatAnimation) {
        this._animateShowing();
        this._isAnimationPaused = void 0;
      }
    }
  }
  _cacheDimensions() {
    if (!this.option("useResizeObserver")) {
      return;
    }
    this._renderedDimensions = {
      width: parseInt(getWidth(this._$content), 10),
      height: parseInt(getHeight(this._$content), 10)
    };
  }
  _renderGeometryImpl() {
    let isDimensionChange = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : false;
    if (!isDimensionChange) {
      this._resetContentHeight();
    }
    super._renderGeometryImpl();
    this._cacheDimensions();
    this._setContentHeight();
  }
  _resetContentHeight() {
    const height = this._getOptionValue("height");
    if ("auto" === height) {
      this.$content().css({
        height: "auto",
        maxHeight: "none"
      });
    }
  }
  _renderDrag() {
    const $dragTarget = this._getDragTarget();
    const {
      dragEnabled
    } = this.option();
    if (!$dragTarget) {
      return;
    }
    const config3 = {
      dragEnabled,
      handle: $dragTarget.get(0),
      draggableElement: this._$content.get(0),
      positionController: this._positionController
    };
    if (this._drag) {
      this._drag.init(config3);
    } else {
      this._drag = new m_popup_drag_default(config3);
    }
    this.$overlayContent().toggleClass("dx-popup-draggable", dragEnabled);
  }
  _renderResize() {
    this._resizable = this._createComponent(this._$content, resizable_default, {
      handles: this.option("resizeEnabled") ? "all" : "none",
      onResizeEnd: (e) => {
        this._resizeEndHandler(e);
        this._observeContentResize(true);
      },
      onResize: (e) => {
        this._setContentHeight();
        this._actions.onResize(e);
      },
      onResizeStart: (e) => {
        this._observeContentResize(false);
        this._actions.onResizeStart(e);
      },
      minHeight: 100,
      minWidth: 100,
      area: this._positionController.$dragResizeContainer,
      keepAspectRatio: false
    });
  }
  _resizeEndHandler(e) {
    const width = this._resizable.option("width");
    const height = this._resizable.option("height");
    width && this._setOptionWithoutOptionChange("width", width);
    height && this._setOptionWithoutOptionChange("height", height);
    this._cacheDimensions();
    this._positionController.resizeHandled();
    this._positionController.detectVisualPositionChange(e.event);
    this._actions.onResizeEnd(e);
  }
  _setContentHeight() {
    const {
      forceApplyBindings
    } = this.option();
    (forceApplyBindings || noop2)();
    const overlayContent = this.$overlayContent().get(0);
    const currentHeightStrategyClass = this._chooseHeightStrategy(overlayContent);
    this.$content().css(this._getHeightCssStyles(currentHeightStrategyClass, overlayContent));
    this._setHeightClasses(this.$overlayContent(), currentHeightStrategyClass);
  }
  _heightStrategyChangeOffset(currentHeightStrategyClass, popupVerticalPaddings) {
    return currentHeightStrategyClass === HEIGHT_STRATEGIES.flex ? -popupVerticalPaddings : 0;
  }
  _chooseHeightStrategy(overlayContent) {
    const isAutoWidth = "auto" === overlayContent.style.width || "" === overlayContent.style.width;
    let currentHeightStrategyClass = HEIGHT_STRATEGIES.static;
    if (this._isAutoHeight() && this.option("autoResizeEnabled")) {
      if (isAutoWidth) {
        currentHeightStrategyClass = HEIGHT_STRATEGIES.inherit;
      } else {
        currentHeightStrategyClass = HEIGHT_STRATEGIES.flex;
      }
    }
    return currentHeightStrategyClass;
  }
  _getHeightCssStyles(currentHeightStrategyClass, overlayContent) {
    let cssStyles = {};
    const contentMaxHeight = this._getOptionValue("maxHeight", overlayContent);
    const contentMinHeight = this._getOptionValue("minHeight", overlayContent);
    const popupHeightParts = this._splitPopupHeight();
    const toolbarsAndVerticalOffsetsHeight = popupHeightParts.header + popupHeightParts.footer + popupHeightParts.contentVerticalOffsets + popupHeightParts.popupVerticalOffsets + this._heightStrategyChangeOffset(currentHeightStrategyClass, popupHeightParts.popupVerticalPaddings);
    if (currentHeightStrategyClass === HEIGHT_STRATEGIES.static) {
      if (!this._isAutoHeight() || contentMaxHeight || contentMinHeight) {
        const overlayHeight = this.option("fullScreen") ? Math.min(getBoundingRect(overlayContent).height, m_window_default.getWindow().innerHeight) : getBoundingRect(overlayContent).height;
        const contentHeight = overlayHeight - toolbarsAndVerticalOffsetsHeight;
        cssStyles = {
          height: Math.max(0, contentHeight),
          minHeight: "auto",
          maxHeight: "auto"
        };
      }
    } else {
      const container = renderer_default(this._positionController.$visualContainer).get(0);
      const maxHeightValue = addOffsetToMaxHeight(contentMaxHeight, -toolbarsAndVerticalOffsetsHeight, container);
      const minHeightValue = addOffsetToMinHeight(contentMinHeight, -toolbarsAndVerticalOffsetsHeight, container);
      cssStyles = {
        height: "auto",
        minHeight: minHeightValue,
        maxHeight: maxHeightValue
      };
    }
    return cssStyles;
  }
  _setHeightClasses($container, currentClass) {
    let excessClasses = "";
    for (const name2 in HEIGHT_STRATEGIES) {
      if (HEIGHT_STRATEGIES[name2] !== currentClass) {
        excessClasses += ` ${HEIGHT_STRATEGIES[name2]}`;
      }
    }
    $container.removeClass(excessClasses).addClass(currentClass);
  }
  _isAutoHeight() {
    return "auto" === this.$overlayContent().get(0).style.height;
  }
  _splitPopupHeight() {
    const topToolbar = this.topToolbar();
    const bottomToolbar = this.bottomToolbar();
    return {
      header: getVisibleHeight(null === topToolbar || void 0 === topToolbar ? void 0 : topToolbar.get(0)),
      footer: getVisibleHeight(null === bottomToolbar || void 0 === bottomToolbar ? void 0 : bottomToolbar.get(0)),
      contentVerticalOffsets: getVerticalOffsets(this.$overlayContent().get(0), true),
      popupVerticalOffsets: getVerticalOffsets(this.$content().get(0), true),
      popupVerticalPaddings: getVerticalOffsets(this.$content().get(0), false)
    };
  }
  _isAllWindowCovered() {
    const {
      fullScreen
    } = this.option();
    return super._isAllWindowCovered() || fullScreen;
  }
  _renderDimensions() {
    if (this.option("fullScreen")) {
      this.$overlayContent().css({
        width: "100%",
        height: "100%",
        minWidth: "",
        maxWidth: "",
        minHeight: "",
        maxHeight: ""
      });
    } else {
      super._renderDimensions();
    }
    if (m_window_default.hasWindow()) {
      this._renderFullscreenWidthClass();
    }
  }
  _dimensionChanged() {
    this._renderGeometry({
      isDimensionChange: true
    });
  }
  _clean() {
    super._clean();
    this._observeContentResize(false);
  }
  _dispose() {
    super._dispose();
    this._toggleBodyScroll(true);
  }
  _renderFullscreenWidthClass() {
    const isFullScreen = getOuterWidth(this.$overlayContent()) === getWidth(window22);
    this.$overlayContent().toggleClass("dx-popup-fullscreen-width", isFullScreen);
  }
  _toggleSafariScrolling() {
    if (!this.option("enableBodyScroll")) {
      return;
    }
    super._toggleSafariScrolling();
  }
  _toggleBodyScroll(enabled) {
    if (!this._bodyOverflowManager) {
      return;
    }
    const {
      setOverflow,
      restoreOverflow
    } = this._bodyOverflowManager;
    if (enabled) {
      restoreOverflow();
    } else {
      setOverflow();
    }
  }
  refreshPosition() {
    this._renderPosition();
  }
  _optionChanged(args) {
    var _this$_resizable2;
    const {
      value: value2,
      name: name2
    } = args;
    switch (name2) {
      case "disabled":
        super._optionChanged(args);
        this._renderTitle();
        this._renderBottom();
        break;
      case "animation":
        this._updateResizeCallbackSkipCondition();
        break;
      case "enableBodyScroll":
        if (this.option("visible")) {
          this._toggleBodyScroll(value2);
        }
        break;
      case "showTitle":
      case "title":
      case "titleTemplate":
        this._renderTitle();
        this._renderGeometry();
        triggerResizeEvent2(this.$overlayContent());
        break;
      case "bottomTemplate":
        this._renderBottom();
        this._renderGeometry();
        triggerResizeEvent2(this.$overlayContent());
        break;
      case "container":
        super._optionChanged(args);
        if (this.option("resizeEnabled")) {
          var _this$_resizable;
          null === (_this$_resizable = this._resizable) || void 0 === _this$_resizable || _this$_resizable.option("area", this._positionController.$dragResizeContainer);
        }
        break;
      case "width":
      case "height":
        super._optionChanged(args);
        null === (_this$_resizable2 = this._resizable) || void 0 === _this$_resizable2 || _this$_resizable2.option(name2, value2);
        break;
      case "onTitleRendered":
        this._createTitleRenderAction();
        break;
      case "toolbarItems":
      case "useDefaultToolbarButtons":
      case "useFlatToolbarButtons": {
        const shouldRenderGeometry = !args.fullName.match(/^toolbarItems((\[\d+\])(\.(options|visible).*)?)?$/);
        this._renderTitle();
        this._renderBottom();
        if (shouldRenderGeometry) {
          this._renderGeometry();
          triggerResizeEvent2(this.$overlayContent());
        }
        break;
      }
      case "dragEnabled":
        this._renderDrag();
        break;
      case "dragAndResizeArea":
        this._positionController.dragAndResizeArea = value2;
        if (this.option("resizeEnabled")) {
          this._resizable.option("area", this._positionController.$dragResizeContainer);
        }
        this._positionController.positionContent();
        break;
      case "dragOutsideBoundary":
        this._positionController.dragOutsideBoundary = value2;
        if (this.option("resizeEnabled")) {
          this._resizable.option("area", this._positionController.$dragResizeContainer);
        }
        break;
      case "outsideDragFactor":
        this._positionController.outsideDragFactor = value2;
        break;
      case "resizeEnabled":
        this._renderResize();
        this._renderGeometry();
        break;
      case "autoResizeEnabled":
        this._renderGeometry();
        triggerResizeEvent2(this.$overlayContent());
        break;
      case "fullScreen":
        this._positionController.fullScreen = value2;
        this._toggleFullScreenClass(value2);
        this._toggleSafariScrolling();
        this._renderGeometry();
        triggerResizeEvent2(this.$overlayContent());
        break;
      case "showCloseButton":
        this._renderTitle();
        break;
      case "preventScrollEvents":
        super._optionChanged(args);
        this._toggleContentScrollClass();
        break;
      default:
        super._optionChanged(args);
    }
  }
  bottomToolbar() {
    return this._$bottom;
  }
  topToolbar() {
    return this._$title;
  }
  $content() {
    return this._$popupContent;
  }
  content() {
    return getPublicElement(this.$content());
  }
  $overlayContent() {
    return this._$content;
  }
  getFocusableElements() {
    return this.$wrapper().find("[tabindex]").filter((index2, item) => item.getAttribute("tabindex") >= 0);
  }
};
component_registrator_default("dxPopup", Popup);
var m_popup_default = Popup;

// node_modules/devextreme/esm/ui/popup/ui.popup.js
var ui_popup_default = m_popup_default;

// node_modules/devextreme/esm/__internal/events/m_swipe.js
var SWIPE_START_EVENT = "dxswipestart";
var SWIPE_EVENT = "dxswipe";
var SWIPE_END_EVENT = "dxswipeend";
var HorizontalStrategy = {
  defaultItemSizeFunc() {
    return getWidth(this.getElement());
  },
  getBounds() {
    return [this._maxLeftOffset, this._maxRightOffset];
  },
  calcOffsetRatio(e) {
    const endEventData = eventData(e);
    return (endEventData.x - (this._savedEventData && this._savedEventData.x || 0)) / this._itemSizeFunc().call(this, e);
  },
  isFastSwipe(e) {
    const endEventData = eventData(e);
    return this.FAST_SWIPE_SPEED_LIMIT * Math.abs(endEventData.x - this._tickData.x) >= endEventData.time - this._tickData.time;
  }
};
var VerticalStrategy = {
  defaultItemSizeFunc() {
    return getHeight(this.getElement());
  },
  getBounds() {
    return [this._maxTopOffset, this._maxBottomOffset];
  },
  calcOffsetRatio(e) {
    const endEventData = eventData(e);
    return (endEventData.y - (this._savedEventData && this._savedEventData.y || 0)) / this._itemSizeFunc().call(this, e);
  },
  isFastSwipe(e) {
    const endEventData = eventData(e);
    return this.FAST_SWIPE_SPEED_LIMIT * Math.abs(endEventData.y - this._tickData.y) >= endEventData.time - this._tickData.time;
  }
};
var STRATEGIES = {
  horizontal: HorizontalStrategy,
  vertical: VerticalStrategy
};
var SwipeEmitter = m_emitter_gesture_default.inherit({
  TICK_INTERVAL: 300,
  FAST_SWIPE_SPEED_LIMIT: 10,
  ctor(element) {
    this.callBase(element);
    this.direction = "horizontal";
    this.elastic = true;
  },
  _getStrategy() {
    return STRATEGIES[this.direction];
  },
  _defaultItemSizeFunc() {
    return this._getStrategy().defaultItemSizeFunc.call(this);
  },
  _itemSizeFunc() {
    return this.itemSizeFunc || this._defaultItemSizeFunc;
  },
  _init(e) {
    this._tickData = eventData(e);
  },
  _start(e) {
    this._savedEventData = eventData(e);
    e = this._fireEvent("dxswipestart", e);
    if (!e.cancel) {
      this._maxLeftOffset = e.maxLeftOffset;
      this._maxRightOffset = e.maxRightOffset;
      this._maxTopOffset = e.maxTopOffset;
      this._maxBottomOffset = e.maxBottomOffset;
    }
  },
  _move(e) {
    const strategy3 = this._getStrategy();
    const moveEventData = eventData(e);
    let offset2 = strategy3.calcOffsetRatio.call(this, e);
    offset2 = this._fitOffset(offset2, this.elastic);
    if (moveEventData.time - this._tickData.time > this.TICK_INTERVAL) {
      this._tickData = moveEventData;
    }
    this._fireEvent("dxswipe", e, {
      offset: offset2
    });
    if (false !== e.cancelable) {
      e.preventDefault();
    }
  },
  _end(e) {
    const strategy3 = this._getStrategy();
    const offsetRatio = strategy3.calcOffsetRatio.call(this, e);
    const isFast = strategy3.isFastSwipe.call(this, e);
    let startOffset = offsetRatio;
    let targetOffset = this._calcTargetOffset(offsetRatio, isFast);
    startOffset = this._fitOffset(startOffset, this.elastic);
    targetOffset = this._fitOffset(targetOffset, false);
    this._fireEvent("dxswipeend", e, {
      offset: startOffset,
      targetOffset
    });
  },
  _fitOffset(offset2, elastic) {
    const strategy3 = this._getStrategy();
    const bounds = strategy3.getBounds.call(this);
    if (offset2 < -bounds[0]) {
      return elastic ? (-2 * bounds[0] + offset2) / 3 : -bounds[0];
    }
    if (offset2 > bounds[1]) {
      return elastic ? (2 * bounds[1] + offset2) / 3 : bounds[1];
    }
    return offset2;
  },
  _calcTargetOffset(offsetRatio, isFast) {
    let result2;
    if (isFast) {
      result2 = Math.ceil(Math.abs(offsetRatio));
      if (offsetRatio < 0) {
        result2 = -result2;
      }
    } else {
      result2 = Math.round(offsetRatio);
    }
    return result2;
  }
});
m_emitter_registrator_default({
  emitter: SwipeEmitter,
  events: ["dxswipestart", "dxswipe", "dxswipeend"]
});

// node_modules/devextreme/esm/__internal/ui/scroll_view/m_scroll_view.native.pull_down.js
var PullDownNativeScrollViewStrategy = class extends m_scrollable_native_default {
  _init(scrollView) {
    super._init(scrollView);
    this._$topPocket = scrollView._$topPocket;
    this._$pullDown = scrollView._$pullDown;
    this._$refreshingText = scrollView._$refreshingText;
    this._$scrollViewContent = renderer_default(scrollView.content());
    this._$container = renderer_default(scrollView.container());
    this._initCallbacks();
  }
  _initCallbacks() {
    this.pullDownCallbacks = callbacks_default();
    this.releaseCallbacks = callbacks_default();
    this.reachBottomCallbacks = callbacks_default();
  }
  render() {
    super.render();
    this._renderPullDown();
    this._releaseState();
  }
  _renderPullDown() {
    const $image = renderer_default("<div>").addClass("dx-scrollview-pull-down-image");
    const $loadContainer = renderer_default("<div>").addClass("dx-scrollview-pull-down-indicator");
    const $loadIndicator = new load_indicator_default(renderer_default("<div>")).$element();
    const $text = this._$pullDownText = renderer_default("<div>").addClass("dx-scrollview-pull-down-text");
    this._$pullingDownText = renderer_default("<div>").text(this.option("pullingDownText")).appendTo($text);
    this._$pulledDownText = renderer_default("<div>").text(this.option("pulledDownText")).appendTo($text);
    this._$refreshingText = renderer_default("<div>").text(this.option("refreshingText")).appendTo($text);
    this._$pullDown.empty().append($image).append($loadContainer.append($loadIndicator)).append($text);
  }
  _releaseState() {
    this._state = 0;
    this._refreshPullDownText();
  }
  _refreshPullDownText() {
    const that = this;
    const pullDownTextItems = [{
      element: this._$pullingDownText,
      visibleState: 0
    }, {
      element: this._$pulledDownText,
      visibleState: 1
    }, {
      element: this._$refreshingText,
      visibleState: 2
    }];
    each(pullDownTextItems, (_, item) => {
      const action = that._state === item.visibleState ? "addClass" : "removeClass";
      item.element[action]("dx-scrollview-pull-down-text-visible");
    });
  }
  update() {
    super.update();
    this._setTopPocketOffset();
  }
  _updateDimensions() {
    super._updateDimensions();
    this._topPocketSize = this._$topPocket.get(0).clientHeight;
    const contentEl = this._$scrollViewContent.get(0);
    const containerEl = this._$container.get(0);
    this._bottomBoundary = Math.max(contentEl.clientHeight - containerEl.clientHeight, 0);
  }
  _allowedDirections() {
    const allowedDirections = super._allowedDirections();
    allowedDirections.vertical = allowedDirections.vertical || this._pullDownEnabled;
    return allowedDirections;
  }
  _setTopPocketOffset() {
    this._$topPocket.css({
      top: -this._topPocketSize
    });
  }
  handleEnd() {
    super.handleEnd();
    this._complete();
  }
  handleStop() {
    super.handleStop();
    this._complete();
  }
  _complete() {
    if (1 === this._state) {
      this._setPullDownOffset(this._topPocketSize);
      clearTimeout(this._pullDownRefreshTimeout);
      this._pullDownRefreshTimeout = setTimeout(() => {
        this._pullDownRefreshing();
      }, 400);
    }
  }
  _setPullDownOffset(offset2) {
    move(this._$topPocket, {
      top: offset2
    });
    move(this._$scrollViewContent, {
      top: offset2
    });
  }
  handleScroll(e) {
    super.handleScroll(e);
    if (2 === this._state) {
      return;
    }
    const currentLocation = this.location().top;
    const scrollDelta = (this._location || 0) - currentLocation;
    this._location = currentLocation;
    if (this._isPullDown()) {
      this._pullDownReady();
    } else if (scrollDelta > 0 && this._isReachBottom()) {
      this._reachBottom();
    } else {
      this._stateReleased();
    }
  }
  _isPullDown() {
    return this._pullDownEnabled && this._location >= this._topPocketSize;
  }
  _isReachBottom() {
    return this._reachBottomEnabled && this.isBottomReached();
  }
  isBottomReached() {
    return Math.round(this._bottomBoundary + Math.floor(this._location)) <= 1;
  }
  _reachBottom() {
    if (3 === this._state) {
      return;
    }
    this._state = 3;
    this.reachBottomCallbacks.fire();
  }
  _pullDownReady() {
    if (1 === this._state) {
      return;
    }
    this._state = 1;
    this._$pullDown.addClass("dx-scrollview-pull-down-ready");
    this._refreshPullDownText();
  }
  _stateReleased() {
    if (0 === this._state) {
      return;
    }
    this._$pullDown.removeClass("dx-scrollview-pull-down-loading").removeClass("dx-scrollview-pull-down-ready");
    this._releaseState();
  }
  _pullDownRefreshing() {
    if (2 === this._state) {
      return;
    }
    this._state = 2;
    this._$pullDown.addClass("dx-scrollview-pull-down-loading").removeClass("dx-scrollview-pull-down-ready");
    this._refreshPullDownText();
    this.pullDownCallbacks.fire();
  }
  pullDownEnable(enabled) {
    if (enabled) {
      this._updateDimensions();
      this._setTopPocketOffset();
    }
    this._pullDownEnabled = enabled;
  }
  reachBottomEnable(enabled) {
    this._reachBottomEnabled = enabled;
  }
  pendingRelease() {
    this._state = 1;
  }
  release() {
    const deferred = Deferred();
    this._updateDimensions();
    clearTimeout(this._releaseTimeout);
    if (3 === this._state) {
      this._state = 0;
    }
    this._releaseTimeout = setTimeout(() => {
      this._setPullDownOffset(0);
      this._stateReleased();
      this.releaseCallbacks.fire();
      this._updateAction();
      deferred.resolve();
    }, 400);
    return deferred.promise();
  }
  dispose() {
    clearTimeout(this._pullDownRefreshTimeout);
    clearTimeout(this._releaseTimeout);
    super.dispose();
  }
};
var m_scroll_view_native_pull_down_default = PullDownNativeScrollViewStrategy;

// node_modules/devextreme/esm/__internal/ui/scroll_view/m_scroll_view.native.swipe_down.js
var SwipeDownNativeScrollViewStrategy = class extends m_scrollable_native_default {
  _init(scrollView) {
    super._init(scrollView);
    this._$topPocket = scrollView._$topPocket;
    this._$pullDown = scrollView._$pullDown;
    this._$scrollViewContent = renderer_default(scrollView.content());
    this._$container = renderer_default(scrollView.container());
    this._initCallbacks();
    this._location = 0;
  }
  _initCallbacks() {
    this.pullDownCallbacks = callbacks_default();
    this.releaseCallbacks = callbacks_default();
    this.reachBottomCallbacks = callbacks_default();
  }
  render() {
    super.render();
    this._renderPullDown();
    this._releaseState();
  }
  _renderPullDown() {
    const $loadContainer = renderer_default("<div>").addClass("dx-scrollview-pull-down-indicator");
    const $loadIndicator = new load_indicator_default(renderer_default("<div>")).$element();
    this._$icon = renderer_default("<div>").addClass("dx-icon-pulldown");
    this._$pullDown.empty().append(this._$icon).append($loadContainer.append($loadIndicator));
  }
  _releaseState() {
    this._state = 0;
    this._releasePullDown();
    this._updateDimensions();
  }
  _releasePullDown() {
    this._$pullDown.css({
      opacity: 0
    });
  }
  _updateDimensions() {
    super._updateDimensions();
    this._topPocketSize = this._$topPocket.get(0).clientHeight;
    const contentEl = this._$scrollViewContent.get(0);
    const containerEl = this._$container.get(0);
    this._bottomBoundary = Math.max(contentEl.clientHeight - containerEl.clientHeight, 0);
  }
  _allowedDirections() {
    const allowedDirections = super._allowedDirections();
    allowedDirections.vertical = allowedDirections.vertical || this._pullDownEnabled;
    return allowedDirections;
  }
  handleInit(e) {
    super.handleInit(e);
    if (0 === this._state && 0 === this._location) {
      this._startClientY = eventData(e.originalEvent).y;
      this._state = 4;
    }
  }
  handleMove(e) {
    super.handleMove(e);
    this._deltaY = eventData(e.originalEvent).y - this._startClientY;
    if (4 === this._state) {
      if (this._pullDownEnabled && this._deltaY > 0) {
        this._state = 5;
      } else {
        this._complete();
      }
    }
    if (5 === this._state) {
      e.preventDefault();
      this._movePullDown();
    }
  }
  _movePullDown() {
    const pullDownHeight = this._getPullDownHeight();
    const top = Math.min(3 * pullDownHeight, this._deltaY + this._getPullDownStartPosition());
    const angle = 180 * top / pullDownHeight / 3;
    this._$pullDown.css({
      opacity: 1
    }).toggleClass("dx-scrollview-pull-down-refreshing", top < pullDownHeight);
    move(this._$pullDown, {
      top
    });
    this._$icon.css({
      transform: `rotate(${angle}deg)`
    });
  }
  _isPullDown() {
    return this._pullDownEnabled && 5 === this._state && this._deltaY >= this._getPullDownHeight() - this._getPullDownStartPosition();
  }
  _getPullDownHeight() {
    return Math.round(0.05 * getOuterHeight(this._$element));
  }
  _getPullDownStartPosition() {
    return -Math.round(1.5 * getOuterHeight(this._$pullDown));
  }
  handleEnd() {
    if (this._isPullDown()) {
      this._pullDownRefreshing();
    }
    this._complete();
  }
  handleStop() {
    this._complete();
  }
  _complete() {
    if (4 === this._state || 5 === this._state) {
      this._releaseState();
    }
  }
  handleScroll(e) {
    super.handleScroll(e);
    if (2 === this._state) {
      return;
    }
    const currentLocation = this.location().top;
    const scrollDelta = this._location - currentLocation;
    this._location = currentLocation;
    if (scrollDelta > 0 && this._isReachBottom()) {
      this._reachBottom();
    } else {
      this._stateReleased();
    }
  }
  _isReachBottom() {
    return this._reachBottomEnabled && this.isBottomReached();
  }
  isBottomReached() {
    return Math.round(this._bottomBoundary + Math.floor(this._location)) <= 1;
  }
  _reachBottom() {
    this.reachBottomCallbacks.fire();
  }
  _stateReleased() {
    if (0 === this._state) {
      return;
    }
    this._$pullDown.removeClass("dx-scrollview-pull-down-loading");
    this._releaseState();
  }
  _pullDownRefreshing() {
    this._state = 2;
    this._pullDownRefreshHandler();
  }
  _pullDownRefreshHandler() {
    this._refreshPullDown();
    this.pullDownCallbacks.fire();
  }
  _refreshPullDown() {
    this._$pullDown.addClass("dx-scrollview-pull-down-loading");
    move(this._$pullDown, {
      top: this._getPullDownHeight()
    });
  }
  pullDownEnable(enabled) {
    this._$topPocket.toggle(enabled);
    this._pullDownEnabled = enabled;
  }
  reachBottomEnable(enabled) {
    this._reachBottomEnabled = enabled;
  }
  pendingRelease() {
    this._state = 1;
  }
  release() {
    const deferred = Deferred();
    this._updateDimensions();
    clearTimeout(this._releaseTimeout);
    this._releaseTimeout = setTimeout(() => {
      this._stateReleased();
      this.releaseCallbacks.fire();
      this._updateAction();
      deferred.resolve();
    }, 800);
    return deferred.promise();
  }
  dispose() {
    clearTimeout(this._pullDownRefreshTimeout);
    clearTimeout(this._releaseTimeout);
    super.dispose();
  }
};
var m_scroll_view_native_swipe_down_default = SwipeDownNativeScrollViewStrategy;

// node_modules/devextreme/esm/__internal/ui/scroll_view/m_scroll_view.simulated.js
var ScrollViewScroller = class extends Scroller {
  ctor() {
    this._topPocketSize = 0;
    this._bottomPocketSize = 0;
    super.ctor.apply(this, arguments);
    this._initCallbacks();
    this._releaseState();
  }
  _releaseState() {
    this._state = 0;
    this._refreshPullDownText();
  }
  _refreshPullDownText() {
    const that = this;
    const pullDownTextItems = [{
      element: this._$pullingDownText,
      visibleState: 0
    }, {
      element: this._$pulledDownText,
      visibleState: 1
    }, {
      element: this._$refreshingText,
      visibleState: 2
    }];
    each(pullDownTextItems, (_, item) => {
      const action = that._state === item.visibleState ? "addClass" : "removeClass";
      item.element[action]("dx-scrollview-pull-down-text-visible");
    });
  }
  _initCallbacks() {
    this.pullDownCallbacks = callbacks_default();
    this.releaseCallbacks = callbacks_default();
    this.reachBottomCallbacks = callbacks_default();
  }
  _updateBounds() {
    const considerPockets = "horizontal" !== this._direction;
    if (considerPockets) {
      this._topPocketSize = this._$topPocket.get(0).clientHeight;
      this._bottomPocketSize = this._$bottomPocket.get(0).clientHeight;
      const containerEl = this._$container.get(0);
      const contentEl = this._$content.get(0);
      this._bottomBoundary = Math.max(contentEl.clientHeight - this._bottomPocketSize - containerEl.clientHeight, 0);
    }
    super._updateBounds();
  }
  _updateScrollbar() {
    this._scrollbar.option({
      containerSize: this._containerSize(),
      contentSize: this._contentSize() - this._topPocketSize - this._bottomPocketSize,
      scaleRatio: this._getScaleRatio()
    });
  }
  _moveContent() {
    super._moveContent();
    if (this._isPullDown()) {
      this._pullDownReady();
    } else if (this._isReachBottom()) {
      this._reachBottomReady();
    } else if (0 !== this._state) {
      this._stateReleased();
    }
  }
  _moveScrollbar() {
    this._scrollbar.moveTo(this._topPocketSize + this._location);
  }
  _isPullDown() {
    return this._pullDownEnabled && this._location >= 0;
  }
  _isReachBottom() {
    return this._reachBottomEnabled && this.isBottomReached();
  }
  isBottomReached() {
    const containerEl = this._$container.get(0);
    return Math.round(this._bottomBoundary - Math.ceil(containerEl.scrollTop)) <= 1;
  }
  _scrollComplete() {
    if (this._inBounds() && 1 === this._state) {
      this._pullDownRefreshing();
    } else if (this._inBounds() && 3 === this._state) {
      this._reachBottomLoading();
    } else {
      super._scrollComplete();
    }
  }
  _reachBottomReady() {
    if (3 === this._state) {
      return;
    }
    this._state = 3;
    this._minOffset = this._getMinOffset();
  }
  _getMaxOffset() {
    return -this._topPocketSize;
  }
  _getMinOffset() {
    return Math.min(super._getMinOffset(), -this._topPocketSize);
  }
  _reachBottomLoading() {
    this.reachBottomCallbacks.fire();
  }
  _pullDownReady() {
    if (1 === this._state) {
      return;
    }
    this._state = 1;
    this._maxOffset = 0;
    this._$pullDown.addClass("dx-scrollview-pull-down-ready");
    this._refreshPullDownText();
  }
  _stateReleased() {
    if (0 === this._state) {
      return;
    }
    this._releaseState();
    this._updateBounds();
    this._$pullDown.removeClass("dx-scrollview-pull-down-loading").removeClass("dx-scrollview-pull-down-ready");
    this.releaseCallbacks.fire();
  }
  _pullDownRefreshing() {
    if (2 === this._state) {
      return;
    }
    this._state = 2;
    this._$pullDown.addClass("dx-scrollview-pull-down-loading").removeClass("dx-scrollview-pull-down-ready");
    this._refreshPullDownText();
    this.pullDownCallbacks.fire();
  }
  _releaseHandler() {
    var _this$_releaseTask;
    if (0 === this._state) {
      this._moveToBounds();
    }
    this._update();
    if (this._releaseTask) {
      this._releaseTask.abort();
    }
    this._releaseTask = executeAsync(this._release.bind(this));
    return null === (_this$_releaseTask = this._releaseTask) || void 0 === _this$_releaseTask ? void 0 : _this$_releaseTask.promise;
  }
  _release() {
    this._stateReleased();
    this._scrollComplete();
  }
  _reachBottomEnablingHandler(enabled) {
    if (this._reachBottomEnabled === enabled) {
      return;
    }
    this._reachBottomEnabled = enabled;
    this._updateBounds();
  }
  _pullDownEnablingHandler(enabled) {
    if (this._pullDownEnabled === enabled) {
      return;
    }
    this._pullDownEnabled = enabled;
    this._considerTopPocketChange();
    this._updateHandler();
  }
  _considerTopPocketChange() {
    this._location -= getHeight(this._$topPocket) || -this._topPocketSize;
    this._maxOffset = 0;
    this._move();
  }
  _pendingReleaseHandler() {
    this._state = 1;
  }
  dispose() {
    if (this._releaseTask) {
      this._releaseTask.abort();
    }
    super.dispose();
  }
};
var SimulatedScrollViewStrategy = class extends SimulatedStrategy {
  _init(scrollView) {
    super._init(scrollView);
    this._$pullDown = scrollView._$pullDown;
    this._$topPocket = scrollView._$topPocket;
    this._$bottomPocket = scrollView._$bottomPocket;
    this._initCallbacks();
  }
  _initCallbacks() {
    this.pullDownCallbacks = callbacks_default();
    this.releaseCallbacks = callbacks_default();
    this.reachBottomCallbacks = callbacks_default();
  }
  render() {
    this._renderPullDown();
    super.render();
  }
  _renderPullDown() {
    const $image = renderer_default("<div>").addClass("dx-scrollview-pull-down-image");
    const $loadContainer = renderer_default("<div>").addClass("dx-scrollview-pull-down-indicator");
    const $loadIndicator = new load_indicator_default(renderer_default("<div>")).$element();
    const $text = this._$pullDownText = renderer_default("<div>").addClass("dx-scrollview-pull-down-text");
    this._$pullingDownText = renderer_default("<div>").text(this.option("pullingDownText")).appendTo($text);
    this._$pulledDownText = renderer_default("<div>").text(this.option("pulledDownText")).appendTo($text);
    this._$refreshingText = renderer_default("<div>").text(this.option("refreshingText")).appendTo($text);
    this._$pullDown.empty().append($image).append($loadContainer.append($loadIndicator)).append($text);
  }
  pullDownEnable(enabled) {
    this._eventHandler("pullDownEnabling", enabled);
  }
  reachBottomEnable(enabled) {
    this._eventHandler("reachBottomEnabling", enabled);
  }
  _createScroller(direction) {
    const that = this;
    const scroller = that._scrollers[direction] = new ScrollViewScroller(that._scrollerOptions(direction));
    scroller.pullDownCallbacks.add(() => {
      that.pullDownCallbacks.fire();
    });
    scroller.releaseCallbacks.add(() => {
      that.releaseCallbacks.fire();
    });
    scroller.reachBottomCallbacks.add(() => {
      that.reachBottomCallbacks.fire();
    });
  }
  _scrollerOptions(direction) {
    return _extends({}, super._scrollerOptions(direction), {
      $topPocket: this._$topPocket,
      $bottomPocket: this._$bottomPocket,
      $pullDown: this._$pullDown,
      $pullDownText: this._$pullDownText,
      $pullingDownText: this._$pullingDownText,
      $pulledDownText: this._$pulledDownText,
      $refreshingText: this._$refreshingText
    });
  }
  pendingRelease() {
    this._eventHandler("pendingRelease");
  }
  release() {
    return this._eventHandler("release").done(this._updateAction);
  }
  location() {
    const location = super.location();
    location.top += getHeight(this._$topPocket);
    return location;
  }
  isBottomReached() {
    return this._scrollers.vertical.isBottomReached();
  }
  dispose() {
    each(this._scrollers, function() {
      this.dispose();
    });
    super.dispose();
  }
};
var m_scroll_view_simulated_default = SimulatedScrollViewStrategy;

// node_modules/devextreme/esm/__internal/ui/scroll_view/m_scroll_view.js
var SCROLLVIEW_LOADPANEL = "dx-scrollview-loadpanel";
var refreshStrategies = {
  pullDown: m_scroll_view_native_pull_down_default,
  swipeDown: m_scroll_view_native_swipe_down_default,
  simulated: m_scroll_view_simulated_default
};
var isServerSide = !hasWindow();
var ScrollViewServerSide = class extends m_scrollable_default {
  finishLoading() {
  }
  release() {
  }
  refresh() {
  }
  scrollOffset() {
    return {
      top: 0,
      left: 0
    };
  }
  isBottomReached() {
    return false;
  }
  _optionChanged(args) {
    const {
      name: name2
    } = args;
    if ("onUpdated" !== name2) {
      return super._optionChanged.apply(this, arguments);
    }
  }
};
var ScrollView = class extends m_scrollable_default {
  _getDefaultOptions() {
    return _extends({}, super._getDefaultOptions(), {
      pullingDownText: message_default.format("dxScrollView-pullingDownText"),
      pulledDownText: message_default.format("dxScrollView-pulledDownText"),
      refreshingText: message_default.format("dxScrollView-refreshingText"),
      reachBottomText: message_default.format("dxScrollView-reachBottomText"),
      onPullDown: null,
      onReachBottom: null,
      refreshStrategy: "pullDown"
    });
  }
  _defaultOptionsRules() {
    return super._defaultOptionsRules().concat([{
      device() {
        const realDevice2 = devices_default.real();
        return "android" === realDevice2.platform;
      },
      options: {
        refreshStrategy: "swipeDown"
      }
    }, {
      device: () => isMaterialBased(),
      options: {
        pullingDownText: "",
        pulledDownText: "",
        refreshingText: "",
        reachBottomText: ""
      }
    }]);
  }
  _init() {
    super._init();
    this._loadingIndicatorEnabled = true;
  }
  _initScrollableMarkup() {
    super._initScrollableMarkup();
    this.$element().addClass("dx-scrollview");
    this._initContent();
    this._initTopPocket();
    this._initBottomPocket();
    this._initLoadPanel();
  }
  _initContent() {
    const $content = renderer_default("<div>").addClass("dx-scrollview-content");
    this._$content.wrapInner($content);
  }
  _initTopPocket() {
    this._$topPocket = renderer_default("<div>").addClass("dx-scrollview-top-pocket");
    this._$pullDown = renderer_default("<div>").addClass("dx-scrollview-pull-down");
    this._$topPocket.append(this._$pullDown);
    this._$content.prepend(this._$topPocket);
  }
  _initBottomPocket() {
    this._$bottomPocket = renderer_default("<div>").addClass("dx-scrollview-bottom-pocket");
    this._$reachBottom = renderer_default("<div>").addClass("dx-scrollview-scrollbottom");
    const $loadContainer = renderer_default("<div>").addClass("dx-scrollview-scrollbottom-indicator");
    const $loadIndicator = new load_indicator_default(renderer_default("<div>")).$element();
    this._$reachBottomText = renderer_default("<div>").addClass("dx-scrollview-scrollbottom-text");
    this._updateReachBottomText();
    this._$reachBottom.append($loadContainer.append($loadIndicator)).append(this._$reachBottomText);
    this._$bottomPocket.append(this._$reachBottom);
    this._$content.append(this._$bottomPocket);
  }
  _initLoadPanel() {
    const $loadPanelElement = renderer_default("<div>").addClass(SCROLLVIEW_LOADPANEL).appendTo(this.$element());
    const {
      refreshingText
    } = this.option();
    this._loadPanel = this._createComponent($loadPanelElement, m_load_panel_default, {
      shading: false,
      delay: 400,
      message: refreshingText,
      position: {
        of: this.$element()
      }
    });
  }
  _updateReachBottomText() {
    const {
      reachBottomText
    } = this.option();
    this._$reachBottomText.text(reachBottomText);
  }
  _createStrategy() {
    const {
      useNative,
      refreshStrategy
    } = this.option();
    const strategyName = useNative ? refreshStrategy : "simulated";
    const strategyClass = refreshStrategies[strategyName];
    this._strategy = new strategyClass(this);
    this._strategy.pullDownCallbacks.add(this._pullDownHandler.bind(this));
    this._strategy.releaseCallbacks.add(this._releaseHandler.bind(this));
    this._strategy.reachBottomCallbacks.add(this._reachBottomHandler.bind(this));
  }
  _createActions() {
    super._createActions();
    this._pullDownAction = this._createActionByOption("onPullDown");
    this._reachBottomAction = this._createActionByOption("onReachBottom");
    this._tryRefreshPocketState();
  }
  _tryRefreshPocketState() {
    this._pullDownEnable(this.hasActionSubscription("onPullDown"));
    this._reachBottomEnable(this.hasActionSubscription("onReachBottom"));
  }
  on(eventName) {
    const result2 = super.on.apply(this, arguments);
    if ("pullDown" === eventName || "reachBottom" === eventName) {
      this._tryRefreshPocketState();
    }
    return result2;
  }
  _pullDownEnable(enabled) {
    if (0 === arguments.length) {
      return this._pullDownEnabled;
    }
    if (this._$pullDown && this._strategy) {
      this._$pullDown.toggle(enabled);
      this._strategy.pullDownEnable(enabled);
      this._pullDownEnabled = enabled;
    }
  }
  _reachBottomEnable(enabled) {
    if (0 === arguments.length) {
      return this._reachBottomEnabled;
    }
    if (this._$reachBottom && this._strategy) {
      this._$reachBottom.toggle(enabled);
      this._strategy.reachBottomEnable(enabled);
      this._reachBottomEnabled = enabled;
    }
  }
  _pullDownHandler() {
    this._loadingIndicator(false);
    this._pullDownLoading();
  }
  _loadingIndicator(value2) {
    if (arguments.length < 1) {
      return this._loadingIndicatorEnabled;
    }
    this._loadingIndicatorEnabled = value2;
  }
  _pullDownLoading() {
    var _this$_pullDownAction;
    this.startLoading();
    null === (_this$_pullDownAction = this._pullDownAction) || void 0 === _this$_pullDownAction || _this$_pullDownAction.call(this);
  }
  _reachBottomHandler() {
    this._loadingIndicator(false);
    this._reachBottomLoading();
  }
  _reachBottomLoading() {
    var _this$_reachBottomAct;
    this.startLoading();
    null === (_this$_reachBottomAct = this._reachBottomAction) || void 0 === _this$_reachBottomAct || _this$_reachBottomAct.call(this);
  }
  _releaseHandler() {
    this.finishLoading();
    this._loadingIndicator(true);
  }
  _optionChanged(args) {
    switch (args.name) {
      case "onPullDown":
      case "onReachBottom":
        this._createActions();
        break;
      case "pullingDownText":
      case "pulledDownText":
      case "refreshingText":
      case "refreshStrategy":
        this._invalidate();
        break;
      case "reachBottomText":
        this._updateReachBottomText();
        break;
      default:
        super._optionChanged(args);
    }
  }
  content() {
    return getPublicElement(this._$content.children().eq(1));
  }
  release(preventReachBottom) {
    if (void 0 !== preventReachBottom) {
      this.toggleLoading(!preventReachBottom);
    }
    return this._strategy.release();
  }
  toggleLoading(showOrHide) {
    this._reachBottomEnable(showOrHide);
  }
  refresh() {
    if (!this.hasActionSubscription("onPullDown")) {
      return;
    }
    this._strategy.pendingRelease();
    this._pullDownLoading();
  }
  startLoading() {
    if (this._loadingIndicator() && this.$element().is(":visible")) {
      this._loadPanel.show();
    }
    this._lock();
  }
  finishLoading() {
    this._loadPanel.hide();
    this._unlock();
  }
  isBottomReached() {
    return this._strategy.isBottomReached();
  }
  _dispose() {
    this._strategy.dispose();
    super._dispose();
    if (this._loadPanel) {
      this._loadPanel.$element().remove();
    }
  }
};
component_registrator_default("dxScrollView", isServerSide ? ScrollViewServerSide : ScrollView);
var m_scroll_view_default = isServerSide ? ScrollViewServerSide : ScrollView;

// node_modules/devextreme/esm/ui/scroll_view.js
var scroll_view_default = m_scroll_view_default;

// node_modules/devextreme/esm/__internal/ui/collection/m_collection_widget.live_update.js
var PRIVATE_KEY_FIELD = "__dx_key__";
var CollectionWidgetLiveUpdate = class extends m_collection_widget_async_default {
  _getDefaultOptions() {
    return _extends({}, super._getDefaultOptions(), {
      repaintChangesOnly: false
    });
  }
  _customizeStoreLoadOptions(e) {
    const dataController2 = this._dataController;
    if (dataController2.getDataSource() && !this._dataController.isLoaded()) {
      this._correctionIndex = 0;
    }
    if (this._correctionIndex && e.storeLoadOptions) {
      e.storeLoadOptions.skip += this._correctionIndex;
    }
  }
  reload() {
    this._correctionIndex = 0;
  }
  _init() {
    super._init();
    this._refreshItemsCache();
    this._correctionIndex = 0;
    this._subscribeLoadOptionsCustomization(true);
  }
  _findItemElementByKey(key) {
    let result2 = renderer_default();
    const keyExpr = this.key();
    this.itemElements().each((_, item) => {
      const $item = renderer_default(item);
      const itemData = this._getItemData($item);
      if (keyExpr ? keysEqual(keyExpr, this.keyOf(itemData), key) : this._isItemEquals(itemData, key)) {
        result2 = $item;
        return false;
      }
    });
    return result2;
  }
  _dataSourceChangedHandler(newItems, e) {
    if (null !== e && void 0 !== e && e.changes) {
      this._modifyByChanges(e.changes);
    } else {
      super._dataSourceChangedHandler(newItems, e);
      this._refreshItemsCache();
    }
  }
  _isItemEquals(item1, item2) {
    if (item1 && item1.__dx_key__) {
      item1 = item1.data;
    }
    try {
      return JSON.stringify(item1) === JSON.stringify(item2);
    } catch (e) {
      return item1 === item2;
    }
  }
  _isItemStrictEquals(item1, item2) {
    return this._isItemEquals(item1, item2);
  }
  _shouldAddNewGroup(changes, items) {
    let result2 = false;
    if (this.option("grouped")) {
      if (!changes.length) {
        result2 = true;
      }
      each(changes, (i, change) => {
        if ("insert" === change.type) {
          result2 = true;
          each(items, (_, item) => {
            if (void 0 !== change.data.key && change.data.key === item.key) {
              result2 = false;
              return false;
            }
          });
        }
      });
    }
    return result2;
  }
  _partialRefresh() {
    if (this.option("repaintChangesOnly")) {
      const keyOf = (data17) => {
        if (data17 && void 0 !== data17.__dx_key__) {
          return data17.__dx_key__;
        }
        return this.keyOf(data17);
      };
      const result2 = findChanges(this._itemsCache, this._editStrategy.itemsGetter(), keyOf, this._isItemStrictEquals.bind(this));
      if (result2 && this._itemsCache.length && !this._shouldAddNewGroup(result2, this._itemsCache)) {
        this._modifyByChanges(result2, true);
        this._renderEmptyMessage();
        return true;
      }
      this._refreshItemsCache();
    }
    return false;
  }
  _refreshItemsCache() {
    if (this.option("repaintChangesOnly")) {
      const items = this._editStrategy.itemsGetter();
      try {
        this._itemsCache = extend(true, [], items);
        if (!this.key()) {
          this._itemsCache = this._itemsCache.map((itemCache, index2) => ({
            [PRIVATE_KEY_FIELD]: items[index2],
            data: itemCache
          }));
        }
      } catch (e) {
        this._itemsCache = extend([], items);
      }
    }
  }
  _dispose() {
    this._subscribeLoadOptionsCustomization(false);
    super._dispose();
  }
  _updateByChange(keyInfo, items, change, isPartialRefresh) {
    if (isPartialRefresh) {
      this._renderItem(change.index, change.data, null, this._findItemElementByKey(change.key));
    } else {
      const changedItem = items[indexByKey(keyInfo, items, change.key)];
      if (changedItem) {
        update(keyInfo, items, change.key, change.data).done(() => {
          this._renderItem(items.indexOf(changedItem), changedItem, null, this._findItemElementByKey(change.key));
        });
      }
    }
  }
  _insertByChange(keyInfo, items, change, isPartialRefresh) {
    when(isPartialRefresh || insert(keyInfo, items, change.data, change.index)).done(() => {
      this._beforeItemElementInserted(change);
      this._renderItem(change.index ?? items.length, change.data);
      this._afterItemElementInserted();
      this._correctionIndex++;
    });
  }
  _updateSelectionAfterRemoveByChange(removeIndex) {
    const {
      selectedIndex,
      selectedItems
    } = this.option();
    if (selectedIndex > removeIndex) {
      this.option("selectedIndex", selectedIndex - 1);
    } else if (selectedIndex === removeIndex && 1 === selectedItems.length) {
      this.option("selectedItems", []);
    } else {
      this._normalizeSelectedItems();
    }
  }
  _beforeItemElementInserted(change) {
    const {
      selectedIndex
    } = this.option();
    if (change.index <= selectedIndex) {
      this.option("selectedIndex", selectedIndex + 1);
    }
  }
  _afterItemElementInserted() {
    this._renderEmptyMessage();
  }
  _removeByChange(keyInfo, items, change, isPartialRefresh) {
    const index2 = isPartialRefresh ? change.index : indexByKey(keyInfo, items, change.key);
    const removedItem = isPartialRefresh ? change.oldItem : items[index2];
    if (removedItem) {
      const $removedItemElement = this._findItemElementByKey(change.key);
      const deletedActionArgs = this._extendActionArgs($removedItemElement);
      this._waitDeletingPrepare($removedItemElement).done(() => {
        if (isPartialRefresh) {
          this._updateIndicesAfterIndex(index2 - 1);
          this._afterItemElementDeleted($removedItemElement, deletedActionArgs);
          this._updateSelectionAfterRemoveByChange(index2);
        } else {
          this._deleteItemElementByIndex(index2);
          this._afterItemElementDeleted($removedItemElement, deletedActionArgs);
        }
      });
      this._correctionIndex--;
    }
  }
  _modifyByChanges(changes, isPartialRefresh) {
    const items = this._editStrategy.itemsGetter();
    const keyInfo = {
      key: this.key.bind(this),
      keyOf: this.keyOf.bind(this)
    };
    const dataController2 = this._dataController;
    const paginate = dataController2.paginate();
    const group = dataController2.group();
    if (paginate || group) {
      changes = changes.filter((item) => "insert" !== item.type || void 0 !== item.index);
    }
    changes.forEach((change) => this[`_${change.type}ByChange`](keyInfo, items, change, isPartialRefresh));
    this._renderedItemsCount = items.length;
    this._refreshItemsCache();
    this._fireContentReadyAction();
  }
  _appendItemToContainer($container, $itemFrame, index2) {
    const nextSiblingElement = $container.children(this._itemSelector()).get(index2);
    dom_adapter_default.insertElement($container.get(0), $itemFrame.get(0), nextSiblingElement);
  }
  _subscribeLoadOptionsCustomization(enable) {
    if (!this._dataController) {
      return;
    }
    if (enable) {
      this._correctionIndex = 0;
      this._dataController.on("customizeStoreLoadOptions", this._customizeStoreLoadOptions.bind(this));
    } else {
      this._dataController.off("customizeStoreLoadOptions", this._customizeStoreLoadOptions.bind(this));
    }
  }
  _optionChanged(args) {
    switch (args.name) {
      case "items": {
        const isItemsUpdated = this._partialRefresh(args.value);
        if (!isItemsUpdated) {
          super._optionChanged(args);
        }
        break;
      }
      case "dataSource":
        if (!this.option("repaintChangesOnly") || !args.value) {
          this.option("items", []);
        }
        this._subscribeLoadOptionsCustomization(false);
        super._optionChanged(args);
        this._subscribeLoadOptionsCustomization(true);
        break;
      case "repaintChangesOnly":
        break;
      default:
        super._optionChanged(args);
    }
  }
};
var m_collection_widget_live_update_default = CollectionWidgetLiveUpdate;

// node_modules/devextreme/esm/__internal/utils/type_conversion.js
function toNumber(attribute) {
  return attribute ? Number(attribute.replace("px", "")) : 0;
}

// node_modules/devextreme/esm/__internal/ui/scroll_view/utils/get_element_style.js
function getElementStyle(el) {
  var _getWindow$getCompute, _getWindow;
  return el && hasWindow() ? null === (_getWindow$getCompute = (_getWindow = getWindow()).getComputedStyle) || void 0 === _getWindow$getCompute ? void 0 : _getWindow$getCompute.call(_getWindow, el) : null;
}
function getElementMargin(element, side) {
  const style = getElementStyle(element);
  return style ? toNumber(style[`margin${titleize(side)}`]) : 0;
}

// node_modules/devextreme/esm/__internal/ui/shared/m_grouped_data_converter_mixin.js
var isCorrectStructure = (data17) => Array.isArray(data17) && data17.every((item) => {
  const hasTwoFields = 2 === Object.keys(item).length;
  const hasCorrectFields = "key" in item && "items" in item;
  return hasTwoFields && hasCorrectFields && Array.isArray(item.items);
});
var m_grouped_data_converter_mixin_default = {
  _getSpecificDataSourceOption() {
    let dataSource = this.option("dataSource");
    let hasSimpleItems = false;
    let data17 = {};
    if (this._getGroupedOption() && isCorrectStructure(dataSource)) {
      data17 = dataSource.reduce((accumulator, item) => {
        const items = item.items.map((innerItem) => {
          if (!isObject(innerItem)) {
            innerItem = {
              text: innerItem
            };
            hasSimpleItems = true;
          }
          if (!("key" in innerItem)) {
            innerItem.key = item.key;
          }
          return innerItem;
        });
        return accumulator.concat(items);
      }, []);
      dataSource = {
        store: {
          type: "array",
          data: data17
        },
        group: {
          selector: "key",
          keepInitialKeyOrder: true
        }
      };
      if (hasSimpleItems) {
        dataSource.searchExpr = "text";
      }
    }
    return dataSource;
  }
};

// node_modules/devextreme/esm/__internal/ui/list/m_item.js
var ListItem = class extends item_default {
  _renderWatchers() {
    super._renderWatchers();
    this._startWatcher("badge", this._renderBadge.bind(this));
    this._startWatcher("showChevron", this._renderShowChevron.bind(this));
  }
  _renderBadge(badge) {
    this._$element.children(".dx-list-item-badge-container").remove();
    if (!badge) {
      return;
    }
    const $badge = renderer_default("<div>").addClass("dx-list-item-badge-container").append(renderer_default("<div>").addClass("dx-list-item-badge").addClass("dx-badge").text(badge));
    const $chevron = this._$element.children(".dx-list-item-chevron-container").first();
    $chevron.length > 0 ? $badge.insertBefore($chevron) : $badge.appendTo(this._$element);
  }
  _renderShowChevron(showChevron) {
    this._$element.children(".dx-list-item-chevron-container").remove();
    if (!showChevron) {
      return;
    }
    const $chevronContainer = renderer_default("<div>").addClass("dx-list-item-chevron-container");
    const $chevron = renderer_default("<div>").addClass("dx-list-item-chevron");
    $chevronContainer.append($chevron).appendTo(this._$element);
  }
};
var m_item_default = ListItem;

// node_modules/devextreme/esm/__internal/ui/list/m_list.base.js
var LIST_SELECT_CHECKBOX = "dx-list-select-checkbox";
var LIST_SELECT_RADIOBUTTON = "dx-list-select-radiobutton";
var groupItemsGetter = compileGetter("items");
var _scrollView;
var ListBase = class extends m_collection_widget_live_update_default {
  _supportedKeys() {
    const that = this;
    const moveFocusPerPage = function(direction) {
      let $item = getEdgeVisibleItem(direction);
      const {
        focusedElement
      } = that.option();
      const isFocusedItem = $item.is(focusedElement);
      if (isFocusedItem) {
        !function($item2, direction2) {
          let resultPosition = $item2.position().top;
          if ("prev" === direction2) {
            resultPosition = $item2.position().top - getHeight(that.$element()) + getOuterHeight($item2);
          }
          that.scrollTo(resultPosition);
        }($item, direction);
        $item = getEdgeVisibleItem(direction);
      }
      that.option("focusedElement", getPublicElement($item));
      that.scrollToItem($item);
    };
    function getEdgeVisibleItem(direction) {
      const scrollTop = that.scrollTop();
      const containerHeight = getHeight(that.$element());
      const {
        focusedElement
      } = that.option();
      let $item = renderer_default(focusedElement);
      let isItemVisible = true;
      if (!$item.length) {
        return renderer_default();
      }
      while (isItemVisible) {
        const $nextItem = $item[direction]();
        if (!$nextItem.length) {
          break;
        }
        const nextItemLocation = $nextItem.position().top + getOuterHeight($nextItem) / 2;
        isItemVisible = nextItemLocation < containerHeight + scrollTop && nextItemLocation > scrollTop;
        if (isItemVisible) {
          $item = $nextItem;
        }
      }
      return $item;
    }
    return _extends({}, super._supportedKeys(), {
      leftArrow: noop2,
      rightArrow: noop2,
      pageUp() {
        moveFocusPerPage("prev");
        return false;
      },
      pageDown() {
        moveFocusPerPage("next");
        return false;
      }
    });
  }
  _getDefaultOptions() {
    return _extends({}, super._getDefaultOptions(), {
      hoverStateEnabled: true,
      pullRefreshEnabled: false,
      scrollingEnabled: true,
      selectByClick: true,
      showScrollbar: "onScroll",
      useNativeScrolling: true,
      bounceEnabled: true,
      scrollByContent: true,
      scrollByThumb: false,
      pullingDownText: message_default.format("dxList-pullingDownText"),
      pulledDownText: message_default.format("dxList-pulledDownText"),
      refreshingText: message_default.format("dxList-refreshingText"),
      pageLoadingText: message_default.format("dxList-pageLoadingText"),
      onScroll: null,
      onPullRefresh: null,
      onPageLoading: null,
      pageLoadMode: "scrollBottom",
      nextButtonText: message_default.format("dxList-nextButtonText"),
      onItemSwipe: null,
      grouped: false,
      onGroupRendered: null,
      collapsibleGroups: false,
      groupTemplate: "group",
      indicateLoading: true,
      activeStateEnabled: true,
      _itemAttributes: {
        role: "option"
      },
      useInkRipple: false,
      wrapItemText: false,
      _swipeEnabled: true,
      showChevronExpr: (data17) => null === data17 || void 0 === data17 ? void 0 : data17.showChevron,
      badgeExpr: (data17) => null === data17 || void 0 === data17 ? void 0 : data17.badge,
      _onItemsRendered: () => {
      }
    });
  }
  _defaultOptionsRules() {
    const themeName = current();
    return super._defaultOptionsRules().concat(deviceDependentOptions(), [{
      device: () => !m_support_default.nativeScrolling,
      options: {
        useNativeScrolling: false
      }
    }, {
      device: (device) => !m_support_default.nativeScrolling && !devices_default.isSimulator() && "desktop" === devices_default.real().deviceType && "generic" === device.platform,
      options: {
        showScrollbar: "onHover",
        pageLoadMode: "nextButton"
      }
    }, {
      device: () => "desktop" === devices_default.real().deviceType && !devices_default.isSimulator(),
      options: {
        focusStateEnabled: true
      }
    }, {
      device: () => isMaterial(themeName),
      options: {
        useInkRipple: true
      }
    }, {
      device: () => isMaterialBased(themeName),
      options: {
        pullingDownText: "",
        pulledDownText: "",
        refreshingText: "",
        pageLoadingText: ""
      }
    }]);
  }
  _visibilityChanged(visible2) {
    if (visible2) {
      this._updateLoadingState(true);
    }
  }
  _itemClass() {
    return "dx-list-item";
  }
  _itemDataKey() {
    return "dxListItemData";
  }
  _itemContainer() {
    return this._$container;
  }
  _getItemsContainer() {
    return this._$listContainer;
  }
  _cleanItemContainer() {
    super._cleanItemContainer();
    const listContainer = this._getItemsContainer();
    renderer_default(listContainer).empty();
    listContainer.appendTo(this._$container);
  }
  _saveSelectionChangeEvent(e) {
    this._selectionChangeEventInstance = e;
  }
  _getSelectionChangeEvent() {
    return this._selectionChangeEventInstance;
  }
  _refreshItemElements() {
    const {
      grouped
    } = this.option();
    const $itemsContainer = this._getItemsContainer();
    if (grouped) {
      this._itemElementsCache = $itemsContainer.children(".dx-list-group").children(".dx-list-group-body").children(this._itemSelector());
    } else {
      this._itemElementsCache = $itemsContainer.children(this._itemSelector());
    }
  }
  _getItemAndHeaderElements() {
    const itemSelector = `> .dx-list-group-body > ${this._itemSelector()}`;
    const itemAndHeaderSelector = `${itemSelector}, > .dx-list-group-header`;
    const $listGroup = this._getItemsContainer().children(".dx-list-group");
    const $items = $listGroup.find(itemAndHeaderSelector);
    return $items;
  }
  _getAvailableItems($itemElements) {
    const {
      collapsibleGroups
    } = this.option();
    if (collapsibleGroups) {
      const $elements = this._getItemAndHeaderElements();
      const $visibleItems = $elements.filter((_, element) => {
        if (renderer_default(element).hasClass("dx-list-group-header")) {
          return true;
        }
        return !renderer_default(element).closest(".dx-list-group").hasClass("dx-list-group-collapsed");
      });
      return $visibleItems;
    }
    return super._getAvailableItems($itemElements);
  }
  _modifyByChanges() {
    super._modifyByChanges.apply(this, arguments);
    this._refreshItemElements();
    this._updateLoadingState(true);
  }
  reorderItem(itemElement, toItemElement) {
    const promise = super.reorderItem(itemElement, toItemElement);
    return promise.done(function() {
      this._refreshItemElements();
    });
  }
  deleteItem(itemElement) {
    const promise = super.deleteItem(itemElement);
    return promise.done(function() {
      this._refreshItemElements();
    });
  }
  _itemElements() {
    return this._itemElementsCache;
  }
  _itemSelectHandler(e) {
    const {
      selectionMode
    } = this.option();
    const isSingleSelectedItemClicked = "single" === selectionMode && this.isItemSelected(e.currentTarget);
    if (isSingleSelectedItemClicked) {
      return;
    }
    const isSelectionControlClicked = renderer_default(e.target).closest(`.${LIST_SELECT_CHECKBOX}`).length || renderer_default(e.target).closest(`.${LIST_SELECT_RADIOBUTTON}`).length;
    if (isSelectionControlClicked) {
      this.option("focusedElement", e.currentTarget);
    }
    return super._itemSelectHandler(e, isSelectionControlClicked);
  }
  _allowDynamicItemsAppend() {
    return true;
  }
  _updateActiveStateUnit() {
    const {
      collapsibleGroups
    } = this.option();
    const selectors = [".dx-list-item", ".dx-list-select-all"];
    if (collapsibleGroups) {
      selectors.push(".dx-list-group-header");
    }
    this._activeStateUnit = selectors.join(",");
  }
  _init() {
    super._init();
    this._updateActiveStateUnit();
    this._dataController.resetDataSourcePageIndex();
    this._$container = this.$element();
    this._$listContainer = renderer_default("<div>").addClass("dx-list-items");
    this._initScrollView();
    this._feedbackShowTimeout = 70;
    this._createGroupRenderAction();
  }
  _scrollBottomMode() {
    const {
      pageLoadMode
    } = this.option();
    return "scrollBottom" === pageLoadMode;
  }
  _nextButtonMode() {
    const {
      pageLoadMode
    } = this.option();
    return "nextButton" === pageLoadMode;
  }
  _dataSourceOptions() {
    const scrollBottom = this._scrollBottomMode();
    const nextButton = this._nextButtonMode();
    return extend(super._dataSourceOptions(), {
      paginate: ensureDefined(scrollBottom || nextButton, true)
    });
  }
  _getGroupedOption() {
    return this.option("grouped");
  }
  _getGroupContainerByIndex(groupIndex) {
    return this._getItemsContainer().find(".dx-list-group").eq(groupIndex).find(".dx-list-group-body");
  }
  _dataSourceFromUrlLoadMode() {
    return "raw";
  }
  _initScrollView() {
    const scrollingEnabled = this.option("scrollingEnabled");
    const pullRefreshEnabled = scrollingEnabled && this.option("pullRefreshEnabled");
    const autoPagingEnabled = scrollingEnabled && this._scrollBottomMode() && !!this._dataController.getDataSource();
    this._scrollView = this._createComponent(this.$element(), getScrollView(), {
      height: this.option("height"),
      width: this.option("width"),
      disabled: this.option("disabled") || !scrollingEnabled,
      onScroll: this._scrollHandler.bind(this),
      onPullDown: pullRefreshEnabled ? this._pullDownHandler.bind(this) : null,
      onReachBottom: autoPagingEnabled ? this._scrollBottomHandler.bind(this) : null,
      showScrollbar: this.option("showScrollbar"),
      useNative: this.option("useNativeScrolling"),
      bounceEnabled: this.option("bounceEnabled"),
      scrollByContent: this.option("scrollByContent"),
      scrollByThumb: this.option("scrollByThumb"),
      pullingDownText: this.option("pullingDownText"),
      pulledDownText: this.option("pulledDownText"),
      refreshingText: this.option("refreshingText"),
      reachBottomText: this.option("pageLoadingText"),
      useKeyboard: false
    });
    this._$container = renderer_default(this._scrollView.content());
    this._$listContainer.appendTo(this._$container);
    this._toggleWrapItemText(this.option("wrapItemText"));
    this._createScrollViewActions();
  }
  _toggleWrapItemText(value2) {
    this._$listContainer.toggleClass("dx-wrap-item-text", value2);
  }
  _createScrollViewActions() {
    this._scrollAction = this._createActionByOption("onScroll");
    this._pullRefreshAction = this._createActionByOption("onPullRefresh");
    this._pageLoadingAction = this._createActionByOption("onPageLoading");
  }
  _scrollHandler(e) {
    var _this$_scrollAction;
    null === (_this$_scrollAction = this._scrollAction) || void 0 === _this$_scrollAction || _this$_scrollAction.call(this, e);
  }
  _initTemplates() {
    this._templateManager.addDefaultTemplates({
      group: new BindableTemplate(($container, data17) => {
        if (isPlainObject(data17)) {
          if (data17.key) {
            $container.text(data17.key);
          }
        } else {
          $container.text(String(data17));
        }
      }, ["key"], this.option("integrationOptions.watchMethod"))
    });
    super._initTemplates();
  }
  _prepareDefaultItemTemplate(data17, $container) {
    super._prepareDefaultItemTemplate(data17, $container);
    if (data17.icon) {
      const $icon = getImageContainer(data17.icon).addClass("dx-list-item-icon");
      const $iconContainer = renderer_default("<div>").addClass("dx-list-item-icon-container");
      $iconContainer.append($icon);
      $container.prepend($iconContainer);
    }
  }
  _getBindableFields() {
    return ["text", "html", "icon"];
  }
  _updateLoadingState(tryLoadMore) {
    const dataController2 = this._dataController;
    const shouldLoadNextPage = this._scrollBottomMode() && tryLoadMore && !dataController2.isLoading() && !this._isLastPage();
    if (this._shouldContinueLoading(shouldLoadNextPage)) {
      this._infiniteDataLoading();
    } else {
      this._scrollView.release(!shouldLoadNextPage && !dataController2.isLoading());
      this._toggleNextButton(this._shouldRenderNextButton() && !this._isLastPage());
      this._loadIndicationSuppressed(false);
    }
  }
  _shouldRenderNextButton() {
    return this._nextButtonMode() && this._dataController.isLoaded();
  }
  _isDataSourceFirstLoadCompleted(newValue) {
    if (isDefined(newValue)) {
      this._isFirstLoadCompleted = newValue;
    }
    return this._isFirstLoadCompleted;
  }
  _dataSourceLoadingChangedHandler(isLoading) {
    if (this._loadIndicationSuppressed()) {
      return;
    }
    if (isLoading && this.option("indicateLoading")) {
      this._showLoadingIndicatorTimer = setTimeout(() => {
        const isEmpty3 = !this._itemElements().length;
        const shouldIndicateLoading = !isEmpty3 || this._isDataSourceFirstLoadCompleted();
        if (shouldIndicateLoading) {
          var _this$_scrollView;
          null === (_this$_scrollView = this._scrollView) || void 0 === _this$_scrollView || _this$_scrollView.startLoading();
        }
      });
    } else {
      var _this$_scrollView2;
      clearTimeout(this._showLoadingIndicatorTimer);
      null === (_this$_scrollView2 = this._scrollView) || void 0 === _this$_scrollView2 || _this$_scrollView2.finishLoading();
    }
    if (!isLoading) {
      this._isDataSourceFirstLoadCompleted(false);
    }
  }
  _dataSourceChangedHandler() {
    if (!this._shouldAppendItems() && hasWindow()) {
      var _this$_scrollView3;
      null === (_this$_scrollView3 = this._scrollView) || void 0 === _this$_scrollView3 || _this$_scrollView3.scrollTo(0);
    }
    super._dataSourceChangedHandler.apply(this, arguments);
    this._isDataSourceFirstLoadCompleted(true);
  }
  _refreshContent() {
    this._prepareContent();
    this._fireContentReadyAction();
  }
  _hideLoadingIfLoadIndicationOff() {
    if (!this.option("indicateLoading")) {
      this._dataSourceLoadingChangedHandler(false);
    }
  }
  _loadIndicationSuppressed(value2) {
    if (!arguments.length) {
      return this._isLoadIndicationSuppressed;
    }
    this._isLoadIndicationSuppressed = value2;
  }
  _scrollViewIsFull() {
    const scrollView = this._scrollView;
    return !scrollView || getHeight(scrollView.content()) > getHeight(scrollView.container());
  }
  _pullDownHandler(e) {
    var _this$_pullRefreshAct;
    null === (_this$_pullRefreshAct = this._pullRefreshAction) || void 0 === _this$_pullRefreshAct || _this$_pullRefreshAct.call(this, e);
    const dataController2 = this._dataController;
    if (dataController2.getDataSource() && !dataController2.isLoading()) {
      this._clearSelectedItems();
      dataController2.pageIndex(0);
      dataController2.reload();
    } else {
      this._updateLoadingState();
    }
  }
  _shouldContinueLoading(shouldLoadNextPage) {
    var _this$_scrollView$scr;
    const isBottomReached = getHeight(this._scrollView.content()) - getHeight(this._scrollView.container()) < ((null === (_this$_scrollView$scr = this._scrollView.scrollOffset()) || void 0 === _this$_scrollView$scr ? void 0 : _this$_scrollView$scr.top) ?? 0);
    return shouldLoadNextPage && (!this._scrollViewIsFull() || isBottomReached);
  }
  _infiniteDataLoading() {
    const isElementVisible2 = this.$element().is(":visible");
    if (isElementVisible2) {
      clearTimeout(this._loadNextPageTimer);
      this._loadNextPageTimer = setTimeout(() => {
        this._loadNextPage();
      });
    }
  }
  _scrollBottomHandler(e) {
    var _this$_pageLoadingAct;
    null === (_this$_pageLoadingAct = this._pageLoadingAction) || void 0 === _this$_pageLoadingAct || _this$_pageLoadingAct.call(this, e);
    const dataController2 = this._dataController;
    if (!dataController2.isLoading() && !this._isLastPage()) {
      this._loadNextPage();
    } else {
      this._updateLoadingState();
    }
  }
  _renderItems(items) {
    if (this.option("grouped")) {
      each(items, this._renderGroup.bind(this));
      this._attachGroupCollapseEvent();
      this._renderEmptyMessage();
      if (isMaterial()) {
        this.attachGroupHeaderInkRippleEvents();
      }
    } else {
      super._renderItems.apply(this, arguments);
    }
    this._refreshItemElements();
    this._updateLoadingState(true);
  }
  _postProcessRenderItems() {
    const {
      _onItemsRendered: onItemsRendered
    } = this.option();
    null === onItemsRendered || void 0 === onItemsRendered || onItemsRendered();
  }
  _attachGroupCollapseEvent() {
    const {
      collapsibleGroups
    } = this.option();
    const eventNameClick = addNamespace2(CLICK_EVENT_NAME, this.NAME);
    const $element = this.$element();
    $element.toggleClass("dx-list-collapsible-groups", collapsibleGroups);
    m_events_engine_default.off($element, eventNameClick, ".dx-list-group-header");
    if (collapsibleGroups) {
      m_events_engine_default.on($element, eventNameClick, ".dx-list-group-header", (e) => {
        this._processGroupCollapse(e);
      });
    }
  }
  _processGroupCollapse(e) {
    const action = this._createAction((e2) => {
      const {
        focusStateEnabled
      } = this.option();
      const $group = renderer_default(e2.event.currentTarget).parent();
      this._collapseGroupHandler($group);
      if (focusStateEnabled) {
        const groupHeader = getPublicElement($group.find(".dx-list-group-header"));
        this.option({
          focusedElement: groupHeader
        });
      }
    }, {
      validatingTargetName: "element"
    });
    action({
      event: e
    });
  }
  _enterKeyHandler(e) {
    const {
      collapsibleGroups,
      focusedElement
    } = this.option();
    const isGroupHeader = renderer_default(focusedElement).hasClass("dx-list-group-header");
    if (collapsibleGroups && isGroupHeader) {
      const params = this._getHandlerExtendedParams(e, renderer_default(focusedElement));
      this._processGroupCollapse(params);
      return;
    }
    super._enterKeyHandler(e);
  }
  _collapseGroupHandler($group, toggle) {
    const deferred = Deferred();
    const $groupHeader = $group.children(".dx-list-group-header");
    const collapsed = $group.hasClass("dx-list-group-collapsed");
    this._updateGroupHeaderAriaExpanded($groupHeader, collapsed);
    if (collapsed === toggle) {
      return deferred.resolve();
    }
    const $groupBody = $group.children(".dx-list-group-body");
    const startHeight = getOuterHeight($groupBody);
    let endHeight = 0;
    if (collapsed) {
      setHeight($groupBody, "auto");
      endHeight = getOuterHeight($groupBody);
    }
    $group.toggleClass("dx-list-group-collapsed", toggle);
    if (fx_default.isAnimating($groupBody)) {
      fx_default.stop($groupBody, false);
    }
    fx_default.animate($groupBody, {
      type: "custom",
      from: {
        height: startHeight
      },
      to: {
        height: endHeight
      },
      duration: 200,
      complete: function() {
        this.updateDimensions();
        this._updateLoadingState(true);
        deferred.resolve();
      }.bind(this)
    });
    return deferred.promise();
  }
  _dataSourceLoadErrorHandler() {
    this._forgetNextPageLoading();
    if (this._initialized) {
      this._renderEmptyMessage();
      this._updateLoadingState();
    }
  }
  _initMarkup() {
    this._itemElementsCache = renderer_default();
    this.$element().addClass("dx-list");
    super._initMarkup();
    this.option("useInkRipple") && this._renderInkRipple();
    const elementAria = {
      role: "group",
      roledescription: message_default.format("dxList-ariaRoleDescription")
    };
    this.setAria(elementAria, this.$element());
    this.setAria({
      role: "application"
    }, this._focusTarget());
    this._setListAria();
  }
  _setListAria() {
    const {
      items,
      allowItemDeleting,
      collapsibleGroups
    } = this.option();
    const label = allowItemDeleting ? message_default.format("dxList-listAriaLabel-deletable") : message_default.format("dxList-listAriaLabel");
    const shouldSetAria = (null === items || void 0 === items ? void 0 : items.length) && !collapsibleGroups;
    const listArea = {
      role: shouldSetAria ? "listbox" : void 0,
      label: shouldSetAria ? label : void 0
    };
    this.setAria(listArea, this._$listContainer);
  }
  _focusTarget() {
    return this._itemContainer();
  }
  _renderInkRipple() {
    this._inkRipple = render();
  }
  _toggleActiveState($element, value2, e) {
    super._toggleActiveState.apply(this, arguments);
    const that = this;
    if (!this._inkRipple) {
      return;
    }
    const config3 = {
      element: $element,
      event: e
    };
    if (value2) {
      if (isMaterial()) {
        this._inkRippleTimer = setTimeout(() => {
          var _that$_inkRipple;
          null === (_that$_inkRipple = that._inkRipple) || void 0 === _that$_inkRipple || _that$_inkRipple.showWave(config3);
        }, 35);
      } else {
        var _that$_inkRipple2;
        null === (_that$_inkRipple2 = that._inkRipple) || void 0 === _that$_inkRipple2 || _that$_inkRipple2.showWave(config3);
      }
    } else {
      clearTimeout(this._inkRippleTimer);
      this._inkRipple.hideWave(config3);
    }
  }
  _postprocessRenderItem(args) {
    this._refreshItemElements();
    super._postprocessRenderItem.apply(this, arguments);
    if (this.option("_swipeEnabled")) {
      this._attachSwipeEvent(renderer_default(args.itemElement));
    }
  }
  _getElementClassToSkipRefreshId() {
    return "dx-list-group-header";
  }
  _attachSwipeEvent($itemElement) {
    const endEventName = addNamespace2(SWIPE_END_EVENT, this.NAME);
    m_events_engine_default.on($itemElement, endEventName, this._itemSwipeEndHandler.bind(this));
  }
  _itemSwipeEndHandler(e) {
    this._itemDXEventHandler(e, "onItemSwipe", {
      direction: e.offset < 0 ? "left" : "right"
    });
  }
  _nextButtonHandler(e) {
    var _this$_pageLoadingAct2;
    null === (_this$_pageLoadingAct2 = this._pageLoadingAction) || void 0 === _this$_pageLoadingAct2 || _this$_pageLoadingAct2.call(this, e);
    const dataController2 = this._dataController;
    if (dataController2.getDataSource() && !dataController2.isLoading()) {
      var _this$_$nextButton;
      this._scrollView.toggleLoading(true);
      null === (_this$_$nextButton = this._$nextButton) || void 0 === _this$_$nextButton || _this$_$nextButton.detach();
      this._loadIndicationSuppressed(true);
      this._loadNextPage();
    }
  }
  _setGroupAria($group, groupHeaderId) {
    const {
      collapsibleGroups
    } = this.option();
    const groupAria = {
      role: collapsibleGroups ? void 0 : "group",
      labelledby: collapsibleGroups ? void 0 : groupHeaderId
    };
    this.setAria(groupAria, $group);
  }
  _updateGroupHeaderAriaExpanded($groupHeader, expanded) {
    this.setAria({
      expanded
    }, $groupHeader);
  }
  _setGroupHeaderAria($groupHeader, listGroupBodyId) {
    const {
      collapsibleGroups
    } = this.option();
    const groupHeaderAria = {
      role: collapsibleGroups ? "button" : void 0,
      expanded: collapsibleGroups ? true : void 0,
      controls: collapsibleGroups ? listGroupBodyId : void 0
    };
    this.setAria(groupHeaderAria, $groupHeader);
  }
  _setGroupBodyAria($groupBody, groupHeaderId) {
    const {
      collapsibleGroups
    } = this.option();
    const groupHeaderAria = {
      role: collapsibleGroups ? "listbox" : void 0,
      labelledby: collapsibleGroups ? groupHeaderId : void 0
    };
    this.setAria(groupHeaderAria, $groupBody);
  }
  _renderGroup(index2, group) {
    const $groupElement = renderer_default("<div>").addClass("dx-list-group").appendTo(this._getItemsContainer());
    const groupHeaderId = `dx-${new guid_default2().toString()}`;
    const $groupHeaderElement = renderer_default("<div>").addClass("dx-list-group-header").attr("id", groupHeaderId).appendTo($groupElement);
    const {
      groupTemplate: templateName
    } = this.option();
    const groupTemplate = this._getTemplate(group.template || templateName, group, index2, $groupHeaderElement);
    const renderArgs = {
      index: index2,
      itemData: group,
      container: getPublicElement($groupHeaderElement)
    };
    this._createItemByTemplate(groupTemplate, renderArgs);
    renderer_default("<div>").addClass("dx-list-group-header-indicator").prependTo($groupHeaderElement);
    const groupBodyId = `dx-${new guid_default2().toString()}`;
    const $groupBody = renderer_default("<div>").addClass("dx-list-group-body").attr("id", groupBodyId).appendTo($groupElement);
    each(groupItemsGetter(group) || [], (itemIndex, item) => {
      this._renderItem({
        group: index2,
        item: itemIndex
      }, item, $groupBody);
    });
    this._groupRenderAction({
      groupElement: getPublicElement($groupElement),
      groupIndex: index2,
      groupData: group
    });
    this._setGroupAria($groupElement, groupHeaderId);
    this._setGroupHeaderAria($groupHeaderElement, groupBodyId);
    this._setGroupBodyAria($groupBody, groupHeaderId);
  }
  downInkRippleHandler(e) {
    this._toggleActiveState(renderer_default(e.currentTarget), true, e);
  }
  upInkRippleHandler(e) {
    this._toggleActiveState(renderer_default(e.currentTarget), false);
  }
  attachGroupHeaderInkRippleEvents() {
    const $element = this.$element();
    this._downInkRippleHandler = this._downInkRippleHandler || this.downInkRippleHandler.bind(this);
    this._upInkRippleHandler = this._upInkRippleHandler || this.upInkRippleHandler.bind(this);
    const downArguments = [$element, "dxpointerdown", ".dx-list-group-header", this._downInkRippleHandler];
    const upArguments = [$element, "dxpointerup dxpointerout", ".dx-list-group-header", this._upInkRippleHandler];
    m_events_engine_default.off(...downArguments);
    m_events_engine_default.on(...downArguments);
    m_events_engine_default.off(...upArguments);
    m_events_engine_default.on(...upArguments);
  }
  _createGroupRenderAction() {
    this._groupRenderAction = this._createActionByOption("onGroupRendered");
  }
  _clean() {
    clearTimeout(this._inkRippleTimer);
    if (this._$nextButton) {
      this._$nextButton.remove();
      this._$nextButton = null;
    }
    super._clean.apply(this, arguments);
  }
  _dispose() {
    this._isDataSourceFirstLoadCompleted(false);
    clearTimeout(this._holdTimer);
    clearTimeout(this._loadNextPageTimer);
    clearTimeout(this._showLoadingIndicatorTimer);
    super._dispose();
  }
  _toggleDisabledState(value2) {
    super._toggleDisabledState(value2);
    this._scrollView.option("disabled", value2 || !this.option("scrollingEnabled"));
  }
  _toggleNextButton(value2) {
    const dataController2 = this._dataController;
    const $nextButton = this._getNextButton();
    this.$element().toggleClass("dx-has-next", value2);
    if (value2 && dataController2.isLoaded()) {
      $nextButton.appendTo(this._itemContainer());
    }
    if (!value2) {
      $nextButton.detach();
    }
  }
  _getNextButton() {
    if (!this._$nextButton) {
      this._$nextButton = this._createNextButton();
    }
    return this._$nextButton;
  }
  _createNextButton() {
    const $result = renderer_default("<div>").addClass("dx-list-next-button");
    const $button = renderer_default("<div>").appendTo($result);
    this._createComponent($button, button_default2, {
      text: this.option("nextButtonText"),
      onClick: this._nextButtonHandler.bind(this),
      type: isMaterialBased() ? "default" : void 0,
      integrationOptions: {}
    });
    return $result;
  }
  _moveFocus() {
    super._moveFocus.apply(this, arguments);
    this.scrollToItem(this.option("focusedElement"));
  }
  _refresh() {
    if (!hasWindow()) {
      super._refresh();
    } else {
      const scrollTop = this._scrollView.scrollTop();
      super._refresh();
      scrollTop && this._scrollView.scrollTo(scrollTop);
    }
  }
  _optionChanged(args) {
    switch (args.name) {
      case "pageLoadMode":
        this._toggleNextButton(args.value);
        this._initScrollView();
        break;
      case "dataSource":
        super._optionChanged(args);
        this._initScrollView();
        this._updateLoadingState(true);
        this._isDataSourceFirstLoadCompleted(false);
        break;
      case "items":
        super._optionChanged(args);
        this._isDataSourceFirstLoadCompleted(false);
        break;
      case "pullingDownText":
      case "pulledDownText":
      case "refreshingText":
      case "pageLoadingText":
      case "showScrollbar":
      case "bounceEnabled":
      case "scrollByContent":
      case "scrollByThumb":
      case "useNativeScrolling":
      case "scrollingEnabled":
      case "pullRefreshEnabled":
        this._initScrollView();
        this._updateLoadingState(true);
        break;
      case "nextButtonText":
      case "onItemSwipe":
      case "useInkRipple":
      case "grouped":
      case "groupTemplate":
      case "showChevronExpr":
      case "badgeExpr":
        this._invalidate();
        break;
      case "onScroll":
      case "onPullRefresh":
      case "onPageLoading":
        this._createScrollViewActions();
        break;
      case "collapsibleGroups":
        this._updateActiveStateUnit();
        this._invalidate();
        break;
      case "wrapItemText":
        this._toggleWrapItemText(args.value);
        break;
      case "onGroupRendered":
        this._createGroupRenderAction();
        break;
      case "width":
      case "height":
        super._optionChanged(args);
        this._scrollView.option(args.name, args.value);
        this._scrollView.update();
        break;
      case "indicateLoading":
        this._hideLoadingIfLoadIndicationOff();
        break;
      case "visible":
        super._optionChanged(args);
        this._scrollView.update();
        break;
      case "rtlEnabled":
        this._initScrollView();
        super._optionChanged(args);
        break;
      case "_swipeEnabled":
      case "_onItemsRendered":
      case "selectByClick":
        break;
      default:
        super._optionChanged(args);
    }
  }
  _extendActionArgs($itemElement) {
    if (!this.option("grouped")) {
      return super._extendActionArgs($itemElement);
    }
    const $group = $itemElement.closest(".dx-list-group");
    const $item = $group.find(".dx-list-item");
    return extend(super._extendActionArgs($itemElement), {
      itemIndex: {
        group: $group.index(),
        item: $item.index($itemElement)
      }
    });
  }
  expandGroup(groupIndex) {
    const deferred = Deferred();
    const $group = this._getItemsContainer().find(".dx-list-group").eq(groupIndex);
    this._collapseGroupHandler($group, false).done(() => {
      deferred.resolveWith(this);
    });
    return deferred.promise();
  }
  collapseGroup(groupIndex) {
    const deferred = Deferred();
    const $group = this._getItemsContainer().find(".dx-list-group").eq(groupIndex);
    this._collapseGroupHandler($group, true).done(() => {
      deferred.resolveWith(this);
    });
    return deferred;
  }
  updateDimensions() {
    const that = this;
    const deferred = Deferred();
    if (that._scrollView) {
      that._scrollView.update().done(() => {
        !that._scrollViewIsFull() && that._updateLoadingState(true);
        deferred.resolveWith(that);
      });
    } else {
      deferred.resolveWith(that);
    }
    return deferred.promise();
  }
  reload() {
    super.reload();
    this.scrollTo(0);
    this._pullDownHandler();
  }
  repaint() {
    this.scrollTo(0);
    super.repaint();
  }
  scrollTop() {
    return this._scrollView.scrollOffset().top;
  }
  clientHeight() {
    return this._scrollView.clientHeight();
  }
  scrollHeight() {
    return this._scrollView.scrollHeight();
  }
  scrollBy(distance) {
    this._scrollView.scrollBy(distance);
  }
  scrollTo(location) {
    this._scrollView.scrollTo(location);
  }
  scrollToItem(itemElement) {
    const $item = this._editStrategy.getItemElement(itemElement);
    const item = null === $item || void 0 === $item ? void 0 : $item.get(0);
    this._scrollView.scrollToElement(item, {
      bottom: getElementMargin(item, "bottom")
    });
  }
  _dimensionChanged() {
    this.updateDimensions();
  }
};
ListBase.include(m_grouped_data_converter_mixin_default);
ListBase.ItemClass = m_item_default;
function getScrollView() {
  return _scrollView || scroll_view_default;
}

// node_modules/devextreme/esm/__internal/ui/toolbar/internal/m_toolbar.menu.list.js
var ToolbarMenuList = class extends ListBase {
  _init() {
    super._init();
    this._activeStateUnit = ".dx-toolbar-menu-action:not(.dx-toolbar-hidden-button-group)";
  }
  _initMarkup() {
    this._renderSections();
    super._initMarkup();
    this._setMenuRole();
  }
  _getSections() {
    return this._itemContainer().children();
  }
  _itemElements() {
    return this._getSections().children(this._itemSelector());
  }
  _renderSections() {
    const $container = this._itemContainer();
    each(["before", "center", "after", "menu"], (_, section) => {
      const sectionName = `_$${section}Section`;
      if (!this[sectionName]) {
        this[sectionName] = renderer_default("<div>").addClass("dx-toolbar-menu-section");
      }
      this[sectionName].appendTo($container);
    });
  }
  _renderItems() {
    super._renderItems.apply(this, arguments);
    this._updateSections();
  }
  _setMenuRole() {
    const $menuContainer = this.$element().find(".dx-scrollview-content");
    $menuContainer.attr("role", "menu");
  }
  _updateSections() {
    const $sections = this.$element().find(".dx-toolbar-menu-section");
    $sections.removeClass("dx-toolbar-menu-last-section");
    $sections.not(":empty").eq(-1).addClass("dx-toolbar-menu-last-section");
  }
  _renderItem(index2, item, itemContainer, $after) {
    const $container = this[`_$${item.location ?? "menu"}Section`];
    const itemElement = super._renderItem(index2, item, $container, $after);
    const itemCssClasses = this._getItemCssClasses(item);
    itemElement.addClass(itemCssClasses.join(" "));
    return itemElement;
  }
  _getItemCssClasses(item) {
    const cssClasses = [];
    const actionableComponents = this._getActionableComponents();
    if (this._getItemTemplateName({
      itemData: item
    })) {
      cssClasses.push("dx-toolbar-menu-custom");
    }
    if (!item.widget || actionableComponents.includes(item.widget)) {
      cssClasses.push("dx-toolbar-menu-action");
    }
    if ("dxButton" === item.widget) {
      cssClasses.push("dx-toolbar-hidden-button");
    }
    if ("dxButtonGroup" === item.widget) {
      cssClasses.push("dx-toolbar-hidden-button-group");
    }
    cssClasses.push(item.cssClass);
    return cssClasses;
  }
  _getActionableComponents() {
    return ["dxButton", "dxButtonGroup"];
  }
  _getItemTemplateName(args) {
    const template = super._getItemTemplateName(args);
    const data17 = args.itemData;
    const menuTemplate = null === data17 || void 0 === data17 ? void 0 : data17.menuItemTemplate;
    return menuTemplate || template;
  }
  _dataSourceOptions() {
    return {
      paginate: false
    };
  }
  _itemClickHandler(e, args, config3) {
    if (renderer_default(e.target).closest(".dx-toolbar-menu-action").length) {
      super._itemClickHandler(e, args, config3);
    }
  }
  _clean() {
    this._getSections().empty();
    super._clean();
  }
};

// node_modules/devextreme/esm/__internal/ui/toolbar/internal/m_toolbar.menu.js
var DropDownMenu = class extends widget_default {
  _supportedKeys() {
    var _this$_list;
    let extension = {};
    if (!this.option("opened") || !(null !== (_this$_list = this._list) && void 0 !== _this$_list && _this$_list.option("focusedElement"))) {
      extension = this._button._supportedKeys();
    }
    return extend(super._supportedKeys(), extension, {
      tab() {
        var _this$_popup;
        null === (_this$_popup = this._popup) || void 0 === _this$_popup || _this$_popup.hide();
      }
    });
  }
  _getDefaultOptions() {
    return _extends({}, super._getDefaultOptions(), {
      items: [],
      onItemClick: null,
      dataSource: null,
      itemTemplate: "item",
      onButtonClick: null,
      activeStateEnabled: true,
      hoverStateEnabled: true,
      opened: false,
      onItemRendered: null,
      closeOnClick: true,
      useInkRipple: false,
      container: void 0,
      animation: {
        show: {
          type: "fade",
          from: 0,
          to: 1
        },
        hide: {
          type: "fade",
          to: 0
        }
      }
    });
  }
  _defaultOptionsRules() {
    return super._defaultOptionsRules().concat([{
      device: () => "desktop" === devices_default.real().deviceType && !devices_default.isSimulator(),
      options: {
        focusStateEnabled: true
      }
    }, {
      device: () => isMaterialBased(),
      options: {
        useInkRipple: true,
        animation: {
          show: {
            type: "pop",
            duration: 200,
            from: {
              scale: 0
            },
            to: {
              scale: 1
            }
          },
          hide: {
            type: "pop",
            duration: 200,
            from: {
              scale: 1
            },
            to: {
              scale: 0
            }
          }
        }
      }
    }]);
  }
  _init() {
    super._init();
    this.$element().addClass("dx-dropdownmenu");
    this._initItemClickAction();
    this._initButtonClickAction();
  }
  _initItemClickAction() {
    this._itemClickAction = this._createActionByOption("onItemClick", {});
  }
  _initButtonClickAction() {
    this._buttonClickAction = this._createActionByOption("onButtonClick", {});
  }
  _initTemplates() {
    this._templateManager.addDefaultTemplates({
      content: new ChildDefaultTemplate("content")
    });
    super._initTemplates();
  }
  _initMarkup() {
    this._renderButton();
    super._initMarkup();
  }
  _render() {
    super._render();
    this.setAria({
      haspopup: true,
      expanded: this.option("opened")
    });
  }
  _renderContentImpl() {
    if (this.option("opened")) {
      this._renderPopup();
    }
  }
  _clean() {
    var _this$_list2, _this$_popup2;
    this._cleanFocusState();
    null === (_this$_list2 = this._list) || void 0 === _this$_list2 || _this$_list2.$element().remove();
    null === (_this$_popup2 = this._popup) || void 0 === _this$_popup2 || _this$_popup2.$element().remove();
    delete this._list;
    delete this._popup;
  }
  _renderButton() {
    const $button = this.$element().addClass("dx-dropdownmenu-button");
    this._button = this._createComponent($button, button_default2, {
      icon: "overflow",
      template: "content",
      stylingMode: isFluent() ? "text" : "contained",
      useInkRipple: this.option("useInkRipple"),
      hoverStateEnabled: false,
      focusStateEnabled: false,
      onClick: (e) => {
        this.option("opened", !this.option("opened"));
        this._buttonClickAction(e);
      }
    });
  }
  _toggleActiveState($element, value2, e) {
    this._button._toggleActiveState($element, value2, e);
  }
  _toggleMenuVisibility(opened) {
    var _this$_popup3, _this$_popup4;
    const state = opened ?? !(null !== (_this$_popup3 = this._popup) && void 0 !== _this$_popup3 && _this$_popup3.option("visible"));
    if (opened) {
      this._renderPopup();
    }
    null === (_this$_popup4 = this._popup) || void 0 === _this$_popup4 || _this$_popup4.toggle(state);
    this.setAria("expanded", state);
  }
  _renderPopup() {
    if (this._$popup) {
      return;
    }
    this._$popup = renderer_default("<div>").appendTo(this.$element());
    const {
      rtlEnabled,
      container,
      animation: animation3
    } = this.option();
    this._popup = this._createComponent(this._$popup, "dxPopup", {
      onInitialized(_ref) {
        let {
          component
        } = _ref;
        component.$wrapper().addClass("dx-dropdownmenu-popup-wrapper").addClass("dx-dropdownmenu-popup");
      },
      deferRendering: false,
      preventScrollEvents: false,
      contentTemplate: (contentElement) => this._renderList(contentElement),
      _ignoreFunctionValueDeprecation: true,
      maxHeight: () => this._getMaxHeight(),
      position: {
        my: "top " + (rtlEnabled ? "left" : "right"),
        at: "bottom " + (rtlEnabled ? "left" : "right"),
        collision: "fit flip",
        offset: {
          v: 3
        },
        of: this.$element()
      },
      animation: animation3,
      onOptionChanged: (_ref2) => {
        let {
          name: name2,
          value: value2
        } = _ref2;
        if ("visible" === name2) {
          this.option("opened", value2);
        }
      },
      container,
      autoResizeEnabled: false,
      height: "auto",
      width: "auto",
      hideOnOutsideClick: (e) => this._closeOutsideDropDownHandler(e),
      hideOnParentScroll: true,
      shading: false,
      dragEnabled: false,
      showTitle: false,
      fullScreen: false,
      _fixWrapperPosition: true
    });
  }
  _getMaxHeight() {
    const $element = this.$element();
    const offsetTop = $element.offset().top;
    const windowHeight = getOuterHeight(getWindow());
    const maxHeight = Math.max(offsetTop, windowHeight - offsetTop - getOuterHeight($element));
    return Math.min(windowHeight, maxHeight - 3 - 10);
  }
  _closeOutsideDropDownHandler(e) {
    const isOutsideClick = !renderer_default(e.target).closest(this.$element()).length;
    return isOutsideClick;
  }
  _renderList(contentElement) {
    const $content = renderer_default(contentElement);
    $content.addClass("dx-dropdownmenu-list");
    const {
      itemTemplate,
      onItemRendered
    } = this.option();
    this._list = this._createComponent($content, ToolbarMenuList, {
      dataSource: this._getListDataSource(),
      pageLoadMode: "scrollBottom",
      indicateLoading: false,
      noDataText: "",
      itemTemplate,
      onItemClick: (e) => {
        if (this.option("closeOnClick")) {
          this.option("opened", false);
        }
        this._itemClickAction(e);
      },
      tabIndex: -1,
      focusStateEnabled: false,
      activeStateEnabled: true,
      onItemRendered,
      _itemAttributes: {
        role: "menuitem"
      }
    });
  }
  _itemOptionChanged(item, property, value2) {
    var _this$_list3;
    null === (_this$_list3 = this._list) || void 0 === _this$_list3 || _this$_list3._itemOptionChanged(item, property, value2);
    toggleItemFocusableElementTabIndex(this._list, item);
  }
  _getListDataSource() {
    return this.option("dataSource") ?? this.option("items");
  }
  _setListDataSource() {
    var _this$_list4;
    null === (_this$_list4 = this._list) || void 0 === _this$_list4 || _this$_list4.option("dataSource", this._getListDataSource());
    delete this._deferRendering;
  }
  _getKeyboardListeners() {
    return super._getKeyboardListeners().concat([this._list]);
  }
  _toggleVisibility(visible2) {
    var _this$_button;
    super._toggleVisibility(visible2);
    null === (_this$_button = this._button) || void 0 === _this$_button || _this$_button.option("visible", visible2);
  }
  _optionChanged(args) {
    var _this$_list5, _this$_list6, _this$_list7;
    const {
      name: name2,
      value: value2
    } = args;
    switch (name2) {
      case "items":
      case "dataSource":
        if (!this.option("opened")) {
          this._deferRendering = true;
        } else {
          this._setListDataSource();
        }
        break;
      case "itemTemplate":
        null === (_this$_list5 = this._list) || void 0 === _this$_list5 || _this$_list5.option(name2, this._getTemplate(value2));
        break;
      case "onItemClick":
        this._initItemClickAction();
        break;
      case "onButtonClick":
        this._buttonClickAction();
        break;
      case "useInkRipple":
        this._invalidate();
        break;
      case "focusStateEnabled":
        null === (_this$_list6 = this._list) || void 0 === _this$_list6 || _this$_list6.option(name2, value2);
        super._optionChanged(args);
        break;
      case "onItemRendered":
        null === (_this$_list7 = this._list) || void 0 === _this$_list7 || _this$_list7.option(name2, value2);
        break;
      case "opened":
        if (this._deferRendering) {
          this._setListDataSource();
        }
        this._toggleMenuVisibility(value2);
        this._updateFocusableItemsTabIndex();
        break;
      case "closeOnClick":
        break;
      case "container":
        this._popup && this._popup.option(name2, value2);
        break;
      case "disabled":
        if (this._list) {
          this._updateFocusableItemsTabIndex();
        }
        break;
      default:
        super._optionChanged(args);
    }
  }
  _updateFocusableItemsTabIndex() {
    this.option("items").forEach((item) => toggleItemFocusableElementTabIndex(this._list, item));
  }
};

// node_modules/devextreme/esm/__internal/ui/toolbar/strategy/m_toolbar.singleline.js
var TOOLBAR_HIDDEN_ITEM = "dx-toolbar-item-invisible";
var SingleLineStrategy = class {
  constructor(toolbar) {
    this._toolbar = toolbar;
  }
  _initMarkup() {
    deferRender(() => {
      this._renderOverflowMenu();
      this._renderMenuItems();
    });
  }
  _renderOverflowMenu() {
    if (!this._hasVisibleMenuItems()) {
      return;
    }
    this._renderMenuButtonContainer();
    const $menu = renderer_default("<div>").appendTo(this._overflowMenuContainer());
    const itemClickAction = this._toolbar._createActionByOption("onItemClick");
    const menuItemTemplate = this._toolbar._getTemplateByOption("menuItemTemplate");
    const {
      disabled,
      menuContainer
    } = this._toolbar.option();
    this._menu = this._toolbar._createComponent($menu, DropDownMenu, {
      disabled,
      itemTemplate: () => menuItemTemplate,
      onItemClick: (e) => {
        itemClickAction(e);
      },
      container: menuContainer,
      onOptionChanged: (_ref) => {
        let {
          name: name2,
          value: value2
        } = _ref;
        if ("opened" === name2) {
          this._toolbar.option("overflowMenuVisible", value2);
        }
        if ("items" === name2) {
          this._updateMenuVisibility(value2);
        }
      }
    });
  }
  renderMenuItems() {
    var _this$_menu;
    if (!this._menu) {
      this._renderOverflowMenu();
    }
    null === (_this$_menu = this._menu) || void 0 === _this$_menu || _this$_menu.option("items", this._getMenuItems());
    if (this._menu && !this._menu.option("items").length) {
      this._menu.option("opened", false);
    }
  }
  _renderMenuButtonContainer() {
    this._$overflowMenuContainer = renderer_default("<div>").appendTo(this._toolbar._$afterSection).addClass("dx-toolbar-button").addClass("dx-toolbar-menu-container");
  }
  _overflowMenuContainer() {
    return this._$overflowMenuContainer;
  }
  _updateMenuVisibility(menuItems) {
    const items = menuItems ?? this._getMenuItems();
    const isMenuVisible = items.length && this._hasVisibleMenuItems(items);
    this._toggleMenuVisibility(isMenuVisible);
  }
  _toggleMenuVisibility(value2) {
    if (!this._overflowMenuContainer()) {
      return;
    }
    this._overflowMenuContainer().toggleClass("dx-state-invisible", !value2);
  }
  _renderMenuItems() {
    deferRender(() => {
      this.renderMenuItems();
    });
  }
  _dimensionChanged() {
    this.renderMenuItems();
  }
  _getToolbarItems() {
    return grep(this._toolbar.option("items") ?? [], (item) => !this._toolbar._isMenuItem(item));
  }
  _getHiddenItems() {
    return this._toolbar._itemContainer().children(`.dx-toolbar-item-auto-hide.${TOOLBAR_HIDDEN_ITEM}`).not(".dx-state-invisible");
  }
  _getMenuItems() {
    const menuItems = grep(this._toolbar.option("items") ?? [], (item) => this._toolbar._isMenuItem(item));
    const $hiddenItems = this._getHiddenItems();
    this._restoreItems = this._restoreItems ?? [];
    const overflowItems = [].slice.call($hiddenItems).map((hiddenItem) => {
      const itemData = this._toolbar._getItemData(hiddenItem);
      const $itemContainer = renderer_default(hiddenItem);
      const $itemMarkup = $itemContainer.children();
      return extend({
        menuItemTemplate: () => {
          this._restoreItems.push({
            container: $itemContainer,
            item: $itemMarkup
          });
          const $container = renderer_default("<div>").addClass("dx-toolbar-item-auto-hide");
          return $container.append($itemMarkup);
        }
      }, itemData);
    });
    return [...overflowItems, ...menuItems];
  }
  _hasVisibleMenuItems(items) {
    const menuItems = items ?? this._toolbar.option("items");
    let result2 = false;
    const optionGetter = compileGetter("visible");
    const overflowGetter = compileGetter("locateInMenu");
    each(menuItems, (index2, item) => {
      const itemVisible = optionGetter(item, {
        functionsAsIs: true
      });
      const itemOverflow = overflowGetter(item, {
        functionsAsIs: true
      });
      if (false !== itemVisible && ("auto" === itemOverflow || "always" === itemOverflow) || "menu" === item.location) {
        result2 = true;
      }
    });
    return result2;
  }
  _arrangeItems() {
    this._toolbar._$centerSection.css({
      margin: "0 auto",
      float: "none"
    });
    each(this._restoreItems ?? [], (_, obj) => {
      renderer_default(obj.container).append(obj.item);
    });
    this._restoreItems = [];
    const elementWidth = getWidth(this._toolbar.$element());
    this._hideOverflowItems(elementWidth);
    return elementWidth;
  }
  _hideOverflowItems(width) {
    const overflowItems = this._toolbar.$element().find(".dx-toolbar-item-auto-hide");
    if (!overflowItems.length) {
      return;
    }
    const elementWidth = width ?? getWidth(this._toolbar.$element());
    renderer_default(overflowItems).removeClass(TOOLBAR_HIDDEN_ITEM);
    let itemsWidth = this._getItemsWidth();
    while (overflowItems.length && elementWidth < itemsWidth) {
      const $item = overflowItems.eq(-1);
      $item.addClass(TOOLBAR_HIDDEN_ITEM);
      itemsWidth = this._getItemsWidth();
      [].splice.apply(overflowItems, [-1, 1]);
    }
  }
  _getItemsWidth() {
    return this._toolbar._getSummaryItemsSize("width", [this._toolbar._$beforeSection, this._toolbar._$centerSection, this._toolbar._$afterSection]);
  }
  _itemOptionChanged(item, property, value2) {
    if ("disabled" === property || "options.disabled" === property) {
      if (this._toolbar._isMenuItem(item)) {
        var _this$_menu2;
        null === (_this$_menu2 = this._menu) || void 0 === _this$_menu2 || _this$_menu2._itemOptionChanged(item, property, value2);
        return;
      }
    }
    this.renderMenuItems();
  }
  _renderItem(item, itemElement) {
    if ("auto" === item.locateInMenu) {
      itemElement.addClass("dx-toolbar-item-auto-hide");
    }
  }
  _optionChanged(name2, value2) {
    var _this$_menu3, _this$_menu4, _this$_menu5, _this$_menu6, _this$_menu7;
    switch (name2) {
      case "disabled":
        null === (_this$_menu3 = this._menu) || void 0 === _this$_menu3 || _this$_menu3.option(name2, value2);
        break;
      case "overflowMenuVisible":
        null === (_this$_menu4 = this._menu) || void 0 === _this$_menu4 || _this$_menu4.option("opened", value2);
        break;
      case "onItemClick":
        null === (_this$_menu5 = this._menu) || void 0 === _this$_menu5 || _this$_menu5.option(name2, value2);
        break;
      case "menuContainer":
        null === (_this$_menu6 = this._menu) || void 0 === _this$_menu6 || _this$_menu6.option("container", value2);
        break;
      case "menuItemTemplate":
        null === (_this$_menu7 = this._menu) || void 0 === _this$_menu7 || _this$_menu7.option("itemTemplate", value2);
    }
  }
};

// node_modules/devextreme/esm/__internal/ui/toolbar/m_toolbar.js
var Toolbar = class extends m_toolbar_base_default {
  _getDefaultOptions() {
    return _extends({}, super._getDefaultOptions(), {
      menuItemTemplate: "menuItem",
      menuContainer: void 0,
      overflowMenuVisible: false,
      multiline: false
    });
  }
  _isMultiline() {
    return this.option("multiline");
  }
  _dimensionChanged(dimension) {
    if ("height" === dimension) {
      return;
    }
    super._dimensionChanged();
    this._layoutStrategy._dimensionChanged();
  }
  _initMarkup() {
    super._initMarkup();
    this._updateFocusableItemsTabIndex();
    this._layoutStrategy._initMarkup();
  }
  _renderToolbar() {
    super._renderToolbar();
    this._renderLayoutStrategy();
  }
  _itemContainer() {
    if (this._isMultiline()) {
      return this._$toolbarItemsContainer;
    }
    return super._itemContainer();
  }
  _renderLayoutStrategy() {
    this.$element().toggleClass("dx-toolbar-multiline", this._isMultiline());
    this._layoutStrategy = this._isMultiline() ? new MultiLineStrategy(this) : new SingleLineStrategy(this);
  }
  _renderSections() {
    if (this._isMultiline()) {
      return;
    }
    return super._renderSections();
  }
  _postProcessRenderItems() {
    this._layoutStrategy._hideOverflowItems();
    this._layoutStrategy._updateMenuVisibility();
    super._postProcessRenderItems();
    this._layoutStrategy._renderMenuItems();
  }
  _renderItem(index2, item, itemContainer, $after) {
    const itemElement = super._renderItem(index2, item, itemContainer, $after);
    this._layoutStrategy._renderItem(item, itemElement);
    const {
      widget,
      showText
    } = item;
    if ("dxButton" === widget && "inMenu" === showText) {
      itemElement.toggleClass("dx-toolbar-text-auto-hide");
    }
    return itemElement;
  }
  _getItemsWidth() {
    return this._layoutStrategy._getItemsWidth();
  }
  _getMenuItems() {
    return this._layoutStrategy._getMenuItems();
  }
  _getToolbarItems() {
    return this._layoutStrategy._getToolbarItems();
  }
  _arrangeItems() {
    if (this.$element().is(":hidden")) {
      return;
    }
    const elementWidth = this._layoutStrategy._arrangeItems();
    if (!this._isMultiline()) {
      super._arrangeItems(elementWidth);
    }
  }
  _itemOptionChanged(item, property, value2, prevValue) {
    if (!this._isMenuItem(item)) {
      super._itemOptionChanged(item, property, value2, prevValue);
    }
    this._layoutStrategy._itemOptionChanged(item, property, value2);
    if ("disabled" === property || "options.disabled" === property) {
      toggleItemFocusableElementTabIndex(this, item);
    }
    if ("location" === property) {
      this.repaint();
    }
  }
  _updateFocusableItemsTabIndex() {
    this._getToolbarItems().forEach((item) => toggleItemFocusableElementTabIndex(this, item));
  }
  _isMenuItem(itemData) {
    return "menu" === itemData.location || "always" === itemData.locateInMenu;
  }
  _isToolbarItem(itemData) {
    return void 0 === itemData.location || "never" === itemData.locateInMenu;
  }
  _optionChanged(args) {
    const {
      name: name2,
      value: value2
    } = args;
    this._layoutStrategy._optionChanged(name2, value2);
    switch (name2) {
      case "menuContainer":
      case "menuItemTemplate":
      case "overflowMenuVisible":
        break;
      case "multiline":
        this._invalidate();
        break;
      case "disabled":
        super._optionChanged(args);
        this._updateFocusableItemsTabIndex();
        break;
      default:
        super._optionChanged(args);
    }
  }
  updateDimensions() {
    this._dimensionChanged();
  }
};
component_registrator_default("dxToolbar", Toolbar);
var m_toolbar_default = Toolbar;

// node_modules/devextreme/esm/ui/toolbar/ui.toolbar.js
var ui_toolbar_default = m_toolbar_default;

// node_modules/devextreme/esm/ui/toolbar.js
var toolbar_default = ui_toolbar_default;

// node_modules/devextreme/esm/__internal/grids/new/grid_core/toolbar/utils.js
function normalizeToolbarItem(item, defaultButtonsMap, defaultItemNames) {
  let button = item;
  if (isString(button)) {
    button = {
      name: button
    };
  }
  if (isDefined(button.name)) {
    if (isDefined(defaultButtonsMap[button.name])) {
      button = extend(true, {}, defaultButtonsMap[button.name], button);
    } else if (defaultItemNames.includes(button.name)) {
      button = _extends({}, button, {
        visible: false
      });
    }
  }
  return extend(true, {}, {
    location: "after"
  }, button);
}
function normalizeToolbarItems(sortedDefaultItems, userItems, defaultItemNames) {
  if (!isDefined(userItems)) {
    return sortedDefaultItems;
  }
  const defaultButtonsMap = {};
  sortedDefaultItems.forEach((button) => {
    defaultButtonsMap[button.name] = button;
  });
  return userItems.map((item) => normalizeToolbarItem(item, defaultButtonsMap, defaultItemNames));
}

// node_modules/devextreme/esm/__internal/grids/grid_core/header_panel/m_header_panel.js
var DEFAULT_TOOLBAR_ITEM_NAMES = ["addRowButton", "applyFilterButton", "columnChooserButton", "exportButton", "groupPanel", "revertButton", "saveButton", "searchPanel"];
var HeaderPanel = class extends ColumnsView {
  init() {
    super.init();
    this._editingController = this.getController("editing");
    this._headerFilterController = this.getController("headerFilter");
    this.createAction("onToolbarPreparing", {
      excludeValidators: ["disabled", "readOnly"]
    });
  }
  _getToolbarItems() {
    return [];
  }
  _getButtonContainer() {
    return renderer_default("<div>").addClass(this.addWidgetPrefix("toolbar-button"));
  }
  _getToolbarButtonClass(specificClass) {
    const secondClass = specificClass ? ` ${specificClass}` : "";
    return this.addWidgetPrefix("toolbar-button") + secondClass;
  }
  _getToolbarOptions() {
    const userToolbarOptions = this.option("toolbar");
    const options2 = {
      toolbarOptions: {
        items: this._getToolbarItems(),
        visible: null === userToolbarOptions || void 0 === userToolbarOptions ? void 0 : userToolbarOptions.visible,
        disabled: null === userToolbarOptions || void 0 === userToolbarOptions ? void 0 : userToolbarOptions.disabled,
        onItemRendered(e) {
          const itemRenderedCallback = e.itemData.onItemRendered;
          if (itemRenderedCallback) {
            itemRenderedCallback(e);
          }
        }
      }
    };
    const userItems = null === userToolbarOptions || void 0 === userToolbarOptions ? void 0 : userToolbarOptions.items;
    options2.toolbarOptions.items = normalizeToolbarItems(options2.toolbarOptions.items, userItems, DEFAULT_TOOLBAR_ITEM_NAMES);
    this.executeAction("onToolbarPreparing", options2);
    if (options2.toolbarOptions && !isDefined(options2.toolbarOptions.visible)) {
      const toolbarItems = options2.toolbarOptions.items;
      options2.toolbarOptions.visible = !!(null !== toolbarItems && void 0 !== toolbarItems && toolbarItems.length);
    }
    return options2.toolbarOptions;
  }
  _renderCore() {
    if (!this._toolbar) {
      const $headerPanel = this.element();
      $headerPanel.addClass(this.addWidgetPrefix("header-panel"));
      const label = message_default.format(this.component.NAME + "-ariaToolbar");
      const $toolbar = renderer_default("<div>").attr("aria-label", label).appendTo($headerPanel);
      this._toolbar = this._createComponent($toolbar, toolbar_default, this._toolbarOptions);
    } else {
      this._toolbar.option(this._toolbarOptions);
    }
  }
  _columnOptionChanged() {
  }
  _handleDataChanged() {
    if (this._requireReady) {
      this.render();
    }
  }
  _isDisabledDefinedByUser(name2) {
    var _this$option;
    const userItems = null === (_this$option = this.option("toolbar")) || void 0 === _this$option ? void 0 : _this$option.items;
    const userItem = null === userItems || void 0 === userItems ? void 0 : userItems.find((item) => (null === item || void 0 === item ? void 0 : item.name) === name2);
    return isDefined(null === userItem || void 0 === userItem ? void 0 : userItem.disabled);
  }
  render() {
    this._toolbarOptions = this._getToolbarOptions();
    super.render.apply(this, arguments);
  }
  setToolbarItemDisabled(name2, disabled) {
    const toolbar = this._toolbar;
    const isDefinedByUser = this._isDisabledDefinedByUser(name2);
    if (!toolbar || isDefinedByUser) {
      return;
    }
    const items = toolbar.option("items") ?? [];
    const itemIndex = items.findIndex((item2) => item2.name === name2);
    if (itemIndex < 0) {
      return;
    }
    const item = toolbar.option(`items[${itemIndex}]`);
    toolbar.option(`items[${itemIndex}].disabled`, disabled);
    if (item.options) {
      toolbar.option(`items[${itemIndex}].options.disabled`, disabled);
    }
  }
  updateToolbarDimensions() {
    var _this$_toolbar;
    null === (_this$_toolbar = this._toolbar) || void 0 === _this$_toolbar || _this$_toolbar.updateDimensions();
  }
  getHeaderPanel() {
    return this.element();
  }
  getHeight() {
    return this.getElementHeight();
  }
  optionChanged(args) {
    if ("onToolbarPreparing" === args.name) {
      this._invalidate();
      args.handled = true;
    }
    if ("toolbar" === args.name) {
      const parts = getPathParts(args.fullName);
      const optionName = args.fullName.replace(/^toolbar\./, "");
      if (1 === parts.length || "visible" === parts[1]) {
        this._invalidate();
      } else if ("items" === parts[1]) {
        if (2 === parts.length) {
          this._invalidate();
        } else if (3 === parts.length) {
          var _this$_toolbar2;
          const normalizedItem = normalizeToolbarItems(this._getToolbarItems(), [args.value], DEFAULT_TOOLBAR_ITEM_NAMES)[0];
          null === (_this$_toolbar2 = this._toolbar) || void 0 === _this$_toolbar2 || _this$_toolbar2.option(optionName, normalizedItem);
        } else if (parts.length >= 4) {
          var _this$_toolbar3;
          null === (_this$_toolbar3 = this._toolbar) || void 0 === _this$_toolbar3 || _this$_toolbar3.option(optionName, args.value);
        }
      } else {
        var _this$_toolbar4;
        null === (_this$_toolbar4 = this._toolbar) || void 0 === _this$_toolbar4 || _this$_toolbar4.option(optionName, args.value);
      }
      args.handled = true;
    }
    super.optionChanged(args);
  }
  isVisible() {
    return !!(this._toolbarOptions && this._toolbarOptions.visible);
  }
  allowDragging(column) {
    return false;
  }
  hasGroupedColumns() {
  }
  getContextMenuItems(options2) {
    return;
  }
};
var resizing = (Base) => class extends Base {
  _updateDimensionsCore() {
    super._updateDimensionsCore.apply(this, arguments);
    this.getView("headerPanel").updateToolbarDimensions();
  }
};
var headerPanelModule = {
  defaultOptions: () => ({}),
  views: {
    headerPanel: HeaderPanel
  },
  extenders: {
    controllers: {
      resizing
    }
  }
};

// node_modules/devextreme/esm/__internal/grids/data_grid/module_not_extended/header_panel.js
var HeaderPanel2 = headerPanelModule.views.headerPanel;
m_core_default.registerModule("headerPanel", headerPanelModule);

// node_modules/devextreme/esm/ui/widget/ui.widget.js
var ui_widget_default = widget_default;

// node_modules/devextreme/esm/__internal/grids/grid_core/m_widget_base.js
var GridCoreWidget = class extends ui_widget_default {
  _getDefaultOptions() {
    const result2 = super._getDefaultOptions();
    each(this.getGridCoreHelper().modules, function() {
      if (isFunction(this.defaultOptions)) {
        extend(true, result2, this.defaultOptions());
      }
    });
    return result2;
  }
  _init() {
    this._activeStateUnit = ".dx-row";
    super._init();
  }
  _setDeprecatedOptions() {
    super._setDeprecatedOptions();
    extend(this._deprecatedOptions, {
      "columnChooser.allowSearch": {
        since: "23.1",
        message: 'Use the "columnChooser.search.enabled" option instead'
      },
      "columnChooser.searchTimeout": {
        since: "23.1",
        message: 'Use the "columnChooser.search.timeout" option instead'
      }
    });
  }
  _clean() {
  }
  _optionChanged(args) {
    this.getGridCoreHelper().callModuleItemsMethod(this, "optionChanged", [args]);
    if (!args.handled) {
      super._optionChanged(args);
    }
  }
  _dimensionChanged() {
    this.updateDimensions(true);
  }
  _visibilityChanged(visible2) {
    if (visible2) {
      this.updateDimensions();
    }
  }
  _renderContentImpl() {
    this.getView("gridView").update();
  }
  _renderContent() {
    const that = this;
    deferRender(() => {
      that._renderContentImpl();
    });
  }
  _dispose() {
    super._dispose();
    this.getGridCoreHelper().callModuleItemsMethod(this, "dispose");
  }
  isReady() {
    return this.getController("data").isReady();
  }
  getController(name2) {
    return this._controllers[name2];
  }
  getView(name2) {
    return this._views[name2];
  }
  getGridCoreHelper() {
  }
  beginUpdate() {
    super.beginUpdate();
    this.getGridCoreHelper().callModuleItemsMethod(this, "beginUpdate");
  }
  endUpdate() {
    this.getGridCoreHelper().callModuleItemsMethod(this, "endUpdate");
    super.endUpdate();
  }
};

// node_modules/devextreme/esm/__internal/grids/data_grid/m_widget_base.js
var DATAGRID_DEPRECATED_TEMPLATE_WARNING = "Specifying grid templates with the jQuery selector name is now deprecated. Use the DOM Node or the jQuery object that references this selector instead.";
m_core_default.registerModulesOrder(["stateStoring", "columns", "selection", "editorFactory", "columnChooser", "grouping", "editing", "editingRowBased", "editingFormBased", "editingCellBased", "masterDetail", "validating", "adaptivity", "data", "virtualScrolling", "columnHeaders", "filterRow", "headerPanel", "headerFilter", "sorting", "search", "rows", "pager", "columnsResizingReordering", "contextMenu", "keyboardNavigation", "headersKeyboardNavigation", "groupPanelKeyboardNavigation", "errorHandling", "summary", "columnFixing", "export", "gridView"]);
var DataGrid = class extends GridCoreWidget {
  _defaultOptionsRules() {
    return super._defaultOptionsRules().concat([{
      device: {
        platform: "ios"
      },
      options: {
        showRowLines: true
      }
    }, {
      device: () => isMaterialBased(),
      options: {
        showRowLines: true,
        showColumnLines: false,
        headerFilter: {
          height: 315
        },
        editing: {
          useIcons: true
        },
        selection: {
          showCheckBoxesMode: "always"
        }
      }
    }, {
      device: () => browser_default.webkit,
      options: {
        loadingTimeout: 30,
        loadPanel: {
          animation: {
            show: {
              easing: "cubic-bezier(1, 0, 1, 0)",
              duration: 500,
              from: {
                opacity: 0
              },
              to: {
                opacity: 1
              }
            }
          }
        }
      }
    }, {
      device: (device) => "desktop" !== device.deviceType,
      options: {
        grouping: {
          expandMode: "rowClick"
        }
      }
    }]);
  }
  _init() {
    super._init();
    m_utils_default.logHeaderFilterDeprecatedWarningIfNeed(this);
    m_core_default.processModules(this, m_core_default);
    m_core_default.callModuleItemsMethod(this, "init");
  }
  _initMarkup() {
    super._initMarkup.apply(this, arguments);
    this.getView("gridView").render(this.$element());
  }
  _setDeprecatedOptions() {
    super._setDeprecatedOptions();
    extend(this._deprecatedOptions, {
      useKeyboard: {
        since: "19.2",
        alias: "keyboardNavigation.enabled"
      },
      rowTemplate: {
        since: "21.2",
        message: 'Use the "dataRowTemplate" option instead'
      }
    });
  }
  static registerModule(name2, module) {
    m_core_default.registerModule(name2, module);
  }
  getGridCoreHelper() {
    return m_core_default;
  }
  _getTemplate(templateName) {
    let template = templateName;
    if (isString(template) && template.startsWith("#")) {
      template = renderer_default(templateName);
      logger.warn(DATAGRID_DEPRECATED_TEMPLATE_WARNING);
    }
    return super._getTemplate(template);
  }
  focus(element) {
    this.getController("keyboardNavigation").focus(element);
  }
};
component_registrator_default("dxDataGrid", DataGrid);
var m_widget_base_default = DataGrid;

// node_modules/devextreme/esm/__internal/grids/grid_core/state_storing/m_state_storing_core.js
var DATE_REGEX = /^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2}(?:\.\d*)?)Z$/;
var parseDates = function(state) {
  if (!state) {
    return;
  }
  each(state, (key, value2) => {
    if (isPlainObject(value2) || Array.isArray(value2)) {
      parseDates(value2);
    } else if ("string" === typeof value2) {
      const date = DATE_REGEX.exec(value2);
      if (date) {
        state[key] = new Date(Date.UTC(+date[1], +date[2] - 1, +date[3], +date[4], +date[5], +date[6]));
      }
    }
  });
};
var getStorage = function(options2) {
  const storage = "sessionStorage" === options2.type ? getSessionStorage() : getWindow().localStorage;
  if (!storage) {
    throw new Error("E1007");
  }
  return storage;
};
var getUniqueStorageKey = function(options2) {
  return isDefined(options2.storageKey) ? options2.storageKey : "storage";
};
var StateStoringController = class extends m_modules_default.ViewController {
  getDataController() {
    return this.getController("data");
  }
  getExportController() {
    return this.getController("export");
  }
  getColumnsController() {
    return this.getController("columns");
  }
  init() {
    this._state = {};
    this._isLoaded = false;
    this._isLoading = false;
    this._windowUnloadHandler = () => {
      if (void 0 !== this._savingTimeoutID) {
        this._saveState(this.state());
      }
    };
    m_events_engine_default.on(getWindow(), "visibilitychange", this._windowUnloadHandler);
    return this;
  }
  optionChanged(args) {
    const that = this;
    if ("stateStoring" === args.name) {
      if (that.isEnabled() && !that.isLoading()) {
        that.load();
      }
      args.handled = true;
    } else {
      super.optionChanged(args);
    }
  }
  dispose() {
    clearTimeout(this._savingTimeoutID);
    m_events_engine_default.off(getWindow(), "visibilitychange", this._windowUnloadHandler);
  }
  _loadState() {
    const options2 = this.option("stateStoring");
    if ("custom" === options2.type) {
      return options2.customLoad && options2.customLoad();
    }
    try {
      return JSON.parse(getStorage(options2).getItem(getUniqueStorageKey(options2)));
    } catch (e) {
      ui_errors_default.log("W1022", "State storing", e.message);
    }
  }
  _saveState(state) {
    const options2 = this.option("stateStoring");
    if ("custom" === options2.type) {
      options2.customSave && options2.customSave(state);
      return;
    }
    try {
      getStorage(options2).setItem(getUniqueStorageKey(options2), JSON.stringify(state));
    } catch (e) {
      ui_errors_default.log(e.message);
    }
  }
  publicMethods() {
    return ["state"];
  }
  isEnabled() {
    return this.option("stateStoring.enabled");
  }
  isLoaded() {
    return this._isLoaded;
  }
  isLoading() {
    return this._isLoading;
  }
  load() {
    this._isLoading = true;
    const loadResult = fromPromise(this._loadState());
    loadResult.always(() => {
      this._isLoaded = true;
      this._isLoading = false;
    }).done((state) => {
      if (null !== state && !isEmptyObject(state)) {
        this.state(state);
      }
    });
    return loadResult;
  }
  state(state) {
    const that = this;
    if (!arguments.length) {
      return extend(true, {}, that._state);
    }
    that._state = extend({}, state);
    parseDates(that._state);
  }
  save() {
    const that = this;
    clearTimeout(that._savingTimeoutID);
    that._savingTimeoutID = setTimeout(() => {
      that._saveState(that.state());
      that._savingTimeoutID = void 0;
    }, that.option("stateStoring.savingTimeout"));
  }
};

// node_modules/devextreme/esm/__internal/grids/grid_core/state_storing/m_state_storing.js
var getDataState = (that) => {
  const pagerView = that.getView("pagerView");
  const dataController2 = that.getController("data");
  const state = {
    allowedPageSizes: pagerView ? pagerView.getPageSizes() : void 0,
    filterPanel: {
      filterEnabled: that.option("filterPanel.filterEnabled")
    },
    filterValue: that.option("filterValue"),
    focusedRowKey: that.option("focusedRowEnabled") ? that.option("focusedRowKey") : void 0
  };
  return extend(state, dataController2.getUserState());
};
var processLoadState = (that) => {
  const columnsController = that.getController("columns");
  const selectionController = that.getController("selection");
  const exportController = that.getController("export");
  const dataController2 = that.getController("data");
  if (columnsController) {
    columnsController.columnsChanged.add(() => {
      that.updateState({
        columns: columnsController.getUserState()
      });
    });
  }
  if (selectionController) {
    selectionController.selectionChanged.add((e) => {
      that.updateState({
        selectedRowKeys: e.selectedRowKeys,
        selectionFilter: e.selectionFilter
      });
    });
  }
  if (dataController2) {
    that._initialPageSize = that.option("paging.pageSize");
    that._initialFilterValue = that.option("filterValue");
    dataController2.changed.add(() => {
      const state = getDataState(that);
      that.updateState(state);
    });
  }
  if (exportController) {
    exportController.selectionOnlyChanged.add(() => {
      that.updateState({
        exportSelectionOnly: exportController.selectionOnly()
      });
    });
  }
};
var getFilterValue = (that, state) => {
  const filterSyncController = that.getController("filterSync");
  const columnsController = that.getController("columns");
  const hasFilterState = state.columns || void 0 !== state.filterValue;
  if (filterSyncController) {
    if (hasFilterState) {
      return state.filterValue || filterSyncController.getFilterValueFromColumns(state.columns);
    }
    return that._initialFilterValue || filterSyncController.getFilterValueFromColumns(columnsController.getColumns());
  }
  return null;
};
var rowsView = (Base) => class extends Base {
  init() {
    super.init();
    this._dataController.stateLoaded.add(() => {
      if (this._dataController.isLoaded() && !this._dataController.getDataSource()) {
        this.setLoading(false);
        this.renderNoDataText();
        const columnHeadersView10 = this.component.getView("columnHeadersView");
        columnHeadersView10 && columnHeadersView10.render();
        this.component._fireContentReadyAction();
      }
    });
  }
};
var stateStoring = (Base) => class extends Base {
  init() {
    super.init.apply(this, arguments);
    processLoadState(this);
    return this;
  }
  isLoading() {
    return super.isLoading() || this.getDataController().isStateLoading();
  }
  state(state) {
    const result2 = super.state.apply(this, arguments);
    if (void 0 !== state) {
      this.applyState(extend(true, {}, state));
    }
    return result2;
  }
  updateState(state) {
    if (this.isEnabled()) {
      const oldState = this.state();
      const newState = extend({}, oldState, state);
      const oldStateHash = getKeyHash(oldState);
      const newStateHash = getKeyHash(newState);
      if (!equalByValue(oldStateHash, newStateHash)) {
        state = extend(true, {}, state);
        extend(this._state, state);
        this.save();
      }
    } else {
      extend(this._state, state);
    }
  }
  applyState(state) {
    var _this$getView;
    const {
      allowedPageSizes
    } = state;
    const {
      searchText
    } = state;
    const {
      selectedRowKeys
    } = state;
    const {
      selectionFilter
    } = state;
    const scrollingMode = this.option("scrolling.mode");
    const isVirtualScrollingMode = "virtual" === scrollingMode || "infinite" === scrollingMode;
    const showPageSizeSelector = true === this.option("pager.visible") && this.option("pager.showPageSizeSelector");
    const hasHeight = null === (_this$getView = this.getView("rowsView")) || void 0 === _this$getView ? void 0 : _this$getView.hasHeight();
    this.component.beginUpdate();
    if (this.getColumnsController()) {
      this.getColumnsController().setUserState(state.columns);
    }
    if (this.getExportController()) {
      this.getExportController().selectionOnly(state.exportSelectionOnly);
    }
    if (!this.option("selection.deferred")) {
      this.option("selectedRowKeys", selectedRowKeys || []);
    }
    this.option("selectionFilter", selectionFilter);
    if (allowedPageSizes && "auto" === this.option("pager.allowedPageSizes")) {
      this.option("pager").allowedPageSizes = allowedPageSizes;
    }
    if (this.option("focusedRowEnabled")) {
      this.option("focusedRowIndex", -1);
      this.option("focusedRowKey", state.focusedRowKey ?? null);
    }
    this.component.endUpdate();
    this.option("searchPanel.text", searchText || "");
    this.option("filterValue", getFilterValue(this, state));
    this.option("filterPanel.filterEnabled", state.filterPanel ? state.filterPanel.filterEnabled : true);
    this.option("paging.pageIndex", (!isVirtualScrollingMode || hasHeight) && state.pageIndex || 0);
    this.option("paging.pageSize", (!isVirtualScrollingMode || showPageSizeSelector) && isDefined(state.pageSize) ? state.pageSize : this._initialPageSize);
    this.getDataController() && this.getDataController().reset();
  }
};
var columns = (Base) => class extends Base {
  _shouldReturnVisibleColumns() {
    const result2 = super._shouldReturnVisibleColumns.apply(this, arguments);
    return result2 && (!this._stateStoringController.isEnabled() || this._stateStoringController.isLoaded());
  }
};
var data3 = (Base) => class extends Base {
  dispose() {
    clearTimeout(this._restoreStateTimeoutID);
    super.dispose();
  }
  callbackNames() {
    return super.callbackNames().concat(["stateLoaded"]);
  }
  _refreshDataSource() {
    if (this._stateStoringController.isEnabled() && !this._stateStoringController.isLoaded()) {
      clearTimeout(this._restoreStateTimeoutID);
      const deferred = new Deferred();
      this._restoreStateTimeoutID = setTimeout(() => {
        this._stateStoringController.load().always(() => {
          this._restoreStateTimeoutID = null;
        }).done(() => {
          super._refreshDataSource();
          this.stateLoaded.fire();
          deferred.resolve();
        }).fail((error2) => {
          this.stateLoaded.fire();
          this._handleLoadError(error2 || "Unknown error");
          deferred.reject();
        });
      });
      return deferred.promise();
    }
    if (!this.isStateLoading()) {
      super._refreshDataSource();
    }
  }
  isLoading() {
    return super.isLoading() || this._stateStoringController.isLoading();
  }
  isStateLoading() {
    return isDefined(this._restoreStateTimeoutID);
  }
  isLoaded() {
    return super.isLoaded() && !this.isStateLoading();
  }
};
var selection = (Base) => class extends Base {
  _fireSelectionChanged(options2) {
    const isDeferredSelection = this.option("selection.deferred");
    if (this._stateStoringController.isLoading() && isDeferredSelection) {
      return;
    }
    super._fireSelectionChanged.apply(this, arguments);
  }
};
var stateStoringModule = {
  defaultOptions: () => ({
    stateStoring: {
      enabled: false,
      storageKey: null,
      type: "localStorage",
      customLoad: null,
      customSave: null,
      savingTimeout: 2e3
    }
  }),
  controllers: {
    stateStoring: StateStoringController
  },
  extenders: {
    views: {
      rowsView
    },
    controllers: {
      stateStoring,
      columns,
      data: data3,
      selection
    }
  }
};

// node_modules/devextreme/esm/__internal/grids/data_grid/module_not_extended/state_storing.js
m_core_default.registerModule("stateStoring", stateStoringModule);

// node_modules/devextreme/esm/__internal/grids/grid_core/selection/m_selection.js
var CHECKBOXES_HIDDEN_CLASS = "dx-select-checkboxes-hidden";
var SHOW_CHECKBOXES_MODE = "selection.showCheckBoxesMode";
var SELECTION_MODE = "selection.mode";
var processLongTap = function(that, dxEvent) {
  const rowsView18 = that.getView("rowsView");
  const selectionController = that.getController("selection");
  const $row = renderer_default(dxEvent.target).closest(".dx-data-row");
  const rowIndex = rowsView18.getRowIndex($row);
  if (rowIndex < 0) {
    return;
  }
  if ("onLongTap" === that.option(SHOW_CHECKBOXES_MODE)) {
    if (selectionController.isSelectionWithCheckboxes()) {
      selectionController.stopSelectionWithCheckboxes();
    } else {
      selectionController.startSelectionWithCheckboxes();
    }
  } else {
    if ("onClick" === that.option(SHOW_CHECKBOXES_MODE)) {
      selectionController.startSelectionWithCheckboxes();
    }
    if ("always" !== that.option(SHOW_CHECKBOXES_MODE)) {
      selectionController.changeItemSelection(rowIndex, {
        control: true
      });
    }
  }
};
var isSeveralRowsSelected = function(that, selectionFilter) {
  let keyIndex = 0;
  const store = that._dataController.store();
  const key = null === store || void 0 === store ? void 0 : store.key();
  const isComplexKey = Array.isArray(key);
  if (!selectionFilter.length) {
    return false;
  }
  if (isComplexKey && Array.isArray(selectionFilter[0]) && "and" === selectionFilter[1]) {
    for (let i = 0; i < selectionFilter.length; i++) {
      if (Array.isArray(selectionFilter[i])) {
        if (selectionFilter[i][0] !== key[keyIndex] || "=" !== selectionFilter[i][1]) {
          return true;
        }
        keyIndex++;
      }
    }
    return false;
  }
  return key !== selectionFilter[0];
};
var selectionCellTemplate = (container, options2) => {
  const {
    component
  } = options2;
  const rowsView18 = component.getView("rowsView");
  if (component.option("renderAsync") && !component.option("selection.deferred")) {
    options2.value = component.isRowSelected(options2.row.key);
  }
  rowsView18.renderSelectCheckBoxContainer(renderer_default(container), options2);
};
var selectionHeaderTemplate = (container, options2) => {
  const {
    column
  } = options2;
  const $cellElement = renderer_default(container);
  const columnHeadersView10 = options2.component.getView("columnHeadersView");
  $cellElement.addClass("dx-editor-cell");
  columnHeadersView10._renderSelectAllCheckBox($cellElement, column);
  columnHeadersView10._attachSelectAllCheckBoxClickEvent($cellElement);
};
var SelectionController = class extends m_modules_default.Controller {
  init() {
    const {
      deferred,
      selectAllMode,
      mode
    } = this.option("selection") ?? {};
    if ("infinite" === this.option("scrolling.mode") && !deferred && "multiple" === mode && "allPages" === selectAllMode) {
      ui_errors_default.log("W1018");
    }
    this._dataController = this.getController("data");
    this._columnsController = this.getController("columns");
    this._stateStoringController = this.getController("stateStoring");
    this._selectionMode = mode;
    this._isSelectionWithCheckboxes = false;
    this._selection = this._createSelection();
    this._updateSelectColumn();
    this.createAction("onSelectionChanged", {
      excludeValidators: ["disabled", "readOnly"]
    });
    if (!this._dataPushedHandler) {
      this._dataPushedHandler = this._handleDataPushed.bind(this);
      this._dataController.pushed.add(this._dataPushedHandler);
    }
  }
  _handleDataPushed(changes) {
    this._deselectRemovedOnPush(changes);
    this._updateSelectedOnPush(changes);
  }
  _deselectRemovedOnPush(changes) {
    const isDeferredSelection = this.option("selection.deferred");
    let removedKeys = changes.filter((change) => "remove" === change.type).map((change) => change.key);
    if (isDeferredSelection) {
      const selectedKeys = this._dataController.items().filter((item) => item.isSelected).map((item) => item.key);
      removedKeys = removedKeys.filter((key) => selectedKeys.find((selectedKey) => equalByValue(selectedKey, key)));
    }
    removedKeys.length && this.deselectRows(removedKeys);
  }
  _updateSelectedOnPush(changes) {
    const isDeferredSelection = this.option("selection.deferred");
    if (isDeferredSelection) {
      return;
    }
    const updateChanges = changes.filter((change) => "update" === change.type);
    const data17 = this.getSelectedRowsData();
    applyBatch({
      keyInfo: this._selection.options,
      data: data17,
      changes: updateChanges
    });
  }
  _getSelectionConfig() {
    const dataController2 = this._dataController;
    const columnsController = this._columnsController;
    const selectionOptions = this.option("selection") ?? {};
    const {
      deferred
    } = selectionOptions;
    const scrollingMode = this.option("scrolling.mode");
    const virtualPaging = "virtual" === scrollingMode || "infinite" === scrollingMode;
    const allowSelectAll = this.option("selection.allowSelectAll");
    const legacyScrollingMode = this.option("scrolling.legacyMode");
    return {
      selectedKeys: this.option("selectedRowKeys"),
      mode: this._selectionMode,
      deferred,
      alwaysSelectByShift: selectionOptions.alwaysSelectByShift,
      maxFilterLengthInRequest: selectionOptions.maxFilterLengthInRequest,
      selectionFilter: this.option("selectionFilter"),
      ignoreDisabledItems: true,
      isVirtualPaging: virtualPaging,
      sensitivity: this.option("selection.sensitivity"),
      allowLoadByRange() {
        const hasGroupColumns = columnsController.getGroupColumns().length > 0;
        return virtualPaging && !legacyScrollingMode && !hasGroupColumns && allowSelectAll && !deferred;
      },
      key: () => null === dataController2 || void 0 === dataController2 ? void 0 : dataController2.key(),
      keyOf: (item) => null === dataController2 || void 0 === dataController2 ? void 0 : dataController2.keyOf(item),
      dataFields() {
        var _dataController$dataS;
        return null === (_dataController$dataS = dataController2.dataSource()) || void 0 === _dataController$dataS ? void 0 : _dataController$dataS.select();
      },
      load(options2) {
        var _dataController$dataS2;
        return (null === (_dataController$dataS2 = dataController2.dataSource()) || void 0 === _dataController$dataS2 ? void 0 : _dataController$dataS2.load(options2)) || new Deferred().resolve([]);
      },
      plainItems: (cached) => dataController2.items(true),
      isItemSelected: (item) => item.selected,
      isSelectableItem: (item) => "data" === (null === item || void 0 === item ? void 0 : item.rowType) && !item.isNewRow,
      getItemData: (item) => isDefined(null === item || void 0 === item ? void 0 : item.rowType) ? (null === item || void 0 === item ? void 0 : item.oldData) || (null === item || void 0 === item ? void 0 : item.data) : item,
      filter: () => dataController2.getCombinedFilter(deferred),
      totalCount: () => dataController2.totalCount(),
      getLoadOptions(loadItemIndex, focusedItemIndex, shiftItemIndex) {
        var _dataController$dataS3;
        const {
          sort,
          filter
        } = (null === (_dataController$dataS3 = dataController2.dataSource()) || void 0 === _dataController$dataS3 ? void 0 : _dataController$dataS3.lastLoadOptions()) ?? {};
        let minIndex = Math.min(loadItemIndex, focusedItemIndex);
        let maxIndex = Math.max(loadItemIndex, focusedItemIndex);
        if (isDefined(shiftItemIndex)) {
          minIndex = Math.min(shiftItemIndex, minIndex);
          maxIndex = Math.max(shiftItemIndex, maxIndex);
        }
        const take = maxIndex - minIndex + 1;
        return {
          skip: minIndex,
          take,
          filter,
          sort
        };
      },
      onSelectionChanged: this._updateSelectedItems.bind(this)
    };
  }
  _updateSelectColumn() {
    const columnsController = this._columnsController;
    const isSelectColumnVisible = this.isSelectColumnVisible();
    columnsController.addCommandColumn({
      type: "selection",
      command: "select",
      visible: isSelectColumnVisible,
      visibleIndex: -1,
      dataType: "boolean",
      alignment: "center",
      cssClass: "dx-command-select",
      width: "auto",
      cellTemplate: selectionCellTemplate,
      headerCellTemplate: selectionHeaderTemplate
    });
    columnsController.columnOption("command:select", "visible", isSelectColumnVisible);
  }
  _createSelection() {
    const options2 = this._getSelectionConfig();
    return new Selection(options2);
  }
  _fireSelectionChanged(options2) {
    const argument = this.option("selection.deferred") ? {
      selectionFilter: this.option("selectionFilter")
    } : {
      selectedRowKeys: this.option("selectedRowKeys")
    };
    this.selectionChanged.fire(argument);
    if (options2) {
      this.executeAction("onSelectionChanged", options2);
    }
  }
  _updateCheckboxesState(options2) {
    const {
      isDeferredMode
    } = options2;
    const {
      selectionFilter
    } = options2;
    const {
      selectedItemKeys
    } = options2;
    const {
      removedItemKeys
    } = options2;
    if ("onClick" === this.option(SHOW_CHECKBOXES_MODE)) {
      if (isDeferredMode ? selectionFilter && isSeveralRowsSelected(this, selectionFilter) : selectedItemKeys.length > 1) {
        this.startSelectionWithCheckboxes();
      } else if (isDeferredMode ? selectionFilter && !selectionFilter.length : 0 === selectedItemKeys.length && removedItemKeys.length) {
        this.stopSelectionWithCheckboxes();
      }
    }
  }
  _updateSelectedItems(args) {
    const that = this;
    let selectionChangedOptions;
    const isDeferredMode = that.option("selection.deferred");
    const selectionFilter = that._selection.selectionFilter();
    const dataController2 = that._dataController;
    const items = dataController2.items(true);
    const visibleItems = dataController2.items();
    if (!items) {
      return;
    }
    const isSelectionWithCheckboxes = that.isSelectionWithCheckboxes();
    const changedItemIndexes = that.getChangedItemIndexes(items);
    const visibleChangedItemIndexes = that.getChangedItemIndexes(visibleItems);
    that._updateCheckboxesState({
      selectedItemKeys: args.selectedItemKeys,
      removedItemKeys: args.removedItemKeys,
      selectionFilter,
      isDeferredMode
    });
    if (changedItemIndexes.length || isSelectionWithCheckboxes !== that.isSelectionWithCheckboxes()) {
      dataController2.updateItems({
        changeType: "updateSelection",
        itemIndexes: visibleChangedItemIndexes
      });
    }
    if (isDeferredMode) {
      that.option("selectionFilter", selectionFilter);
      selectionChangedOptions = {};
    } else if (args.addedItemKeys.length || args.removedItemKeys.length) {
      that._selectedItemsInternalChange = true;
      that.option("selectedRowKeys", args.selectedItemKeys.slice(0));
      that._selectedItemsInternalChange = false;
      selectionChangedOptions = {
        selectedRowsData: args.selectedItems.slice(0),
        selectedRowKeys: args.selectedItemKeys.slice(0),
        currentSelectedRowKeys: args.addedItemKeys.slice(0),
        currentDeselectedRowKeys: args.removedItemKeys.slice(0)
      };
    }
    that._fireSelectionChanged(selectionChangedOptions);
  }
  getChangedItemIndexes(items) {
    const that = this;
    const itemIndexes = [];
    const isDeferredSelection = this.option("selection.deferred");
    for (let i = 0, {
      length
    } = items; i < length; i++) {
      const row = items[i];
      const isItemSelected = that.isRowSelected(isDeferredSelection ? row.data : row.key);
      if (that._selection.isDataItem(row) && row.isSelected !== isItemSelected) {
        itemIndexes.push(i);
      }
    }
    return itemIndexes;
  }
  callbackNames() {
    return ["selectionChanged"];
  }
  optionChanged(args) {
    var _this$_selection;
    super.optionChanged(args);
    const selectionOptionsExists = !!(null !== (_this$_selection = this._selection) && void 0 !== _this$_selection && _this$_selection.options);
    switch (args.name) {
      case "selection": {
        const oldSelectionMode = this._selectionMode;
        this.init();
        if (selectionOptionsExists && "selection.sensitivity" === args.fullName) {
          this._selection.options.sensitivity = args.value;
        }
        if ("selection.showCheckBoxesMode" !== args.fullName) {
          const selectionMode = this._selectionMode;
          let selectedRowKeys = this.option("selectedRowKeys");
          if (oldSelectionMode !== selectionMode) {
            if ("single" === selectionMode) {
              if (selectedRowKeys.length > 1) {
                selectedRowKeys = [selectedRowKeys[0]];
              }
            } else if ("multiple" !== selectionMode) {
              selectedRowKeys = [];
            }
          }
          this.selectRows(selectedRowKeys).always(() => {
            this._fireSelectionChanged();
          });
        }
        this._columnsController.updateColumns();
        args.handled = true;
        break;
      }
      case "selectionFilter":
        this._selection.selectionFilter(args.value);
        args.handled = true;
        break;
      case "selectedRowKeys": {
        const value2 = args.value || [];
        if (Array.isArray(value2) && !this._selectedItemsInternalChange && (this.component.getDataSource() || !value2.length)) {
          this.selectRows(value2);
        }
        args.handled = true;
        break;
      }
    }
  }
  publicMethods() {
    return ["selectRows", "deselectRows", "selectRowsByIndexes", "getSelectedRowKeys", "getSelectedRowsData", "clearSelection", "selectAll", "deselectAll", "startSelectionWithCheckboxes", "stopSelectionWithCheckboxes", "isRowSelected"];
  }
  isRowSelected(arg) {
    return this._selection.isItemSelected(arg);
  }
  isSelectColumnVisible() {
    return "multiple" === this.option(SELECTION_MODE) && ("always" === this.option(SHOW_CHECKBOXES_MODE) || "onClick" === this.option(SHOW_CHECKBOXES_MODE) || this._isSelectionWithCheckboxes);
  }
  _isOnePageSelectAll() {
    return "page" === this.option("selection.selectAllMode");
  }
  isSelectAll() {
    return this._selection.getSelectAllState(this._isOnePageSelectAll());
  }
  selectAll() {
    if ("onClick" === this.option(SHOW_CHECKBOXES_MODE)) {
      this.startSelectionWithCheckboxes();
    }
    return this._selection.selectAll(this._isOnePageSelectAll());
  }
  deselectAll() {
    return this._selection.deselectAll(this._isOnePageSelectAll());
  }
  clearSelection() {
    return this.selectedItemKeys([]);
  }
  refresh() {
    const selectedRowKeys = this.option("selectedRowKeys") ?? [];
    if (!this.option("selection.deferred") && selectedRowKeys.length) {
      return this.selectedItemKeys(selectedRowKeys);
    }
    return new Deferred().resolve().promise();
  }
  selectedItemKeys(value2, preserve, isDeselect, isSelectAll) {
    return this._selection.selectedItemKeys(value2, preserve, isDeselect, isSelectAll);
  }
  getSelectedRowKeys(mode) {
    return this._selection.getSelectedItemKeys();
  }
  selectRows(keys, preserve) {
    return this.selectedItemKeys(keys, preserve);
  }
  deselectRows(keys) {
    return this.selectedItemKeys(keys, true, true);
  }
  selectRowsByIndexes(indexes) {
    const items = this._dataController.items();
    const keys = [];
    if (!Array.isArray(indexes)) {
      indexes = Array.prototype.slice.call(arguments, 0);
    }
    each(indexes, function() {
      const item = items[this];
      if (item && "data" === item.rowType) {
        keys.push(item.key);
      }
    });
    return this.selectRows(keys);
  }
  getSelectedRowsData(mode) {
    return this._selection.getSelectedItems();
  }
  loadSelectedItemsWithFilter() {
    return this._selection.loadSelectedItemsWithFilter();
  }
  changeItemSelection(visibleItemIndex, keys, setFocusOnly) {
    keys = keys || {};
    if (this.isSelectionWithCheckboxes()) {
      keys.control = true;
    }
    const loadedItemIndex = visibleItemIndex + this._dataController.getRowIndexOffset() - this._dataController.getRowIndexOffset(true);
    return this._selection.changeItemSelection(loadedItemIndex, keys, setFocusOnly);
  }
  focusedItemIndex(itemIndex) {
    const that = this;
    if (isDefined(itemIndex)) {
      that._selection._focusedItemIndex = itemIndex;
    } else {
      return that._selection._focusedItemIndex;
    }
    return;
  }
  isSelectionWithCheckboxes() {
    return "multiple" === this.option(SELECTION_MODE) && ("always" === this.option(SHOW_CHECKBOXES_MODE) || this._isSelectionWithCheckboxes);
  }
  startSelectionWithCheckboxes() {
    const that = this;
    if ("multiple" === that.option(SELECTION_MODE) && !that.isSelectionWithCheckboxes()) {
      that._isSelectionWithCheckboxes = true;
      that._updateSelectColumn();
      return true;
    }
    return false;
  }
  stopSelectionWithCheckboxes() {
    const that = this;
    if (that._isSelectionWithCheckboxes) {
      that._isSelectionWithCheckboxes = false;
      that._updateSelectColumn();
      return true;
    }
    return false;
  }
};
var dataSelectionExtenderMixin = (Base) => class extends Base {
  init() {
    const isDeferredMode = this.option("selection.deferred");
    super.init.apply(this, arguments);
    if (isDeferredMode) {
      this._selectionController._updateCheckboxesState({
        isDeferredMode: true,
        selectionFilter: this.option("selectionFilter")
      });
    }
  }
  _loadDataSource() {
    const that = this;
    return super._loadDataSource().always(() => {
      that._selectionController.refresh();
    });
  }
  _processDataItem(item, options2) {
    const hasSelectColumn = this._selectionController.isSelectColumnVisible();
    const isDeferredSelection = options2.isDeferredSelection = void 0 === options2.isDeferredSelection ? this.option("selection.deferred") : options2.isDeferredSelection;
    const dataItem = super._processDataItem.apply(this, arguments);
    dataItem.isSelected = this._selectionController.isRowSelected(isDeferredSelection ? dataItem.data : dataItem.key);
    if (hasSelectColumn && dataItem.values) {
      for (let i = 0; i < options2.visibleColumns.length; i++) {
        if ("select" === options2.visibleColumns[i].command) {
          dataItem.values[i] = dataItem.isSelected;
          break;
        }
      }
    }
    return dataItem;
  }
  refresh(options2) {
    const that = this;
    const d = new Deferred();
    super.refresh.apply(this, arguments).done(() => {
      if (!options2 || options2.selection) {
        that._selectionController.refresh().done(d.resolve).fail(d.reject);
      } else {
        d.resolve();
      }
    }).fail(d.reject);
    return d.promise();
  }
  _handleDataChanged(e) {
    const hasLoadOperation = this.hasLoadOperation();
    super._handleDataChanged.apply(this, arguments);
    if (hasLoadOperation && !this._repaintChangesOnly) {
      this._selectionController.focusedItemIndex(-1);
    }
  }
  _applyChange(change) {
    if (change && "updateSelection" === change.changeType) {
      change.items.forEach((item, index2) => {
        const currentItem = this._items[index2];
        if (currentItem) {
          currentItem.isSelected = item.isSelected;
          currentItem.values = item.values;
        }
      });
      return;
    }
    return super._applyChange.apply(this, arguments);
  }
  _endUpdateCore() {
    const changes = this._changes;
    const isUpdateSelection = changes.length > 1 && changes.every((change) => "updateSelection" === change.changeType);
    if (isUpdateSelection) {
      const itemIndexes = changes.map((change) => change.itemIndexes || []).reduce((a, b) => a.concat(b));
      this._changes = [{
        changeType: "updateSelection",
        itemIndexes
      }];
    }
    super._endUpdateCore.apply(this, arguments);
  }
};
var contextMenu = (Base) => class extends Base {
  _contextMenuPrepared(options2) {
    const dxEvent = options2.event;
    if (dxEvent.originalEvent && "dxhold" !== dxEvent.originalEvent.type || options2.items && options2.items.length > 0) {
      return;
    }
    processLongTap(this, dxEvent);
  }
};
var columnHeadersSelectionExtenderMixin = (Base) => class extends Base {
  init() {
    super.init();
    this._selectionController.selectionChanged.add(this._updateSelectAllValue.bind(this));
  }
  _updateSelectAllValue() {
    const that = this;
    const $element = that.element();
    const $editor = null === $element || void 0 === $element ? void 0 : $element.find(".dx-select-checkbox");
    if ($element && $editor.length && "multiple" === that.option("selection.mode")) {
      const selectAllValue = that._selectionController.isSelectAll();
      const hasSelection = false !== selectAllValue;
      const isVisible2 = that.option("selection.allowSelectAll") ? !that._dataController.isEmpty() : hasSelection;
      $editor.dxCheckBox("instance").option({
        visible: isVisible2,
        value: selectAllValue
      });
    }
  }
  _handleDataChanged(e) {
    super._handleDataChanged(e);
    if (!e || "refresh" === e.changeType || e.repaintChangesOnly && "update" === e.changeType) {
      this.waitAsyncTemplates().done(() => {
        this._updateSelectAllValue();
      });
    }
  }
  _renderSelectAllCheckBox($container, column) {
    const that = this;
    const isEmptyData = that._dataController.isEmpty();
    const groupElement = renderer_default("<div>").appendTo($container).addClass("dx-select-checkbox");
    that.setAria("label", message_default.format("dxDataGrid-ariaSelectAll"), groupElement);
    that._editorFactoryController.createEditor(groupElement, extend({}, column, {
      parentType: "headerRow",
      dataType: "boolean",
      value: this._selectionController.isSelectAll(),
      editorOptions: {
        visible: !isEmptyData && (that.option("selection.allowSelectAll") || false !== this._selectionController.isSelectAll())
      },
      tabIndex: that.option("useLegacyKeyboardNavigation") ? -1 : that.option("tabIndex") || 0,
      setValue: (value2, e) => {
        const allowSelectAll = that.option("selection.allowSelectAll");
        e.component.option("visible", allowSelectAll || false !== e.component.option("value"));
        if (!e.event || this._selectionController.isSelectAll() === value2) {
          return;
        }
        if (e.value && !allowSelectAll) {
          e.component.option("value", false);
        } else {
          e.value ? this._selectionController.selectAll() : this._selectionController.deselectAll();
        }
        e.event.preventDefault();
      }
    }));
    return groupElement;
  }
  _attachSelectAllCheckBoxClickEvent($element) {
    m_events_engine_default.on($element, CLICK_EVENT_NAME, this.createAction((e) => {
      const {
        event
      } = e;
      if (!renderer_default(event.target).closest(".dx-select-checkbox").length) {
        m_events_engine_default.trigger(renderer_default(event.currentTarget).children(".dx-select-checkbox"), CLICK_EVENT_NAME);
      }
      event.preventDefault();
    }));
  }
};
var rowsViewSelectionExtenderMixin = (Base) => class extends Base {
  renderSelectCheckBoxContainer($container, options2) {
    if ("data" === options2.rowType && !options2.row.isNewRow) {
      $container.addClass("dx-editor-cell");
      this._attachCheckBoxClickEvent($container);
      this._renderSelectCheckBox($container, options2);
    } else {
      m_utils_default.setEmptyText($container);
    }
  }
  _renderSelectCheckBox(container, options2) {
    const groupElement = renderer_default("<div>").addClass("dx-select-checkbox").appendTo(container);
    this.setAria("label", message_default.format("dxDataGrid-ariaSelectRow"), groupElement);
    this._editorFactoryController.createEditor(groupElement, extend({}, options2.column, {
      parentType: "dataRow",
      dataType: "boolean",
      lookup: null,
      value: options2.value,
      setValue(value2, e) {
        var _e$event;
        if ("keydown" === (null === e || void 0 === e || null === (_e$event = e.event) || void 0 === _e$event ? void 0 : _e$event.type)) {
          m_events_engine_default.trigger(e.element, CLICK_EVENT_NAME, e);
        }
      },
      row: options2.row
    }));
    return groupElement;
  }
  _attachCheckBoxClickEvent($element) {
    m_events_engine_default.on($element, CLICK_EVENT_NAME, this.createAction(function(e) {
      const {
        event
      } = e;
      const rowIndex = this.getRowIndex(renderer_default(event.currentTarget).closest(".dx-row"));
      if (rowIndex >= 0) {
        this._selectionController.startSelectionWithCheckboxes();
        this._selectionController.changeItemSelection(rowIndex, {
          shift: event.shiftKey
        });
        if (renderer_default(event.target).closest(".dx-select-checkbox").length) {
          this._dataController.updateItems({
            changeType: "updateSelection",
            itemIndexes: [rowIndex]
          });
        }
      }
    }));
  }
  _update(change) {
    const that = this;
    const tableElements = that.getTableElements();
    if ("updateSelection" === change.changeType) {
      if (tableElements.length > 0) {
        each(tableElements, (_, tableElement) => {
          each(change.itemIndexes || [], (_2, index2) => {
            let $row;
            if (change.items[index2]) {
              $row = that._getRowElements(renderer_default(tableElement)).eq(index2);
              if ($row.length) {
                const {
                  isSelected
                } = change.items[index2];
                $row.toggleClass("dx-selection", void 0 === isSelected ? false : isSelected).find(".dx-select-checkbox").dxCheckBox("option", "value", isSelected);
                that.setAria("selected", isSelected, $row);
              }
            }
          });
        });
        that._updateCheckboxesClass();
      }
    } else {
      super._update(change);
    }
  }
  _createTable() {
    const that = this;
    const selectionMode = that.option("selection.mode");
    const $table = super._createTable.apply(that, arguments);
    if ("none" !== selectionMode) {
      if ("onLongTap" === that.option(SHOW_CHECKBOXES_MODE) || !m_support_default.touch) {
        m_events_engine_default.on($table, addNamespace2(m_hold_default.name, "dxDataGridRowsView"), ".dx-data-row", that.createAction((e) => {
          processLongTap(that.component, e.event);
          e.event.stopPropagation();
        }));
      }
      m_events_engine_default.on($table, "mousedown selectstart", that.createAction((e) => {
        const {
          event
        } = e;
        if (event.shiftKey) {
          event.preventDefault();
        }
      }));
    }
    return $table;
  }
  _createRow(row) {
    const $row = super._createRow.apply(this, arguments);
    if (row) {
      const {
        isSelected
      } = row;
      if (isSelected) {
        $row.addClass("dx-selection");
      }
      const selectionMode = this.option(SELECTION_MODE);
      if ("none" !== selectionMode) {
        this.setAria("selected", isSelected, $row);
      }
    }
    return $row;
  }
  _rowClickForTreeList(e) {
    super._rowClick(e);
  }
  _rowClick(e) {
    const that = this;
    const dxEvent = e.event;
    const isSelectionDisabled = renderer_default(dxEvent.target).closest(".dx-selection-disabled").length;
    if (!that.isClickableElement(renderer_default(dxEvent.target))) {
      if (!isSelectionDisabled && ("multiple" !== that.option(SELECTION_MODE) || "always" !== that.option(SHOW_CHECKBOXES_MODE))) {
        if (that._selectionController.changeItemSelection(e.rowIndex, {
          control: isCommandKeyPressed(dxEvent),
          shift: dxEvent.shiftKey
        })) {
          dxEvent.preventDefault();
          e.handled = true;
        }
      }
      super._rowClick(e);
    }
  }
  isClickableElement($target) {
    const isCommandSelect = $target.closest(".dx-command-select").length;
    return !!isCommandSelect;
  }
  _renderCore(change) {
    const deferred = super._renderCore(change);
    this._updateCheckboxesClass();
    return deferred;
  }
  _updateCheckboxesClass() {
    const tableElements = this.getTableElements();
    const isCheckBoxesHidden = this._selectionController.isSelectColumnVisible() && !this._selectionController.isSelectionWithCheckboxes();
    each(tableElements, (_, tableElement) => {
      renderer_default(tableElement).toggleClass(CHECKBOXES_HIDDEN_CLASS, isCheckBoxesHidden);
    });
  }
};
var selectionModule = {
  defaultOptions: () => ({
    selection: {
      mode: "none",
      showCheckBoxesMode: "onClick",
      allowSelectAll: true,
      selectAllMode: "allPages",
      deferred: false,
      maxFilterLengthInRequest: 1500,
      alwaysSelectByShift: false
    },
    selectionFilter: [],
    selectedRowKeys: []
  }),
  controllers: {
    selection: SelectionController
  },
  extenders: {
    controllers: {
      data: dataSelectionExtenderMixin,
      contextMenu
    },
    views: {
      columnHeadersView: columnHeadersSelectionExtenderMixin,
      rowsView: rowsViewSelectionExtenderMixin
    }
  }
};

// node_modules/devextreme/esm/__internal/grids/data_grid/module_not_extended/selection.js
m_core_default.registerModule("selection", selectionModule);

// node_modules/devextreme/esm/__internal/ui/check_box/check_box_icon.js
var _excluded7 = ["size"];
var defaultCheckBoxIconProps = {};
var CheckBoxIcon = class extends BaseInfernoComponent {
  constructor(props) {
    super(props);
    this.state = {};
    this.elementRef = createRef();
    this.__getterCache = {};
  }
  get cssStyles() {
    if (void 0 !== this.__getterCache.cssStyles) {
      return this.__getterCache.cssStyles;
    }
    return this.__getterCache.cssStyles = (() => {
      const {
        size
      } = this.props;
      const fontSize = normalizeStyleProp("fontSize", size);
      return {
        fontSize
      };
    })();
  }
  get restAttributes() {
    const _this$props = this.props, restProps = _objectWithoutPropertiesLoose(_this$props, _excluded7);
    return restProps;
  }
  componentWillUpdate(nextProps) {
    if (this.props.size !== nextProps.size) {
      this.__getterCache.cssStyles = void 0;
    }
  }
  render() {
    const {
      elementRef,
      cssStyles
    } = this;
    return createVNode(1, "span", "dx-checkbox-icon", null, 1, {
      style: normalizeStyles(cssStyles)
    }, null, elementRef);
  }
};
CheckBoxIcon.defaultProps = defaultCheckBoxIconProps;

// node_modules/devextreme/esm/__internal/core/r1/utils/get_updated_options.js
var defaultNotDeepCopyArrays = ["dataSource", "selectedRowKeys"];
var propsToIgnore = {
  integrationOptions: true
};
function getDiffItem(key, value2, previousValue) {
  return {
    path: key,
    value: value2,
    previousValue
  };
}
function compare2(resultPaths, item1, item2, key, fullPropName, notDeepCopyArrays) {
  if (propsToIgnore[key]) {
    return;
  }
  const type1 = type(item1);
  const type2 = type(item2);
  if (item1 === item2) {
    return;
  }
  if (type1 !== type2) {
    resultPaths.push(getDiffItem(key, item2, item1));
  } else if ("object" === type1) {
    if (!isPlainObject(item2)) {
      resultPaths.push(getDiffItem(key, item2, item1));
    } else {
      const diffPaths = objectDiffs(item1, item2, fullPropName, notDeepCopyArrays);
      resultPaths.push(...diffPaths.map((item) => _extends({}, item, {
        path: `${key}.${item.path}`
      })));
    }
  } else if ("array" === type1) {
    const notDeepCopy = notDeepCopyArrays.some((prop) => fullPropName.includes(prop));
    if (notDeepCopy && item1 !== item2) {
      resultPaths.push(getDiffItem(key, item2, item1));
    } else if (item1.length !== item2.length) {
      resultPaths.push(getDiffItem(key, item2, item1));
    } else {
      const diffPaths = objectDiffs(item1, item2, fullPropName, notDeepCopyArrays);
      [].push.apply(resultPaths, diffPaths.map((item) => _extends({}, item, {
        path: `${key}${item.path}`
      })));
    }
  } else {
    resultPaths.push(getDiffItem(key, item2, item1));
  }
}
var objectDiffsFiltered = (propsEnumerator) => (oldProps, props, fullPropName, notDeepCopyArrays) => {
  const resultPaths = [];
  const processItem = !Array.isArray(oldProps) ? (propName) => {
    compare2(resultPaths, oldProps[propName], props[propName], propName, `${fullPropName}.${propName}`, notDeepCopyArrays);
  } : (propName) => {
    compare2(resultPaths, oldProps[propName], props[propName], `[${propName}]`, `${fullPropName}.${propName}`, notDeepCopyArrays);
  };
  propsEnumerator(oldProps).forEach(processItem);
  Object.keys(props).filter((propName) => !Object.prototype.hasOwnProperty.call(oldProps, propName) && oldProps[propName] !== props[propName]).forEach((propName) => {
    resultPaths.push({
      path: propName,
      value: props[propName],
      previousValue: oldProps[propName]
    });
  });
  return resultPaths;
};
var objectDiffs = objectDiffsFiltered((oldProps) => Object.keys(oldProps));
var reactProps = {
  key: true,
  ref: true,
  children: true,
  style: true
};
var objectDiffsWithoutReactProps = objectDiffsFiltered((prop) => Object.keys(prop).filter((p2) => !reactProps[p2]));
function getUpdatedOptions(oldProps, props) {
  let notDeepCopyArrays = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : defaultNotDeepCopyArrays;
  return objectDiffsWithoutReactProps(oldProps, props, "", notDeepCopyArrays);
}

// node_modules/devextreme/esm/__internal/core/r1/dom_component_wrapper.js
var _excluded8 = ["componentProps", "componentType", "templateNames"];
var normalizeProps2 = (props) => Object.keys(props).reduce((accumulator, key) => {
  if (void 0 !== props[key]) {
    accumulator[key] = props[key];
  }
  return accumulator;
}, {});
var DomComponentWrapper = class extends InfernoComponent {
  constructor(props) {
    super(props);
    this.state = {};
    this.refs = null;
    this.widgetRef = createRef();
    this.instance = null;
    this.prevProps = null;
    this.getInstance = this.getInstance.bind(this);
    this.setupWidget = this.setupWidget.bind(this);
    this.updateWidget = this.updateWidget.bind(this);
  }
  getConfig() {
    const {
      id
    } = ConfigContext;
    if (this.context[id]) {
      return this.context[id];
    }
    return ConfigContext.defaultValue;
  }
  render() {
    return normalizeProps2(createVNode(1, "div", this.props.componentProps.className, null, 1, _extends({}, this.getRestAttributes()), null, this.widgetRef));
  }
  componentWillUpdate(nextProps, nextState, context2) {
    super.componentWillUpdate(nextProps, nextState, context2);
  }
  createEffects() {
    return [new InfernoEffect(this.setupWidget, []), new InfernoEffect(this.updateWidget, [this.props.componentProps, this.getConfig(), this.props.templateNames])];
  }
  updateEffects() {
    var _this$_effects$;
    const dependency = [this.props.componentProps, this.getConfig(), this.props.templateNames];
    null === (_this$_effects$ = this._effects[1]) || void 0 === _this$_effects$ || _this$_effects$.update(dependency);
  }
  setupWidget() {
    const current2 = this.widgetRef.current;
    const componentInstance = new this.props.componentType(current2, this.getProperties());
    this.instance = componentInstance;
    return () => {
      componentInstance.dispose();
      this.instance = null;
    };
  }
  updateWidget() {
    if (!this.instance) {
      return;
    }
    const updatedOptions = getUpdatedOptions(this.prevProps ?? {}, this.getProperties());
    if (updatedOptions.length) {
      this.instance.beginUpdate();
      updatedOptions.forEach((_ref2) => {
        var _this$instance;
        const {
          path,
          value: value2
        } = _ref2;
        null === (_this$instance = this.instance) || void 0 === _this$instance || _this$instance.option(path, value2);
      });
      this.instance.endUpdate();
    }
    this.prevProps = this.getProperties();
  }
  getRestAttributes() {
    const _this$props = this.props, restAttr = _objectWithoutPropertiesLoose(_this$props, _excluded8);
    return restAttr;
  }
  getProperties() {
    var _this$getConfig;
    const normalizedProps = normalizeProps2(this.props.componentProps);
    const {
      valueChange
    } = normalizedProps;
    const properties = extend({
      rtlEnabled: null === (_this$getConfig = this.getConfig()) || void 0 === _this$getConfig ? void 0 : _this$getConfig.rtlEnabled,
      isRenovated: true
    }, normalizedProps);
    if (valueChange) {
      properties.onValueChanged = (_ref3) => {
        const {
          value: value2
        } = _ref3;
        return valueChange(value2);
      };
    }
    const templates = this.props.templateNames;
    templates.forEach((name2) => {
      if (hasTemplate2(name2, properties, this)) {
        properties[name2] = (item, index2, container) => {
          renderTemplate(this.props.componentProps[name2], {
            item,
            index: index2,
            container
          }, this);
        };
      }
    });
    return properties;
  }
  getInstance() {
    return this.instance;
  }
};

// node_modules/devextreme/esm/__internal/ui/check_box/wrappers/validation_message.js
var _excluded9 = ["accessKey", "activeStateEnabled", "boundary", "className", "contentId", "disabled", "focusStateEnabled", "height", "hint", "hoverStateEnabled", "mode", "offset", "onClick", "onKeyDown", "positionSide", "rtlEnabled", "tabIndex", "target", "validationErrors", "visible", "visualContainer", "width"];
var defaultValidationMessageProps = _extends({}, BaseWidgetDefaultProps, {
  mode: "auto",
  positionSide: "top",
  offset: Object.freeze({
    h: 0,
    v: 0
  }),
  isReactComponentWrapper: true
});
var ValidationMessage2 = class extends BaseInfernoComponent {
  constructor(props) {
    super(props);
    this.state = {};
  }
  get restAttributes() {
    const _this$props = this.props, restProps = _objectWithoutPropertiesLoose(_this$props, _excluded9);
    return restProps;
  }
  render() {
    return normalizeProps(createComponentVNode(2, DomComponentWrapper, _extends({
      componentType: validation_message_default,
      componentProps: this.props,
      templateNames: []
    }, this.restAttributes)));
  }
};
ValidationMessage2.defaultProps = defaultValidationMessageProps;

// node_modules/devextreme/esm/__internal/ui/check_box/editor_base/editor.js
var _excluded10 = ["accessKey", "activeStateEnabled", "aria", "children", "className", "classes", "defaultValue", "disabled", "focusStateEnabled", "height", "hint", "hoverStateEnabled", "inputAttr", "isDirty", "isValid", "name", "onClick", "onFocusIn", "onKeyDown", "readOnly", "rtlEnabled", "tabIndex", "validationError", "validationErrors", "validationMessageMode", "validationMessagePosition", "validationStatus", "value", "valueChange", "visible", "width"];
var getCssClasses3 = (model) => {
  const {
    classes,
    isValid,
    readOnly
  } = model;
  const classesMap = {
    "dx-state-readonly": !!readOnly,
    "dx-invalid": !isValid,
    [String(classes)]: !!classes
  };
  return combineClasses2(classesMap);
};
var defaultEditorProps = _extends({}, WidgetDefaultProps, {
  readOnly: false,
  name: "",
  validationError: null,
  validationErrors: null,
  validationMessageMode: "auto",
  validationMessagePosition: "bottom",
  validationStatus: "valid",
  isValid: true,
  isDirty: false,
  inputAttr: {},
  defaultValue: null,
  valueChange: () => {
  }
});
var Editor2 = class extends InfernoWrapperComponent {
  constructor(props) {
    super(props);
    this.state = {};
    this.widgetRef = createRef();
    this.rootElementRef = createRef();
    this.__getterCache = {};
    this.state = {
      validationMessageGuid: `dx-${new guid_default2()}`,
      isValidationMessageVisible: false,
      value: void 0 !== this.props.value ? this.props.value : this.props.defaultValue
    };
    this.updateValidationMessageVisibility = this.updateValidationMessageVisibility.bind(this);
    this.focus = this.focus.bind(this);
    this.blur = this.blur.bind(this);
    this.onFocusIn = this.onFocusIn.bind(this);
  }
  createEffects() {
    return [new InfernoEffect(this.updateValidationMessageVisibility, [this.props.isValid, this.props.validationStatus, this.props.validationError, this.props.validationErrors]), createReRenderEffect()];
  }
  updateEffects() {
    var _this$_effects;
    null === (_this$_effects = this._effects) || void 0 === _this$_effects || null === (_this$_effects = _this$_effects[0]) || void 0 === _this$_effects || _this$_effects.update([this.props.isValid, this.props.validationStatus, this.props.validationError, this.props.validationErrors]);
  }
  updateValidationMessageVisibility() {
    this.setState(() => ({
      isValidationMessageVisible: this.shouldShowValidationMessage
    }));
  }
  onFocusIn(event) {
    const {
      onFocusIn
    } = this.props;
    null === onFocusIn || void 0 === onFocusIn || onFocusIn(event);
  }
  get cssClasses() {
    return `${getCssClasses3(_extends({}, this.props, { value: void 0 !== this.props.value ? this.props.value : this.state.value }))}`;
  }
  get shouldShowValidationMessage() {
    const {
      isValid,
      validationStatus
    } = this.props;
    const validationErrors = this.validationErrors ?? [];
    const isEditorValid = isValid && "invalid" !== validationStatus;
    return !isEditorValid && validationErrors.length > 0;
  }
  get aria() {
    const {
      isValid,
      readOnly
    } = this.props;
    const result2 = {
      readonly: readOnly ? "true" : "false",
      invalid: !isValid ? "true" : "false"
    };
    if (this.shouldShowValidationMessage) {
      result2.describedBy = this.state.validationMessageGuid;
    }
    return _extends({}, result2, this.props.aria);
  }
  get validationErrors() {
    if (void 0 !== this.__getterCache.validationErrors) {
      return this.__getterCache.validationErrors;
    }
    return this.__getterCache.validationErrors = (() => {
      const {
        validationError,
        validationErrors
      } = this.props;
      let allValidationErrors = validationErrors && [...validationErrors];
      if (!allValidationErrors && validationError) {
        allValidationErrors = [_extends({}, validationError)];
      }
      return allValidationErrors;
    })();
  }
  get validationMessageTarget() {
    var _this$rootElementRef;
    return null === (_this$rootElementRef = this.rootElementRef) || void 0 === _this$rootElementRef ? void 0 : _this$rootElementRef.current;
  }
  get restAttributes() {
    const _this$props = this.props, restProps = _objectWithoutPropertiesLoose(_this$props, _excluded10);
    return restProps;
  }
  focus() {
    this.widgetRef.current.focus();
  }
  blur() {
    this.widgetRef.current.blur();
  }
  componentWillUpdate(nextProps) {
    super.componentWillUpdate();
    if (this.props.validationError !== nextProps.validationError || this.props.validationErrors !== nextProps.validationErrors) {
      this.__getterCache.validationErrors = void 0;
    }
  }
  render() {
    return normalizeProps(createComponentVNode(2, Widget2, _extends({
      rootElementRef: this.rootElementRef,
      aria: this.aria,
      classes: this.cssClasses,
      activeStateEnabled: this.props.activeStateEnabled,
      focusStateEnabled: this.props.focusStateEnabled,
      hoverStateEnabled: this.props.hoverStateEnabled,
      accessKey: this.props.accessKey,
      className: this.props.className,
      rtlEnabled: this.props.rtlEnabled,
      hint: this.props.hint,
      disabled: this.props.disabled,
      height: this.props.height,
      width: this.props.width,
      onFocusIn: this.props.onFocusIn,
      onClick: this.props.onClick,
      onKeyDown: this.props.onKeyDown,
      tabIndex: this.props.tabIndex,
      visible: this.props.visible
    }, this.restAttributes, {
      children: createFragment([this.props.children, this.state.isValidationMessageVisible && createComponentVNode(2, ValidationMessage2, {
        validationErrors: this.validationErrors,
        mode: this.props.validationMessageMode,
        positionSide: this.props.validationMessagePosition,
        rtlEnabled: this.props.rtlEnabled,
        target: this.validationMessageTarget,
        boundary: this.validationMessageTarget,
        visualContainer: this.validationMessageTarget,
        contentId: this.state.validationMessageGuid
      })], 0)
    }), null, this.widgetRef));
  }
};
Editor2.defaultProps = defaultEditorProps;

// node_modules/devextreme/esm/__internal/ui/check_box/check_box.js
var _excluded11 = ["accessKey", "activeStateEnabled", "aria", "className", "classes", "defaultValue", "disabled", "enableThreeStateBehavior", "focusStateEnabled", "height", "hint", "hoverStateEnabled", "iconSize", "inputAttr", "isDirty", "isValid", "name", "onClick", "onFocusIn", "onKeyDown", "readOnly", "rtlEnabled", "saveValueChangeEvent", "tabIndex", "text", "validationError", "validationErrors", "validationMessageMode", "validationMessagePosition", "validationStatus", "value", "valueChange", "visible", "width"];
var getCssClasses4 = (model) => {
  const {
    text,
    value: value2
  } = model;
  const checked = value2;
  const indeterminate = null === checked;
  const classesMap = {
    "dx-checkbox": true,
    "dx-checkbox-checked": true === checked,
    "dx-checkbox-has-text": !!text,
    "dx-checkbox-indeterminate": indeterminate
  };
  return combineClasses2(classesMap);
};
var defaultCheckBoxProps = _extends({}, defaultEditorProps, {
  text: "",
  enableThreeStateBehavior: false,
  activeStateEnabled: true,
  hoverStateEnabled: true,
  get focusStateEnabled() {
    return "desktop" === devices_default.real().deviceType && !devices_default.isSimulator();
  },
  defaultValue: false,
  valueChange: () => {
  }
});
var CheckBox = class extends InfernoWrapperComponent {
  constructor(props) {
    super(props);
    this.editorRef = createRef();
    this.state = {
      value: void 0 !== this.props.value ? this.props.value : this.props.defaultValue
    };
    this.focus = this.focus.bind(this);
    this.blur = this.blur.bind(this);
    this.onWidgetClick = this.onWidgetClick.bind(this);
    this.keyDown = this.keyDown.bind(this);
  }
  createEffects() {
    return [createReRenderEffect()];
  }
  onWidgetClick(event) {
    const {
      enableThreeStateBehavior,
      readOnly,
      saveValueChangeEvent
    } = this.props;
    if (!readOnly) {
      null === saveValueChangeEvent || void 0 === saveValueChangeEvent || saveValueChangeEvent(event);
      if (enableThreeStateBehavior) {
        var _this$props$valueChan, _this$props;
        let __newValue;
        this.setState((__state_argument) => {
          __newValue = null === (void 0 !== this.props.value ? this.props.value : __state_argument.value) || (!(void 0 !== this.props.value ? this.props.value : __state_argument.value) ? null : false);
          return {
            value: __newValue
          };
        });
        null === (_this$props$valueChan = (_this$props = this.props).valueChange) || void 0 === _this$props$valueChan || _this$props$valueChan.call(_this$props, __newValue);
      } else {
        var _this$props$valueChan2, _this$props2;
        let __newValue;
        this.setState((__state_argument) => {
          __newValue = !((void 0 !== this.props.value ? this.props.value : __state_argument.value) ?? false);
          return {
            value: __newValue
          };
        });
        null === (_this$props$valueChan2 = (_this$props2 = this.props).valueChange) || void 0 === _this$props$valueChan2 || _this$props$valueChan2.call(_this$props2, __newValue);
      }
    }
  }
  keyDown(e) {
    const {
      onKeyDown
    } = this.props;
    const {
      keyName,
      originalEvent,
      which
    } = e;
    const result2 = null === onKeyDown || void 0 === onKeyDown ? void 0 : onKeyDown(e);
    if (null !== result2 && void 0 !== result2 && result2.cancel) {
      return result2;
    }
    if ("space" === keyName || "space" === which) {
      originalEvent.preventDefault();
      this.onWidgetClick(originalEvent);
    }
    return;
  }
  get cssClasses() {
    return getCssClasses4(_extends({}, this.props, {
      value: void 0 !== this.props.value ? this.props.value : this.state.value
    }));
  }
  get aria() {
    const checked = true === (void 0 !== this.props.value ? this.props.value : this.state.value);
    const indeterminate = null === (void 0 !== this.props.value ? this.props.value : this.state.value);
    const result2 = {
      role: "checkbox",
      checked: indeterminate ? "mixed" : `${checked}`
    };
    return _extends({}, result2, this.props.aria);
  }
  get restAttributes() {
    const _this$props3 = this.props, restProps = _objectWithoutPropertiesLoose(_this$props3, _excluded11);
    return restProps;
  }
  focus() {
    this.editorRef.current.focus();
  }
  blur() {
    this.editorRef.current.blur();
  }
  render() {
    const value2 = void 0 !== this.props.value ? this.props.value : this.state.value;
    return normalizeProps(createComponentVNode(2, Editor2, _extends({
      aria: this.aria,
      classes: this.cssClasses,
      onClick: this.onWidgetClick,
      onKeyDown: this.keyDown,
      accessKey: this.props.accessKey,
      activeStateEnabled: this.props.activeStateEnabled,
      focusStateEnabled: this.props.focusStateEnabled,
      hoverStateEnabled: this.props.hoverStateEnabled,
      className: this.props.className,
      disabled: this.props.disabled,
      readOnly: this.props.readOnly,
      hint: this.props.hint,
      height: this.props.height,
      width: this.props.width,
      rtlEnabled: this.props.rtlEnabled,
      tabIndex: this.props.tabIndex,
      visible: this.props.visible,
      validationError: this.props.validationError,
      validationErrors: this.props.validationErrors,
      validationMessageMode: this.props.validationMessageMode,
      validationMessagePosition: this.props.validationMessagePosition,
      validationStatus: this.props.validationStatus,
      isValid: this.props.isValid,
      onFocusIn: this.props.onFocusIn
    }, this.restAttributes, {
      children: createFragment([normalizeProps(createVNode(64, "input", null, null, 1, _extends({
        type: "hidden",
        value: `${value2}`
      }, this.props.name && {
        name: this.props.name
      }))), createVNode(1, "div", "dx-checkbox-container", [createComponentVNode(2, CheckBoxIcon, {
        size: this.props.iconSize,
        isChecked: true === value2
      }), this.props.text && createVNode(1, "span", "dx-checkbox-text", this.props.text, 0)], 0)], 4)
    }), null, this.editorRef));
  }
};
function __processTwoWayProps(defaultProps) {
  const twoWayProps = ["value"];
  return Object.keys(defaultProps).reduce((props, propName) => {
    const propValue = defaultProps[propName];
    const defaultPropName = twoWayProps.some((p2) => p2 === propName) ? `default${propName.charAt(0).toUpperCase()}${propName.slice(1)}` : propName;
    props[defaultPropName] = propValue;
    return props;
  }, {});
}
CheckBox.defaultProps = defaultCheckBoxProps;
var __defaultOptionRules2 = [];
function defaultOptions2(rule) {
  __defaultOptionRules2.push(rule);
  CheckBox.defaultProps = Object.create(Object.prototype, Object.assign(Object.getOwnPropertyDescriptors(CheckBox.defaultProps), Object.getOwnPropertyDescriptors(__processTwoWayProps(convertRulesToOptions(__defaultOptionRules2)))));
}

// node_modules/devextreme/esm/ui/editor/editor.js
var editor_default2 = editor_default;

// node_modules/devextreme/esm/__internal/core/r1/utils/dom.js
function querySelectorInSameDocument(el, selector) {
  var _el$getRootNode;
  const root = (null === (_el$getRootNode = el.getRootNode) || void 0 === _el$getRootNode ? void 0 : _el$getRootNode.call(el)) ?? document;
  return root.querySelector(selector);
}

// node_modules/devextreme/esm/__internal/ui/check_box/editor_base/wrapper.js
var INVALID_MESSAGE_AUTO3 = "dx-invalid-message-auto";
var VALIDATION_TARGET2 = "dx-validation-target";
var Editor3 = class extends ComponentWrapper {
  getProps() {
    const props = super.getProps();
    props.onFocusIn = () => {
      const isValidationMessageShownOnFocus = "auto" === this.option("validationMessageMode");
      if (isValidationMessageShownOnFocus) {
        const $validationMessageWrapper = renderer_default(querySelectorInSameDocument(this.element(), ".dx-invalid-message.dx-overlay-wrapper"));
        null === $validationMessageWrapper || void 0 === $validationMessageWrapper || $validationMessageWrapper.removeClass(INVALID_MESSAGE_AUTO3);
        const timeToWaitBeforeShow = 150;
        if (this.showValidationMessageTimeout) {
          clearTimeout(this.showValidationMessageTimeout);
        }
        this.showValidationMessageTimeout = setTimeout(() => {
          null === $validationMessageWrapper || void 0 === $validationMessageWrapper || $validationMessageWrapper.addClass(INVALID_MESSAGE_AUTO3);
        }, timeToWaitBeforeShow);
      }
    };
    props.saveValueChangeEvent = (e) => {
      this._valueChangeEventInstance = e;
    };
    return props;
  }
  _createElement(element) {
    super._createElement(element);
    this.showValidationMessageTimeout = void 0;
    this.validationRequest = callbacks_default();
    data(this.$element()[0], VALIDATION_TARGET2, this);
  }
  _render() {
    var _this$option;
    null === (_this$option = this.option("_onMarkupRendered")) || void 0 === _this$option || _this$option();
  }
  _init() {
    super._init();
    this._initialValue = this.option("value");
  }
  _initializeComponent() {
    super._initializeComponent();
    this._valueChangeAction = this._createActionByOption("onValueChanged", {
      excludeValidators: ["disabled", "readOnly"]
    });
  }
  _initOptions(options2) {
    super._initOptions(options2);
    this.option(validation_engine_default.initValidationOptions(options2));
  }
  _getDefaultOptions() {
    return extend(super._getDefaultOptions(), {
      validationMessageOffset: {
        h: 0,
        v: 0
      },
      validationTooltipOptions: {}
    });
  }
  _bindInnerWidgetOptions(innerWidget, optionsContainer) {
    const innerWidgetOptions = extend({}, innerWidget.option());
    const syncOptions = () => this._silent(optionsContainer, innerWidgetOptions);
    syncOptions();
    innerWidget.on("optionChanged", syncOptions);
  }
  _raiseValidation(value2, previousValue) {
    const areValuesEmpty = !isDefined(value2) && !isDefined(previousValue);
    if (value2 !== previousValue && !areValuesEmpty) {
      this.validationRequest.fire({
        value: value2,
        editor: this
      });
    }
  }
  _raiseValueChangeAction(value2, previousValue) {
    var _this$_valueChangeAct;
    null === (_this$_valueChangeAct = this._valueChangeAction) || void 0 === _this$_valueChangeAct || _this$_valueChangeAct.call(this, {
      element: this.$element(),
      previousValue,
      value: value2,
      event: this._valueChangeEventInstance
    });
    this._valueChangeEventInstance = void 0;
  }
  _optionChanged(option) {
    const {
      name: name2,
      previousValue,
      value: value2
    } = option;
    if (name2 && void 0 !== this._getActionConfigs()[name2]) {
      this._addAction(name2);
    }
    switch (name2) {
      case "value":
        this._raiseValidation(value2, previousValue);
        this.option("isDirty", this._initialValue !== value2);
        this._raiseValueChangeAction(value2, previousValue);
        break;
      case "onValueChanged":
        this._valueChangeAction = this._createActionByOption("onValueChanged", {
          excludeValidators: ["disabled", "readOnly"]
        });
        break;
      case "isValid":
      case "validationError":
      case "validationErrors":
      case "validationStatus":
        this.option(validation_engine_default.synchronizeValidationOptions(option, this.option()));
    }
    super._optionChanged(option);
  }
  clear() {
    const {
      value: value2
    } = this._getDefaultOptions();
    this.option({
      value: value2
    });
  }
  reset() {
    let value2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : void 0;
    if (arguments.length) {
      this._initialValue = value2;
    }
    this.option("value", this._initialValue);
    this.option("isDirty", false);
    this.option("isValid", true);
  }
  _dispose() {
    super._dispose();
    data(this.element(), VALIDATION_TARGET2, null);
    if (this.showValidationMessageTimeout) {
      clearTimeout(this.showValidationMessageTimeout);
    }
  }
};
var prevIsEditor = editor_default2.isEditor;
var newIsEditor = (instance) => prevIsEditor(instance) || instance instanceof Editor3;
Editor3.isEditor = newIsEditor;
editor_default2.isEditor = newIsEditor;

// node_modules/devextreme/esm/__internal/ui/check_box/wrapper.js
var CheckBox2 = class extends Editor3 {
  _useTemplates() {
    return false;
  }
  _isFocused() {
    const focusTarget = this.$element()[0];
    return focusTarget.classList.contains("dx-state-focused");
  }
  getSupportedKeyNames() {
    return ["space"];
  }
  getProps() {
    const props = super.getProps();
    if (null !== props.value) {
      props.value = Boolean(props.value);
    }
    return props;
  }
};

// node_modules/devextreme/esm/__internal/ui/check_box/generated_wrapper.js
var CheckBox3 = class extends CheckBox2 {
  getProps() {
    const props = super.getProps();
    props.onKeyDown = this._wrapKeyDownHandler(props.onKeyDown);
    return props;
  }
  focus() {
    var _this$viewRef;
    return null === (_this$viewRef = this.viewRef) || void 0 === _this$viewRef ? void 0 : _this$viewRef.focus(...arguments);
  }
  blur() {
    var _this$viewRef2;
    return null === (_this$viewRef2 = this.viewRef) || void 0 === _this$viewRef2 ? void 0 : _this$viewRef2.blur(...arguments);
  }
  _getActionConfigs() {
    return {
      onFocusIn: {},
      onClick: {}
    };
  }
  get _propsInfo() {
    return {
      twoWay: [
        ["value", "defaultValue", "valueChange"]
      ],
      allowNull: ["defaultValue", "validationError", "validationErrors", "value"],
      elements: [],
      templates: [],
      props: ["text", "iconSize", "enableThreeStateBehavior", "activeStateEnabled", "hoverStateEnabled", "focusStateEnabled", "saveValueChangeEvent", "defaultValue", "valueChange", "readOnly", "name", "validationError", "validationErrors", "validationMessageMode", "validationMessagePosition", "validationStatus", "isValid", "isDirty", "inputAttr", "onFocusIn", "className", "accessKey", "disabled", "height", "hint", "onClick", "onKeyDown", "rtlEnabled", "tabIndex", "visible", "width", "aria", "value"]
    };
  }
  get _viewComponent() {
    return CheckBox;
  }
};
component_registrator_default("dxCheckBox", CheckBox3);
CheckBox3.defaultOptions = defaultOptions2;

// node_modules/devextreme/esm/__internal/ui/check_box/index.js
var check_box_default = CheckBox3;

// node_modules/devextreme/esm/ui/check_box.js
var check_box_default2 = check_box_default;

// node_modules/devextreme/esm/__internal/ui/tree_view/m_tree_view.base.js
var WIDGET_CLASS3 = "dx-treeview";
var NODE_CLASS = `${WIDGET_CLASS3}-node`;
var NODE_CONTAINER_CLASS = `${NODE_CLASS}-container`;
var NODE_LOAD_INDICATOR_CLASS = `${NODE_CLASS}-loadindicator`;
var OPENED_NODE_CONTAINER_CLASS = `${NODE_CLASS}-container-opened`;
var IS_LEAF = `${NODE_CLASS}-is-leaf`;
var ITEM_CLASS3 = `${WIDGET_CLASS3}-item`;
var ITEM_WITH_CHECKBOX_CLASS = `${ITEM_CLASS3}-with-checkbox`;
var ITEM_WITH_CUSTOM_EXPANDER_ICON_CLASS = `${ITEM_CLASS3}-with-custom-expander-icon`;
var CUSTOM_EXPANDER_ICON_ITEM_CONTAINER_CLASS = `${WIDGET_CLASS3}-custom-expander-icon-item-container`;
var ITEM_WITHOUT_CHECKBOX_CLASS = `${ITEM_CLASS3}-without-checkbox`;
var ITEM_DATA_KEY = `${ITEM_CLASS3}-data`;
var TOGGLE_ITEM_VISIBILITY_CLASS = `${WIDGET_CLASS3}-toggle-item-visibility`;
var CUSTOM_COLLAPSE_ICON_CLASS = `${WIDGET_CLASS3}-custom-collapse-icon`;
var CUSTOM_EXPAND_ICON_CLASS = `${WIDGET_CLASS3}-custom-expand-icon`;
var LOAD_INDICATOR_CLASS = `${WIDGET_CLASS3}-loadindicator`;
var LOAD_INDICATOR_WRAPPER_CLASS = `${WIDGET_CLASS3}-loadindicator-wrapper`;
var TOGGLE_ITEM_VISIBILITY_OPENED_CLASS = `${WIDGET_CLASS3}-toggle-item-visibility-opened`;
var SELECT_ALL_ITEM_CLASS = `${WIDGET_CLASS3}-select-all-item`;
var DATA_ITEM_ID = "data-item-id";
var ROOT_NODE_CLASS = `${WIDGET_CLASS3}-root-node`;
var EXPANDER_ICON_STUB_CLASS = `${WIDGET_CLASS3}-expander-icon-stub`;
var TreeViewBase = class extends m_hierarchical_collection_widget_default {
  _supportedKeys() {
    const click2 = (e) => {
      const {
        focusedElement
      } = this.option();
      const $itemElement = renderer_default(focusedElement);
      if (!$itemElement.length) {
        return;
      }
      e.target = $itemElement;
      e.currentTarget = $itemElement;
      this._itemClickHandler(e, $itemElement.children(`.${ITEM_CLASS3}`));
      const expandEventName = this._getEventNameByOption(this.option("expandEvent"));
      const expandByClick = expandEventName === addNamespace2(CLICK_EVENT_NAME, "dxTreeView_expand");
      if (expandByClick) {
        this._expandEventHandler(e);
      }
    };
    const select = (e) => {
      e.preventDefault();
      const {
        focusedElement
      } = this.option();
      const $focusedElement = renderer_default(focusedElement);
      const checkboxInstance = this._getCheckBoxInstance($focusedElement);
      if (!checkboxInstance.option("disabled")) {
        const currentState = checkboxInstance.option("value");
        this._updateItemSelection(!currentState, $focusedElement.find(`.${ITEM_CLASS3}`).get(0), true);
      }
    };
    const toggleExpandedNestedItems = function(state, e) {
      if (!this.option("expandAllEnabled")) {
        return;
      }
      e.preventDefault();
      const $rootElement = renderer_default(this.option("focusedElement"));
      if (!$rootElement.length) {
        return;
      }
      const rootItem = this._getItemData($rootElement.find(`.${ITEM_CLASS3}`));
      this._toggleExpandedNestedItems([rootItem], state);
    };
    return _extends({}, super._supportedKeys(), {
      enter: this._showCheckboxes() ? select : click2,
      space: this._showCheckboxes() ? select : click2,
      asterisk: toggleExpandedNestedItems.bind(this, true),
      minus: toggleExpandedNestedItems.bind(this, false)
    });
  }
  _toggleExpandedNestedItems(items, state) {
    if (!items) {
      return;
    }
    for (let i = 0, len = items.length; i < len; i++) {
      const item = items[i];
      const node = this._dataAdapter.getNodeByItem(item);
      this._toggleExpandedState(node, state);
      this._toggleExpandedNestedItems(item.items, state);
    }
  }
  _getNodeElement(node, cache) {
    const key = this._encodeString(node.internalFields.key);
    if (cache) {
      if (!cache.$nodeByKey) {
        cache.$nodeByKey = {};
        this.$element().find(`.${NODE_CLASS}`).each(function() {
          const $node = renderer_default(this);
          const key2 = $node.attr(DATA_ITEM_ID);
          cache.$nodeByKey[key2] = $node;
        });
      }
      return cache.$nodeByKey[key] || renderer_default();
    }
    const element = this.$element().get(0).querySelector(`[${DATA_ITEM_ID}="${key}"]`);
    return renderer_default(element);
  }
  _widgetClass() {
    return WIDGET_CLASS3;
  }
  _getDefaultOptions() {
    const defaultOptions4 = extend(super._getDefaultOptions(), {
      animationEnabled: true,
      dataStructure: "tree",
      deferRendering: true,
      expandAllEnabled: false,
      hasItemsExpr: "hasItems",
      selectNodesRecursive: true,
      expandNodesRecursive: true,
      showCheckBoxesMode: "none",
      expandIcon: null,
      collapseIcon: null,
      selectAllText: message_default.format("dxList-selectAll"),
      onItemSelectionChanged: null,
      onItemExpanded: null,
      onItemCollapsed: null,
      scrollDirection: "vertical",
      useNativeScrolling: true,
      virtualModeEnabled: false,
      rootValue: 0,
      focusStateEnabled: false,
      selectionMode: "multiple",
      expandEvent: "dblclick",
      selectByClick: false,
      createChildren: null,
      onSelectAllValueChanged: null,
      _supportItemUrl: false
    });
    return extend(true, defaultOptions4, {
      integrationOptions: {
        useDeferUpdateForTemplates: false
      }
    });
  }
  _defaultOptionsRules() {
    return super._defaultOptionsRules().concat([{
      device: () => !m_support_default.nativeScrolling,
      options: {
        useNativeScrolling: false
      }
    }]);
  }
  _initSelectedItems() {
  }
  _syncSelectionOptions() {
    return Deferred().resolve().promise();
  }
  _fireSelectionChanged() {
    this._createActionByOption("onSelectionChanged", {
      excludeValidators: ["disabled", "readOnly"]
    })();
  }
  _createSelectAllValueChangedAction() {
    this._selectAllValueChangedAction = this._createActionByOption("onSelectAllValueChanged", {
      excludeValidators: ["disabled", "readOnly"]
    });
  }
  _fireSelectAllValueChanged(value2) {
    var _this$_selectAllValue;
    null === (_this$_selectAllValue = this._selectAllValueChangedAction) || void 0 === _this$_selectAllValue || _this$_selectAllValue.call(this, {
      value: value2
    });
  }
  _checkBoxModeChange(value2, previousValue) {
    const searchEnabled = this.option("searchEnabled");
    const previousSelectAllEnabled = this._selectAllEnabled(previousValue);
    const previousItemsContainer = this._itemContainer(searchEnabled, previousSelectAllEnabled);
    this._detachClickEvent(previousItemsContainer);
    this._detachExpandEvent(previousItemsContainer);
    if ("none" === previousValue || "none" === value2) {
      return;
    }
    const selectAllExists = this._$selectAllItem && this._$selectAllItem.length;
    switch (value2) {
      case "selectAll":
        if (!selectAllExists) {
          this._createSelectAllValueChangedAction();
          this._renderSelectAllItem();
        }
        break;
      case "normal":
        if (selectAllExists) {
          var _this$_$selectAllItem;
          null === (_this$_$selectAllItem = this._$selectAllItem) || void 0 === _this$_$selectAllItem || _this$_$selectAllItem.remove();
          delete this._$selectAllItem;
        }
    }
  }
  _removeSelection() {
    const that = this;
    each(this._dataAdapter.getFullData(), (_, node) => {
      if (!that._hasChildren(node)) {
        return;
      }
      that._dataAdapter.toggleSelection(node.internalFields.key, false, true);
    });
  }
  _optionChanged(args) {
    const {
      name: name2,
      value: value2,
      previousValue
    } = args;
    switch (name2) {
      case "selectAllText":
        if (this._$selectAllItem) {
          this._$selectAllItem.dxCheckBox("instance").option("text", value2);
        }
        break;
      case "showCheckBoxesMode":
        this._checkBoxModeChange(value2, previousValue);
        this._invalidate();
        break;
      case "scrollDirection":
        this.getScrollable().option("direction", value2);
        break;
      case "useNativeScrolling":
        this.getScrollable().option("useNative", value2);
        break;
      case "items":
        delete this._$selectAllItem;
        super._optionChanged(args);
        break;
      case "dataSource":
        super._optionChanged(args);
        this._initDataAdapter();
        this._filter = {};
        break;
      case "hasItemsExpr":
        this._initAccessors();
        this.repaint();
        break;
      case "expandEvent":
        this._attachExpandEvent();
        break;
      case "deferRendering":
      case "dataStructure":
      case "rootValue":
      case "createChildren":
      case "expandNodesRecursive":
      case "onItemSelectionChanged":
      case "onItemExpanded":
      case "onItemCollapsed":
      case "expandAllEnabled":
      case "animationEnabled":
      case "virtualModeEnabled":
      case "selectByClick":
      case "_supportItemUrl":
        break;
      case "selectionMode":
        this._initDataAdapter();
        super._optionChanged(args);
        break;
      case "onSelectAllValueChanged":
        this._createSelectAllValueChangedAction();
        break;
      case "selectNodesRecursive":
        this._dataAdapter.setOption("recursiveSelection", args.value);
        this.repaint();
        break;
      case "expandIcon":
      case "collapseIcon":
        this.repaint();
        break;
      default:
        super._optionChanged(args);
    }
  }
  _initDataSource() {
    if (this._useCustomChildrenLoader()) {
      this._loadChildrenByCustomLoader(null).done((newItems) => {
        if (newItems && newItems.length) {
          this.option("items", newItems);
        }
      });
    } else {
      super._initDataSource();
      this._isVirtualMode() && this._initVirtualMode();
    }
  }
  _initVirtualMode() {
    const filter = this._filter;
    if (!filter.custom) {
      filter.custom = this._dataSource.filter();
    }
    if (!filter.internal) {
      filter.internal = [this.option("parentIdExpr"), this.option("rootValue")];
    }
  }
  _useCustomChildrenLoader() {
    return isFunction(this.option("createChildren")) && this._isDataStructurePlain();
  }
  _loadChildrenByCustomLoader(parentNode) {
    const invocationResult = this.option("createChildren").call(this, parentNode);
    if (Array.isArray(invocationResult)) {
      return Deferred().resolve(invocationResult).promise();
    }
    if (invocationResult && isFunction(invocationResult.then)) {
      return fromPromise(invocationResult);
    }
    return Deferred().resolve([]).promise();
  }
  _combineFilter() {
    if (!this._filter.custom || !this._filter.custom.length) {
      return this._filter.internal;
    }
    return [this._filter.custom, this._filter.internal];
  }
  _dataSourceLoadErrorHandler() {
    this._renderEmptyMessage();
  }
  _init() {
    this._filter = {};
    super._init();
    this._activeStateUnit = `.${ITEM_CLASS3}`;
    this._initStoreChangeHandlers();
  }
  _dataSourceChangedHandler(newItems) {
    const items = this.option("items");
    if (this._initialized && this._isVirtualMode() && items.length) {
      return;
    }
    this.option("items", newItems);
  }
  _removeTreeViewLoadIndicator() {
    if (!this._treeViewLoadIndicator) {
      return;
    }
    this._treeViewLoadIndicator.remove();
    this._treeViewLoadIndicator = null;
  }
  _createTreeViewLoadIndicator() {
    this._treeViewLoadIndicator = renderer_default("<div>").addClass(LOAD_INDICATOR_CLASS);
    this._createComponent(this._treeViewLoadIndicator, load_indicator_default, {});
    return this._treeViewLoadIndicator;
  }
  _dataSourceLoadingChangedHandler(isLoading) {
    let resultFilter;
    if (this._isVirtualMode()) {
      resultFilter = this._combineFilter();
      this._dataSource.filter(resultFilter);
    }
    if (isLoading && !this._dataSource.isLoaded()) {
      this.option("items", []);
      const $wrapper = renderer_default("<div>").addClass(LOAD_INDICATOR_WRAPPER_CLASS);
      this._createTreeViewLoadIndicator().appendTo($wrapper);
      this.itemsContainer().append($wrapper);
      if (this._isVirtualMode() && this._dataSource.filter() !== resultFilter) {
        this._dataSource.filter([]);
      }
    } else {
      this._removeTreeViewLoadIndicator();
    }
  }
  _initStoreChangeHandlers() {
    const {
      dataStructure
    } = this.option();
    if ("plain" !== dataStructure) {
      return;
    }
    this._dataSource && this._dataSource.store().on("inserted", (newItem) => {
      this.option().items = this.option("items").concat(newItem);
      this._dataAdapter.addItem(newItem);
      if (!this._dataAdapter.isFiltered(newItem)) {
        return;
      }
      this._updateLevel(this._parentIdGetter(newItem));
    }).on("removed", (removedKey) => {
      const node = this._dataAdapter.getNodeByKey(removedKey);
      if (isDefined(node)) {
        this.option("items")[this._dataAdapter.getIndexByKey(node.internalFields.key)] = 0;
        this._markChildrenItemsToRemove(node);
        this._removeItems();
        this._dataAdapter.removeItem(removedKey);
        this._updateLevel(this._parentIdGetter(node));
      }
    });
  }
  _markChildrenItemsToRemove(node) {
    const keys = node.internalFields.childrenKeys;
    each(keys, (_, key) => {
      this.option("items")[this._dataAdapter.getIndexByKey(key)] = 0;
      this._markChildrenItemsToRemove(this._dataAdapter.getNodeByKey(key));
    });
  }
  _removeItems() {
    const items = extend(true, [], this.option("items"));
    let counter = 0;
    each(items, (index2, item) => {
      if (!item) {
        this.option("items").splice(index2 - counter, 1);
        counter++;
      }
    });
  }
  _updateLevel(parentId) {
    const $container = this._getContainerByParentKey(parentId);
    this._renderItems($container, this._dataAdapter.getChildrenNodes(parentId));
  }
  _getOldContainer($itemElement) {
    if ($itemElement.length) {
      return $itemElement.children(`.${NODE_CONTAINER_CLASS}`);
    }
    const scrollable = this.getScrollable();
    if (scrollable) {
      return renderer_default(scrollable.content()).children();
    }
    return renderer_default();
  }
  _getContainerByParentKey(parentId) {
    const node = this._dataAdapter.getNodeByKey(parentId);
    const $itemElement = node ? this._getNodeElement(node) : [];
    this._getOldContainer($itemElement).remove();
    const $container = this._renderNodeContainer($itemElement);
    if (this._isRootLevel(parentId)) {
      const scrollable = this.getScrollable();
      if (!scrollable) {
        this._renderScrollableContainer();
      }
      renderer_default(scrollable.content()).append($container);
    }
    return $container;
  }
  _isRootLevel(parentId) {
    return parentId === this.option("rootValue");
  }
  _getAccessors() {
    const accessors = super._getAccessors();
    accessors.push("hasItems");
    return accessors;
  }
  _getDataAdapterOptions() {
    var _this$_dataSource, _this$_dataSource2, _this$_dataSource2$lo;
    return {
      rootValue: this.option("rootValue"),
      multipleSelection: !this._isSingleSelection(),
      recursiveSelection: this._isRecursiveSelection(),
      recursiveExpansion: this.option("expandNodesRecursive"),
      selectionRequired: this.option("selectionRequired"),
      dataType: this.option("dataStructure"),
      sort: null === (_this$_dataSource = this._dataSource) || void 0 === _this$_dataSource ? void 0 : _this$_dataSource.sort(),
      langParams: null === (_this$_dataSource2 = this._dataSource) || void 0 === _this$_dataSource2 || null === (_this$_dataSource2$lo = _this$_dataSource2.loadOptions) || void 0 === _this$_dataSource2$lo || null === (_this$_dataSource2$lo = _this$_dataSource2$lo.call(_this$_dataSource2)) || void 0 === _this$_dataSource2$lo ? void 0 : _this$_dataSource2$lo.langParams
    };
  }
  _initMarkup() {
    this._renderScrollableContainer();
    this._renderEmptyMessage(this._dataAdapter.getRootNodes());
    super._initMarkup();
    this._setAriaRole();
  }
  _setAriaRole() {
    const {
      items
    } = this.option();
    if (items && items.length) {
      this.setAria({
        role: "tree"
      });
    }
  }
  _renderContentImpl() {
    const $nodeContainer = this._renderNodeContainer();
    renderer_default(this.getScrollable().content()).append($nodeContainer);
    if (!this.option("items") || !this.option("items").length) {
      return;
    }
    this._renderItems($nodeContainer, this._dataAdapter.getRootNodes());
    this._attachExpandEvent();
    if (this._selectAllEnabled()) {
      this._createSelectAllValueChangedAction();
      this._renderSelectAllItem($nodeContainer);
    }
  }
  _isVirtualMode() {
    return this.option("virtualModeEnabled") && this._isDataStructurePlain() && !!this.option("dataSource");
  }
  _isDataStructurePlain() {
    const {
      dataStructure
    } = this.option();
    return "plain" === dataStructure;
  }
  _fireContentReadyAction() {
    const dataSource = this.getDataSource();
    const skipContentReadyAction = dataSource && !dataSource.isLoaded() || this._skipContentReadyAndItemExpanded;
    const scrollable = this.getScrollable();
    if (scrollable && hasWindow()) {
      scrollable.update();
    }
    if (!skipContentReadyAction) {
      super._fireContentReadyAction();
    }
    if (scrollable && hasWindow()) {
      scrollable.update();
    }
  }
  _renderScrollableContainer() {
    this._scrollable = this._createComponent(renderer_default("<div>").appendTo(this.$element()), m_scrollable_default, {
      useNative: this.option("useNativeScrolling"),
      direction: this.option("scrollDirection"),
      useKeyboard: false
    });
  }
  _renderNodeContainer($parent) {
    const $container = renderer_default("<ul>").addClass(NODE_CONTAINER_CLASS);
    this.setAria("role", "group", $container);
    if (null !== $parent && void 0 !== $parent && $parent.length) {
      const itemData = this._getItemData($parent.children(`.${ITEM_CLASS3}`));
      if (this._expandedGetter(itemData)) {
        $container.addClass(OPENED_NODE_CONTAINER_CLASS);
      }
      $container.appendTo($parent);
    }
    return $container;
  }
  _createDOMElement($nodeContainer, node) {
    var _node$internalFields;
    const $node = renderer_default("<li>").addClass(NODE_CLASS).attr(DATA_ITEM_ID, this._encodeString(node.internalFields.key)).prependTo($nodeContainer);
    const attrs = {
      role: "treeitem",
      label: this._displayGetter(node.internalFields.item) || "",
      level: this._getLevel($nodeContainer)
    };
    const hasChildNodes = !!(null !== node && void 0 !== node && null !== (_node$internalFields = node.internalFields) && void 0 !== _node$internalFields && null !== (_node$internalFields = _node$internalFields.childrenKeys) && void 0 !== _node$internalFields && _node$internalFields.length);
    if (hasChildNodes) {
      attrs.expanded = node.internalFields.expanded || false;
    }
    this.setAria(attrs, $node);
    return $node;
  }
  _getLevel($nodeContainer) {
    const parent = $nodeContainer.parent();
    return parent.hasClass("dx-scrollable-content") ? 1 : parseInt(parent.attr("aria-level")) + 1;
  }
  _showCheckboxes() {
    const {
      showCheckBoxesMode
    } = this.option();
    return "none" !== showCheckBoxesMode;
  }
  _hasCustomExpanderIcons() {
    return this.option("expandIcon") || this.option("collapseIcon");
  }
  _selectAllEnabled(showCheckBoxesMode) {
    const mode = showCheckBoxesMode ?? this.option("showCheckBoxesMode");
    return "selectAll" === mode && !this._isSingleSelection();
  }
  _renderItems($nodeContainer, nodes) {
    const length = nodes.length - 1;
    for (let i = length; i >= 0; i--) {
      this._renderItem(i, nodes[i], $nodeContainer);
    }
    this._renderedItemsCount += nodes.length;
  }
  _renderItem(nodeIndex, node, $nodeContainer) {
    const $node = this._createDOMElement($nodeContainer, node);
    const nodeData = node.internalFields;
    const showCheckBox = this._showCheckboxes();
    $node.addClass(showCheckBox ? ITEM_WITH_CHECKBOX_CLASS : ITEM_WITHOUT_CHECKBOX_CLASS);
    $node.toggleClass("dx-state-invisible", false === nodeData.item.visible);
    if (this._hasCustomExpanderIcons()) {
      $node.addClass(ITEM_WITH_CUSTOM_EXPANDER_ICON_CLASS);
      $nodeContainer.addClass(CUSTOM_EXPANDER_ICON_ITEM_CONTAINER_CLASS);
    }
    this.setAria("selected", nodeData.selected, $node);
    this._toggleSelectedClass($node, nodeData.selected);
    if (nodeData.disabled) {
      this.setAria("disabled", nodeData.disabled, $node);
    }
    super._renderItem(this._renderedItemsCount + nodeIndex, nodeData.item, $node);
    const parent = this._getNode(node.internalFields.parentKey);
    if (!parent) {
      $node.addClass(ROOT_NODE_CLASS);
    }
    if (false !== nodeData.item.visible) {
      this._renderChildren($node, node);
    }
  }
  _setAriaSelectionAttribute() {
  }
  _renderChildren($node, node) {
    if (!this._hasChildren(node)) {
      this._addLeafClass($node);
      renderer_default("<div>").addClass(EXPANDER_ICON_STUB_CLASS).appendTo(this._getItem($node));
      return;
    }
    if (this._hasCustomExpanderIcons()) {
      this._renderCustomExpanderIcons($node, node);
    } else {
      this._renderDefaultExpanderIcons($node, node);
    }
    if (this._shouldRenderSublevel(node.internalFields.expanded)) {
      this._loadSublevel(node).done((childNodes) => {
        this._renderSublevel($node, this._getActualNode(node), childNodes);
      });
    }
  }
  _shouldRenderSublevel(expanded) {
    return expanded || !this.option("deferRendering");
  }
  _getActualNode(cachedNode) {
    return this._dataAdapter.getNodeByKey(cachedNode.internalFields.key);
  }
  _hasChildren(node) {
    if (this._isVirtualMode() || this._useCustomChildrenLoader()) {
      return false !== this._hasItemsGetter(node.internalFields.item);
    }
    return super._hasChildren(node);
  }
  _loadSublevel(node) {
    const deferred = Deferred();
    const childrenNodes = this._getChildNodes(node);
    if (childrenNodes.length) {
      deferred.resolve(childrenNodes);
    } else {
      this._loadNestedItems(node).done((items) => {
        deferred.resolve(this._dataAdapter.getNodesByItems(items));
      });
    }
    return deferred.promise();
  }
  _getItemExtraPropNames() {
    return ["url", "linkAttr"];
  }
  _addContent($container, itemData) {
    const {
      html,
      url
    } = itemData;
    if (this.option("_supportItemUrl") && url) {
      $container.html(html);
      const link = this._getLinkContainer(this._getIconContainer(itemData), this._getTextContainer(itemData), itemData);
      $container.append(link);
    } else {
      super._addContent($container, itemData);
    }
  }
  _postprocessRenderItem(args) {
    const {
      itemData,
      itemElement
    } = args;
    if (this._showCheckboxes()) {
      this._renderCheckBox(itemElement, this._getNode(itemData));
    }
    super._postprocessRenderItem(args);
  }
  _renderSublevel($node, node, childNodes) {
    const $nestedNodeContainer = this._renderNodeContainer($node);
    const childNodesByChildrenKeys = childNodes.filter((childNode) => -1 !== node.internalFields.childrenKeys.indexOf(childNode.internalFields.key));
    this._renderItems($nestedNodeContainer, childNodesByChildrenKeys);
    if (childNodesByChildrenKeys.length && !node.internalFields.selected) {
      const firstChild = childNodesByChildrenKeys[0];
      this._updateParentsState(firstChild, this._getNodeElement(firstChild));
    }
    this._normalizeIconState($node, childNodesByChildrenKeys.length);
    if (node.internalFields.expanded) {
      $nestedNodeContainer.addClass(OPENED_NODE_CONTAINER_CLASS);
    }
  }
  _executeItemRenderAction(itemIndex, itemData, itemElement) {
    const node = this._getNode(itemElement);
    this._getItemRenderAction()({
      itemElement,
      itemIndex,
      itemData,
      node: this._dataAdapter.getPublicNode(node)
    });
  }
  _addLeafClass($node) {
    $node.addClass(IS_LEAF);
  }
  _expandEventHandler(e) {
    const $nodeElement = renderer_default(e.currentTarget.parentNode);
    if (!$nodeElement.hasClass(IS_LEAF)) {
      this._toggleExpandedState(e.currentTarget, void 0, e);
    }
  }
  _attachExpandEvent() {
    const expandedEventName = this._getEventNameByOption(this.option("expandEvent"));
    const $itemsContainer = this._itemContainer();
    this._detachExpandEvent($itemsContainer);
    m_events_engine_default.on($itemsContainer, expandedEventName, this._itemSelector(), this._expandEventHandler.bind(this));
  }
  _detachExpandEvent(itemsContainer) {
    m_events_engine_default.off(itemsContainer, ".dxTreeView_expand", this._itemSelector());
  }
  _getEventNameByOption(name2) {
    const event = "click" === name2 ? CLICK_EVENT_NAME : DBLCLICK_EVENT_NAME;
    return addNamespace2(event, "dxTreeView_expand");
  }
  _getNode(identifier) {
    if (!isDefined(identifier)) {
      return null;
    }
    if (identifier.internalFields) {
      return identifier;
    }
    if (isPrimitive(identifier)) {
      return this._dataAdapter.getNodeByKey(identifier);
    }
    const itemElement = renderer_default(identifier).get(0);
    if (!itemElement) {
      return null;
    }
    if (dom_adapter_default.isElementNode(itemElement)) {
      return this._getNodeByElement(itemElement);
    }
    return this._dataAdapter.getNodeByItem(itemElement);
  }
  _getNodeByElement(itemElement) {
    const $node = renderer_default(itemElement).closest(`.${NODE_CLASS}`);
    const key = this._decodeString($node.attr(DATA_ITEM_ID));
    return this._dataAdapter.getNodeByKey(key);
  }
  _toggleExpandedState(itemElement, state, e) {
    const node = this._getNode(itemElement);
    if (!node) {
      return Deferred().reject().promise();
    }
    if (node.internalFields.disabled) {
      return Deferred().reject().promise();
    }
    const currentState = node.internalFields.expanded;
    if (currentState === state) {
      return Deferred().resolve().promise();
    }
    if (this._hasChildren(node)) {
      const $node = this._getNodeElement(node);
      if ($node.find(`.${NODE_LOAD_INDICATOR_CLASS}:not(.dx-state-invisible)`).length) {
        return Deferred().reject().promise();
      }
      if (!currentState && !this._nodeHasRenderedChildren($node)) {
        this._createLoadIndicator($node);
      }
    }
    if (!isDefined(state)) {
      state = !currentState;
    }
    this._dataAdapter.toggleExpansion(node.internalFields.key, state);
    return this._updateExpandedItemsUI(node, state, e);
  }
  _nodeHasRenderedChildren($node) {
    const $nodeContainer = $node.children(`.${NODE_CONTAINER_CLASS}`);
    return $nodeContainer.not(":empty").length;
  }
  _getItem($node) {
    return $node.children(`.${ITEM_CLASS3}`).eq(0);
  }
  _createLoadIndicator($node) {
    const $treeviewItem = this._getItem($node);
    this._createComponent(renderer_default("<div>").addClass(NODE_LOAD_INDICATOR_CLASS), load_indicator_default, {}).$element().appendTo($treeviewItem);
    const $icon = $treeviewItem.children(`.${TOGGLE_ITEM_VISIBILITY_CLASS},.${CUSTOM_EXPAND_ICON_CLASS}`);
    $icon.hide();
  }
  _renderExpanderIcon($node, node, $icon, iconClass) {
    $icon.appendTo(this._getItem($node));
    $icon.addClass(iconClass);
    if (node.internalFields.disabled) {
      $icon.addClass("dx-state-disabled");
    }
    this._renderToggleItemVisibilityIconClick($icon, node);
  }
  _renderDefaultExpanderIcons($node, node) {
    const $treeViewItem = this._getItem($node);
    const $icon = renderer_default("<div>").addClass(TOGGLE_ITEM_VISIBILITY_CLASS).appendTo($treeViewItem);
    if (node.internalFields.expanded) {
      $icon.addClass(TOGGLE_ITEM_VISIBILITY_OPENED_CLASS);
      $node.parent().addClass(OPENED_NODE_CONTAINER_CLASS);
    }
    if (node.internalFields.disabled) {
      $icon.addClass("dx-state-disabled");
    }
    this._renderToggleItemVisibilityIconClick($icon, node);
  }
  _renderCustomExpanderIcons($node, node) {
    const {
      expandIcon,
      collapseIcon
    } = this.option();
    const $expandIcon = getImageContainer(expandIcon ?? collapseIcon);
    const $collapseIcon = getImageContainer(collapseIcon ?? expandIcon);
    this._renderExpanderIcon($node, node, $expandIcon, CUSTOM_EXPAND_ICON_CLASS);
    this._renderExpanderIcon($node, node, $collapseIcon, CUSTOM_COLLAPSE_ICON_CLASS);
    const isNodeExpanded = node.internalFields.expanded;
    if (isNodeExpanded) {
      $node.parent().addClass(OPENED_NODE_CONTAINER_CLASS);
    }
    this._toggleCustomExpanderIcons($expandIcon, $collapseIcon, isNodeExpanded);
  }
  _renderToggleItemVisibilityIconClick($icon, node) {
    const eventName = addNamespace2(CLICK_EVENT_NAME, this.NAME);
    m_events_engine_default.off($icon, eventName);
    m_events_engine_default.on($icon, eventName, (e) => {
      this._toggleExpandedState(node.internalFields.key, void 0, e);
      return false;
    });
  }
  _toggleCustomExpanderIcons($expandIcon, $collapseIcon, isNodeExpanded) {
    $collapseIcon.toggle(isNodeExpanded);
    $expandIcon.toggle(!isNodeExpanded);
  }
  _updateExpandedItemsUI(node, state, e) {
    const $node = this._getNodeElement(node);
    const isHiddenNode = !$node.length || state && $node.is(":hidden");
    if (this.option("expandNodesRecursive") && isHiddenNode) {
      const parentNode = this._getNode(node.internalFields.parentKey);
      if (parentNode) {
        this._updateExpandedItemsUI(parentNode, state, e);
      }
    }
    if (!this._hasCustomExpanderIcons()) {
      const $icon = this._getItem($node).children(`.${TOGGLE_ITEM_VISIBILITY_CLASS}`);
      $icon.toggleClass(TOGGLE_ITEM_VISIBILITY_OPENED_CLASS, state);
    } else if (this._nodeHasRenderedChildren($node)) {
      const $item = this._getItem($node);
      const $childExpandIcons = $item.children(`.${CUSTOM_EXPAND_ICON_CLASS}`);
      const $childCollapseIcons = $item.children(`.${CUSTOM_COLLAPSE_ICON_CLASS}`);
      this._toggleCustomExpanderIcons($childExpandIcons, $childCollapseIcons, state);
    }
    const $nodeContainer = $node.children(`.${NODE_CONTAINER_CLASS}`);
    const nodeContainerExists = $nodeContainer.length > 0;
    const completionCallback = Deferred();
    if (!state || nodeContainerExists && !$nodeContainer.is(":empty")) {
      this._animateNodeContainer(node, state, e, completionCallback);
      return completionCallback.promise();
    }
    if (0 === node.internalFields.childrenKeys.length && (this._isVirtualMode() || this._useCustomChildrenLoader())) {
      this._loadNestedItemsWithUpdate(node, state, e, completionCallback);
      return completionCallback.promise();
    }
    this._renderSublevel($node, node, this._getChildNodes(node));
    this._fireContentReadyAction();
    this._animateNodeContainer(node, state, e, completionCallback);
    return completionCallback.promise();
  }
  _loadNestedItemsWithUpdate(node, state, e, completionCallback) {
    const $node = this._getNodeElement(node);
    this._loadNestedItems(node).done((items) => {
      const actualNodeData = this._getActualNode(node);
      this._renderSublevel($node, actualNodeData, this._dataAdapter.getNodesByItems(items));
      if (!items || !items.length) {
        completionCallback.resolve();
        return;
      }
      this._fireContentReadyAction();
      this._animateNodeContainer(actualNodeData, state, e, completionCallback);
    });
  }
  _loadNestedItems(node) {
    if (this._useCustomChildrenLoader()) {
      const publicNode = this._dataAdapter.getPublicNode(node);
      return this._loadChildrenByCustomLoader(publicNode).done((newItems) => {
        if (!this._areNodesExists(newItems)) {
          this._appendItems(newItems);
        }
      });
    }
    if (!this._isVirtualMode()) {
      return Deferred().resolve([]).promise();
    }
    this._filter.internal = [this.option("parentIdExpr"), node.internalFields.key];
    this._dataSource.filter(this._combineFilter());
    return this._dataSource.load().done((newItems) => {
      if (!this._areNodesExists(newItems)) {
        this._appendItems(newItems);
      }
    });
  }
  _areNodesExists(newItems) {
    const keyOfRootItem = this.keyOf(newItems[0]);
    const fullData = this._dataAdapter.getFullData();
    return !!this._dataAdapter.getNodeByKey(keyOfRootItem, fullData);
  }
  _appendItems(newItems) {
    const {
      items = []
    } = this.option();
    this.option().items = items.concat(newItems);
    this._initDataAdapter();
  }
  _animateNodeContainer(node, state, e, completionCallback) {
    const $node = this._getNodeElement(node);
    const $nodeContainer = $node.children(`.${NODE_CONTAINER_CLASS}`);
    if (node && completionCallback && 0 === $nodeContainer.length) {
      completionCallback.resolve();
    }
    $nodeContainer.addClass(OPENED_NODE_CONTAINER_CLASS);
    const nodeHeight = getHeight($nodeContainer);
    fx_default.stop($nodeContainer, true);
    fx_default.animate($nodeContainer, {
      type: "custom",
      duration: this.option("animationEnabled") ? 400 : 0,
      from: {
        maxHeight: state ? 0 : nodeHeight
      },
      to: {
        maxHeight: state ? nodeHeight : 0
      },
      complete: function() {
        $nodeContainer.css("maxHeight", "none");
        $nodeContainer.toggleClass(OPENED_NODE_CONTAINER_CLASS, state);
        this.setAria("expanded", state, $node);
        this.getScrollable().update();
        this._fireExpandedStateUpdatedEvent(state, node, e);
        if (completionCallback) {
          completionCallback.resolve();
        }
      }.bind(this)
    });
  }
  _fireExpandedStateUpdatedEvent(isExpanded, node, e) {
    if (!this._hasChildren(node) || this._skipContentReadyAndItemExpanded) {
      return;
    }
    const optionName = isExpanded ? "onItemExpanded" : "onItemCollapsed";
    if (isDefined(e)) {
      this._itemDXEventHandler(e, optionName, {
        node: this._dataAdapter.getPublicNode(node)
      });
    } else {
      const target = this._getNodeElement(node);
      this._itemEventHandler(target, optionName, {
        event: e,
        node: this._dataAdapter.getPublicNode(node)
      });
    }
  }
  _normalizeIconState($node, hasNewItems) {
    const $loadIndicator = $node.find(`.${NODE_LOAD_INDICATOR_CLASS}`);
    if ($loadIndicator.length) {
      var _LoadIndicator$getIns;
      null === (_LoadIndicator$getIns = load_indicator_default.getInstance($loadIndicator)) || void 0 === _LoadIndicator$getIns || _LoadIndicator$getIns.option("visible", false);
    }
    const $treeViewItem = this._getItem($node);
    const $toggleItem = $treeViewItem.children(`.${CUSTOM_COLLAPSE_ICON_CLASS},.${TOGGLE_ITEM_VISIBILITY_CLASS}`);
    if (hasNewItems) {
      $toggleItem.show();
      return;
    }
    $toggleItem.removeClass(TOGGLE_ITEM_VISIBILITY_CLASS);
    $node.addClass(IS_LEAF);
  }
  _emptyMessageContainer() {
    const scrollable = this.getScrollable();
    return scrollable ? renderer_default(scrollable.content()) : super._emptyMessageContainer();
  }
  _renderContent() {
    const {
      items
    } = this.option();
    if (items && items.length) {
      this._contentAlreadyRendered = true;
    }
    super._renderContent();
  }
  _renderSelectAllItem($container) {
    const {
      selectAllText,
      focusStateEnabled
    } = this.option();
    $container = $container || this.$element().find(`.${NODE_CONTAINER_CLASS}`).first();
    this._$selectAllItem = renderer_default("<div>").addClass(SELECT_ALL_ITEM_CLASS);
    const value2 = this._dataAdapter.isAllSelected();
    this._createComponent(this._$selectAllItem, check_box_default2, {
      value: value2,
      elementAttr: {
        "aria-label": "Select All"
      },
      text: selectAllText,
      focusStateEnabled,
      onValueChanged: this._onSelectAllCheckboxValueChanged.bind(this),
      onInitialized: (_ref) => {
        let {
          component
        } = _ref;
        component.registerKeyHandler("enter", () => {
          component.option("value", !component.option("value"));
        });
      }
    });
    this._toggleSelectedClass(this._$selectAllItem, value2);
    $container.before(this._$selectAllItem);
  }
  _onSelectAllCheckboxValueChanged(args) {
    this._toggleSelectAll(args);
    this._fireSelectAllValueChanged(args.value);
  }
  _toggleSelectAll(args) {
    this._dataAdapter.toggleSelectAll(args.value);
    this._updateItemsUI();
    this._fireSelectionChanged();
  }
  _renderCheckBox($node, node) {
    const $checkbox = renderer_default("<div>").appendTo($node);
    this._createComponent($checkbox, check_box_default2, {
      value: node.internalFields.selected,
      onValueChanged: this._changeCheckboxValue.bind(this),
      focusStateEnabled: false,
      elementAttr: {
        "aria-label": message_default.format("CheckState")
      },
      disabled: this._disabledGetter(node)
    });
  }
  _toggleSelectedClass($node, value2) {
    $node.toggleClass("dx-state-selected", !!value2);
  }
  _toggleNodeDisabledState(node, state) {
    const $node = this._getNodeElement(node);
    const $item = $node.find(`.${ITEM_CLASS3}`).eq(0);
    this._dataAdapter.toggleNodeDisabledState(node.internalFields.key, state);
    $item.toggleClass("dx-state-disabled", !!state);
    if (this._showCheckboxes()) {
      const checkbox = this._getCheckBoxInstance($node);
      checkbox.option("disabled", !!state);
    }
  }
  _itemOptionChanged(item, property, value2) {
    const node = this._dataAdapter.getNodeByItem(item);
    if (property === this.option("disabledExpr")) {
      this._toggleNodeDisabledState(node, value2);
    }
  }
  _changeCheckboxValue(e) {
    const $node = renderer_default(e.element).closest(`.${NODE_CLASS}`);
    const $item = this._getItem($node);
    const item = this._getItemData($item);
    const node = this._getNodeByElement($item);
    const {
      value: value2
    } = e;
    if (node && node.internalFields.selected === value2) {
      return;
    }
    this._updateItemSelection(value2, item, e.event);
  }
  _isSingleSelection() {
    const {
      selectionMode
    } = this.option();
    return "single" === selectionMode;
  }
  _isRecursiveSelection() {
    const {
      selectionMode
    } = this.option();
    return this.option("selectNodesRecursive") && "single" !== selectionMode;
  }
  _isLastSelectedBranch(publicNode, selectedNodesKeys, deep) {
    const keyIndex = selectedNodesKeys.indexOf(publicNode.key);
    if (keyIndex >= 0) {
      selectedNodesKeys.splice(keyIndex, 1);
    }
    if (deep) {
      each(publicNode.children, (_, childNode) => {
        this._isLastSelectedBranch(childNode, selectedNodesKeys, true);
      });
    }
    if (publicNode.parent) {
      this._isLastSelectedBranch(publicNode.parent, selectedNodesKeys);
    }
    return 0 === selectedNodesKeys.length;
  }
  _isLastRequired(node) {
    const selectionRequired = this.option("selectionRequired");
    const isSingleMode = this._isSingleSelection();
    const selectedNodesKeys = this.getSelectedNodeKeys();
    if (!selectionRequired) {
      return;
    }
    if (isSingleMode) {
      return 1 === selectedNodesKeys.length;
    }
    return this._isLastSelectedBranch(node.internalFields.publicNode, selectedNodesKeys.slice(), true);
  }
  _updateItemSelection(value2, itemElement, dxEvent) {
    const node = this._getNode(itemElement);
    if (!node || false === node.visible) {
      return false;
    }
    if (node.internalFields.selected === value2) {
      return true;
    }
    if (!value2 && this._isLastRequired(node)) {
      if (this._showCheckboxes()) {
        const $node = this._getNodeElement(node);
        this._getCheckBoxInstance($node).option("value", true);
      }
      return false;
    }
    if (value2 && this._isSingleSelection()) {
      const selectedKeys = this.getSelectedNodeKeys();
      each(selectedKeys, (index2, key) => {
        this._dataAdapter.toggleSelection(key, false);
        this._updateItemsUI();
        this._fireItemSelectionChanged(this._getNode(key));
      });
    }
    this._dataAdapter.toggleSelection(node.internalFields.key, value2);
    const isAllSelected = this._dataAdapter.isAllSelected();
    const needFireSelectAllChanged = this._selectAllEnabled() && this._$selectAllItem.dxCheckBox("instance").option("value") !== isAllSelected;
    this._updateItemsUI();
    this._fireItemSelectionChanged(node, dxEvent);
    this._fireSelectionChanged();
    if (needFireSelectAllChanged) {
      this._fireSelectAllValueChanged(isAllSelected);
    }
    return true;
  }
  _fireItemSelectionChanged(node, dxEvent) {
    const initiator = dxEvent || this._findItemElementByItem(node.internalFields.item);
    const handler = dxEvent ? this._itemDXEventHandler : this._itemEventHandler;
    handler.call(this, initiator, "onItemSelectionChanged", {
      node: this._dataAdapter.getPublicNode(node),
      itemData: node.internalFields.item
    });
  }
  _getCheckBoxInstance($node) {
    const $treeViewItem = this._getItem($node);
    return $treeViewItem.children(".dx-checkbox").dxCheckBox("instance");
  }
  _updateItemsUI() {
    const cache = {};
    each(this._dataAdapter.getData(), (_, node) => {
      const $node = this._getNodeElement(node, cache);
      const nodeSelection = node.internalFields.selected;
      if (!$node.length) {
        return;
      }
      this._toggleSelectedClass($node, nodeSelection);
      this.setAria("selected", nodeSelection, $node);
      if (this._showCheckboxes()) {
        this._getCheckBoxInstance($node).option("value", nodeSelection);
      }
    });
    if (this._selectAllEnabled()) {
      const selectAllCheckbox = this._$selectAllItem.dxCheckBox("instance");
      selectAllCheckbox.option("onValueChanged", void 0);
      selectAllCheckbox.option("value", this._dataAdapter.isAllSelected());
      selectAllCheckbox.option("onValueChanged", this._onSelectAllCheckboxValueChanged.bind(this));
    }
  }
  _updateParentsState(node, $node) {
    if (!$node) {
      return;
    }
    const parentNode = this._dataAdapter.getNodeByKey(node.internalFields.parentKey);
    const $parentNode = renderer_default($node.parents(`.${NODE_CLASS}`)[0]);
    if (this._showCheckboxes()) {
      var _this$_getCheckBoxIns;
      const parentValue = parentNode.internalFields.selected;
      null === (_this$_getCheckBoxIns = this._getCheckBoxInstance($parentNode)) || void 0 === _this$_getCheckBoxIns || _this$_getCheckBoxIns.option("value", parentValue);
      this._toggleSelectedClass($parentNode, parentValue);
    }
    if (parentNode.internalFields.parentKey !== this.option("rootValue")) {
      this._updateParentsState(parentNode, $parentNode);
    }
  }
  _itemEventHandlerImpl(initiator, action, actionArgs) {
    const $itemElement = renderer_default(initiator).closest(`.${NODE_CLASS}`).children(`.${ITEM_CLASS3}`);
    return action(extend(this._extendActionArgs($itemElement), actionArgs));
  }
  _itemContextMenuHandler(e) {
    this._createEventHandler("onItemContextMenu", e);
  }
  _itemHoldHandler(e) {
    this._createEventHandler("onItemHold", e);
  }
  _createEventHandler(eventName, e) {
    const node = this._getNodeByElement(e.currentTarget);
    this._itemDXEventHandler(e, eventName, {
      node: this._dataAdapter.getPublicNode(node)
    });
  }
  _itemClass() {
    return ITEM_CLASS3;
  }
  _itemDataKey() {
    return ITEM_DATA_KEY;
  }
  _attachClickEvent() {
    const $itemContainer = this._itemContainer();
    this._detachClickEvent($itemContainer);
    const {
      clickEventNamespace,
      itemSelector,
      pointerDownEventNamespace,
      nodeSelector
    } = this._getItemClickEventData();
    m_events_engine_default.on($itemContainer, clickEventNamespace, itemSelector, (e) => {
      if (renderer_default(e.target).hasClass("dx-checkbox-icon") || renderer_default(e.target).hasClass("dx-checkbox")) {
        return;
      }
      this._itemClickHandler(e, renderer_default(e.currentTarget));
    });
    m_events_engine_default.on($itemContainer, pointerDownEventNamespace, nodeSelector, (e) => {
      this._itemPointerDownHandler(e);
    });
  }
  _detachClickEvent(itemsContainer) {
    const {
      clickEventNamespace,
      itemSelector,
      pointerDownEventNamespace,
      nodeSelector
    } = this._getItemClickEventData();
    m_events_engine_default.off(itemsContainer, clickEventNamespace, itemSelector);
    m_events_engine_default.off(itemsContainer, pointerDownEventNamespace, nodeSelector);
  }
  _getItemClickEventData() {
    const itemSelector = `.${this._itemClass()}`;
    const nodeSelector = `.${NODE_CLASS}, .${SELECT_ALL_ITEM_CLASS}`;
    const clickEventNamespace = addNamespace2(CLICK_EVENT_NAME, this.NAME);
    const pointerDownEventNamespace = addNamespace2(m_pointer_default.down, this.NAME);
    return {
      clickEventNamespace,
      itemSelector,
      pointerDownEventNamespace,
      nodeSelector
    };
  }
  _itemClick(actionArgs) {
    const args = actionArgs.args[0];
    const target = args.event.target[0] || args.event.target;
    const link = target.getElementsByClassName("dx-item-url")[0];
    if (args.itemData.url && link) {
      link.click();
    }
  }
  _itemClickHandler(e, $item) {
    const itemData = this._getItemData($item);
    const node = this._getNodeByElement($item);
    this._itemDXEventHandler(e, "onItemClick", {
      node: this._dataAdapter.getPublicNode(node)
    }, {
      beforeExecute: this._itemClick
    });
    if (this.option("selectByClick") && !e.isDefaultPrevented()) {
      this._updateItemSelection(!node.internalFields.selected, itemData, e);
    }
  }
  _updateSelectionToFirstItem($items, startIndex) {
    let itemIndex = startIndex;
    while (itemIndex >= 0) {
      const $item = renderer_default($items[itemIndex]);
      this._updateItemSelection(true, $item.find(`.${ITEM_CLASS3}`).get(0));
      itemIndex--;
    }
  }
  _updateSelectionToLastItem($items, startIndex) {
    const {
      length
    } = $items;
    let itemIndex = startIndex;
    while (itemIndex < length) {
      const $item = renderer_default($items[itemIndex]);
      this._updateItemSelection(true, $item.find(`.${ITEM_CLASS3}`).get(0));
      itemIndex++;
    }
  }
  focus() {
    if (this._selectAllEnabled()) {
      m_events_engine_default.trigger(this._$selectAllItem, "focus");
      return;
    }
    super.focus();
  }
  _focusInHandler(e) {
    this._updateFocusState(e, true);
    const isSelectAllItem = renderer_default(e.target).hasClass(SELECT_ALL_ITEM_CLASS);
    if (isSelectAllItem || this.option("focusedElement")) {
      clearTimeout(this._setFocusedItemTimeout);
      this._setFocusedItemTimeout = setTimeout(() => {
        const {
          focusedElement
        } = this.option();
        const element = isSelectAllItem ? getPublicElement(this._$selectAllItem) : renderer_default(focusedElement);
        this._setFocusedItem(element);
      });
      return;
    }
    const $activeItem = this._getActiveItem();
    this.option("focusedElement", getPublicElement($activeItem.closest(`.${NODE_CLASS}`)));
  }
  _itemPointerDownHandler(e) {
    if (!this.option("focusStateEnabled")) {
      return;
    }
    const $target = renderer_default(e.target).closest(`.${NODE_CLASS}, .${SELECT_ALL_ITEM_CLASS}`);
    if (!$target.length) {
      return;
    }
    const itemElement = $target.hasClass("dx-state-disabled") ? null : $target;
    this.option("focusedElement", getPublicElement(itemElement));
  }
  _findNonDisabledNodes($nodes) {
    return $nodes.not(function() {
      return renderer_default(this).children(`.${ITEM_CLASS3}`).hasClass("dx-state-disabled");
    });
  }
  _moveFocus(location, e) {
    const FOCUS_LEFT = this.option("rtlEnabled") ? "right" : "left";
    const FOCUS_RIGHT = this.option("rtlEnabled") ? "left" : "right";
    this.$element().find(`.${NODE_CONTAINER_CLASS}`).each(function() {
      fx_default.stop(this, true);
    });
    const $items = this._nodeElements();
    if (!$items || !$items.length) {
      return;
    }
    switch (location) {
      case "up": {
        const $prevItem = this._prevItem($items);
        this.option("focusedElement", getPublicElement($prevItem));
        const prevItemElement = this._getNodeItemElement($prevItem);
        this.getScrollable().scrollToElement(prevItemElement);
        if (e.shiftKey && this._showCheckboxes()) {
          this._updateItemSelection(true, prevItemElement);
        }
        break;
      }
      case "down": {
        const $nextItem = this._nextItem($items);
        this.option("focusedElement", getPublicElement($nextItem));
        const nextItemElement = this._getNodeItemElement($nextItem);
        this.getScrollable().scrollToElement(nextItemElement);
        if (e.shiftKey && this._showCheckboxes()) {
          this._updateItemSelection(true, nextItemElement);
        }
        break;
      }
      case "first": {
        const $firstItem = $items.first();
        if (e.shiftKey && this._showCheckboxes()) {
          this._updateSelectionToFirstItem($items, $items.index(this._prevItem($items)));
        }
        this.option("focusedElement", getPublicElement($firstItem));
        this.getScrollable().scrollToElement(this._getNodeItemElement($firstItem));
        break;
      }
      case "last": {
        const $lastItem = $items.last();
        if (e.shiftKey && this._showCheckboxes()) {
          this._updateSelectionToLastItem($items, $items.index(this._nextItem($items)));
        }
        this.option("focusedElement", getPublicElement($lastItem));
        this.getScrollable().scrollToElement(this._getNodeItemElement($lastItem));
        break;
      }
      case FOCUS_RIGHT:
        this._expandFocusedContainer();
        break;
      case FOCUS_LEFT:
        this._collapseFocusedContainer();
        break;
      default:
        super._moveFocus.apply(this, arguments);
    }
  }
  _getNodeItemElement($node) {
    return $node.find(`.${ITEM_CLASS3}`).get(0);
  }
  _nodeElements() {
    return this.$element().find(`.${NODE_CLASS}`).not(":hidden");
  }
  _expandFocusedContainer() {
    const {
      focusedElement
    } = this.option();
    const $focusedNode = renderer_default(focusedElement);
    if (!$focusedNode.length || $focusedNode.hasClass(IS_LEAF)) {
      return;
    }
    const $node = $focusedNode.find(`.${NODE_CONTAINER_CLASS}`).eq(0);
    if ($node.hasClass(OPENED_NODE_CONTAINER_CLASS)) {
      const $nextItem = this._nextItem(this._findNonDisabledNodes(this._nodeElements()));
      this.option("focusedElement", getPublicElement($nextItem));
      this.getScrollable().scrollToElement(this._getNodeItemElement($nextItem));
      return;
    }
    const node = this._getNodeByElement(this._getItem($focusedNode));
    this._toggleExpandedState(node, true);
  }
  _getClosestNonDisabledNode($node) {
    do {
      $node = $node.parent().closest(`.${NODE_CLASS}`);
    } while ($node.children(".dx-treeview-item.dx-state-disabled").length);
    return $node;
  }
  _collapseFocusedContainer() {
    const {
      focusedElement
    } = this.option();
    const $focusedNode = renderer_default(focusedElement);
    if (!$focusedNode.length) {
      return;
    }
    const nodeElement = $focusedNode.find(`.${NODE_CONTAINER_CLASS}`).eq(0);
    if (!$focusedNode.hasClass(IS_LEAF) && nodeElement.hasClass(OPENED_NODE_CONTAINER_CLASS)) {
      const node = this._getNodeByElement(this._getItem($focusedNode));
      this._toggleExpandedState(node, false);
    } else {
      const collapsedNode = this._getClosestNonDisabledNode($focusedNode);
      collapsedNode.length && this.option("focusedElement", getPublicElement(collapsedNode));
      this.getScrollable().scrollToElement(this._getNodeItemElement(collapsedNode));
    }
  }
  _encodeString(value2) {
    return isString(value2) ? encodeURI(value2) : value2;
  }
  _decodeString(value2) {
    return isString(value2) ? decodeURI(value2) : value2;
  }
  getScrollable() {
    return this._scrollable;
  }
  updateDimensions() {
    const deferred = Deferred();
    const scrollable = this.getScrollable();
    if (scrollable) {
      scrollable.update().done(() => {
        deferred.resolveWith(this);
      });
    } else {
      deferred.resolveWith(this);
    }
    return deferred.promise();
  }
  selectItem(itemElement) {
    return this._updateItemSelection(true, itemElement);
  }
  unselectItem(itemElement) {
    return this._updateItemSelection(false, itemElement);
  }
  expandItem(itemElement) {
    return this._toggleExpandedState(itemElement, true);
  }
  collapseItem(itemElement) {
    return this._toggleExpandedState(itemElement, false);
  }
  getNodes() {
    return this._dataAdapter.getTreeNodes();
  }
  getSelectedNodes() {
    return this.getSelectedNodeKeys().map((key) => {
      const node = this._dataAdapter.getNodeByKey(key);
      return this._dataAdapter.getPublicNode(node);
    });
  }
  getSelectedNodeKeys() {
    return this._dataAdapter.getSelectedNodesKeys();
  }
  selectAll() {
    if (this._selectAllEnabled()) {
      this._$selectAllItem.dxCheckBox("instance").option("value", true);
    } else {
      this._toggleSelectAll({
        value: true
      });
    }
  }
  unselectAll() {
    if (this._selectAllEnabled()) {
      this._$selectAllItem.dxCheckBox("instance").option("value", false);
    } else {
      this._toggleSelectAll({
        value: false
      });
    }
  }
  _allItemsExpandedHandler() {
    this._skipContentReadyAndItemExpanded = false;
    this._fireContentReadyAction();
  }
  expandAll() {
    const nodes = this._dataAdapter.getData();
    const expandingPromises = [];
    this._skipContentReadyAndItemExpanded = true;
    nodes.forEach((node) => expandingPromises.push(this._toggleExpandedState(node.internalFields.key, true)));
    Promise.allSettled(expandingPromises).then(() => {
      var _this$_allItemsExpand;
      return null === (_this$_allItemsExpand = this._allItemsExpandedHandler) || void 0 === _this$_allItemsExpand ? void 0 : _this$_allItemsExpand.call(this);
    });
  }
  collapseAll() {
    each(this._dataAdapter.getExpandedNodesKeys(), (_, key) => {
      this._toggleExpandedState(key, false);
    });
  }
  scrollToItem(keyOrItemOrElement) {
    const node = this._getNode(keyOrItemOrElement);
    if (!node) {
      return Deferred().reject().promise();
    }
    const nodeKeysToExpand = [];
    let parentNode = node.internalFields.publicNode.parent;
    while (null != parentNode) {
      if (!parentNode.expanded) {
        nodeKeysToExpand.push(parentNode.key);
      }
      parentNode = parentNode.parent;
    }
    const scrollCallback = Deferred();
    this._expandNodes(nodeKeysToExpand.reverse()).always(() => {
      const $element = this._getNodeElement(node);
      if ($element && $element.length) {
        this.scrollToElementTopLeft($element.get(0));
        scrollCallback.resolve();
      } else {
        scrollCallback.reject();
      }
    });
    return scrollCallback.promise();
  }
  scrollToElementTopLeft(targetElement) {
    const scrollable = this.getScrollable();
    const {
      scrollDirection,
      rtlEnabled
    } = this.option();
    const targetLocation = {
      top: 0,
      left: 0
    };
    const relativeOffset = getRelativeOffset(SCROLLABLE_CONTENT_CLASS, targetElement);
    if (scrollDirection !== DIRECTION_VERTICAL) {
      const containerElement = renderer_default(scrollable.container()).get(0);
      targetLocation.left = rtlEnabled ? relativeOffset.left + targetElement.offsetWidth - containerElement.clientWidth : relativeOffset.left;
    }
    if (scrollDirection !== DIRECTION_HORIZONTAL) {
      targetLocation.top = relativeOffset.top;
    }
    scrollable.scrollTo(targetLocation);
  }
  _expandNodes(keysToExpand) {
    if (!keysToExpand || 0 === keysToExpand.length) {
      return Deferred().resolve().promise();
    }
    const resultCallback = Deferred();
    const callbacksByNodes = keysToExpand.map((key) => this.expandItem(key));
    when.apply(renderer_default, callbacksByNodes).done(() => resultCallback.resolve()).fail(() => resultCallback.reject());
    return resultCallback.promise();
  }
  _dispose() {
    super._dispose();
    clearTimeout(this._setFocusedItemTimeout);
    this._allItemsExpandedHandler = null;
  }
};
var m_tree_view_base_default = TreeViewBase;

// node_modules/devextreme/esm/__internal/ui/tree_view/m_tree_view.search.js
ui_search_box_mixin_default.setEditorClass(text_box_default2);
var WIDGET_CLASS4 = "dx-treeview";
var NODE_CONTAINER_CLASS2 = `${WIDGET_CLASS4}-node-container`;
var TreeViewSearch = m_tree_view_base_default.inherit(ui_search_box_mixin_default).inherit({
  _addWidgetPrefix: (className) => `${WIDGET_CLASS4}-${className}`,
  _optionChanged(args) {
    switch (args.name) {
      case "searchValue":
        if (this._showCheckboxes() && this._isRecursiveSelection()) {
          this._removeSelection();
        }
        this._initDataAdapter();
        this._updateSearch();
        this._repaintContainer();
        this.option("focusedElement", null);
        break;
      case "searchExpr":
        this._initDataAdapter();
        this.repaint();
        break;
      case "searchMode":
        this.option("expandNodesRecursive") ? this._updateDataAdapter() : this._initDataAdapter();
        this.repaint();
        break;
      default:
        this.callBase(args);
    }
  },
  _updateDataAdapter() {
    this._setOptionWithoutOptionChange("expandNodesRecursive", false);
    this._initDataAdapter();
    this._setOptionWithoutOptionChange("expandNodesRecursive", true);
  },
  _getDataAdapterOptions() {
    return extend(this.callBase(), {
      searchValue: this.option("searchValue"),
      searchMode: this.option("searchMode") || "contains",
      searchExpr: this.option("searchExpr")
    });
  },
  _getNodeContainer() {
    return this.$element().find(`.${NODE_CONTAINER_CLASS2}`).first();
  },
  _updateSearch() {
    if (this._searchEditor) {
      const editorOptions = this._getSearchEditorOptions();
      this._searchEditor.option(editorOptions);
    }
  },
  _repaintContainer() {
    const $container = this._getNodeContainer();
    let rootNodes;
    if ($container.length) {
      $container.empty();
      rootNodes = this._dataAdapter.getRootNodes();
      this._renderEmptyMessage(rootNodes);
      this._renderItems($container, rootNodes);
      this._fireContentReadyAction();
    }
  },
  _focusTarget() {
    return this._itemContainer(this.option("searchEnabled"));
  },
  _cleanItemContainer() {
    this.$element().empty();
  },
  _itemContainer(isSearchMode, selectAllEnabled) {
    selectAllEnabled ?? (selectAllEnabled = this._selectAllEnabled());
    if (selectAllEnabled) {
      return this._getNodeContainer();
    }
    if (this._scrollable && isSearchMode) {
      return renderer_default(this._scrollable.content());
    }
    return this.callBase();
  },
  _addWidgetClass() {
    this.$element().addClass(this._widgetClass());
  },
  _clean() {
    this.callBase();
    this._removeSearchBox();
  }
});
component_registrator_default("dxTreeView", TreeViewSearch);
var m_tree_view_search_default = TreeViewSearch;

// node_modules/devextreme/esm/ui/tree_view.js
var tree_view_default = m_tree_view_search_default;

// node_modules/devextreme/esm/__internal/grids/grid_core/column_chooser/const.js
var defaultOptions3 = {
  columnChooser: {
    enabled: false,
    search: {
      enabled: false,
      timeout: 500,
      editorOptions: {}
    },
    selection: {
      allowSelectAll: false,
      selectByClick: false,
      recursive: false
    },
    position: void 0,
    sortOrder: void 0,
    mode: "dragAndDrop",
    width: 250,
    height: 260,
    title: message_default.format("dxDataGrid-columnChooserTitle"),
    emptyPanelText: message_default.format("dxDataGrid-columnChooserEmptyText"),
    container: void 0
  }
};

// node_modules/devextreme/esm/__internal/grids/grid_core/column_chooser/m_column_chooser.js
var COLUMN_CHOOSER_DRAG_CLASS = "column-chooser-mode-drag";
var COLUMN_CHOOSER_SELECT_CLASS = "column-chooser-mode-select";
var COLUMN_OPTIONS_USED_IN_ITEMS = ["showInColumnChooser", "caption", "allowHiding", "visible", "cssClass", "ownerBand"];
var processItems = function(that, chooserColumns) {
  const items = [];
  const isSelectMode = that.isSelectMode();
  const isRecursive = that.option("columnChooser.selection.recursive");
  if (chooserColumns.length) {
    each(chooserColumns, (index2, column) => {
      const item = {
        text: column.caption,
        cssClass: column.cssClass,
        allowHiding: column.allowHiding,
        expanded: true,
        id: column.index,
        disabled: false === column.allowHiding,
        parentId: isDefined(column.ownerBand) ? column.ownerBand : null
      };
      const isRecursiveWithColumns = isRecursive && column.hasColumns;
      if (isSelectMode && !isRecursiveWithColumns) {
        item.selected = column.visible;
      }
      items.push(item);
    });
  }
  return items;
};
var ColumnChooserController = class extends m_modules_default.ViewController {
  init() {
    super.init();
    this._rowsView = this.getView("rowsView");
  }
  renderShowColumnChooserButton($element) {
    const that = this;
    const columnChooserButtonClass = that.addWidgetPrefix("column-chooser-button");
    const columnChooserEnabled = that.option("columnChooser.enabled");
    const $showColumnChooserButton = $element.find(`.${columnChooserButtonClass}`);
    let $columnChooserButton;
    if (columnChooserEnabled) {
      if (!$showColumnChooserButton.length) {
        $columnChooserButton = renderer_default("<div>").addClass(columnChooserButtonClass).appendTo($element);
        that._createComponent($columnChooserButton, button_default2, {
          icon: "column-chooser",
          onClick() {
            that.getView("columnChooserView").showColumnChooser();
          },
          hint: that.option("columnChooser.title"),
          integrationOptions: {}
        });
      } else {
        $showColumnChooserButton.show();
      }
    } else {
      $showColumnChooserButton.hide();
    }
  }
  getPosition() {
    var _this$_rowsView;
    const position3 = this.option("columnChooser.position");
    return isDefined(position3) ? position3 : {
      my: "right bottom",
      at: "right bottom",
      of: null === (_this$_rowsView = this._rowsView) || void 0 === _this$_rowsView ? void 0 : _this$_rowsView.element(),
      collision: "fit",
      offset: "-2 -2",
      boundaryOffset: "2 2"
    };
  }
};
var ColumnChooserView = class extends ColumnsView {
  optionChanged(args) {
    if ("columnChooser" === args.name) {
      this._initializePopupContainer();
      this.render(null, "full");
    } else {
      super.optionChanged(args);
    }
  }
  publicMethods() {
    return ["showColumnChooser", "hideColumnChooser"];
  }
  _resizeCore() {
  }
  _isWinDevice() {
    return !!devices_default.real().win;
  }
  _initializePopupContainer() {
    const that = this;
    const columnChooserClass = that.addWidgetPrefix("column-chooser");
    const $element = that.element().addClass(columnChooserClass);
    const columnChooserOptions = that.option("columnChooser");
    const popupPosition = this._columnChooserController.getPosition();
    const dxPopupOptions = {
      visible: false,
      shading: false,
      showCloseButton: true,
      dragEnabled: true,
      resizeEnabled: true,
      wrapperAttr: {
        class: columnChooserClass
      },
      toolbarItems: [{
        text: columnChooserOptions.title,
        toolbar: "top",
        location: "before"
      }],
      position: popupPosition,
      width: columnChooserOptions.width,
      height: columnChooserOptions.height,
      rtlEnabled: that.option("rtlEnabled"),
      onHidden() {
        if (that._isWinDevice()) {
          renderer_default("body").removeClass(that.addWidgetPrefix("notouch-action"));
        }
      },
      container: columnChooserOptions.container,
      _loopFocus: true
    };
    if (!isDefined(this._popupContainer)) {
      that._popupContainer = that._createComponent($element, ui_popup_default, dxPopupOptions);
      that._popupContainer.on("optionChanged", (args) => {
        if ("visible" === args.name) {
          that.renderCompleted.fire();
        }
      });
    } else {
      this._popupContainer.option(dxPopupOptions);
    }
    this.setPopupAttributes();
  }
  setPopupAttributes() {
    const isSelectMode = this.isSelectMode();
    const isBandColumnsUsed = this._columnsController.isBandColumnsUsed();
    this._popupContainer.setAria({
      role: "dialog",
      label: message_default.format("dxDataGrid-columnChooserTitle")
    });
    this._popupContainer.$wrapper().toggleClass(this.addWidgetPrefix(COLUMN_CHOOSER_DRAG_CLASS), !isSelectMode).toggleClass(this.addWidgetPrefix(COLUMN_CHOOSER_SELECT_CLASS), isSelectMode);
    this._popupContainer.$content().addClass(this.addWidgetPrefix("column-chooser-list"));
    if (isSelectMode && !isBandColumnsUsed) {
      this._popupContainer.$content().addClass(this.addWidgetPrefix("column-chooser-plain"));
    }
  }
  _renderCore(change) {
    if (this._popupContainer) {
      const isDragMode = !this.isSelectMode();
      if (!this._columnChooserList || "full" === change) {
        this._renderTreeView();
      } else if (isDragMode) {
        this._updateItems();
      }
    }
  }
  _renderTreeView() {
    var _columnChooser$search, _columnChooser$search2, _columnChooser$search3;
    const that = this;
    const $container = this._popupContainer.$content();
    const columnChooser = this.option("columnChooser");
    const isSelectMode = this.isSelectMode();
    const searchEnabled = isDefined(columnChooser.allowSearch) ? columnChooser.allowSearch : null === (_columnChooser$search = columnChooser.search) || void 0 === _columnChooser$search ? void 0 : _columnChooser$search.enabled;
    const searchTimeout = isDefined(columnChooser.searchTimeout) ? columnChooser.searchTimeout : null === (_columnChooser$search2 = columnChooser.search) || void 0 === _columnChooser$search2 ? void 0 : _columnChooser$search2.timeout;
    const treeViewConfig = {
      dataStructure: "plain",
      activeStateEnabled: true,
      focusStateEnabled: true,
      hoverStateEnabled: true,
      itemTemplate: "item",
      showCheckBoxesMode: "none",
      rootValue: null,
      searchEnabled,
      searchTimeout,
      searchEditorOptions: null === (_columnChooser$search3 = columnChooser.search) || void 0 === _columnChooser$search3 ? void 0 : _columnChooser$search3.editorOptions
    };
    if (this._isWinDevice()) {
      treeViewConfig.useNativeScrolling = false;
    }
    extend(treeViewConfig, isSelectMode ? this._prepareSelectModeConfig() : this._prepareDragModeConfig());
    if (this._columnChooserList) {
      if (!treeViewConfig.searchEnabled) {
        treeViewConfig.searchValue = "";
      }
      this._columnChooserList.option(treeViewConfig);
      this._updateItems();
    } else {
      this._columnChooserList = this._createComponent($container, tree_view_default, treeViewConfig);
      this._updateItems();
      let scrollTop = 0;
      this._columnChooserList.on("optionChanged", (e) => {
        const scrollable = e.component.getScrollable();
        scrollTop = scrollable.scrollTop();
      });
      this._columnChooserList.on("contentReady", (e) => {
        deferUpdate(() => {
          const scrollable = e.component.getScrollable();
          scrollable.scrollTo({
            y: scrollTop
          });
          that.renderCompleted.fire();
        });
      });
    }
  }
  _prepareDragModeConfig() {
    const columnChooserOptions = this.option("columnChooser");
    return {
      noDataText: columnChooserOptions.emptyPanelText,
      activeStateEnabled: false,
      hoverStateEnabled: false,
      itemTemplate(data17, index2, item) {
        renderer_default(item).text(data17.text).parent().addClass(data17.cssClass).addClass("dx-column-chooser-item");
      }
    };
  }
  _prepareSelectModeConfig() {
    const that = this;
    const selectionOptions = this.option("columnChooser.selection") ?? {};
    let isUpdatingSelection = false;
    return {
      selectByClick: selectionOptions.selectByClick,
      selectNodesRecursive: selectionOptions.recursive,
      showCheckBoxesMode: selectionOptions.allowSelectAll ? "selectAll" : "normal",
      onSelectionChanged: (e) => {
        if (isUpdatingSelection) {
          return;
        }
        const nodes = ((nodes2) => {
          const addNodesToArray = (nodes3, flatNodesArray) => nodes3.reduce((result2, node) => {
            result2.push(node);
            if (node.children.length) {
              addNodesToArray(node.children, result2);
            }
            return result2;
          }, flatNodesArray);
          return addNodesToArray(nodes2, []);
        })(e.component.getNodes());
        e.component.beginUpdate();
        isUpdatingSelection = true;
        ((e2, nodes2) => {
          nodes2.filter((node) => false === node.itemData.allowHiding).forEach((node) => e2.component.selectItem(node.key));
        })(e, nodes);
        e.component.endUpdate();
        isUpdatingSelection = false;
        that.component.beginUpdate();
        this._isUpdatingColumnVisibility = true;
        ((nodes2) => {
          nodes2.forEach((node) => {
            const columnIndex = node.itemData.id;
            const isVisible2 = false !== node.selected;
            that._columnsController.columnOption(columnIndex, "visible", isVisible2);
          });
        })(nodes);
        that.component.endUpdate();
        this._isUpdatingColumnVisibility = false;
      }
    };
  }
  _updateItems() {
    const isSelectMode = this.isSelectMode();
    const chooserColumns = this._columnsController.getChooserColumns(isSelectMode);
    const items = processItems(this, chooserColumns);
    this._columnChooserList.option("items", items);
  }
  _updateItemsSelection(columnIndices) {
    const changedColumns = null === columnIndices || void 0 === columnIndices ? void 0 : columnIndices.map((columnIndex) => this._columnsController.columnOption(columnIndex));
    this._columnChooserList.beginUpdate();
    null === changedColumns || void 0 === changedColumns || changedColumns.forEach((_ref) => {
      let {
        visible: visible2,
        index: index2
      } = _ref;
      if (visible2) {
        this._columnChooserList.selectItem(index2);
      } else {
        this._columnChooserList.unselectItem(index2);
      }
    });
    this._columnChooserList.endUpdate();
  }
  _columnOptionChanged(e) {
    super._columnOptionChanged(e);
    const isSelectMode = this.isSelectMode();
    if (isSelectMode && this._columnChooserList && !this._isUpdatingColumnVisibility) {
      const {
        optionNames
      } = e;
      const onlyVisibleChanged = optionNames.visible && 1 === optionNames.length;
      const columnIndices = isDefined(e.columnIndex) ? [e.columnIndex] : e.columnIndices;
      const needUpdate = COLUMN_OPTIONS_USED_IN_ITEMS.some((optionName) => optionNames[optionName]) || e.changeTypes.columns && optionNames.all;
      if (needUpdate) {
        this._updateItemsSelection(columnIndices);
        if (!onlyVisibleChanged) {
          this._updateItems();
        }
      }
    }
  }
  getColumnElements() {
    var _this$_popupContainer;
    const result2 = [];
    const isSelectMode = this.isSelectMode();
    const chooserColumns = this._columnsController.getChooserColumns(isSelectMode);
    const $content = null === (_this$_popupContainer = this._popupContainer) || void 0 === _this$_popupContainer ? void 0 : _this$_popupContainer.$content();
    const $nodes = null === $content || void 0 === $content ? void 0 : $content.find(".dx-treeview-node");
    if ($nodes) {
      chooserColumns.forEach((column) => {
        const $node = $nodes.filter(`[data-item-id = '${column.index}']`);
        const item = $node.length ? $node.children(".dx-column-chooser-item").get(0) : null;
        result2.push(item);
      });
    }
    return renderer_default(result2);
  }
  getName() {
    return "columnChooser";
  }
  getColumns() {
    return this._columnsController.getChooserColumns();
  }
  allowDragging(column) {
    const isParentColumnVisible = this._columnsController.isParentColumnVisible(column.index);
    const isColumnHidden = !column.visible && column.allowHiding;
    return this.isColumnChooserVisible() && isParentColumnVisible && isColumnHidden;
  }
  allowColumnHeaderDragging(column) {
    const isDragMode = !this.isSelectMode();
    return isDragMode && this.isColumnChooserVisible() && column.allowHiding;
  }
  getBoundingRect() {
    var _that$_popupContainer;
    const container = null === (_that$_popupContainer = this._popupContainer) || void 0 === _that$_popupContainer ? void 0 : _that$_popupContainer.$overlayContent();
    if (null !== container && void 0 !== container && container.is(":visible")) {
      const offset2 = container.offset();
      return {
        left: offset2.left,
        top: offset2.top,
        right: offset2.left + getOuterWidth(container),
        bottom: offset2.top + getOuterHeight(container)
      };
    }
    return null;
  }
  showColumnChooser() {
    if (!this._popupContainer) {
      this._initializePopupContainer();
      this.render();
    }
    this._popupContainer.show();
    if (this._isWinDevice()) {
      renderer_default("body").addClass(this.addWidgetPrefix("notouch-action"));
    }
  }
  hideColumnChooser() {
    if (this._popupContainer) {
      this._popupContainer.hide();
    }
  }
  isColumnChooserVisible() {
    const popupContainer = this._popupContainer;
    return null === popupContainer || void 0 === popupContainer ? void 0 : popupContainer.option("visible");
  }
  isSelectMode() {
    return "select" === this.option("columnChooser.mode");
  }
  hasHiddenColumns() {
    const isEnabled = this.option("columnChooser.enabled");
    const hiddenColumns = this.getColumns().filter((column) => !column.visible);
    return isEnabled && hiddenColumns.length;
  }
};
var headerPanel2 = (Base) => class extends Base {
  _getToolbarItems() {
    const items = super._getToolbarItems();
    return this._appendColumnChooserItem(items);
  }
  _appendColumnChooserItem(items) {
    const that = this;
    const columnChooserEnabled = that.option("columnChooser.enabled");
    if (columnChooserEnabled) {
      const onClickHandler = function() {
        that.component.getView("columnChooserView").showColumnChooser();
      };
      const onInitialized = function(e) {
        renderer_default(e.element).addClass(that._getToolbarButtonClass(that.addWidgetPrefix("column-chooser-button")));
      };
      const hintText = that.option("columnChooser.title");
      const toolbarItem = {
        widget: "dxButton",
        options: {
          icon: "column-chooser",
          onClick: onClickHandler,
          hint: hintText,
          text: hintText,
          onInitialized,
          elementAttr: {
            "aria-haspopup": "dialog"
          }
        },
        showText: "inMenu",
        location: "after",
        name: "columnChooserButton",
        locateInMenu: "auto",
        sortIndex: 40
      };
      items.push(toolbarItem);
    }
    return items;
  }
  optionChanged(args) {
    if ("columnChooser" === args.name) {
      this._invalidate();
      args.handled = true;
    } else {
      super.optionChanged(args);
    }
  }
};
var columns2 = (Base) => class extends Base {
  allowMoveColumn(fromVisibleIndex, toVisibleIndex, sourceLocation, targetLocation) {
    const isSelectMode = "select" === this.option("columnChooser.mode");
    const isMoveColumnDisallowed = isSelectMode && "columnChooser" === targetLocation;
    return isMoveColumnDisallowed ? false : super.allowMoveColumn(fromVisibleIndex, toVisibleIndex, sourceLocation, targetLocation);
  }
};
var columnHeadersView2 = (Base) => class extends Base {
  allowDragging(column) {
    const isDragMode = !this._columnChooserView.isSelectMode();
    const isColumnChooserVisible = this._columnChooserView.isColumnChooserVisible();
    return isDragMode && isColumnChooserVisible && column.allowHiding || super.allowDragging(column);
  }
};
var columnChooserModule = {
  defaultOptions: () => defaultOptions3,
  controllers: {
    columnChooser: ColumnChooserController
  },
  views: {
    columnChooserView: ColumnChooserView
  },
  extenders: {
    views: {
      headerPanel: headerPanel2,
      columnHeadersView: columnHeadersView2
    },
    controllers: {
      columns: columns2
    }
  }
};

// node_modules/devextreme/esm/__internal/grids/data_grid/module_not_extended/column_chooser.js
var ColumnChooserController2 = columnChooserModule.controllers.columnChooser;
var ColumnChooserView2 = columnChooserModule.views.columnChooserView;
m_core_default.registerModule("columnChooser", columnChooserModule);

// node_modules/devextreme/esm/__internal/grids/data_grid/grouping/const.js
var CLASSES5 = {
  groupPanel: "dx-datagrid-group-panel",
  groupPanelMessage: "dx-group-panel-message",
  groupPanelItem: "dx-group-panel-item",
  groupPanelLabel: "dx-toolbar-label",
  groupPanelContainer: "dx-toolbar-item"
};
var CONTEXT_MENU_GROUP_BY_COLUMN_ICON_NAME = "groupbycolumn";
var CONTEXT_MENU_UNGROUP_COLUMN_ICON_NAME = "ungroupcolumn";
var CONTEXT_MENU_UNGROUP_ALL_COLUMNS_ICON_NAME = "ungroupallcolumns";

// node_modules/devextreme/esm/__internal/grids/data_grid/m_utils.js
function createGroupFilter(path, storeLoadOptions) {
  const groups = normalizeSortingInfo(storeLoadOptions.group);
  const filter = [];
  for (let i = 0; i < path.length; i++) {
    filter.push([groups[i].selector, "=", path[i]]);
  }
  if (storeLoadOptions.filter) {
    filter.push(storeLoadOptions.filter);
  }
  return m_utils_default.combineFilters(filter);
}

// node_modules/devextreme/esm/__internal/grids/data_grid/grouping/m_grouping_core.js
function createOffsetFilter(path, storeLoadOptions, lastLevelOnly) {
  const groups = normalizeSortingInfo(storeLoadOptions.group);
  let filter = [];
  for (let i = lastLevelOnly ? path.length - 1 : 0; i < path.length; i++) {
    const filterElement = [];
    for (let j = 0; j <= i; j++) {
      const {
        selector
      } = groups[j];
      if (i === j && (null === path[j] || false === path[j] || true === path[j])) {
        if (false === path[j]) {
          filterElement.push([selector, "=", groups[j].desc ? true : null]);
        } else if (path[j] ? !groups[j].desc : groups[j].desc) {
          filterElement.push([selector, "<>", path[j]]);
        } else {
          filterElement.push([selector, "<>", null]);
          filterElement.push([selector, "=", null]);
        }
      } else {
        const currentFilter = [selector, i === j ? groups[j].desc ? ">" : "<" : "=", path[j]];
        if ("<" === currentFilter[1]) {
          filterElement.push([currentFilter, "or", [selector, "=", null]]);
        } else {
          filterElement.push(currentFilter);
        }
      }
    }
    filter.push(m_core_default.combineFilters(filterElement));
  }
  filter = m_core_default.combineFilters(filter, "or");
  return m_core_default.combineFilters([filter, storeLoadOptions.filter]);
}
var findGroupInfoByKey = function(groupsInfo, key) {
  const {
    hash
  } = groupsInfo;
  return hash && hash[JSON.stringify(key)];
};
var getGroupInfoIndexByOffset = function(groupsInfo, offset2) {
  let leftIndex = 0;
  let rightIndex = groupsInfo.length - 1;
  if (!groupsInfo.length) {
    return 0;
  }
  do {
    const middleIndex = rightIndex + leftIndex >> 1;
    if (groupsInfo[middleIndex].offset > offset2) {
      rightIndex = middleIndex;
    } else {
      leftIndex = middleIndex;
    }
  } while (rightIndex - leftIndex > 1);
  let index2;
  for (index2 = leftIndex; index2 <= rightIndex; index2++) {
    if (groupsInfo[index2].offset > offset2) {
      break;
    }
  }
  return index2;
};
var cleanGroupsInfo = function(groupsInfo, groupIndex, groupsCount) {
  for (let i = 0; i < groupsInfo.length; i++) {
    if (groupIndex + 1 >= groupsCount) {
      groupsInfo[i].children = [];
    } else {
      cleanGroupsInfo(groupsInfo[i].children, groupIndex + 1, groupsCount);
    }
  }
};
var calculateItemsCount = function(that, items, groupsCount) {
  let result2 = 0;
  if (items) {
    if (!groupsCount) {
      result2 = items.length;
    } else {
      for (let i = 0; i < items.length; i++) {
        if (that.isGroupItemCountable(items[i])) {
          result2++;
        }
        result2 += calculateItemsCount(that, items[i].items, groupsCount - 1);
      }
    }
  }
  return result2;
};
var GroupingHelper = class {
  constructor(dataSourceAdapter) {
    this._dataSource = dataSourceAdapter;
    this.reset();
  }
  reset() {
    this._groupsInfo = [];
    this._totalCountCorrection = 0;
  }
  totalCountCorrection() {
    return this._totalCountCorrection;
  }
  updateTotalItemsCount(totalCountCorrection) {
    this._totalCountCorrection = totalCountCorrection || 0;
  }
  isGroupItemCountable(item) {
    return !this._isVirtualPaging() || !item.isContinuation;
  }
  _isVirtualPaging() {
    const scrollingMode = this._dataSource.option("scrolling.mode");
    return "virtual" === scrollingMode || "infinite" === scrollingMode;
  }
  itemsCount() {
    const dataSourceAdapter = this._dataSource;
    const dataSource = dataSourceAdapter._dataSource;
    const groupCount = m_core_default.normalizeSortingInfo(dataSource.group() || []).length;
    const itemsCount = calculateItemsCount(this, dataSource.items(), groupCount);
    return itemsCount;
  }
  foreachGroups(callback, childrenAtFirst, foreachCollapsedGroups2, updateOffsets, updateParentOffsets) {
    const that = this;
    return function foreachGroupsCore(groupsInfo, callback2, childrenAtFirst2, parents) {
      const callbackResults = [];
      function executeCallback(callback3, data17, parents2, callbackResults2) {
        const callbackResult = data17 && callback3(data17, parents2);
        callbackResult && callbackResults2.push(callbackResult);
        return callbackResult;
      }
      for (let i = 0; i < groupsInfo.length; i++) {
        parents.push(groupsInfo[i].data);
        if (!childrenAtFirst2 && false === executeCallback(callback2, groupsInfo[i].data, parents, callbackResults)) {
          return false;
        }
        if (!groupsInfo[i].data || groupsInfo[i].data.isExpanded || foreachCollapsedGroups2) {
          const {
            children
          } = groupsInfo[i];
          const callbackResult = children.length && foreachGroupsCore(children, callback2, childrenAtFirst2, parents);
          callbackResult && callbackResults.push(callbackResult);
          if (false === callbackResult) {
            return false;
          }
        }
        if (childrenAtFirst2 && false === executeCallback(callback2, groupsInfo[i].data, parents, callbackResults)) {
          return false;
        }
        if (!groupsInfo[i].data || groupsInfo[i].data.offset !== groupsInfo[i].offset) {
          updateOffsets = true;
        }
        parents.pop();
      }
      const currentParents = updateParentOffsets && parents.slice(0);
      return updateOffsets && when.apply(renderer_default, callbackResults).always(() => {
        that._updateGroupInfoOffsets(groupsInfo, currentParents);
      });
    }(that._groupsInfo, callback, childrenAtFirst, []);
  }
  _updateGroupInfoOffsets(groupsInfo, parents) {
    parents = parents || [];
    for (let index2 = 0; index2 < groupsInfo.length; index2++) {
      const groupInfo = groupsInfo[index2];
      if (groupInfo.data && groupInfo.data.offset !== groupInfo.offset) {
        groupInfo.offset = groupInfo.data.offset;
        for (let parentIndex = 0; parentIndex < parents.length; parentIndex++) {
          parents[parentIndex].offset = groupInfo.offset;
        }
      }
    }
    groupsInfo.sort((a, b) => a.offset - b.offset);
  }
  findGroupInfo(path) {
    let groupInfo;
    let groupsInfo = this._groupsInfo;
    for (let pathIndex = 0; groupsInfo && pathIndex < path.length; pathIndex++) {
      groupInfo = findGroupInfoByKey(groupsInfo, path[pathIndex]);
      groupsInfo = groupInfo && groupInfo.children;
    }
    return groupInfo && groupInfo.data;
  }
  addGroupInfo(groupInfoData) {
    const that = this;
    let groupInfo;
    const {
      path
    } = groupInfoData;
    let groupsInfo = that._groupsInfo;
    for (let pathIndex = 0; pathIndex < path.length; pathIndex++) {
      groupInfo = findGroupInfoByKey(groupsInfo, path[pathIndex]);
      if (!groupInfo) {
        groupInfo = {
          key: path[pathIndex],
          offset: groupInfoData.offset,
          data: {
            offset: groupInfoData.offset,
            isExpanded: true,
            path: path.slice(0, pathIndex + 1)
          },
          children: []
        };
        const index2 = getGroupInfoIndexByOffset(groupsInfo, groupInfoData.offset);
        groupsInfo.splice(index2, 0, groupInfo);
        groupsInfo.hash = groupsInfo.hash || {};
        groupsInfo.hash[JSON.stringify(groupInfo.key)] = groupInfo;
      }
      if (pathIndex === path.length - 1) {
        groupInfo.data = groupInfoData;
        if (groupInfo.offset !== groupInfoData.offset) {
          that._updateGroupInfoOffsets(groupsInfo);
        }
      }
      groupsInfo = groupInfo.children;
    }
  }
  allowCollapseAll() {
    return true;
  }
  refresh(options2) {
    const that = this;
    const {
      storeLoadOptions
    } = options2;
    const groups = normalizeSortingInfo(storeLoadOptions.group || []);
    const oldGroups = "_group" in that ? normalizeSortingInfo(that._group || []) : groups;
    let groupsCount = Math.min(oldGroups.length, groups.length);
    that._group = storeLoadOptions.group;
    for (let groupIndex = 0; groupIndex < groupsCount; groupIndex++) {
      if (oldGroups[groupIndex].selector !== groups[groupIndex].selector) {
        groupsCount = groupIndex;
        break;
      }
    }
    if (!groupsCount) {
      that.reset();
    } else {
      cleanGroupsInfo(that._groupsInfo, 0, groupsCount);
    }
  }
  handleDataLoading() {
  }
  handleDataLoaded(options2, callBase) {
    callBase(options2);
  }
  handleDataLoadedCore(options2, callBase) {
    callBase(options2);
  }
};

// node_modules/devextreme/esm/__internal/grids/data_grid/grouping/m_grouping_collapsed.js
function getContinuationGroupCount(groupOffset, pageSize, groupSize, groupIndex) {
  groupIndex = groupIndex || 0;
  if (pageSize > 1 && groupSize > 0) {
    let pageOffset = groupOffset - Math.floor(groupOffset / pageSize) * pageSize || pageSize;
    pageOffset += groupSize - groupIndex - 2;
    if (pageOffset < 0) {
      pageOffset += pageSize;
    }
    return Math.floor(pageOffset / (pageSize - groupIndex - 1));
  }
  return 0;
}
var foreachExpandedGroups = function(that, callback, updateGroups) {
  return that.foreachGroups((groupInfo, parents) => {
    if (groupInfo.isExpanded) {
      return callback(groupInfo, parents);
    }
  }, true, false, updateGroups, updateGroups);
};
var processGroupItems = function(that, items, groupsCount, expandedInfo, path, isCustomLoading, isLastGroupExpanded) {
  let isExpanded;
  expandedInfo.items = expandedInfo.items || [];
  expandedInfo.paths = expandedInfo.paths || [];
  expandedInfo.count = expandedInfo.count || 0;
  expandedInfo.lastCount = expandedInfo.lastCount || 0;
  if (!groupsCount) {
    return;
  }
  for (let i = 0; i < items.length; i++) {
    const item = items[i];
    if (void 0 !== item.items) {
      path.push(item.key);
      if (isCustomLoading) {
        isExpanded = true;
      } else {
        const groupInfo = that.findGroupInfo(path);
        isExpanded = groupInfo && groupInfo.isExpanded;
      }
      if (!isExpanded) {
        item.collapsedItems = item.items;
        item.items = null;
      } else if (item.items) {
        processGroupItems(that, item.items, groupsCount - 1, expandedInfo, path, isCustomLoading, isLastGroupExpanded);
      } else if (1 === groupsCount && item.count && (!isCustomLoading || isLastGroupExpanded)) {
        expandedInfo.items.push(item);
        expandedInfo.paths.push(path.slice(0));
        expandedInfo.count += expandedInfo.lastCount;
        expandedInfo.lastCount = item.count;
      }
      path.pop();
    }
  }
};
var updateGroupInfoItem = function(that, item, isLastGroupLevel, path, offset2) {
  const groupInfo = that.findGroupInfo(path);
  let count;
  if (!groupInfo) {
    if (isLastGroupLevel) {
      count = item.count > 0 ? item.count : item.items.length;
    }
    that.addGroupInfo({
      isExpanded: that._isGroupExpanded(path.length - 1),
      path: path.slice(0),
      offset: offset2,
      count: count || 0
    });
  } else {
    if (isLastGroupLevel) {
      groupInfo.count = item.count > 0 ? item.count : item.items && item.items.length || 0;
    } else {
      item.count = groupInfo.count || item.count;
    }
    groupInfo.offset = offset2;
  }
};
var updateGroupInfos = function(that, options2, items, loadedGroupCount, groupIndex, path, parentIndex) {
  const groupCount = options2.group ? options2.group.length : 0;
  const isLastGroupLevel = groupCount === loadedGroupCount;
  const remotePaging = options2.remoteOperations.paging;
  let offset2 = 0;
  let totalCount = 0;
  let count;
  groupIndex = groupIndex || 0;
  path = path || [];
  if (remotePaging && !parentIndex) {
    offset2 = 0 === groupIndex ? options2.skip || 0 : options2.skips[groupIndex - 1] || 0;
  }
  if (groupIndex >= loadedGroupCount) {
    return items.length;
  }
  for (let i = 0; i < items.length; i++) {
    const item = items[i];
    if (item) {
      path.push(item.key);
      if (!item.count && !item.items || void 0 === item.items) {
        return -1;
      }
      updateGroupInfoItem(that, item, isLastGroupLevel, path, offset2 + i);
      count = item.items ? updateGroupInfos(that, options2, item.items, loadedGroupCount, groupIndex + 1, path, i) : item.count || -1;
      if (count < 0) {
        return -1;
      }
      totalCount += count;
      path.pop();
    }
  }
  return totalCount;
};
var isGroupExpanded = function(groups, groupIndex) {
  return groups && groups.length && groups[groupIndex] && !!groups[groupIndex].isExpanded;
};
var getTotalOffset = function(groupInfos, pageSize, offset2) {
  let groupSize;
  let totalOffset = offset2;
  for (let groupIndex = 0; groupIndex < groupInfos.length; groupIndex++) {
    groupSize = groupInfos[groupIndex].offset + 1;
    if (groupIndex > 0) {
      groupSize += groupInfos[groupIndex - 1].childrenTotalCount;
      if (pageSize) {
        groupSize += getContinuationGroupCount(totalOffset, pageSize, groupSize, groupIndex - 1) * groupIndex;
      }
    }
    totalOffset += groupSize;
  }
  return totalOffset;
};
function applyContinuationToGroupItem(options2, expandedInfo, groupLevel, expandedItemIndex) {
  const item = expandedInfo.items[expandedItemIndex];
  const skip = options2.skips && options2.skips[groupLevel];
  const take = options2.takes && options2.takes[groupLevel];
  const isLastExpandedItem = expandedItemIndex === expandedInfo.items.length - 1;
  const isFirstExpandedItem = 0 === expandedItemIndex;
  const lastExpandedItemSkip = isFirstExpandedItem && skip || 0;
  const isItemsTruncatedByTake = item.count > take + lastExpandedItemSkip;
  if (isFirstExpandedItem && void 0 !== skip) {
    item.isContinuation = true;
  }
  if (isLastExpandedItem && void 0 !== take && isItemsTruncatedByTake) {
    item.isContinuationOnNextPage = true;
  }
}
function fillSkipTakeInExpandedInfo(options2, expandedInfo, currentGroupCount) {
  const currentGroupIndex = currentGroupCount - 1;
  const groupCount = options2.group ? options2.group.length : 0;
  expandedInfo.skip = options2.skips && options2.skips[currentGroupIndex];
  if (options2.takes && void 0 !== options2.takes[currentGroupIndex]) {
    if (groupCount === currentGroupCount) {
      expandedInfo.take = expandedInfo.count ? expandedInfo.count - (expandedInfo.skip || 0) : 0;
    } else {
      expandedInfo.take = 0;
    }
    expandedInfo.take += options2.takes[currentGroupIndex];
  }
}
function isDataDeferred(data17) {
  return !Array.isArray(data17);
}
function makeDataDeferred(options2) {
  if (!isDataDeferred(options2.data)) {
    options2.data = new Deferred();
  }
}
function loadGroupItems(that, options2, loadedGroupCount, expandedInfo, groupLevel, data17) {
  if (!options2.isCustomLoading) {
    expandedInfo = {};
    processGroupItems(that, data17, loadedGroupCount, expandedInfo, []);
    fillSkipTakeInExpandedInfo(options2, expandedInfo, loadedGroupCount);
  }
  const groupCount = options2.group ? options2.group.length : 0;
  if (expandedInfo.paths.length && groupCount - loadedGroupCount > 0) {
    makeDataDeferred(options2);
    loadExpandedGroups(that, options2, expandedInfo, loadedGroupCount, groupLevel, data17);
  } else if (expandedInfo.paths.length && options2.storeLoadOptions.group) {
    makeDataDeferred(options2);
    loadLastLevelGroupItems(that, options2, expandedInfo, data17);
  } else if (isDataDeferred(options2.data)) {
    options2.data.resolve(data17);
  }
}
function loadExpandedGroups(that, options2, expandedInfo, loadedGroupCount, groupLevel, data17) {
  const groups = options2.group || [];
  const currentGroup = groups[groupLevel + 1];
  const deferreds = [];
  each(expandedInfo.paths, (expandedItemIndex) => {
    var _options$storeLoadOpt;
    const loadOptions = {
      requireTotalCount: false,
      requireGroupCount: true,
      group: [currentGroup],
      groupSummary: options2.storeLoadOptions.groupSummary,
      filter: createGroupFilter(expandedInfo.paths[expandedItemIndex], {
        filter: options2.storeLoadOptions.filter,
        group: groups
      }),
      select: options2.storeLoadOptions.select,
      langParams: null === (_options$storeLoadOpt = options2.storeLoadOptions) || void 0 === _options$storeLoadOpt ? void 0 : _options$storeLoadOpt.langParams
    };
    if (0 === expandedItemIndex) {
      loadOptions.skip = expandedInfo.skip || 0;
    }
    if (expandedItemIndex === expandedInfo.paths.length - 1) {
      loadOptions.take = expandedInfo.take;
    }
    const loadResult = 0 === loadOptions.take ? [] : that._dataSource.loadFromStore(loadOptions);
    when(loadResult).done((data18) => {
      const item = expandedInfo.items[expandedItemIndex];
      applyContinuationToGroupItem(options2, expandedInfo, groupLevel, expandedItemIndex);
      item.items = data18;
    });
    deferreds.push(loadResult);
  });
  when.apply(null, deferreds).done(() => {
    updateGroupInfos(that, options2, data17, loadedGroupCount + 1);
    loadGroupItems(that, options2, loadedGroupCount + 1, expandedInfo, groupLevel + 1, data17);
  });
}
function loadLastLevelGroupItems(that, options2, expandedInfo, data17) {
  const expandedFilters = [];
  const groups = options2.group || [];
  each(expandedInfo.paths, (_, expandedPath) => {
    expandedFilters.push(createGroupFilter(expandedPath, {
      group: options2.isCustomLoading ? options2.storeLoadOptions.group : groups
    }));
  });
  let {
    filter
  } = options2.storeLoadOptions;
  if (!options2.storeLoadOptions.isLoadingAll) {
    filter = m_core_default.combineFilters([filter, m_core_default.combineFilters(expandedFilters, "or")]);
  }
  const loadOptions = extend({}, options2.storeLoadOptions, {
    requireTotalCount: false,
    requireGroupCount: false,
    group: null,
    sort: groups.concat(m_core_default.normalizeSortingInfo(options2.storeLoadOptions.sort || [])),
    filter
  });
  const isPagingLocal = that._dataSource.isLastLevelGroupItemsPagingLocal();
  if (!isPagingLocal) {
    loadOptions.skip = expandedInfo.skip;
    loadOptions.take = expandedInfo.take;
  }
  when(0 === expandedInfo.take ? [] : that._dataSource.loadFromStore(loadOptions)).done((items) => {
    if (isPagingLocal) {
      items = that._dataSource.sortLastLevelGroupItems(items, groups, expandedInfo.paths);
      items = expandedInfo.skip ? items.slice(expandedInfo.skip) : items;
      items = expandedInfo.take ? items.slice(0, expandedInfo.take) : items;
    }
    each(expandedInfo.items, (index2, item) => {
      const itemCount = item.count - (0 === index2 && expandedInfo.skip || 0);
      const expandedItems = items.splice(0, itemCount);
      applyContinuationToGroupItem(options2, expandedInfo, groups.length - 1, index2);
      item.items = expandedItems;
    });
    options2.data.resolve(data17);
  }).fail(options2.data.reject);
}
var loadGroupTotalCount = function(dataSource, options2) {
  const d = new Deferred();
  const isGrouping = !!(options2.group && options2.group.length);
  const loadOptions = extend({
    skip: 0,
    take: 1,
    requireGroupCount: isGrouping,
    requireTotalCount: !isGrouping
  }, options2, {
    group: isGrouping ? options2.group : null
  });
  dataSource.load(loadOptions).done((data17, extra) => {
    const count = extra && (isGrouping ? extra.groupCount : extra.totalCount);
    if (!isFinite(count)) {
      d.reject(errors.Error(isGrouping ? "E4022" : "E4021"));
      return;
    }
    d.resolve(count);
  }).fail(d.reject.bind(d));
  return d;
};
var GroupingHelper2 = class extends GroupingHelper {
  updateTotalItemsCount(options2) {
    let totalItemsCount = 0;
    const totalCount = options2.extra && options2.extra.totalCount || 0;
    const groupCount = options2.extra && options2.extra.groupCount || 0;
    const pageSize = this._dataSource.pageSize();
    const isVirtualPaging2 = this._isVirtualPaging();
    foreachExpandedGroups(this, (groupInfo) => {
      groupInfo.childrenTotalCount = 0;
    });
    foreachExpandedGroups(this, (groupInfo, parents) => {
      const totalOffset = getTotalOffset(parents, isVirtualPaging2 ? 0 : pageSize, totalItemsCount);
      let count = groupInfo.count + groupInfo.childrenTotalCount;
      if (!isVirtualPaging2) {
        count += getContinuationGroupCount(totalOffset, pageSize, count, parents.length - 1);
      }
      if (parents[parents.length - 2]) {
        parents[parents.length - 2].childrenTotalCount += count;
      } else {
        totalItemsCount += count;
      }
    });
    super.updateTotalItemsCount(totalItemsCount - totalCount + groupCount);
  }
  _isGroupExpanded(groupIndex) {
    const groups = this._dataSource.group();
    return isGroupExpanded(groups, groupIndex);
  }
  _updatePagingOptions(options2, callback) {
    const that = this;
    const isVirtualPaging2 = that._isVirtualPaging();
    const pageSize = that._dataSource.pageSize();
    const skips = [];
    const takes = [];
    let skipChildrenTotalCount = 0;
    let childrenTotalCount = 0;
    if (options2.take) {
      foreachExpandedGroups(this, (groupInfo) => {
        groupInfo.childrenTotalCount = 0;
        groupInfo.skipChildrenTotalCount = 0;
      });
      foreachExpandedGroups(that, (groupInfo, parents) => {
        let take;
        let takeCorrection = 0;
        let parentTakeCorrection = 0;
        const totalOffset = getTotalOffset(parents, isVirtualPaging2 ? 0 : pageSize, childrenTotalCount);
        let continuationGroupCount = 0;
        let skipContinuationGroupCount = 0;
        let groupInfoCount = groupInfo.count + groupInfo.childrenTotalCount;
        let childrenGroupInfoCount = groupInfoCount;
        callback && callback(groupInfo, totalOffset);
        const skip = options2.skip - totalOffset;
        if (totalOffset <= options2.skip + options2.take && groupInfoCount) {
          take = options2.take;
          if (!isVirtualPaging2) {
            continuationGroupCount = getContinuationGroupCount(totalOffset, pageSize, groupInfoCount, parents.length - 1);
            groupInfoCount += continuationGroupCount * parents.length;
            childrenGroupInfoCount += continuationGroupCount;
            if (pageSize && skip >= 0) {
              takeCorrection = parents.length;
              parentTakeCorrection = parents.length - 1;
              skipContinuationGroupCount = Math.floor(skip / pageSize);
            }
          }
          if (skip >= 0) {
            if (totalOffset + groupInfoCount > options2.skip) {
              skips.unshift(skip - skipContinuationGroupCount * takeCorrection - groupInfo.skipChildrenTotalCount);
            }
            if (totalOffset + groupInfoCount >= options2.skip + take) {
              takes.unshift(take - takeCorrection - groupInfo.childrenTotalCount + groupInfo.skipChildrenTotalCount);
            }
          } else if (totalOffset + groupInfoCount >= options2.skip + take) {
            takes.unshift(take + skip - groupInfo.childrenTotalCount);
          }
        }
        if (totalOffset <= options2.skip) {
          if (parents[parents.length - 2]) {
            parents[parents.length - 2].skipChildrenTotalCount += Math.min(childrenGroupInfoCount, skip + 1 - skipContinuationGroupCount * parentTakeCorrection);
          } else {
            skipChildrenTotalCount += Math.min(childrenGroupInfoCount, skip + 1);
          }
        }
        if (totalOffset <= options2.skip + take) {
          groupInfoCount = Math.min(childrenGroupInfoCount, skip + take - (skipContinuationGroupCount + 1) * parentTakeCorrection);
          if (parents[parents.length - 2]) {
            parents[parents.length - 2].childrenTotalCount += groupInfoCount;
          } else {
            childrenTotalCount += groupInfoCount;
          }
        }
      });
      options2.skip -= skipChildrenTotalCount;
      options2.take -= childrenTotalCount - skipChildrenTotalCount;
    }
    options2.skips = skips;
    options2.takes = takes;
  }
  changeRowExpand(path) {
    const groupInfo = this.findGroupInfo(path);
    const dataSource = this._dataSource;
    const remoteGroupPaging = dataSource.remoteOperations().groupPaging;
    const groups = m_core_default.normalizeSortingInfo(dataSource.group());
    if (groupInfo) {
      groupInfo.isExpanded = !groupInfo.isExpanded;
      if (remoteGroupPaging && groupInfo.isExpanded && path.length < groups.length) {
        return loadGroupTotalCount(dataSource, {
          filter: createGroupFilter(path, {
            filter: dataSource.lastLoadOptions().filter,
            group: dataSource.group()
          }),
          group: [groups[path.length]],
          select: dataSource.select()
        }).done((groupCount) => {
          groupInfo.count = groupCount;
        });
      }
      return new Deferred().resolve();
    }
    return new Deferred().reject();
  }
  handleDataLoading(options2) {
    const that = this;
    const {
      storeLoadOptions
    } = options2;
    const groups = m_core_default.normalizeSortingInfo(storeLoadOptions.group || options2.loadOptions.group);
    if (options2.isCustomLoading || !groups.length) {
      return;
    }
    if (options2.remoteOperations.grouping) {
      const remotePaging = that._dataSource.remoteOperations().paging;
      storeLoadOptions.group = m_core_default.normalizeSortingInfo(storeLoadOptions.group);
      storeLoadOptions.group.forEach((group, index2) => {
        const isLastGroup = index2 === storeLoadOptions.group.length - 1;
        group.isExpanded = !remotePaging || !isLastGroup;
      });
    }
    options2.group = options2.group || groups;
    if (options2.remoteOperations.paging) {
      options2.skip = storeLoadOptions.skip;
      options2.take = storeLoadOptions.take;
      storeLoadOptions.requireGroupCount = true;
      storeLoadOptions.group = groups.slice(0, 1);
      that._updatePagingOptions(options2);
      storeLoadOptions.skip = options2.skip;
      storeLoadOptions.take = options2.take;
    } else {
      options2.skip = options2.loadOptions.skip;
      options2.take = options2.loadOptions.take;
      that._updatePagingOptions(options2);
    }
  }
  handleDataLoadedCore(options2, callBase) {
    const that = this;
    const loadedGroupCount = m_core_default.normalizeSortingInfo(options2.storeLoadOptions.group || options2.loadOptions.group).length;
    const groupCount = options2.group ? options2.group.length : 0;
    let totalCount;
    const expandedInfo = {};
    if (options2.isCustomLoading) {
      callBase(options2);
      processGroupItems(that, options2.data, loadedGroupCount, expandedInfo, [], options2.isCustomLoading, options2.storeLoadOptions.isLoadingAll);
    } else {
      if (!options2.remoteOperations.paging) {
        that.foreachGroups((groupInfo) => {
          groupInfo.count = 0;
        });
      }
      totalCount = updateGroupInfos(that, options2, options2.data, loadedGroupCount);
      if (totalCount < 0) {
        options2.data = new Deferred().reject(ui_errors_default.Error("E1037"));
        return;
      }
      if (!options2.remoteOperations.paging) {
        if (loadedGroupCount && options2.extra && options2.loadOptions.requireTotalCount) {
          options2.extra.totalCount = totalCount;
          options2.extra.groupCount = options2.data.length;
        }
      }
      if (groupCount && options2.storeLoadOptions.requireGroupCount && !isFinite(options2.extra.groupCount)) {
        options2.data = new Deferred().reject(errors.Error("E4022"));
        return;
      }
      that.updateTotalItemsCount(options2);
      if (!options2.remoteOperations.paging) {
        that._updatePagingOptions(options2);
        options2.lastLoadOptions.skips = options2.skips;
        options2.lastLoadOptions.takes = options2.takes;
      }
      callBase(options2);
      if (!options2.remoteOperations.paging) {
        that._processPaging(options2, loadedGroupCount);
      }
    }
    loadGroupItems(that, options2, loadedGroupCount, expandedInfo, 0, options2.data);
  }
  _processSkips(items, skips, groupCount) {
    if (!groupCount) {
      return;
    }
    const firstItem = items[0];
    const skip = skips[0];
    const children = firstItem && firstItem.items;
    if (void 0 !== skip) {
      firstItem.isContinuation = true;
      if (children) {
        firstItem.items = children.slice(skip);
        this._processSkips(firstItem.items, skips.slice(1), groupCount - 1);
      }
    }
  }
  _processTakes(items, skips, takes, groupCount, parents) {
    if (!groupCount || !items) {
      return;
    }
    parents = parents || [];
    const lastItem = items[items.length - 1];
    let children = lastItem && lastItem.items;
    const take = takes[0];
    const skip = skips[0];
    if (lastItem) {
      const maxTakeCount = lastItem.count - (lastItem.isContinuation && skip || 0) || children.length;
      if (void 0 !== take && maxTakeCount > take) {
        lastItem.isContinuationOnNextPage = true;
        parents.forEach((parent) => {
          parent.isContinuationOnNextPage = true;
        });
        if (children) {
          children = children.slice(0, take);
          lastItem.items = children;
        }
      }
      parents.push(lastItem);
      this._processTakes(children, skips.slice(1), takes.slice(1), groupCount - 1, parents);
    }
  }
  _processPaging(options2, groupCount) {
    this._processSkips(options2.data, options2.skips, groupCount);
    this._processTakes(options2.data, options2.skips, options2.takes, groupCount);
  }
  isLastLevelGroupItemsPagingLocal() {
    return false;
  }
  sortLastLevelGroupItems(items) {
    return items;
  }
  refresh(options2, operationTypes) {
    const that = this;
    const dataSource = that._dataSource;
    const {
      storeLoadOptions
    } = options2;
    const group = options2.group || options2.storeLoadOptions.group;
    const oldGroups = m_core_default.normalizeSortingInfo(that._group);
    let isExpanded;
    let groupIndex;
    function handleGroup(groupInfo, parents) {
      if (parents.length === groupIndex + 1) {
        groupInfo.isExpanded = isExpanded;
      }
    }
    for (groupIndex = 0; groupIndex < oldGroups.length; groupIndex++) {
      isExpanded = isGroupExpanded(group, groupIndex);
      if (isGroupExpanded(that._group, groupIndex) !== isExpanded) {
        that.foreachGroups(handleGroup);
      }
    }
    super.refresh.apply(this, arguments);
    if (group && options2.remoteOperations.paging && operationTypes.reload) {
      return foreachExpandedGroups(that, (groupInfo) => {
        const groupCountQuery = loadGroupTotalCount(dataSource, {
          filter: createGroupFilter(groupInfo.path, {
            filter: storeLoadOptions.filter,
            group
          }),
          group: group.slice(groupInfo.path.length),
          select: storeLoadOptions.select
        });
        const groupOffsetQuery = loadGroupTotalCount(dataSource, {
          filter: createOffsetFilter(groupInfo.path, {
            filter: storeLoadOptions.filter,
            group
          }, true),
          group: group.slice(groupInfo.path.length - 1, groupInfo.path.length),
          select: storeLoadOptions.select
        });
        return when(groupOffsetQuery, groupCountQuery).done((offset2, count) => {
          offset2 = parseInt(offset2.length ? offset2[0] : offset2);
          count = parseInt(count.length ? count[0] : count);
          groupInfo.offset = offset2;
          if (groupInfo.count !== count) {
            groupInfo.count = count;
            that.updateTotalItemsCount(options2);
          }
        });
      }, true);
    }
  }
};

// node_modules/devextreme/esm/__internal/grids/data_grid/grouping/m_grouping_expanded.js
var loadTotalCount = function(dataSource, options2) {
  const d = new Deferred();
  const loadOptions = extend({
    skip: 0,
    take: 1,
    requireTotalCount: true
  }, options2);
  dataSource.load(loadOptions).done((data17, extra) => {
    d.resolve(extra && extra.totalCount);
  }).fail(d.reject.bind(d));
  return d;
};
var foreachCollapsedGroups = function(that, callback, updateOffsets) {
  return that.foreachGroups((groupInfo) => {
    if (!groupInfo.isExpanded) {
      return callback(groupInfo);
    }
  }, false, false, updateOffsets, true);
};
var correctSkipLoadOption = function(that, skip) {
  let skipCorrection = 0;
  let resultSkip = skip || 0;
  if (skip) {
    foreachCollapsedGroups(that, (groupInfo) => {
      if (groupInfo.offset - skipCorrection >= skip) {
        return false;
      }
      skipCorrection += groupInfo.count - 1;
    });
    resultSkip += skipCorrection;
  }
  return resultSkip;
};
var processGroupItems2 = function(that, items, path, offset2, skipFirstItem, take) {
  let removeLastItemsCount = 0;
  let needRemoveFirstItem = false;
  for (let i = 0; i < items.length; i++) {
    const item = items[i];
    if (void 0 !== item.items) {
      path.push(item.key);
      const groupInfo = that.findGroupInfo(path);
      if (groupInfo && !groupInfo.isExpanded) {
        item.collapsedItems = item.items;
        item.items = null;
        offset2 += groupInfo.count;
        take--;
        if (take < 0) {
          removeLastItemsCount++;
        }
        if (skipFirstItem) {
          needRemoveFirstItem = true;
        }
      } else if (item.items) {
        const offsetInfo = processGroupItems2(that, item.items, path, offset2, skipFirstItem, take);
        if (skipFirstItem) {
          if (offsetInfo.offset - offset2 > 1) {
            item.isContinuation = true;
          } else {
            needRemoveFirstItem = true;
          }
        }
        offset2 = offsetInfo.offset;
        take = offsetInfo.take;
        if (take < 0) {
          if (item.items.length) {
            item.isContinuationOnNextPage = true;
          } else {
            removeLastItemsCount++;
          }
        }
      }
      path.pop();
    } else {
      if (skipFirstItem) {
        needRemoveFirstItem = true;
      }
      offset2++;
      take--;
      if (take < 0) {
        removeLastItemsCount++;
      }
    }
    skipFirstItem = false;
  }
  if (needRemoveFirstItem) {
    items.splice(0, 1);
  }
  if (removeLastItemsCount) {
    items.splice(-removeLastItemsCount, removeLastItemsCount);
  }
  return {
    offset: offset2,
    take
  };
};
var pathEquals = function(path1, path2) {
  if (path1.length !== path2.length) {
    return false;
  }
  for (let i = 0; i < path1.length; i++) {
    if (!keysEqual(null, path1[i], path2[i])) {
      return false;
    }
  }
  return true;
};
var updateGroupOffsets = function(that, items, path, offset2, additionalGroupInfo) {
  if (!items) {
    return;
  }
  for (let i = 0; i < items.length; i++) {
    const item = items[i];
    if ("key" in item && void 0 !== item.items) {
      path.push(item.key);
      if (additionalGroupInfo && pathEquals(additionalGroupInfo.path, path) && !item.isContinuation) {
        additionalGroupInfo.offset = offset2;
      }
      const groupInfo = that.findGroupInfo(path);
      if (groupInfo && !item.isContinuation) {
        groupInfo.offset = offset2;
      }
      if (groupInfo && !groupInfo.isExpanded) {
        offset2 += groupInfo.count;
      } else {
        offset2 = updateGroupOffsets(that, item.items, path, offset2, additionalGroupInfo);
      }
      path.pop();
    } else {
      offset2++;
    }
  }
  return offset2;
};
var removeGroupLoadOption = function(storeLoadOptions, loadOptions) {
  if (loadOptions.group) {
    const groups = m_core_default.normalizeSortingInfo(loadOptions.group);
    const sorts = m_core_default.normalizeSortingInfo(storeLoadOptions.sort);
    storeLoadOptions.sort = m_store_helper_default.arrangeSortingInfo(groups, sorts);
    delete loadOptions.group;
  }
};
var createNotGroupFilter = function(path, storeLoadOptions, group) {
  const groups = m_core_default.normalizeSortingInfo(group || storeLoadOptions.group);
  let filter = [];
  for (let i = 0; i < path.length; i++) {
    const filterElement = [];
    for (let j = 0; j <= i; j++) {
      filterElement.push([groups[j].selector, i === j ? "<>" : "=", path[j]]);
    }
    filter.push(m_core_default.combineFilters(filterElement));
  }
  filter = m_core_default.combineFilters(filter, "or");
  return m_core_default.combineFilters([filter, storeLoadOptions.filter]);
};
var getGroupCount = function(item, groupCount) {
  let count = item.count || item.items.length;
  if (!item.count && groupCount > 1) {
    count = 0;
    for (let i = 0; i < item.items.length; i++) {
      count += getGroupCount(item.items[i], groupCount - 1);
    }
  }
  return count;
};
var GroupingHelper3 = class extends GroupingHelper {
  handleDataLoading(options2) {
    const {
      storeLoadOptions
    } = options2;
    const collapsedGroups = [];
    let collapsedItemsCount = 0;
    let skipFirstItem = false;
    let take;
    const {
      group
    } = options2.loadOptions;
    let skipCorrection = 0;
    removeGroupLoadOption(storeLoadOptions, options2.loadOptions);
    options2.group = options2.group || group;
    if (options2.isCustomLoading) {
      return;
    }
    const loadOptions = extend({}, storeLoadOptions);
    loadOptions.skip = correctSkipLoadOption(this, storeLoadOptions.skip);
    if (loadOptions.skip && loadOptions.take && group) {
      loadOptions.skip--;
      loadOptions.take++;
      skipFirstItem = true;
    }
    if (loadOptions.take && group) {
      take = loadOptions.take;
      loadOptions.take++;
    }
    foreachCollapsedGroups(this, (groupInfo) => {
      if (groupInfo.offset >= loadOptions.skip + loadOptions.take + skipCorrection) {
        return false;
      }
      if (groupInfo.offset >= loadOptions.skip + skipCorrection && groupInfo.count) {
        skipCorrection += groupInfo.count - 1;
        collapsedGroups.push(groupInfo);
        collapsedItemsCount += groupInfo.count;
      }
    });
    each(collapsedGroups, function() {
      loadOptions.filter = createNotGroupFilter(this.path, loadOptions, group);
    });
    options2.storeLoadOptions = loadOptions;
    options2.collapsedGroups = collapsedGroups;
    options2.collapsedItemsCount = collapsedItemsCount;
    options2.skip = loadOptions.skip || 0;
    options2.skipFirstItem = skipFirstItem;
    options2.take = take;
  }
  handleDataLoaded(options2, callBase) {
    const that = this;
    const {
      collapsedGroups
    } = options2;
    const groups = m_core_default.normalizeSortingInfo(options2.group);
    const groupCount = groups.length;
    function appendCollapsedPath(data17, path, groups2, collapsedGroup, offset2) {
      if (!data17 || !path.length || !groups2.length) {
        return;
      }
      let keyValue;
      let i;
      const pathValue = toComparable(path[0], true);
      for (i = 0; i < data17.length; i++) {
        keyValue = toComparable(data17[i].key, true);
        if (offset2 >= collapsedGroup.offset || pathValue === keyValue) {
          break;
        } else {
          offset2 += getGroupCount(data17[i], groups2.length);
        }
      }
      if (!data17.length || pathValue !== keyValue) {
        data17.splice(i, 0, {
          key: path[0],
          items: [],
          count: 1 === path.length ? collapsedGroup.count : void 0
        });
      }
      appendCollapsedPath(data17[i].items, path.slice(1), groups2.slice(1), collapsedGroup, offset2);
    }
    if (options2.collapsedItemsCount && options2.extra && options2.extra.totalCount >= 0) {
      if (!options2.extra._totalCountWasIncreasedByCollapsedItems) {
        options2.extra.totalCount += options2.collapsedItemsCount;
        options2.extra._totalCountWasIncreasedByCollapsedItems = true;
      }
    }
    callBase(options2);
    if (groupCount) {
      let {
        data: data17
      } = options2;
      const query2 = m_query_default(data17);
      m_store_helper_default.multiLevelGroup(query2, groups).enumerate().done((groupedData) => {
        data17 = groupedData;
      });
      if (collapsedGroups) {
        for (let pathIndex = 0; pathIndex < collapsedGroups.length; pathIndex++) {
          appendCollapsedPath(data17, collapsedGroups[pathIndex].path, groups, collapsedGroups[pathIndex], options2.skip);
        }
      }
      if (!options2.isCustomLoading) {
        processGroupItems2(that, data17, [], options2.skip, options2.skipFirstItem, options2.take);
      }
      options2.data = data17;
    }
  }
  isGroupItemCountable(item) {
    return null === item.items;
  }
  updateTotalItemsCount() {
    let itemsCountCorrection = 0;
    foreachCollapsedGroups(this, (groupInfo) => {
      if (groupInfo.count) {
        itemsCountCorrection -= groupInfo.count - 1;
      }
    });
    super.updateTotalItemsCount(itemsCountCorrection);
  }
  changeRowExpand(path) {
    const that = this;
    const dataSource = that._dataSource;
    const beginPageIndex = dataSource.beginPageIndex ? dataSource.beginPageIndex() : dataSource.pageIndex();
    const dataSourceItems = dataSource.items();
    const offset2 = correctSkipLoadOption(that, beginPageIndex * dataSource.pageSize());
    let groupInfo = that.findGroupInfo(path);
    let groupCountQuery;
    if (groupInfo && !groupInfo.isExpanded) {
      groupCountQuery = new Deferred().resolve(groupInfo.count);
    } else {
      groupCountQuery = loadTotalCount(dataSource, {
        filter: createGroupFilter(path, {
          filter: dataSource.filter(),
          group: dataSource.group()
        })
      });
    }
    return when(groupCountQuery).done((count) => {
      count = parseInt(count.length ? count[0] : count);
      if (groupInfo) {
        updateGroupOffsets(that, dataSourceItems, [], offset2);
        groupInfo.isExpanded = !groupInfo.isExpanded;
        groupInfo.count = count;
      } else {
        groupInfo = {
          offset: -1,
          count,
          path,
          isExpanded: false
        };
        updateGroupOffsets(that, dataSourceItems, [], offset2, groupInfo);
        if (groupInfo.offset >= 0) {
          that.addGroupInfo(groupInfo);
        }
      }
      that.updateTotalItemsCount();
    }).fail(function() {
      dataSource._eventsStrategy.fireEvent("loadError", arguments);
    });
  }
  allowCollapseAll() {
    return false;
  }
  refresh(options2, operationTypes) {
    const that = this;
    const {
      storeLoadOptions
    } = options2;
    const dataSource = that._dataSource;
    super.refresh.apply(this, arguments);
    if (operationTypes.reload) {
      return foreachCollapsedGroups(that, (groupInfo) => {
        const groupCountQuery = loadTotalCount(dataSource, {
          filter: createGroupFilter(groupInfo.path, storeLoadOptions)
        });
        const groupOffsetQuery = loadTotalCount(dataSource, {
          filter: createOffsetFilter(groupInfo.path, storeLoadOptions)
        });
        return when(groupOffsetQuery, groupCountQuery).done((offset2, count) => {
          offset2 = parseInt(offset2.length ? offset2[0] : offset2);
          count = parseInt(count.length ? count[0] : count);
          groupInfo.offset = offset2;
          if (groupInfo.count !== count) {
            groupInfo.count = count;
            that.updateTotalItemsCount();
          }
        });
      }, true);
    }
  }
};

// node_modules/devextreme/esm/__internal/grids/data_grid/grouping/m_grouping.js
var dataSourceAdapterExtender = (Base) => class extends Base {
  init() {
    super.init.apply(this, arguments);
    this._initGroupingHelper();
  }
  _initGroupingHelper(options2) {
    const grouping = this._grouping;
    const isAutoExpandAll = this.option("grouping.autoExpandAll");
    const isFocusedRowEnabled = this.option("focusedRowEnabled");
    const remoteOperations = options2 ? options2.remoteOperations : this.remoteOperations();
    const isODataRemoteOperations = remoteOperations.filtering && remoteOperations.sorting && remoteOperations.paging;
    if (isODataRemoteOperations && !remoteOperations.grouping && (isAutoExpandAll || !isFocusedRowEnabled)) {
      if (!grouping || grouping instanceof GroupingHelper2) {
        this._grouping = new GroupingHelper3(this);
      }
    } else if (!grouping || grouping instanceof GroupingHelper3) {
      this._grouping = new GroupingHelper2(this);
    }
  }
  totalItemsCount() {
    const totalCount = super.totalItemsCount();
    return totalCount > 0 && this._dataSource.group() && this._dataSource.requireTotalCount() ? totalCount + this._grouping.totalCountCorrection() : totalCount;
  }
  itemsCount() {
    return this._dataSource.group() ? this._grouping.itemsCount() || 0 : super.itemsCount.apply(this, arguments);
  }
  allowCollapseAll() {
    return this._grouping.allowCollapseAll();
  }
  isGroupItemCountable(item) {
    return this._grouping.isGroupItemCountable(item);
  }
  isRowExpanded(key) {
    const groupInfo = this._grouping.findGroupInfo(key);
    return groupInfo ? groupInfo.isExpanded : !this._grouping.allowCollapseAll();
  }
  collapseAll(groupIndex) {
    return this._collapseExpandAll(groupIndex, false);
  }
  expandAll(groupIndex) {
    return this._collapseExpandAll(groupIndex, true);
  }
  _collapseExpandAll(groupIndex, isExpand) {
    const that = this;
    const dataSource = that._dataSource;
    const group = dataSource.group();
    const groups = m_core_default.normalizeSortingInfo(group || []);
    if (groups.length) {
      for (let i = 0; i < groups.length; i++) {
        if (void 0 === groupIndex || groupIndex === i) {
          groups[i].isExpanded = isExpand;
        } else if (null !== group && void 0 !== group && group[i]) {
          groups[i].isExpanded = group[i].isExpanded;
        }
      }
      dataSource.group(groups);
      that._grouping.foreachGroups((groupInfo, parents) => {
        if (void 0 === groupIndex || groupIndex === parents.length - 1) {
          groupInfo.isExpanded = isExpand;
        }
      }, false, true);
      that.resetPagesCache();
    }
    return true;
  }
  refresh() {
    super.refresh.apply(this, arguments);
    return this._grouping.refresh.apply(this._grouping, arguments);
  }
  changeRowExpand(path) {
    const that = this;
    const dataSource = that._dataSource;
    if (dataSource.group()) {
      dataSource.beginLoading();
      if (that._lastLoadOptions) {
        that._lastLoadOptions.groupExpand = true;
      }
      return that._changeRowExpandCore(path).always(() => {
        dataSource.endLoading();
      });
    }
  }
  _changeRowExpandCore(path) {
    return this._grouping.changeRowExpand(path);
  }
  _hasGroupLevelsExpandState(group, isExpanded) {
    if (group && Array.isArray(group)) {
      for (let i = 0; i < group.length; i++) {
        if (group[i].isExpanded === isExpanded) {
          return true;
        }
      }
    }
  }
  _customizeRemoteOperations(options2, operationTypes) {
    const {
      remoteOperations
    } = options2;
    if (options2.storeLoadOptions.group) {
      if (remoteOperations.grouping && !options2.isCustomLoading) {
        if (!remoteOperations.groupPaging || this._hasGroupLevelsExpandState(options2.storeLoadOptions.group, true)) {
          remoteOperations.paging = false;
        }
      }
      if (!remoteOperations.grouping && (!remoteOperations.sorting || !remoteOperations.filtering || options2.isCustomLoading || this._hasGroupLevelsExpandState(options2.storeLoadOptions.group, false))) {
        remoteOperations.paging = false;
      }
    } else if (!options2.isCustomLoading && remoteOperations.paging && operationTypes.grouping) {
      this.resetCache();
    }
    super._customizeRemoteOperations.apply(this, arguments);
  }
  _handleDataLoading(options2) {
    super._handleDataLoading(options2);
    this._initGroupingHelper(options2);
    return this._grouping.handleDataLoading(options2);
  }
  _handleDataLoaded(options2) {
    return this._grouping.handleDataLoaded(options2, super._handleDataLoaded.bind(this));
  }
  _handleDataLoadedCore(options2) {
    return this._grouping.handleDataLoadedCore(options2, super._handleDataLoadedCore.bind(this));
  }
};
m_data_source_adapter_default.extend(dataSourceAdapterExtender);
var GroupingDataControllerExtender = (Base) => class extends Base {
  init() {
    super.init();
    this.createAction("onRowExpanding");
    this.createAction("onRowExpanded");
    this.createAction("onRowCollapsing");
    this.createAction("onRowCollapsed");
  }
  _beforeProcessItems(items) {
    const groupColumns = this._columnsController.getGroupColumns();
    items = super._beforeProcessItems(items);
    if (items.length && groupColumns.length) {
      items = this._processGroupItems(items, groupColumns.length);
    }
    return items;
  }
  _processItem(item, options2) {
    if (isDefined(item.groupIndex) && isString(item.rowType) && 0 === item.rowType.indexOf("group")) {
      item = this._processGroupItem(item, options2);
      options2.dataIndex = 0;
    } else {
      item = super._processItem.apply(this, arguments);
    }
    return item;
  }
  _processGroupItem(item, options2) {
    return item;
  }
  _processGroupItems(items, groupsCount, options2) {
    const that = this;
    const groupedColumns = that._columnsController.getGroupColumns();
    const column = groupedColumns[groupedColumns.length - groupsCount];
    if (!options2) {
      const scrollingMode = that.option("scrolling.mode");
      options2 = {
        collectContinuationItems: "virtual" !== scrollingMode && "infinite" !== scrollingMode,
        resultItems: [],
        path: [],
        values: []
      };
    }
    const {
      resultItems
    } = options2;
    if (options2.data) {
      if (options2.collectContinuationItems || !options2.data.isContinuation) {
        resultItems.push({
          rowType: "group",
          data: options2.data,
          groupIndex: options2.path.length - 1,
          isExpanded: !!options2.data.items,
          key: options2.path.slice(0),
          values: options2.values.slice(0)
        });
      }
    }
    if (items) {
      if (0 === groupsCount) {
        resultItems.push.apply(resultItems, items);
      } else {
        for (let i = 0; i < items.length; i++) {
          const item = items[i];
          if (item && "items" in item) {
            options2.data = item;
            options2.path.push(item.key);
            options2.values.push(column && column.deserializeValue && !column.calculateDisplayValue ? column.deserializeValue(item.key) : item.key);
            that._processGroupItems(item.items, groupsCount - 1, options2);
            options2.data = void 0;
            options2.path.pop();
            options2.values.pop();
          } else {
            resultItems.push(item);
          }
        }
      }
    }
    return resultItems;
  }
  publicMethods() {
    return super.publicMethods().concat(["collapseAll", "expandAll", "isRowExpanded", "expandRow", "collapseRow"]);
  }
  collapseAll(groupIndex) {
    const dataSource = this._dataSource;
    if (dataSource && dataSource.collapseAll(groupIndex)) {
      dataSource.pageIndex(0);
      dataSource.reload();
    }
  }
  expandAll(groupIndex) {
    const dataSource = this._dataSource;
    if (dataSource && dataSource.expandAll(groupIndex)) {
      dataSource.pageIndex(0);
      dataSource.reload();
    }
  }
  changeRowExpand(key) {
    const that = this;
    const expanded = that.isRowExpanded(key);
    const args = {
      key,
      expanded
    };
    that.executeAction(expanded ? "onRowCollapsing" : "onRowExpanding", args);
    if (!args.cancel) {
      return when(that._changeRowExpandCore(key)).done(() => {
        args.expanded = !expanded;
        that.executeAction(expanded ? "onRowCollapsed" : "onRowExpanded", args);
      });
    }
    return new Deferred().resolve();
  }
  _changeRowExpandCore(key) {
    const that = this;
    const dataSource = this._dataSource;
    const d = new Deferred();
    if (!dataSource) {
      d.resolve();
    } else {
      when(dataSource.changeRowExpand(key)).done(() => {
        that.load().done(d.resolve).fail(d.reject);
      }).fail(d.reject);
    }
    return d;
  }
  isRowExpanded(key) {
    const dataSource = this._dataSource;
    return dataSource && dataSource.isRowExpanded(key);
  }
  expandRow(key) {
    if (!this.isRowExpanded(key)) {
      return this.changeRowExpand(key);
    }
    return new Deferred().resolve();
  }
  collapseRow(key) {
    if (this.isRowExpanded(key)) {
      return this.changeRowExpand(key);
    }
    return new Deferred().resolve();
  }
  optionChanged(args) {
    if ("grouping" === args.name) {
      args.name = "dataSource";
    }
    super.optionChanged(args);
  }
};
var onGroupingMenuItemClick = function(column, rowIndex, params) {
  var _this$getKeyboardNavi, _keyboardNavigationCo2;
  const keyboardNavigationController = null === (_this$getKeyboardNavi = this.getKeyboardNavigationController) || void 0 === _this$getKeyboardNavi ? void 0 : _this$getKeyboardNavi.call(this);
  switch (params.itemData.value) {
    case "group":
      var _keyboardNavigationCo;
      this.isNeedToFocusColumn = true;
      null === keyboardNavigationController || void 0 === keyboardNavigationController || null === (_keyboardNavigationCo = keyboardNavigationController.groupColumn) || void 0 === _keyboardNavigationCo || _keyboardNavigationCo.call(keyboardNavigationController, column, rowIndex);
      break;
    case "ungroup":
      this.isNeedToFocusColumn = true;
      null === keyboardNavigationController || void 0 === keyboardNavigationController || null === (_keyboardNavigationCo2 = keyboardNavigationController.ungroupColumn) || void 0 === _keyboardNavigationCo2 || _keyboardNavigationCo2.call(keyboardNavigationController, column, rowIndex);
      break;
    case "ungroupAll":
      this.isNeedToFocusColumn = true;
      null === keyboardNavigationController || void 0 === keyboardNavigationController || keyboardNavigationController.ungroupAllColumns();
  }
};
var isGroupPanelVisible = (groupPanelOptions) => {
  const visible2 = null === groupPanelOptions || void 0 === groupPanelOptions ? void 0 : groupPanelOptions.visible;
  return "auto" === visible2 ? "desktop" === devices_default.current().deviceType : !!visible2;
};
var allowDragging = (groupPanelOptions, column) => {
  const isVisible2 = isGroupPanelVisible(groupPanelOptions);
  const canDrag = (null === groupPanelOptions || void 0 === groupPanelOptions ? void 0 : groupPanelOptions.allowColumnDragging) && (null === column || void 0 === column ? void 0 : column.allowGrouping);
  return isVisible2 && !!canDrag;
};
var GroupingHeaderPanelExtender = (Base) => class extends ColumnContextMenuMixin(Base) {
  _getToolbarItems() {
    const items = super._getToolbarItems();
    return this._appendGroupingItem(items);
  }
  _appendGroupingItem(items) {
    if (this._isGroupPanelVisible()) {
      let isRendered = false;
      const toolbarItem = {
        template: () => {
          const $groupPanel = renderer_default("<div>").addClass(CLASSES5.groupPanel);
          this._updateGroupPanelContent($groupPanel);
          registerKeyboardAction2("groupPanel", this, $groupPanel, void 0, this._handleActionKeyDown.bind(this));
          return $groupPanel;
        },
        name: "groupPanel",
        onItemRendered: () => {
          isRendered && this.renderCompleted.fire();
          isRendered = true;
        },
        location: "before",
        locateInMenu: "never",
        sortIndex: 1
      };
      items.push(toolbarItem);
      this.updateToolbarDimensions();
    }
    return items;
  }
  _handleActionKeyDown(args) {
    const {
      event
    } = args;
    const $target = renderer_default(event.target);
    const groupColumnIndex = $target.closest(`.${CLASSES5.groupPanelItem}`).index();
    const column = this._columnsController.getGroupColumns()[groupColumnIndex];
    const columnIndex = column && column.index;
    if ($target.is(".dx-header-filter")) {
      this._headerFilterController.showHeaderFilterMenu(columnIndex, true);
    } else {
      this._processGroupItemAction(columnIndex);
    }
    event.preventDefault();
  }
  _isGroupPanelVisible() {
    return isGroupPanelVisible(this.option("groupPanel"));
  }
  _renderGroupPanelItems($groupPanel, groupColumns) {
    const that = this;
    $groupPanel.empty();
    each(groupColumns, (index2, groupColumn) => {
      that._createGroupPanelItem($groupPanel, groupColumn);
    });
    restoreFocus(this);
  }
  _createGroupPanelItem($rootElement, groupColumn) {
    const $groupPanelItem = renderer_default("<div>").addClass(groupColumn.cssClass).addClass(CLASSES5.groupPanelItem).data("columnData", groupColumn).appendTo($rootElement).text(groupColumn.caption);
    setTabIndex(this, $groupPanelItem);
    return $groupPanelItem;
  }
  getGroupAndUngroupItems(options2) {
    const {
      column
    } = options2;
    const contextMenuEnabled = this.option("grouping.contextMenuEnabled");
    if (contextMenuEnabled && column) {
      const isGroupingAllowed = isDefined(column.allowGrouping) ? column.allowGrouping : true;
      if (isGroupingAllowed) {
        const isColumnGrouped = isDefined(column.groupIndex) && column.groupIndex > -1;
        const groupingTexts = this.option("grouping.texts");
        const onItemClick = onGroupingMenuItemClick.bind(this, column, 0);
        return [{
          text: groupingTexts.ungroup,
          value: "ungroup",
          disabled: !isColumnGrouped,
          onItemClick,
          icon: CONTEXT_MENU_UNGROUP_COLUMN_ICON_NAME
        }, {
          text: groupingTexts.ungroupAll,
          value: "ungroupAll",
          onItemClick,
          icon: CONTEXT_MENU_UNGROUP_ALL_COLUMNS_ICON_NAME
        }];
      }
    }
    return [];
  }
  _columnOptionChanged(e) {
    if (!this._requireReady && !m_core_default.checkChanges(e.optionNames, ["width", "visibleWidth"])) {
      const $toolbarElement = this.element();
      const $groupPanel = null === $toolbarElement || void 0 === $toolbarElement ? void 0 : $toolbarElement.find(`.${CLASSES5.groupPanel}`);
      if ($groupPanel && $groupPanel.length) {
        this._updateGroupPanelContent($groupPanel);
        this.updateToolbarDimensions();
        this.renderCompleted.fire();
      }
    }
    super._columnOptionChanged();
  }
  _updateGroupPanelContent($groupPanel) {
    const groupColumns = this.getColumns();
    const groupPanelOptions = this.option("groupPanel");
    this._renderGroupPanelItems($groupPanel, groupColumns);
    if (groupPanelOptions.allowColumnDragging && !groupColumns.length) {
      renderer_default("<div>").addClass(CLASSES5.groupPanelMessage).text(groupPanelOptions.emptyPanelText).appendTo($groupPanel);
      $groupPanel.closest(`.${CLASSES5.groupPanelContainer}`).addClass(CLASSES5.groupPanelLabel);
      $groupPanel.closest(`.${CLASSES5.groupPanelLabel}`).css("maxWidth", "none");
    }
  }
  allowDragging(column) {
    const groupPanelOptions = this.option("groupPanel");
    return allowDragging(groupPanelOptions, column);
  }
  getColumnElements() {
    const $element = this.element();
    return null === $element || void 0 === $element ? void 0 : $element.find(`.${CLASSES5.groupPanelItem}`);
  }
  getColumns() {
    return this._columnsController.getGroupColumns();
  }
  getBoundingRect() {
    const $element = this.element();
    if (null !== $element && void 0 !== $element && $element.find(`.${CLASSES5.groupPanel}`).length) {
      const offset2 = $element.offset();
      return {
        top: offset2.top,
        bottom: offset2.top + getHeight($element)
      };
    }
    return null;
  }
  getName() {
    return "group";
  }
  hasGroupedColumns() {
    return this._isGroupPanelVisible() && !!this.getColumns().length;
  }
  optionChanged(args) {
    if ("groupPanel" === args.name) {
      this._invalidate();
      args.handled = true;
    } else {
      super.optionChanged(args);
    }
  }
  getKeyboardNavigationController() {
    return this.getController("groupPanelKeyboardNavigation");
  }
  isColumnReorderingEnabled(column) {
    return this.allowDragging(column);
  }
  getContextMenuItems(options2) {
    let items = super.getContextMenuItems(options2);
    const $groupedColumnElement = renderer_default(options2.targetElement).closest(`.${CLASSES5.groupPanelItem}`);
    if (!$groupedColumnElement.length) {
      return;
    }
    options2.column = this._columnsController.columnOption(`groupIndex:${$groupedColumnElement.index()}`);
    const groupAndUngroupItems = this.getGroupAndUngroupItems(options2);
    if (null !== groupAndUngroupItems && void 0 !== groupAndUngroupItems && groupAndUngroupItems.length) {
      items = items ?? [];
      items.push(...groupAndUngroupItems);
    }
    const moveColumnItems = this.getMoveColumnContextMenuItems(options2);
    if (null !== moveColumnItems && void 0 !== moveColumnItems && moveColumnItems.length) {
      items = items ?? [];
      items.push(...moveColumnItems);
    }
    return items;
  }
};
var GroupingRowsViewExtender = (Base) => class extends Base {
  getContextMenuItems(options2) {
    const that = this;
    const contextMenuEnabled = that.option("grouping.contextMenuEnabled");
    let items;
    if (contextMenuEnabled && options2.row && "group" === options2.row.rowType) {
      const columnsController = that._columnsController;
      const column = columnsController.columnOption(`groupIndex:${options2.row.groupIndex}`);
      if (column && column.allowGrouping) {
        const groupingTexts = that.option("grouping.texts");
        const onItemClick = (e) => {
          var _e$itemData, _e$itemData2;
          if ("ungroup" === (null === (_e$itemData = e.itemData) || void 0 === _e$itemData ? void 0 : _e$itemData.value)) {
            columnsController.columnOption(column.dataField, "groupIndex", -1);
          } else if ("ungroupAll" === (null === (_e$itemData2 = e.itemData) || void 0 === _e$itemData2 ? void 0 : _e$itemData2.value)) {
            columnsController.clearGrouping();
          }
        };
        items = [];
        items.push({
          text: groupingTexts.ungroup,
          value: "ungroup",
          onItemClick,
          icon: CONTEXT_MENU_UNGROUP_COLUMN_ICON_NAME
        }, {
          text: groupingTexts.ungroupAll,
          value: "ungroupAll",
          onItemClick,
          icon: CONTEXT_MENU_UNGROUP_ALL_COLUMNS_ICON_NAME
        });
      }
    }
    return items;
  }
  _rowClick(e) {
    const that = this;
    const expandMode = that.option("grouping.expandMode");
    const scrollingMode = that.option("scrolling.mode");
    const isGroupRowStateChanged = "infinite" !== scrollingMode && "rowClick" === expandMode && renderer_default(e.event.target).closest(".dx-group-row").length;
    const isExpandButtonClicked = renderer_default(e.event.target).closest(".dx-datagrid-expand").length;
    if (isGroupRowStateChanged || isExpandButtonClicked) {
      that._changeGroupRowState(e);
    }
    super._rowClick(e);
  }
  _changeGroupRowState(e) {
    const row = this._dataController.items()[e.rowIndex];
    const allowCollapsing = this._columnsController.columnOption(`groupIndex:${row.groupIndex}`, "allowCollapsing");
    if ("data" === row.rowType || "group" === row.rowType && false !== allowCollapsing) {
      this._dataController.changeRowExpand(row.key, true);
      e.event.preventDefault();
      e.handled = true;
    }
  }
};
var columnHeadersViewExtender = (Base) => class extends Base {
  getContextMenuItems(options2) {
    const that = this;
    const groupItems = [];
    const contextMenuEnabled = that.option("grouping.contextMenuEnabled");
    let items = super.getContextMenuItems(options2);
    if (contextMenuEnabled && options2.row && ("header" === options2.row.rowType || "detailAdaptive" === options2.row.rowType)) {
      const {
        column,
        rowIndex
      } = options2;
      if (!column.command && (!isDefined(column.allowGrouping) || column.allowGrouping)) {
        const groupingTexts = that.option("grouping.texts");
        const isColumnGrouped = isDefined(column.groupIndex) && column.groupIndex > -1;
        const onItemClick = onGroupingMenuItemClick.bind(that, column, rowIndex);
        groupItems.push({
          text: groupingTexts.groupByThisColumn,
          value: "group",
          beginGroup: true,
          disabled: isColumnGrouped,
          onItemClick,
          icon: CONTEXT_MENU_GROUP_BY_COLUMN_ICON_NAME
        });
        if (column.showWhenGrouped) {
          groupItems.push({
            text: groupingTexts.ungroup,
            value: "ungroup",
            disabled: !isColumnGrouped,
            onItemClick,
            icon: CONTEXT_MENU_UNGROUP_COLUMN_ICON_NAME
          });
        }
        groupItems.push({
          text: groupingTexts.ungroupAll,
          value: "ungroupAll",
          onItemClick,
          icon: CONTEXT_MENU_UNGROUP_ALL_COLUMNS_ICON_NAME
        });
      }
    }
    if (groupItems.length) {
      items = items ?? [];
      const clearSortingItemIndex = items.findIndex((item) => "clearSorting" === item.name) + 1;
      items.splice(clearSortingItemIndex, 0, ...groupItems);
    }
    return items;
  }
  allowDragging(column) {
    const groupPanelOptions = this.option("groupPanel");
    return allowDragging(groupPanelOptions, column) || super.allowDragging(column);
  }
};
m_core_default.registerModule("grouping", {
  defaultOptions: () => ({
    grouping: {
      autoExpandAll: true,
      allowCollapsing: true,
      contextMenuEnabled: true,
      expandMode: "buttonClick",
      texts: {
        groupContinuesMessage: message_default.format("dxDataGrid-groupContinuesMessage"),
        groupContinuedMessage: message_default.format("dxDataGrid-groupContinuedMessage"),
        groupByThisColumn: message_default.format("dxDataGrid-groupHeaderText"),
        ungroup: message_default.format("dxDataGrid-ungroupHeaderText"),
        ungroupAll: message_default.format("dxDataGrid-ungroupAllText")
      }
    },
    groupPanel: {
      visible: false,
      emptyPanelText: message_default.format("dxDataGrid-groupPanelEmptyText"),
      allowColumnDragging: true
    }
  }),
  extenders: {
    controllers: {
      data: GroupingDataControllerExtender,
      columns: (Base) => class extends Base {
        _getExpandColumnOptions() {
          const options2 = super._getExpandColumnOptions.apply(this, arguments);
          options2.cellTemplate = m_core_default.getExpandCellTemplate();
          return options2;
        }
      },
      editing: (Base) => class extends Base {
        _isProcessedItem(item) {
          return isDefined(item.groupIndex) && isString(item.rowType) && 0 === item.rowType.indexOf("group");
        }
      }
    },
    views: {
      headerPanel: GroupingHeaderPanelExtender,
      rowsView: GroupingRowsViewExtender,
      columnHeadersView: columnHeadersViewExtender
    }
  }
});

// node_modules/devextreme/esm/__internal/grids/grid_core/master_detail/m_master_detail.js
var columns3 = (Base) => class extends Base {
  _getExpandColumnsCore() {
    const expandColumns = super._getExpandColumnsCore();
    if (this.option("masterDetail.enabled")) {
      expandColumns.push({
        type: "detailExpand",
        cellTemplate: m_utils_default.getExpandCellTemplate()
      });
    }
    return expandColumns;
  }
};
var initMasterDetail = function(that) {
  that._expandedItems = [];
  that._isExpandAll = that.option("masterDetail.autoExpandAll");
};
var dataMasterDetailExtenderMixin = (Base) => class extends Base {
  init() {
    initMasterDetail(this);
    super.init();
  }
  expandAll(groupIndex) {
    const that = this;
    if (groupIndex < 0) {
      that._isExpandAll = true;
      that._expandedItems = [];
      that.updateItems();
    } else {
      super.expandAll.apply(that, arguments);
    }
  }
  collapseAll(groupIndex) {
    const that = this;
    if (groupIndex < 0) {
      that._isExpandAll = false;
      that._expandedItems = [];
      that.updateItems();
    } else {
      super.collapseAll.apply(that, arguments);
    }
  }
  isRowExpandedHack() {
    return super.isRowExpanded.apply(this, arguments);
  }
  isRowExpanded(key) {
    const that = this;
    const expandIndex = m_utils_default.getIndexByKey(key, that._expandedItems);
    if (Array.isArray(key)) {
      return super.isRowExpanded.apply(that, arguments);
    }
    return !!(that._isExpandAll ^ (expandIndex >= 0 && that._expandedItems[expandIndex].visible));
  }
  _getRowIndicesForExpand(key) {
    const rowIndex = this.getRowIndexByKey(key);
    return [rowIndex, rowIndex + 1];
  }
  _changeRowExpandCore(key) {
    const that = this;
    let result2;
    if (Array.isArray(key)) {
      result2 = super._changeRowExpandCore.apply(that, arguments);
    } else {
      const expandIndex = m_utils_default.getIndexByKey(key, that._expandedItems);
      if (expandIndex >= 0) {
        const {
          visible: visible2
        } = that._expandedItems[expandIndex];
        that._expandedItems[expandIndex].visible = !visible2;
      } else {
        that._expandedItems.push({
          key,
          visible: true
        });
      }
      that.updateItems({
        changeType: "update",
        rowIndices: that._getRowIndicesForExpand(key)
      });
      result2 = new Deferred().resolve();
    }
    return result2;
  }
  _processDataItemHack() {
    return super._processDataItem.apply(this, arguments);
  }
  _processDataItem(data17, options2) {
    const dataItem = super._processDataItem.apply(this, arguments);
    dataItem.isExpanded = this.isRowExpanded(dataItem.key);
    if (void 0 === options2.detailColumnIndex) {
      options2.detailColumnIndex = -1;
      each(options2.visibleColumns, (index2, column) => {
        if ("expand" === column.command && !isDefined(column.groupIndex)) {
          options2.detailColumnIndex = index2;
          return false;
        }
        return;
      });
    }
    if (options2.detailColumnIndex >= 0) {
      dataItem.values[options2.detailColumnIndex] = dataItem.isExpanded;
    }
    return dataItem;
  }
  _processItemsHack() {
    return super._processItems.apply(this, arguments);
  }
  _processItems(items, change) {
    const that = this;
    const {
      changeType
    } = change;
    const result2 = [];
    items = super._processItems.apply(that, arguments);
    if ("loadingAll" === changeType) {
      return items;
    }
    if ("refresh" === changeType) {
      that._expandedItems = grep(that._expandedItems, (item) => item.visible);
    }
    each(items, (index2, item) => {
      result2.push(item);
      const expandIndex = m_utils_default.getIndexByKey(item.key, that._expandedItems);
      if ("data" === item.rowType && (item.isExpanded || expandIndex >= 0) && !item.isNewRow) {
        result2.push({
          visible: item.isExpanded,
          rowType: "detail",
          key: item.key,
          data: item.data,
          values: []
        });
      }
    });
    return result2;
  }
  optionChanged(args) {
    const that = this;
    let isEnabledChanged;
    let isAutoExpandAllChanged;
    if ("masterDetail" === args.name) {
      args.name = "dataSource";
      switch (args.fullName) {
        case "masterDetail": {
          const value2 = args.value || {};
          const previousValue = args.previousValue || {};
          isEnabledChanged = value2.enabled !== previousValue.enabled;
          isAutoExpandAllChanged = value2.autoExpandAll !== previousValue.autoExpandAll;
          break;
        }
        case "masterDetail.template":
          initMasterDetail(that);
          break;
        case "masterDetail.enabled":
          isEnabledChanged = true;
          break;
        case "masterDetail.autoExpandAll":
          isAutoExpandAllChanged = true;
      }
      if (isEnabledChanged || isAutoExpandAllChanged) {
        initMasterDetail(that);
      }
    }
    super.optionChanged(args);
  }
};
var resizing2 = (Base) => class extends Base {
  fireContentReadyAction() {
    super.fireContentReadyAction.apply(this, arguments);
    this._updateParentDataGrids(this.component.$element());
  }
  _updateParentDataGrids($element) {
    const $masterDetailRow = $element.closest(".dx-master-detail-row");
    if ($masterDetailRow.length) {
      when(this._updateMasterDataGrid($masterDetailRow, $element)).done(() => {
        this._updateParentDataGrids($masterDetailRow.parent());
      });
    }
  }
  _updateMasterDataGrid($masterDetailRow, $detailElement) {
    const masterRowOptions = renderer_default($masterDetailRow).data("options");
    const masterDataGrid = renderer_default($masterDetailRow).closest(`.${this.getWidgetContainerClass()}`).parent().data("dxDataGrid");
    if (masterRowOptions && masterDataGrid) {
      return this._updateMasterDataGridCore(masterDataGrid, masterRowOptions);
    }
    return;
  }
  _updateMasterDataGridCore(masterDataGrid, masterRowOptions) {
    var _masterDataGrid$getVi, _masterDataGrid$getVi2;
    const d = Deferred();
    if (null !== (_masterDataGrid$getVi = masterDataGrid.getView("rowsView")) && void 0 !== _masterDataGrid$getVi && null !== (_masterDataGrid$getVi2 = _masterDataGrid$getVi.isFixedColumns) && void 0 !== _masterDataGrid$getVi2 && _masterDataGrid$getVi2.call(_masterDataGrid$getVi)) {
      this._updateFixedMasterDetailGrids(masterDataGrid, masterRowOptions.rowIndex, renderer_default(masterRowOptions.rowElement)).done(d.resolve);
    } else {
      if (true === masterDataGrid.option("scrolling.useNative")) {
        masterDataGrid.updateDimensions().done(() => d.resolve(true));
        return;
      }
      const scrollable = masterDataGrid.getScrollable();
      if (scrollable) {
        null === scrollable || void 0 === scrollable || scrollable.update().done(() => d.resolve());
      } else {
        d.resolve();
      }
    }
    return d.promise();
  }
  _updateFixedMasterDetailGrids(masterDataGrid, masterRowIndex, $detailElement) {
    const d = Deferred();
    const $rows = renderer_default(masterDataGrid.getRowElement(masterRowIndex));
    const $tables = renderer_default(masterDataGrid.getView("rowsView").getTableElements());
    const rowsNotEqual = 2 === (null === $rows || void 0 === $rows ? void 0 : $rows.length) && getHeight($rows.eq(0)) !== getHeight($rows.eq(1));
    const tablesNotEqual = 2 === (null === $tables || void 0 === $tables ? void 0 : $tables.length) && getHeight($tables.eq(0)) !== getHeight($tables.eq(1));
    if (rowsNotEqual || tablesNotEqual) {
      const detailElementWidth = getWidth($detailElement);
      masterDataGrid.updateDimensions().done(() => {
        const isDetailHorizontalScrollCanBeShown = this.option("columnAutoWidth") && true === masterDataGrid.option("scrolling.useNative");
        const isDetailGridWidthChanged = isDetailHorizontalScrollCanBeShown && detailElementWidth !== getWidth($detailElement);
        if (isDetailHorizontalScrollCanBeShown && isDetailGridWidthChanged) {
          this.updateDimensions().done(() => d.resolve(true));
        } else {
          d.resolve(true);
        }
      });
      return d.promise();
    }
    return Deferred().resolve();
  }
  _toggleBestFitMode(isBestFit) {
    super._toggleBestFitMode.apply(this, arguments);
    if (this.option("masterDetail.template")) {
      const $rowsTable = this._rowsView.getTableElement();
      if ($rowsTable) {
        $rowsTable.find(".dx-master-detail-cell").css("maxWidth", isBestFit ? 0 : "");
      }
    }
  }
};
var rowsView2 = (Base) => class extends Base {
  _getCellTemplate(options2) {
    const that = this;
    const {
      column
    } = options2;
    const editingController = this._editingController;
    const isEditRow = editingController && editingController.isEditRow(options2.rowIndex);
    let template;
    if ("detail" === column.command && !isEditRow) {
      template = that.option("masterDetail.template") || {
        allowRenderToDetachedContainer: false,
        render: that._getDefaultTemplate(column)
      };
    } else {
      template = super._getCellTemplate.apply(that, arguments);
    }
    return template;
  }
  _isDetailRow(row) {
    return (null === row || void 0 === row ? void 0 : row.rowType) && 0 === row.rowType.indexOf("detail");
  }
  _createRow(row) {
    const $row = super._createRow.apply(this, arguments);
    if (row && this._isDetailRow(row)) {
      this.option("showRowLines") && $row.addClass("dx-row-lines");
      $row.addClass("dx-master-detail-row");
      if (isDefined(row.visible)) {
        $row.toggle(row.visible);
      }
    }
    return $row;
  }
  _renderCells($row, options2) {
    const {
      row
    } = options2;
    if (row.rowType && this._isDetailRow(row)) {
      if (this._needRenderCell(0, options2.columnIndices)) {
        this._renderMasterDetailCell($row, row, options2);
      }
    } else {
      super._renderCells.apply(this, arguments);
    }
  }
  _renderMasterDetailCell($row, row, options2) {
    const visibleColumns = this._columnsController.getVisibleColumns();
    const $detailCell = this._renderCell($row, {
      value: null,
      row,
      rowIndex: row.rowIndex,
      column: {
        command: "detail"
      },
      columnIndex: 0,
      change: options2.change
    });
    $detailCell.addClass("dx-cell-focus-disabled").addClass("dx-master-detail-cell").attr("colSpan", visibleColumns.length);
    const isEditForm2 = row.isEditing;
    if (!isEditForm2) {
      $detailCell.attr("aria-roledescription", message_default.format("dxDataGrid-masterDetail"));
    }
    return $detailCell;
  }
};
var masterDetailModule = {
  defaultOptions: () => ({
    masterDetail: {
      enabled: false,
      autoExpandAll: false,
      template: null
    }
  }),
  extenders: {
    controllers: {
      columns: columns3,
      data: dataMasterDetailExtenderMixin,
      resizing: resizing2
    },
    views: {
      rowsView: rowsView2
    }
  }
};

// node_modules/devextreme/esm/__internal/grids/data_grid/module_not_extended/master_detail.js
m_core_default.registerModule("masterDetail", masterDetailModule);

// node_modules/devextreme/esm/__internal/ui/text_box/m_text_editor.js
component_registrator_default("dxTextEditor", m_text_editor_mask_default);
var m_text_editor_default = m_text_editor_mask_default;

// node_modules/devextreme/esm/__internal/ui/number_box/m_number_box.spin.js
var SPIN_CLASS = "dx-numberbox-spin";
var SPIN_BUTTON_CLASS = "dx-numberbox-spin-button";
var NUMBER_BOX = "dxNumberBox";
var POINTERUP_EVENT_NAME = addNamespace2(m_pointer_default.up, NUMBER_BOX);
var POINTERCANCEL_EVENT_NAME = addNamespace2(m_pointer_default.cancel, NUMBER_BOX);
var SpinButton = class extends widget_default {
  _getDefaultOptions() {
    return _extends({}, super._getDefaultOptions(), {
      direction: "up",
      onChange: null,
      activeStateEnabled: true,
      hoverStateEnabled: true
    });
  }
  _initMarkup() {
    super._initMarkup();
    const {
      direction: spinDirection
    } = this.option();
    const direction = `${SPIN_CLASS}-${spinDirection}`;
    this.$element().addClass(SPIN_BUTTON_CLASS).addClass(direction);
    this._spinIcon = renderer_default("<div>").addClass(`${direction}-icon`).appendTo(this.$element());
  }
  _render() {
    super._render();
    const eventName = addNamespace2(m_pointer_default.down, this.NAME);
    const $element = this.$element();
    m_events_engine_default.off($element, eventName);
    m_events_engine_default.on($element, eventName, this._spinDownHandler.bind(this));
    this._spinChangeHandler = this._createActionByOption("onChange");
  }
  _spinDownHandler(e) {
    e.preventDefault();
    this._clearTimer();
    m_events_engine_default.on(this.$element(), m_hold_default.name, () => {
      this._feedBackDeferred = Deferred();
      lock(this._feedBackDeferred);
      this._spinChangeHandler({
        event: e
      });
      this._holdTimer = setInterval(this._spinChangeHandler, 100, {
        event: e
      });
    });
    const document2 = dom_adapter_default.getDocument();
    m_events_engine_default.on(document2, POINTERUP_EVENT_NAME, this._clearTimer.bind(this));
    m_events_engine_default.on(document2, POINTERCANCEL_EVENT_NAME, this._clearTimer.bind(this));
    this._spinChangeHandler({
      event: e
    });
  }
  _dispose() {
    this._clearTimer();
    super._dispose();
  }
  _clearTimer() {
    m_events_engine_default.off(this.$element(), m_hold_default.name);
    const document2 = dom_adapter_default.getDocument();
    m_events_engine_default.off(document2, POINTERUP_EVENT_NAME);
    m_events_engine_default.off(document2, POINTERCANCEL_EVENT_NAME);
    if (this._feedBackDeferred) {
      this._feedBackDeferred.resolve();
    }
    if (this._holdTimer) {
      clearInterval(this._holdTimer);
    }
  }
  _optionChanged(args) {
    switch (args.name) {
      case "onChange":
      case "direction":
        this._invalidate();
        break;
      default:
        super._optionChanged(args);
    }
  }
};
var m_number_box_spin_default = SpinButton;

// node_modules/devextreme/esm/__internal/ui/number_box/m_number_box.spins.js
var SPIN_CLASS2 = "dx-numberbox-spin";
var SPIN_CONTAINER_CLASS = "dx-numberbox-spin-container";
var SPIN_TOUCH_FRIENDLY_CLASS = "dx-numberbox-spin-touch-friendly";
var SpinButtons = class extends TextEditorButton {
  _attachEvents(instance, $spinContainer) {
    const {
      editor
    } = this;
    const eventName = addNamespace2(m_pointer_default.down, editor.NAME);
    const $spinContainerChildren = $spinContainer.children();
    const pointerDownAction = editor._createAction((e) => editor._spinButtonsPointerDownHandler(e));
    m_events_engine_default.off($spinContainer, eventName);
    m_events_engine_default.on($spinContainer, eventName, (e) => pointerDownAction({
      event: e
    }));
    m_number_box_spin_default.getInstance($spinContainerChildren.eq(0)).option("onChange", (e) => editor._spinUpChangeHandler(e));
    m_number_box_spin_default.getInstance($spinContainerChildren.eq(1)).option("onChange", (e) => editor._spinDownChangeHandler(e));
  }
  _create() {
    const {
      editor
    } = this;
    const $spinContainer = renderer_default("<div>").addClass(SPIN_CONTAINER_CLASS);
    const $spinUp = renderer_default("<div>").appendTo($spinContainer);
    const $spinDown = renderer_default("<div>").appendTo($spinContainer);
    const options2 = this._getOptions();
    this._addToContainer($spinContainer);
    editor._createComponent($spinUp, m_number_box_spin_default, extend({
      direction: "up"
    }, options2));
    editor._createComponent($spinDown, m_number_box_spin_default, extend({
      direction: "down"
    }, options2));
    this._legacyRender(editor.$element(), this._isTouchFriendly(), options2.visible);
    return {
      instance: $spinContainer,
      $element: $spinContainer
    };
  }
  _getOptions() {
    const {
      editor
    } = this;
    const visible2 = this._isVisible();
    const disabled = editor.option("disabled");
    return {
      visible: visible2,
      disabled
    };
  }
  _isVisible() {
    const {
      editor
    } = this;
    return super._isVisible() && editor.option("showSpinButtons");
  }
  _isTouchFriendly() {
    const {
      editor
    } = this;
    return editor.option("showSpinButtons") && editor.option("useLargeSpinButtons");
  }
  _legacyRender($editor, isTouchFriendly, isVisible2) {
    $editor.toggleClass(SPIN_TOUCH_FRIENDLY_CLASS, isTouchFriendly);
    $editor.toggleClass(SPIN_CLASS2, isVisible2);
  }
  update() {
    const shouldUpdate = super.update();
    if (shouldUpdate) {
      const {
        editor,
        instance
      } = this;
      const $editor = editor.$element();
      const isVisible2 = this._isVisible();
      const isTouchFriendly = this._isTouchFriendly();
      const $spinButtons = instance.children();
      const spinUp = m_number_box_spin_default.getInstance($spinButtons.eq(0));
      const spinDown = m_number_box_spin_default.getInstance($spinButtons.eq(1));
      const options2 = this._getOptions();
      spinUp.option(options2);
      spinDown.option(options2);
      this._legacyRender($editor, isTouchFriendly, isVisible2);
    }
  }
};

// node_modules/devextreme/esm/__internal/ui/number_box/m_number_box.base.js
var math = Math;
var WIDGET_CLASS5 = "dx-numberbox";
var FIREFOX_CONTROL_KEYS = ["tab", "del", "backspace", "leftArrow", "rightArrow", "home", "end", "enter"];
var NumberBoxBase = class extends m_text_editor_default {
  _supportedKeys() {
    return _extends({}, super._supportedKeys(), {
      upArrow(e) {
        if (!isCommandKeyPressed(e)) {
          e.preventDefault();
          e.stopPropagation();
          this._spinUpChangeHandler(e);
        }
      },
      downArrow(e) {
        if (!isCommandKeyPressed(e)) {
          e.preventDefault();
          e.stopPropagation();
          this._spinDownChangeHandler(e);
        }
      },
      enter() {
      }
    });
  }
  _getDefaultOptions() {
    return _extends({}, super._getDefaultOptions(), {
      value: 0,
      min: void 0,
      max: void 0,
      step: 1,
      showSpinButtons: false,
      useLargeSpinButtons: true,
      mode: "text",
      invalidValueMessage: message_default.format("dxNumberBox-invalidValueMessage"),
      buttons: void 0
    });
  }
  _useTemplates() {
    return false;
  }
  _getDefaultButtons() {
    return super._getDefaultButtons().concat([{
      name: "spins",
      Ctor: SpinButtons
    }]);
  }
  _isSupportInputMode() {
    const version2 = parseFloat(browser_default.version);
    return browser_default.chrome && version2 >= 66 || browser_default.safari && version2 >= 12;
  }
  _defaultOptionsRules() {
    return super._defaultOptionsRules().concat([{
      device: () => devices_default.real().generic && !devices_default.isSimulator(),
      options: {
        useLargeSpinButtons: false
      }
    }, {
      device: function() {
        return "desktop" !== devices_default.real().deviceType && !this._isSupportInputMode();
      }.bind(this),
      options: {
        mode: "number"
      }
    }]);
  }
  _initMarkup() {
    this._renderSubmitElement();
    this.$element().addClass(WIDGET_CLASS5);
    super._initMarkup();
    this._toggleTabIndex();
  }
  _getDefaultAttributes() {
    const attributes = super._getDefaultAttributes();
    attributes.inputmode = "decimal";
    return attributes;
  }
  _renderContentImpl() {
    this.option("isValid") && this._validateValue(this.option("value"));
    this.setAria("role", "spinbutton");
  }
  _renderSubmitElement() {
    this._$submitElement = renderer_default("<input>").attr("type", "hidden").appendTo(this.$element());
    this._setSubmitValue(this.option("value"));
  }
  _setSubmitValue(value2) {
    this._getSubmitElement().val(applyServerDecimalSeparator(value2));
  }
  _getSubmitElement() {
    return this._$submitElement;
  }
  _keyPressHandler(e) {
    super._keyPressHandler();
    const char = getChar(e);
    const isInputCharValid = /[\d.,eE\-+]/.test(char);
    if (!isInputCharValid) {
      const keyName = normalizeKeyName(e);
      if (isCommandKeyPressed(e) || keyName && FIREFOX_CONTROL_KEYS.includes(keyName)) {
        return;
      }
      e.preventDefault();
      return;
    }
    this._keyPressed = true;
  }
  _hasMouseWheelHandler() {
    return true;
  }
  _onMouseWheel(dxEvent) {
    dxEvent.delta > 0 ? this._spinValueChange(1, dxEvent) : this._spinValueChange(-1, dxEvent);
  }
  _renderValue() {
    const inputValue = this._input().val();
    const value2 = this.option("value");
    if (!inputValue.length || Number(inputValue) !== value2) {
      this._forceValueRender();
      this._toggleEmptinessEventHandler();
    }
    const valueText = isDefined(value2) ? null : message_default.format("dxNumberBox-noDataText");
    this.setAria({
      valuenow: ensureDefined(value2, ""),
      valuetext: valueText
    });
    this.option("text", this._input().val());
    this._updateButtons();
    return Deferred().resolve();
  }
  _forceValueRender() {
    const value2 = this.option("value");
    const number = Number(value2);
    const formattedValue = isNaN(number) ? "" : this._applyDisplayValueFormatter(value2);
    this._renderDisplayText(formattedValue);
  }
  _applyDisplayValueFormatter(value2) {
    const {
      displayValueFormatter
    } = this.option();
    return null === displayValueFormatter || void 0 === displayValueFormatter ? void 0 : displayValueFormatter(value2);
  }
  _renderProps() {
    this._input().prop({
      min: this.option("min"),
      max: this.option("max"),
      step: this.option("step")
    });
    this.setAria({
      valuemin: ensureDefined(this.option("min"), ""),
      valuemax: ensureDefined(this.option("max"), "")
    });
  }
  _spinButtonsPointerDownHandler() {
    const $input = this._input();
    if (!this.option("useLargeSpinButtons") && dom_adapter_default.getActiveElement() !== $input[0]) {
      m_events_engine_default.trigger($input, "focus");
    }
  }
  _spinUpChangeHandler(e) {
    if (!this.option("readOnly")) {
      this._spinValueChange(1, e.event || e);
    }
  }
  _spinDownChangeHandler(e) {
    if (!this.option("readOnly")) {
      this._spinValueChange(-1, e.event || e);
    }
  }
  _spinValueChange(sign2, dxEvent) {
    const step = parseFloat(this.option("step"));
    if (0 === step) {
      return;
    }
    let value2 = parseFloat(this._normalizeInputValue()) || 0;
    value2 = this._correctRounding(value2, step * sign2);
    const min = this.option("min");
    const max = this.option("max");
    if (isDefined(min)) {
      value2 = Math.max(min, value2);
    }
    if (isDefined(max)) {
      value2 = Math.min(max, value2);
    }
    this._saveValueChangeEvent(dxEvent);
    this.option("value", value2);
  }
  _correctRounding(value2, step) {
    const regex = /[,.](.*)/;
    const isFloatValue = regex.test(value2);
    const isFloatStep = regex.test(step);
    if (isFloatValue || isFloatStep) {
      const valueAccuracy = isFloatValue ? regex.exec(value2)[0].length : 0;
      const stepAccuracy = isFloatStep ? regex.exec(step)[0].length : 0;
      const accuracy = math.max(valueAccuracy, stepAccuracy);
      value2 = this._round(value2 + step, accuracy);
      return value2;
    }
    return value2 + step;
  }
  _round(value2, precision) {
    precision = precision || 0;
    const multiplier = 10 ** precision;
    value2 *= multiplier;
    value2 = Math.round(value2) / multiplier;
    return value2;
  }
  _renderValueChangeEvent() {
    super._renderValueChangeEvent();
    const forceValueChangeEvent = addNamespace2("focusout", "NumberBoxForceValueChange");
    m_events_engine_default.off(this.element(), forceValueChangeEvent);
    m_events_engine_default.on(this.element(), forceValueChangeEvent, this._forceRefreshInputValue.bind(this));
  }
  _forceRefreshInputValue() {
    const {
      mode
    } = this.option();
    if ("number" === mode) {
      return;
    }
    const $input = this._input();
    const formattedValue = this._applyDisplayValueFormatter(this.option("value"));
    $input.val(null);
    $input.val(formattedValue);
  }
  _valueChangeEventHandler(e) {
    const $input = this._input();
    const inputValue = this._normalizeText();
    const value2 = this._parseValue(inputValue);
    const valueHasDigits = "." !== inputValue && "-" !== inputValue;
    if (this._isValueValid() && !this._validateValue(value2)) {
      $input.val(this._applyDisplayValueFormatter(value2));
      return;
    }
    if (valueHasDigits) {
      super._valueChangeEventHandler(e, isNaN(value2) ? null : value2);
    }
    this._applyValueBoundaries(inputValue, value2);
    this.validationRequest.fire({
      value: value2,
      editor: this
    });
  }
  _applyValueBoundaries(inputValue, parsedValue) {
    const isValueIncomplete = this._isValueIncomplete(inputValue);
    const isValueCorrect = this._isValueInRange(inputValue);
    if (!isValueIncomplete && !isValueCorrect && null !== parsedValue) {
      if (Number(inputValue) !== parsedValue) {
        this._input().val(this._applyDisplayValueFormatter(parsedValue));
      }
    }
  }
  _replaceCommaWithPoint(value2) {
    return value2.replace(",", ".");
  }
  _inputIsInvalid() {
    const {
      mode
    } = this.option();
    const isNumberMode = "number" === mode;
    const validityState = this._input().get(0).validity;
    return isNumberMode && (null === validityState || void 0 === validityState ? void 0 : validityState.badInput);
  }
  _renderDisplayText(text) {
    if (this._inputIsInvalid()) {
      return;
    }
    super._renderDisplayText(text);
  }
  _isValueIncomplete(value2) {
    return /(^-$)|(^-?\d*\.$)|(\d+e-?$)/i.test(value2);
  }
  _isValueInRange(value2) {
    return inRange(value2, this.option("min"), this.option("max"));
  }
  _isNumber(value2) {
    return null !== this._parseValue(value2);
  }
  _validateValue(value2) {
    const inputValue = this._normalizeText();
    const isValueValid = this._isValueValid();
    let isValid = true;
    const isNumber2 = this._isNumber(inputValue);
    if (isNaN(Number(value2))) {
      isValid = false;
    }
    if (!value2 && isValueValid) {
      isValid = true;
    } else if (!isNumber2 && !isValueValid) {
      isValid = false;
    }
    this.option({
      isValid,
      validationError: isValid ? null : {
        editorSpecific: true,
        message: this.option("invalidValueMessage")
      }
    });
    return isValid;
  }
  _normalizeInputValue() {
    return this._parseValue(this._normalizeText());
  }
  _normalizeText() {
    const value2 = this._input().val().trim();
    return this._replaceCommaWithPoint(value2);
  }
  _parseValue(value2) {
    const number = parseFloat(value2);
    if (isNaN(number)) {
      return null;
    }
    return fitIntoRange(number, this.option("min"), this.option("max"));
  }
  _clearValue() {
    if (this._inputIsInvalid()) {
      this._input().val("");
      this._validateValue();
    }
    super._clearValue();
  }
  clear() {
    if (null === this.option("value")) {
      this.option("text", "");
      if (this._input().length) {
        this._renderValue();
      }
    } else {
      this.option("value", null);
    }
  }
  _optionChanged(args) {
    switch (args.name) {
      case "value":
        this._validateValue(args.value);
        this._setSubmitValue(args.value);
        super._optionChanged(args);
        this._resumeValueChangeAction();
        break;
      case "step":
        this._renderProps();
        break;
      case "min":
      case "max":
        this._renderProps();
        this.option("value", this._parseValue(this.option("value")));
        break;
      case "showSpinButtons":
      case "useLargeSpinButtons":
        this._updateButtons(["spins"]);
        break;
      case "invalidValueMessage":
        break;
      default:
        super._optionChanged(args);
    }
  }
};
var m_number_box_base_default = NumberBoxBase;

// node_modules/devextreme/esm/__internal/ui/number_box/m_utils.js
var getRealSeparatorIndex = function(str) {
  let quoteBalance = 0;
  let separatorCount = 0;
  for (let i = 0; i < str.length; ++i) {
    if ("'" === str[i]) {
      quoteBalance++;
    }
    if ("." === str[i]) {
      ++separatorCount;
      if (quoteBalance % 2 === 0) {
        return {
          occurrence: separatorCount,
          index: i
        };
      }
    }
  }
  return {
    occurrence: 1,
    index: -1
  };
};
var getNthOccurrence = function(str, c, n) {
  let i = -1;
  while (n-- && i++ < str.length) {
    i = str.indexOf(c, i);
  }
  return i;
};
var splitByIndex = function(str, index2) {
  if (-1 === index2) {
    return [str];
  }
  return [str.slice(0, index2), str.slice(index2 + 1)];
};
var adjustPercentValue = function(rawValue, precision) {
  return rawValue && adjust(rawValue / 100, precision);
};

// node_modules/devextreme/esm/__internal/ui/number_box/m_number_box.caret.js
var getCaretBoundaries = function(text, format2) {
  if ("string" === typeof format2) {
    const signParts = format2.split(";");
    const sign2 = number_default2.getSign(text, format2);
    signParts[1] = signParts[1] || `-${signParts[0]}`;
    format2 = signParts[sign2 < 0 ? 1 : 0];
    const mockEscapedStubs = (str) => str.replace(/'([^']*)'/g, (str2) => str2.split("").map(() => " ").join("").substr(2));
    format2 = mockEscapedStubs(format2);
    const prefixStubLength = /^[^#0.,]*/.exec(format2)[0].length;
    const postfixStubLength = /[^#0.,]*$/.exec(format2)[0].length;
    return {
      start: prefixStubLength,
      end: text.length - postfixStubLength
    };
  }
  return {
    start: 0,
    end: text.length
  };
};
var _getDigitCountBeforeIndex = function(index2, text) {
  const decimalSeparator = number_default2.getDecimalSeparator();
  const regExp = new RegExp(`[^0-9${escapeRegExp(decimalSeparator)}]`, "g");
  const textBeforePosition = text.slice(0, index2);
  return textBeforePosition.replace(regExp, "").length;
};
var _reverseText = function(text) {
  return text.split("").reverse().join("");
};
var _getDigitPositionByIndex = function(digitIndex, text) {
  if (!digitIndex) {
    return -1;
  }
  const regExp = /[0-9]/g;
  let counter = 1;
  let index2 = null;
  let result2 = regExp.exec(text);
  while (result2) {
    index2 = result2.index;
    if (counter >= digitIndex) {
      return index2;
    }
    counter++;
    result2 = regExp.exec(text);
  }
  return null === index2 ? text.length : index2;
};
var _trimNonNumericCharsFromEnd = function(text) {
  return text.replace(/[^0-9e]+$/, "");
};
var getCaretWithOffset = function(caret3, offset2) {
  if (void 0 === caret3.start) {
    caret3 = {
      start: caret3,
      end: caret3
    };
  }
  return {
    start: caret3.start + offset2,
    end: caret3.end + offset2
  };
};
var getCaretAfterFormat = function(text, formatted, caret3, format2) {
  caret3 = getCaretWithOffset(caret3, 0);
  const point = number_default2.getDecimalSeparator();
  const isSeparatorBasedText = isSeparatorBasedString(text);
  const realSeparatorOccurrenceIndex = getRealSeparatorIndex(format2).occurrence;
  const pointPosition = isSeparatorBasedText ? 0 : getNthOccurrence(text, point, realSeparatorOccurrenceIndex);
  const newPointPosition = getNthOccurrence(formatted, point, realSeparatorOccurrenceIndex);
  const textParts = splitByIndex(text, pointPosition);
  const formattedParts = splitByIndex(formatted, newPointPosition);
  const isCaretOnFloat = -1 !== pointPosition && caret3.start > pointPosition;
  if (isCaretOnFloat) {
    const relativeIndex = caret3.start - pointPosition - 1;
    const digitsBefore = _getDigitCountBeforeIndex(relativeIndex, textParts[1]);
    const newPosition = formattedParts[1] ? newPointPosition + 1 + _getDigitPositionByIndex(digitsBefore, formattedParts[1]) + 1 : formatted.length;
    return getCaretInBoundaries(newPosition, formatted, format2);
  }
  const formattedIntPart = _trimNonNumericCharsFromEnd(formattedParts[0]);
  const positionFromEnd = textParts[0].length - caret3.start;
  const digitsFromEnd = _getDigitCountBeforeIndex(positionFromEnd, _reverseText(textParts[0]));
  const newPositionFromEnd = _getDigitPositionByIndex(digitsFromEnd, _reverseText(formattedIntPart));
  const newPositionFromBegin = formattedIntPart.length - (newPositionFromEnd + 1);
  return getCaretInBoundaries(newPositionFromBegin, formatted, format2);
};
function isSeparatorBasedString(text) {
  return 1 === text.length && !!text.match(/^[,.][0-9]*$/g);
}
var isCaretInBoundaries = function(caret3, text, format2) {
  caret3 = getCaretWithOffset(caret3, 0);
  const boundaries = getCaretInBoundaries(caret3, text, format2);
  return caret3.start >= boundaries.start && caret3.end <= boundaries.end;
};
function getCaretInBoundaries(caret3, text, format2) {
  caret3 = getCaretWithOffset(caret3, 0);
  const boundaries = getCaretBoundaries(text, format2);
  const adjustedCaret = {
    start: fitIntoRange(caret3.start, boundaries.start, boundaries.end),
    end: fitIntoRange(caret3.end, boundaries.start, boundaries.end)
  };
  return adjustedCaret;
}
var getCaretOffset = function(previousText, newText, format2) {
  const previousBoundaries = getCaretBoundaries(previousText, format2);
  const newBoundaries = getCaretBoundaries(newText, format2);
  return newBoundaries.start - previousBoundaries.start;
};

// node_modules/devextreme/esm/__internal/ui/number_box/m_number_box.mask.js
var NumberBoxMask = class extends m_number_box_base_default {
  _getDefaultOptions() {
    return _extends({}, super._getDefaultOptions(), {
      useMaskBehavior: true,
      format: null
    });
  }
  _isDeleteKey(key) {
    return "del" === key;
  }
  _supportedKeys() {
    if (!this._useMaskBehavior()) {
      return super._supportedKeys();
    }
    return _extends({}, super._supportedKeys(), {
      minus: this._revertSign.bind(this),
      del: this._removeHandler.bind(this),
      backspace: this._removeHandler.bind(this),
      leftArrow: this._arrowHandler.bind(this, -1),
      rightArrow: this._arrowHandler.bind(this, 1),
      home: this._moveCaretToBoundaryEventHandler.bind(this, 1),
      enter: this._updateFormattedValue.bind(this),
      end: this._moveCaretToBoundaryEventHandler.bind(this, -1)
    });
  }
  _getTextSeparatorIndex(text) {
    const decimalSeparator = number_default2.getDecimalSeparator();
    const realSeparatorOccurrenceIndex = getRealSeparatorIndex(this.option("format")).occurrence;
    return getNthOccurrence(text, decimalSeparator, realSeparatorOccurrenceIndex);
  }
  _focusInHandler(e) {
    if (!this._preventNestedFocusEvent(e)) {
      this.clearCaretTimeout();
      this._caretTimeout = setTimeout(() => {
        this._caretTimeout = void 0;
        const caret3 = this._caret();
        if (caret3.start === caret3.end && this._useMaskBehavior()) {
          const text = this._getInputVal();
          const decimalSeparatorIndex = this._getTextSeparatorIndex(text);
          if (decimalSeparatorIndex >= 0) {
            this._caret({
              start: decimalSeparatorIndex,
              end: decimalSeparatorIndex
            });
          } else {
            this._moveCaretToBoundaryEventHandler(-1, e);
          }
        }
      }, 0);
    }
    super._focusInHandler(e);
  }
  _focusOutHandler(e) {
    const shouldHandleEvent = !this._preventNestedFocusEvent(e);
    if (shouldHandleEvent) {
      this._focusOutOccurs = true;
      if (this._useMaskBehavior()) {
        this._updateFormattedValue();
      }
    }
    super._focusOutHandler(e);
    if (shouldHandleEvent) {
      this._focusOutOccurs = false;
    }
  }
  _hasValueBeenChanged(inputValue) {
    const format2 = this._getFormatPattern();
    const value2 = this.option("value");
    const formatted = this._format(value2, format2) || "";
    return formatted !== inputValue;
  }
  _updateFormattedValue() {
    const inputValue = this._getInputVal();
    if (this._hasValueBeenChanged(inputValue)) {
      this._updateParsedValue();
      this._adjustParsedValue();
      this._setTextByParsedValue();
      const {
        value: value2
      } = this.option();
      if (this._parsedValue !== value2) {
        m_events_engine_default.trigger(this._input(), "change");
      }
    }
  }
  _arrowHandler(step, e) {
    if (!this._useMaskBehavior()) {
      return;
    }
    const text = this._getInputVal();
    const format2 = this._getFormatPattern();
    let nextCaret = getCaretWithOffset(this._caret(), step);
    if (!isCaretInBoundaries(nextCaret, text, format2)) {
      nextCaret = 1 === step ? nextCaret.end : nextCaret.start;
      e.preventDefault();
      this._caret(getCaretInBoundaries(nextCaret, text, format2));
    }
  }
  _moveCaretToBoundary(direction) {
    const boundaries = getCaretBoundaries(this._getInputVal(), this._getFormatPattern());
    const newCaret = getCaretWithOffset(1 === direction ? boundaries.start : boundaries.end, 0);
    this._caret(newCaret);
  }
  _moveCaretToBoundaryEventHandler(direction, e) {
    if (!this._useMaskBehavior() || null !== e && void 0 !== e && e.shiftKey) {
      return;
    }
    this._moveCaretToBoundary(direction);
    null === e || void 0 === e || e.preventDefault();
  }
  _shouldMoveCaret(text, caret3) {
    const decimalSeparator = number_default2.getDecimalSeparator();
    const isDecimalSeparatorNext = text.charAt(caret3.end) === decimalSeparator;
    const moveToFloat = (this._lastKey === decimalSeparator || "." === this._lastKey || "," === this._lastKey) && isDecimalSeparatorNext;
    return moveToFloat;
  }
  _getInputVal() {
    return number_default2.convertDigits(this._input().val(), true);
  }
  _keyboardHandler(e) {
    this.clearCaretTimeout();
    this._lastKey = number_default2.convertDigits(getChar(e), true);
    this._lastKeyName = normalizeKeyName(e);
    if (!this._shouldHandleKey(e.originalEvent)) {
      return super._keyboardHandler(e);
    }
    const normalizedText = this._getInputVal();
    const caret3 = this._caret();
    let enteredChar;
    if ("minus" === this._lastKeyName) {
      enteredChar = "";
    } else {
      enteredChar = 110 === e.which ? number_default2.getDecimalSeparator() : this._lastKey;
    }
    const newValue = this._tryParse(normalizedText, caret3, enteredChar);
    if (this._shouldMoveCaret(normalizedText, caret3)) {
      this._moveCaret(1);
      e.originalEvent.preventDefault();
    }
    if (void 0 === newValue) {
      if ("minus" !== this._lastKeyName) {
        e.originalEvent.preventDefault();
      }
    } else {
      this._parsedValue = newValue;
    }
    return super._keyboardHandler(e);
  }
  _keyPressHandler(e) {
    if (!this._useMaskBehavior()) {
      super._keyPressHandler(e);
    }
  }
  _removeHandler(e) {
    const caret3 = this._caret();
    const text = this._getInputVal();
    let {
      start
    } = caret3;
    let {
      end
    } = caret3;
    this._lastKey = getChar(e);
    this._lastKeyName = normalizeKeyName(e);
    const isDeleteKey = this._isDeleteKey(this._lastKeyName);
    const isBackspaceKey = !isDeleteKey;
    if (start === end) {
      const caretPosition = start;
      const canDelete = isBackspaceKey && caretPosition > 0 || isDeleteKey && caretPosition < text.length;
      if (canDelete) {
        isDeleteKey && end++;
        isBackspaceKey && start--;
      } else {
        e.preventDefault();
        return;
      }
    }
    const char = text.slice(start, end);
    if (this._isStub(char)) {
      this._moveCaret(isDeleteKey ? 1 : -1);
      if (this._parsedValue < 0 || 1 / this._parsedValue === -1 / 0) {
        this._revertSign(e);
        this._setTextByParsedValue();
        const shouldTriggerInputEvent = this.option("valueChangeEvent").split(" ").includes("input");
        if (shouldTriggerInputEvent) {
          m_events_engine_default.trigger(this._input(), "input");
        }
      }
      e.preventDefault();
      return;
    }
    const decimalSeparator = number_default2.getDecimalSeparator();
    if (char === decimalSeparator) {
      const decimalSeparatorIndex = text.indexOf(decimalSeparator);
      if (this._isNonStubAfter(decimalSeparatorIndex + 1)) {
        this._moveCaret(isDeleteKey ? 1 : -1);
        e.preventDefault();
      }
      return;
    }
    if (end - start < text.length) {
      const editedText = this._replaceSelectedText(text, {
        start,
        end
      }, "");
      const noDigits = editedText.search(/[0-9]/) < 0;
      if (noDigits && this._isValueInRange(0)) {
        this._parsedValue = this._parsedValue < 0 || 1 / this._parsedValue === -1 / 0 ? -0 : 0;
        return;
      }
    }
    const valueAfterRemoving = this._tryParse(text, {
      start,
      end
    }, "");
    if (void 0 === valueAfterRemoving) {
      e.preventDefault();
    } else {
      this._parsedValue = valueAfterRemoving;
    }
  }
  _isPercentFormat() {
    const format2 = this._getFormatPattern();
    const noEscapedFormat = format2.replace(/'[^']+'/g, "");
    return -1 !== noEscapedFormat.indexOf("%");
  }
  _parse(text, format2) {
    const formatOption = this.option("format");
    const isCustomParser = isFunction(formatOption.parser);
    const parser = isCustomParser ? formatOption.parser : number_default2.parse;
    let integerPartStartIndex = 0;
    if (!isCustomParser) {
      const formatPointIndex = getRealSeparatorIndex(format2).index;
      const textPointIndex = this._getTextSeparatorIndex(text);
      const formatIntegerPartLength = -1 !== formatPointIndex ? formatPointIndex : format2.length;
      const textIntegerPartLength = -1 !== textPointIndex ? textPointIndex : text.length;
      if (textIntegerPartLength > formatIntegerPartLength && -1 === format2.indexOf("#")) {
        integerPartStartIndex = textIntegerPartLength - formatIntegerPartLength;
      }
    }
    text = text.substr(integerPartStartIndex);
    return parser(text, format2);
  }
  _format(value2, format2) {
    const formatOption = this.option("format");
    const customFormatter = (null === formatOption || void 0 === formatOption ? void 0 : formatOption.formatter) || formatOption;
    const formatter = isFunction(customFormatter) ? customFormatter : number_default2.format;
    const formattedValue = null === value2 ? "" : formatter(value2, format2);
    return formattedValue;
  }
  _getFormatPattern() {
    if (!this._currentFormat) {
      this._updateFormat();
    }
    return this._currentFormat;
  }
  _updateFormat() {
    const {
      format: format2
    } = this.option();
    const isCustomParser = isFunction(null === format2 || void 0 === format2 ? void 0 : format2.parser);
    const isLDMLPattern = isString(format2) && (format2.includes("0") || format2.includes("#"));
    const isExponentialFormat = "exponential" === format2 || "exponential" === (null === format2 || void 0 === format2 ? void 0 : format2.type);
    const shouldUseFormatAsIs = isCustomParser || isLDMLPattern || isExponentialFormat;
    this._currentFormat = shouldUseFormatAsIs ? format2 : getFormat((value2) => {
      const text = this._format(value2, format2);
      return number_default2.convertDigits(text, true);
    });
  }
  _getFormatForSign(text) {
    const format2 = this._getFormatPattern();
    if (isString(format2)) {
      const signParts = format2.split(";");
      const sign3 = number_default2.getSign(text, format2);
      signParts[1] = signParts[1] || `-${signParts[0]}`;
      return sign3 < 0 ? signParts[1] : signParts[0];
    }
    const sign2 = number_default2.getSign(text);
    return sign2 < 0 ? "-" : "";
  }
  _removeStubs(text, excludeComma) {
    const format2 = this._getFormatForSign(text);
    const thousandsSeparator = number_default2.getThousandsSeparator();
    const stubs = this._getStubs(format2);
    let result2 = text;
    if (stubs.length) {
      const prefixStubs = stubs[0];
      const postfixRegex = new RegExp(`(${escapeRegExp(stubs[1] || "")})$`, "g");
      const decoratorsRegex = new RegExp(`[-${escapeRegExp(excludeComma ? "" : thousandsSeparator)}]`, "g");
      result2 = result2.replace(prefixStubs, "").replace(postfixRegex, "").replace(decoratorsRegex, "");
    }
    return result2;
  }
  _getStubs(format2) {
    const regExpResult = /[^']([#0.,]+)/g.exec(format2);
    const pattern = regExpResult && regExpResult[0].trim();
    return format2.split(pattern).map((stub) => stub.replace(/'/g, ""));
  }
  _truncateToPrecision(value2, maxPrecision) {
    if (isDefined(value2)) {
      const strValue = value2.toString();
      const decimalSeparatorIndex = strValue.indexOf(".");
      if (strValue && decimalSeparatorIndex > -1) {
        const parsedValue = parseFloat(strValue.substr(0, decimalSeparatorIndex + maxPrecision + 1));
        return isNaN(parsedValue) ? value2 : parsedValue;
      }
    }
    return value2;
  }
  _tryParse(text, selection2, char) {
    const isTextSelected = selection2.start !== selection2.end;
    const isWholeTextSelected = isTextSelected && 0 === selection2.start && selection2.end === text.length;
    const decimalSeparator = number_default2.getDecimalSeparator();
    if (isWholeTextSelected && char === decimalSeparator) {
      return 0;
    }
    const editedText = this._replaceSelectedText(text, selection2, char);
    const format2 = this._getFormatPattern();
    let parsedValue = this._getParsedValue(editedText, format2);
    const maxPrecision = !format2.parser && this._getPrecisionLimits(editedText).max;
    const isValueChanged = parsedValue !== this._parsedValue;
    const isDecimalPointRestricted = char === decimalSeparator && 0 === maxPrecision;
    const isUselessCharRestricted = !isTextSelected && !isValueChanged && "-" !== char && this._isStub(char);
    if (isDecimalPointRestricted || isUselessCharRestricted) {
      return;
    }
    if ("" === this._removeStubs(editedText)) {
      parsedValue = Math.abs(0 * this._parsedValue);
    }
    if (isNaN(parsedValue)) {
      return;
    }
    const value2 = null === parsedValue ? this._parsedValue : parsedValue;
    parsedValue = maxPrecision ? this._truncateToPrecision(value2, maxPrecision) : parsedValue;
    if (!format2.parser && this._isPercentFormat()) {
      const interval = this._getIntervalFromPrecision(maxPrecision);
      return adjustPercentValue(parsedValue, interval);
    }
    return parsedValue;
  }
  _getIntervalFromPrecision(precision) {
    if (precision < 1) {
      return 1;
    }
    return 10 ** -precision;
  }
  _getParsedValue(text, format2) {
    const sign2 = number_default2.getSign(text, (null === format2 || void 0 === format2 ? void 0 : format2.formatter) || format2);
    const textWithoutStubs = this._removeStubs(text, true);
    const parsedValue = this._parse(textWithoutStubs, format2);
    const parsedValueSign = parsedValue < 0 ? -1 : 1;
    const parsedValueWithSign = isNumeric(parsedValue) && sign2 !== parsedValueSign ? sign2 * parsedValue : parsedValue;
    return parsedValueWithSign;
  }
  _isValueIncomplete(text) {
    if (!this._useMaskBehavior()) {
      return super._isValueIncomplete(text);
    }
    const caret3 = this._caret();
    const point = number_default2.getDecimalSeparator();
    const pointIndex = this._getTextSeparatorIndex(text);
    const isCaretOnFloat = pointIndex >= 0 && pointIndex < caret3.start;
    const textParts = this._removeStubs(text, true).split(point);
    if (!isCaretOnFloat || 2 !== textParts.length) {
      return false;
    }
    const floatLength = textParts[1].length;
    const format2 = this._getFormatPattern();
    const isCustomParser = !!format2.parser;
    const precision = !isCustomParser && this._getPrecisionLimits(this._getFormatPattern());
    const isPrecisionInRange = isCustomParser ? true : inRange(floatLength, precision.min, precision.max);
    const endsWithZero = "0" === textParts[1].charAt(floatLength - 1);
    return isPrecisionInRange && (endsWithZero || !floatLength);
  }
  _isValueInRange(value2) {
    const min = ensureDefined(this.option("min"), -1 / 0);
    const max = ensureDefined(this.option("max"), 1 / 0);
    return inRange(value2, min, max);
  }
  _setInputText(text) {
    const normalizedText = number_default2.convertDigits(text, true);
    const newCaret = getCaretAfterFormat(this._getInputVal(), normalizedText, this._caret(), this._getFormatPattern());
    this._input().val(text);
    this._toggleEmptinessEventHandler();
    this._formattedValue = text;
    if (!this._focusOutOccurs) {
      this._caret(newCaret);
    }
  }
  _useMaskBehavior() {
    const {
      useMaskBehavior
    } = this.option();
    return !!this.option("format") && useMaskBehavior;
  }
  _renderInputType() {
    const {
      mode
    } = this.option();
    const isNumberType = "number" === mode;
    const isDesktop = "desktop" === devices_default.real().deviceType;
    if (this._useMaskBehavior() && isNumberType) {
      this._setInputType(isDesktop || this._isSupportInputMode() ? "text" : "tel");
    } else {
      super._renderInputType();
    }
  }
  _isChar(str) {
    return isString(str) && 1 === str.length;
  }
  _moveCaret(offset2) {
    if (!offset2) {
      return;
    }
    const newCaret = getCaretWithOffset(this._caret(), offset2);
    const adjustedCaret = getCaretInBoundaries(newCaret, this._getInputVal(), this._getFormatPattern());
    this._caret(adjustedCaret);
  }
  _shouldHandleKey(e) {
    const keyName = normalizeKeyName(e);
    const isSpecialChar = isCommandKeyPressed(e) || e.altKey || e.shiftKey || !this._isChar(keyName);
    const isMinusKey = "minus" === keyName;
    const useMaskBehavior = this._useMaskBehavior();
    return useMaskBehavior && !isSpecialChar && !isMinusKey;
  }
  _renderInput() {
    super._renderInput();
    this._renderFormatter();
  }
  _renderFormatter() {
    this._clearCache();
    this._detachFormatterEvents();
    if (this._useMaskBehavior()) {
      this._attachFormatterEvents();
    }
  }
  _detachFormatterEvents() {
    m_events_engine_default.off(this._input(), ".dxNumberFormatter");
  }
  _isInputFromPaste(e) {
    var _e$originalEvent;
    const inputType2 = null === (_e$originalEvent = e.originalEvent) || void 0 === _e$originalEvent ? void 0 : _e$originalEvent.inputType;
    if (isDefined(inputType2)) {
      return "insertFromPaste" === inputType2;
    }
    return this._isValuePasted;
  }
  _attachFormatterEvents() {
    const $input = this._input();
    m_events_engine_default.on($input, addNamespace2("input", "dxNumberFormatter"), (e) => {
      this._formatValue(e);
      this._isValuePasted = false;
    });
    m_events_engine_default.on($input, addNamespace2("dxclick", "dxNumberFormatter"), () => {
      if (!this._caretTimeout) {
        this._caretTimeout = setTimeout(() => {
          this._caretTimeout = void 0;
          this._caret(getCaretInBoundaries(this._caret(), this._getInputVal(), this._getFormatPattern()));
        }, 0);
      }
    });
    m_events_engine_default.on($input, DBLCLICK_EVENT_NAME, () => {
      this.clearCaretTimeout();
    });
  }
  clearCaretTimeout() {
    clearTimeout(this._caretTimeout);
    this._caretTimeout = void 0;
  }
  _forceRefreshInputValue() {
    if (!this._useMaskBehavior()) {
      return super._forceRefreshInputValue();
    }
  }
  _isNonStubAfter(index2) {
    const text = this._getInputVal().slice(index2);
    return text && !this._isStub(text, true);
  }
  _isStub(str, isString4) {
    const escapedDecimalSeparator = escapeRegExp(number_default2.getDecimalSeparator());
    const regExpString = `^[^0-9${escapedDecimalSeparator}]+$`;
    const stubRegExp = new RegExp(regExpString, "g");
    return stubRegExp.test(str) && (isString4 || this._isChar(str));
  }
  _parseValue(text) {
    if (!this._useMaskBehavior()) {
      return super._parseValue(text);
    }
    return this._parsedValue;
  }
  _getPrecisionLimits(text) {
    const currentFormat = this._getFormatForSign(text);
    const realSeparatorIndex = getRealSeparatorIndex(currentFormat).index;
    const floatPart = (splitByIndex(currentFormat, realSeparatorIndex)[1] || "").replace(/[^#0]/g, "");
    const minPrecision = floatPart.replace(/^(0*)#*/, "$1").length;
    const maxPrecision = floatPart.length;
    return {
      min: minPrecision,
      max: maxPrecision
    };
  }
  _revertSign(e) {
    if (!this._useMaskBehavior()) {
      return;
    }
    const caret3 = this._caret();
    if (caret3.start !== caret3.end) {
      if ("minus" === normalizeKeyName(e)) {
        this._applyRevertedSign(e, caret3, true);
        return;
      }
      this._caret(getCaretInBoundaries(0, this._getInputVal(), this._getFormatPattern()));
    }
    this._applyRevertedSign(e, caret3);
  }
  _applyRevertedSign(e, caret3, preserveSelectedText) {
    const newValue = -1 * ensureDefined(this._parsedValue, null);
    if (this._isValueInRange(newValue) || 0 === newValue) {
      this._parsedValue = newValue;
      if (preserveSelectedText) {
        const format2 = this._getFormatPattern();
        const previousText = this._getInputVal();
        this._setTextByParsedValue();
        e.preventDefault();
        const currentText = this._getInputVal();
        const offset2 = getCaretOffset(previousText, currentText, format2);
        caret3 = getCaretWithOffset(caret3, offset2);
        const caretInBoundaries = getCaretInBoundaries(caret3, currentText, format2);
        this._caret(caretInBoundaries);
      }
    }
  }
  _removeMinusFromText(text, caret3) {
    const isMinusPressed = "minus" === this._lastKeyName && "-" === text.charAt(caret3.start - 1);
    return isMinusPressed ? this._replaceSelectedText(text, {
      start: caret3.start - 1,
      end: caret3.start
    }, "") : text;
  }
  _setTextByParsedValue() {
    const format2 = this._getFormatPattern();
    const parsed = this._parseValue();
    const formatted = this._format(parsed, format2) || "";
    this._setInputText(formatted);
  }
  _formatValue(e) {
    let normalizedText = this._getInputVal();
    const caret3 = this._caret();
    const textWithoutMinus = this._removeMinusFromText(normalizedText, caret3);
    const wasMinusRemoved = textWithoutMinus !== normalizedText;
    normalizedText = textWithoutMinus;
    if (!this._isInputFromPaste(e) && this._isValueIncomplete(textWithoutMinus)) {
      this._formattedValue = normalizedText;
      if (wasMinusRemoved) {
        this._setTextByParsedValue();
      }
      return;
    }
    const textWasChanged = number_default2.convertDigits(this._formattedValue, true) !== normalizedText;
    if (textWasChanged) {
      const value2 = this._tryParse(normalizedText, caret3, "");
      if (isDefined(value2)) {
        this._parsedValue = value2;
      }
    }
    this._setTextByParsedValue();
  }
  _renderDisplayText() {
    if (this._useMaskBehavior()) {
      this._toggleEmptinessEventHandler();
    } else {
      super._renderDisplayText.apply(this, arguments);
    }
  }
  _renderValue() {
    if (this._useMaskBehavior()) {
      const {
        value: value2
      } = this.option();
      this._parsedValue = value2;
      this._setTextByParsedValue();
    }
    return super._renderValue();
  }
  _updateParsedValue() {
    const inputValue = this._getInputVal();
    this._parsedValue = this._tryParse(inputValue, this._caret());
  }
  _adjustParsedValue() {
    if (!this._useMaskBehavior()) {
      return;
    }
    const clearedText = this._removeStubs(this._getInputVal());
    const parsedValue = clearedText ? this._parseValue() : null;
    if (!isNumeric(parsedValue)) {
      this._parsedValue = parsedValue;
      return;
    }
    this._parsedValue = fitIntoRange(parsedValue, this.option("min"), this.option("max"));
  }
  _valueChangeEventHandler(e) {
    if (!this._useMaskBehavior()) {
      return super._valueChangeEventHandler(e);
    }
    const caret3 = this._caret();
    this._saveValueChangeEvent(e);
    this._lastKey = null;
    this._lastKeyName = null;
    this._updateParsedValue();
    this._adjustParsedValue();
    this.option("value", this._parsedValue);
    if (caret3) {
      this._caret(caret3);
    }
  }
  _optionChanged(args) {
    switch (args.name) {
      case "format":
      case "useMaskBehavior":
        this._renderInputType();
        this._updateFormat();
        this._renderFormatter();
        this._renderValue();
        this._refreshValueChangeEvent();
        this._refreshEvents();
        break;
      case "min":
      case "max":
        this._adjustParsedValue();
        super._optionChanged(args);
        break;
      default:
        super._optionChanged(args);
    }
  }
  _clearCache() {
    delete this._formattedValue;
    delete this._lastKey;
    delete this._lastKeyName;
    delete this._parsedValue;
    delete this._focusOutOccurs;
    clearTimeout(this._caretTimeout);
    delete this._caretTimeout;
  }
  _clean() {
    this._clearCache();
    super._clean();
  }
};
var m_number_box_mask_default = NumberBoxMask;

// node_modules/devextreme/esm/__internal/ui/number_box/m_number_box.js
component_registrator_default("dxNumberBox", m_number_box_mask_default);
var m_number_box_default = m_number_box_mask_default;

// node_modules/devextreme/esm/ui/number_box.js
var number_box_default = m_number_box_default;

// node_modules/devextreme/esm/__internal/ui/radio_group/m_radio_button.js
var RadioButton = class extends editor_default {
  _supportedKeys() {
    return _extends({}, super._supportedKeys(), {
      space: function(e) {
        e.preventDefault();
        this._clickAction({
          event: e
        });
      }
    });
  }
  _getDefaultOptions() {
    return _extends({}, super._getDefaultOptions(), {
      hoverStateEnabled: true,
      activeStateEnabled: true,
      value: false
    });
  }
  _canValueBeChangedByClick() {
    return true;
  }
  _defaultOptionsRules() {
    return super._defaultOptionsRules().concat([{
      device: () => "desktop" === devices_default.real().deviceType && !devices_default.isSimulator(),
      options: {
        focusStateEnabled: true
      }
    }]);
  }
  _init() {
    super._init();
    this.$element().addClass("dx-radiobutton");
  }
  _initMarkup() {
    super._initMarkup();
    this._renderIcon();
    this._renderCheckedState(this.option("value"));
    this._renderClick();
    this.setAria("role", "radio");
  }
  _renderIcon() {
    this._$icon = renderer_default("<div>").addClass("dx-radiobutton-icon");
    renderer_default("<div>").addClass("dx-radiobutton-icon-dot").appendTo(this._$icon);
    this.$element().append(this._$icon);
  }
  _renderCheckedState(checked) {
    this.$element().toggleClass("dx-radiobutton-checked", checked).find(".dx-radiobutton-icon").toggleClass("dx-radiobutton-icon-checked", checked);
    this.setAria("checked", checked);
  }
  _renderClick() {
    const eventName = addNamespace2(CLICK_EVENT_NAME, this.NAME);
    this._clickAction = this._createAction((args) => {
      this._clickHandler(args.event);
    });
    m_events_engine_default.off(this.$element(), eventName);
    m_events_engine_default.on(this.$element(), eventName, (e) => {
      var _this$_clickAction;
      null === (_this$_clickAction = this._clickAction) || void 0 === _this$_clickAction || _this$_clickAction.call(this, {
        event: e
      });
    });
  }
  _clickHandler(e) {
    this._saveValueChangeEvent(e);
    this.option("value", true);
    this._saveValueChangeEvent(void 0);
  }
  _optionChanged(args) {
    const {
      name: name2,
      value: value2
    } = args;
    if ("value" === name2) {
      this._renderCheckedState(value2);
      super._optionChanged(args);
    } else {
      super._optionChanged(args);
    }
  }
};
component_registrator_default("dxRadioButton", RadioButton);
var m_radio_button_default = RadioButton;

// node_modules/devextreme/esm/ui/radio_group/radio_button.js
var radio_button_default = m_radio_button_default;

// node_modules/devextreme/esm/__internal/ui/list/m_list.edit.decorator.js
var LIST_EDIT_DECORATOR = "dxListEditDecorator";
var SWIPE_START_EVENT_NAME = addNamespace2(SWIPE_START_EVENT, LIST_EDIT_DECORATOR);
var SWIPE_UPDATE_EVENT_NAME = addNamespace2(SWIPE_EVENT, LIST_EDIT_DECORATOR);
var SWIPE_END_EVENT_NAME = addNamespace2(SWIPE_END_EVENT, LIST_EDIT_DECORATOR);
var EditDecorator = class extends class_default.inherit({}) {
  ctor(list) {
    this._list = list;
    this._init();
  }
  _shouldHandleSwipe() {
    return false;
  }
  _init() {
  }
  _attachSwipeEvent(config3) {
    const swipeConfig = {
      itemSizeFunc: function() {
        if (this._clearSwipeCache) {
          this._itemWidthCache = getWidth(this._list.$element());
          this._clearSwipeCache = false;
        }
        return this._itemWidthCache;
      }.bind(this)
    };
    m_events_engine_default.on(config3.$itemElement, SWIPE_START_EVENT_NAME, swipeConfig, this._itemSwipeStartHandler.bind(this));
    m_events_engine_default.on(config3.$itemElement, SWIPE_UPDATE_EVENT_NAME, this._itemSwipeUpdateHandler.bind(this));
    m_events_engine_default.on(config3.$itemElement, SWIPE_END_EVENT_NAME, this._itemSwipeEndHandler.bind(this));
  }
  _itemSwipeStartHandler(e) {
    const $itemElement = renderer_default(e.currentTarget);
    if ($itemElement.is(".dx-state-disabled, .dx-state-disabled *")) {
      e.cancel = true;
      return;
    }
    clearTimeout(this._list._inkRippleTimer);
    this._swipeStartHandler($itemElement, e);
  }
  _itemSwipeUpdateHandler(e) {
    const $itemElement = renderer_default(e.currentTarget);
    this._swipeUpdateHandler($itemElement, e);
  }
  _itemSwipeEndHandler(e) {
    const $itemElement = renderer_default(e.currentTarget);
    this._swipeEndHandler($itemElement, e);
    this._clearSwipeCache = true;
  }
  beforeBag(config3) {
  }
  afterBag() {
  }
  _commonOptions() {
    return {
      activeStateEnabled: this._list.option("activeStateEnabled"),
      hoverStateEnabled: this._list.option("hoverStateEnabled"),
      focusStateEnabled: this._list.option("focusStateEnabled")
    };
  }
  modifyElement(config3) {
    if (this._shouldHandleSwipe()) {
      this._attachSwipeEvent(config3);
      this._clearSwipeCache = true;
    }
  }
  afterRender() {
  }
  handleClick($itemElement, e) {
  }
  handleKeyboardEvents(currentFocusedIndex, moveFocusUp) {
  }
  handleEnterPressing() {
  }
  handleContextMenu($itemElement) {
  }
  _swipeStartHandler($element, event) {
  }
  _swipeUpdateHandler($element, event) {
  }
  _swipeEndHandler($element, event) {
  }
  visibilityChange() {
  }
  getExcludedSelectors() {
  }
  dispose() {
  }
};
var m_list_edit_decorator_default = EditDecorator;

// node_modules/devextreme/esm/__internal/ui/list/m_list.edit.decorator_registry.js
var registry = {};
function register(option, type2, decoratorClass) {
  const decoratorsRegistry = registry;
  const decoratorConfig = {};
  decoratorConfig[option] = decoratorsRegistry[option] ? decoratorsRegistry[option] : {};
  decoratorConfig[option][type2] = decoratorClass;
  extend(decoratorsRegistry, decoratorConfig);
}

// node_modules/devextreme/esm/__internal/ui/list/m_list.edit.decorator.selection.js
var SELECT_DECORATOR_ENABLED_CLASS = "dx-list-select-decorator-enabled";
var SELECT_CHECKBOX_CONTAINER_CLASS = "dx-list-select-checkbox-container";
var SELECT_CHECKBOX_CLASS = "dx-list-select-checkbox";
var SELECT_RADIO_BUTTON_CONTAINER_CLASS = "dx-list-select-radiobutton-container";
var SELECT_RADIO_BUTTON_CLASS = "dx-list-select-radiobutton";
var CLICK_EVENT_NAME2 = addNamespace2(CLICK_EVENT_NAME, "dxListEditDecorator");
var EditDecoratorSelection = class extends m_list_edit_decorator_default {
  _init() {
    super._init.apply(this, arguments);
    const selectionMode = this._list.option("selectionMode");
    this._singleStrategy = "single" === selectionMode;
    this._containerClass = this._singleStrategy ? SELECT_RADIO_BUTTON_CONTAINER_CLASS : SELECT_CHECKBOX_CONTAINER_CLASS;
    this._controlClass = this._singleStrategy ? SELECT_RADIO_BUTTON_CLASS : SELECT_CHECKBOX_CLASS;
    this._controlWidget = this._singleStrategy ? radio_button_default : check_box_default2;
    this._list.$element().addClass(SELECT_DECORATOR_ENABLED_CLASS);
  }
  beforeBag(config3) {
    const {
      $itemElement
    } = config3;
    const $container = config3.$container.addClass(this._containerClass);
    const $control = renderer_default("<div>").addClass(this._controlClass).appendTo($container);
    new this._controlWidget($control, extend(this._commonOptions(), {
      value: this._isSelected($itemElement),
      elementAttr: {
        "aria-label": message_default.format("CheckState")
      },
      focusStateEnabled: false,
      hoverStateEnabled: false,
      onValueChanged: (_ref) => {
        let {
          value: value2,
          component,
          event
        } = _ref;
        const isUiClick = !!event;
        if (isUiClick) {
          component._valueChangeEventInstance = void 0;
          component.option("value", !value2);
        }
      }
    }));
  }
  modifyElement(config3) {
    super.modifyElement.apply(this, arguments);
    const {
      $itemElement
    } = config3;
    const control = this._controlWidget.getInstance($itemElement.find(`.${this._controlClass}`));
    m_events_engine_default.on($itemElement, "stateChanged", (e, state) => {
      control.option("value", state);
    });
  }
  _updateSelectAllState() {
    if (!this._$selectAll) {
      return;
    }
    this._selectAllCheckBox.option("value", this._list.isSelectAll());
  }
  afterRender() {
    if ("all" !== this._list.option("selectionMode")) {
      return;
    }
    if (!this._$selectAll) {
      this._renderSelectAll();
    } else {
      this._updateSelectAllState();
    }
  }
  handleKeyboardEvents(currentFocusedIndex, moveFocusUp) {
    const moveFocusDown = !moveFocusUp;
    const list = this._list;
    const $selectAll = this._$selectAll;
    const lastItemIndex = list._getLastItemIndex();
    const isFocusOutOfList = moveFocusUp && 0 === currentFocusedIndex || moveFocusDown && currentFocusedIndex === lastItemIndex;
    const hasSelectAllItem = !!$selectAll;
    if (hasSelectAllItem && isFocusOutOfList) {
      list.option("focusedElement", $selectAll);
      list.scrollToItem(list.option("focusedElement"));
      return true;
    }
    return false;
  }
  handleEnterPressing(e) {
    var _this$_$selectAll;
    if (null !== (_this$_$selectAll = this._$selectAll) && void 0 !== _this$_$selectAll && _this$_$selectAll.hasClass("dx-state-focused")) {
      e.target = this._$selectAll.get(0);
      this._selectAllHandler(e);
      return true;
    }
  }
  _renderSelectAll() {
    this._$selectAll = renderer_default("<div>").addClass("dx-list-select-all");
    const downArrowHandler = this._list._supportedKeys().downArrow.bind(this._list);
    const selectAllCheckBoxElement = renderer_default("<div>").addClass("dx-list-select-all-checkbox").appendTo(this._$selectAll);
    this._selectAllCheckBox = this._list._createComponent(selectAllCheckBoxElement, check_box_default2, {
      elementAttr: {
        "aria-label": message_default.format("dxList-selectAll")
      },
      focusStateEnabled: false,
      hoverStateEnabled: false
    });
    this._selectAllCheckBox.registerKeyHandler("downArrow", downArrowHandler);
    renderer_default("<div>").addClass("dx-list-select-all-label").text(this._list.option("selectAllText")).appendTo(this._$selectAll);
    this._list.itemsContainer().prepend(this._$selectAll);
    this._updateSelectAllState();
    this._updateSelectAllAriaLabel();
    this._attachSelectAllHandler();
  }
  _attachSelectAllHandler() {
    this._selectAllCheckBox.option("onValueChanged", (_ref2) => {
      let {
        value: value2,
        event,
        component
      } = _ref2;
      const isUiClick = !!event;
      if (isUiClick) {
        component._setOptionWithoutOptionChange("value", !value2);
        return;
      }
      this._updateSelectAllAriaLabel();
      this._list._createActionByOption("onSelectAllValueChanged")({
        value: value2
      });
    });
    m_events_engine_default.off(this._$selectAll, CLICK_EVENT_NAME2);
    m_events_engine_default.on(this._$selectAll, CLICK_EVENT_NAME2, this._selectAllHandler.bind(this));
  }
  _updateSelectAllAriaLabel() {
    if (!this._$selectAll) {
      return;
    }
    const {
      value: value2
    } = this._selectAllCheckBox.option();
    const indeterminate = void 0 === value2;
    const stateVariableName = indeterminate ? "indeterminate" : value2 ? "checked" : "notChecked";
    const label = `${message_default.format("dxList-selectAll")}, ${message_default.format(`dxList-selectAll-${stateVariableName}`)}`;
    this._$selectAll.attr({
      "aria-label": label
    });
  }
  _selectAllHandler(event) {
    var _this$_$selectAll2;
    event.stopPropagation();
    this._list._saveSelectionChangeEvent(event);
    const {
      value: value2
    } = this._selectAllCheckBox.option();
    let selectionDeferred;
    if (true !== value2) {
      selectionDeferred = this._selectAllItems();
    } else {
      selectionDeferred = this._unselectAllItems();
    }
    this._list.option("focusedElement", null === (_this$_$selectAll2 = this._$selectAll) || void 0 === _this$_$selectAll2 ? void 0 : _this$_$selectAll2.get(0));
    return selectionDeferred;
  }
  _checkSelectAllCapability() {
    const list = this._list;
    const dataController2 = list._dataController;
    if ("allPages" === list.option("selectAllMode") && list.option("grouped") && !dataController2.group()) {
      ui_errors_default.log("W1010");
      return false;
    }
    return true;
  }
  _selectAllItems() {
    if (!this._checkSelectAllCapability()) {
      return Deferred().resolve();
    }
    return this._list._selection.selectAll("page" === this._list.option("selectAllMode"));
  }
  _unselectAllItems() {
    if (!this._checkSelectAllCapability()) {
      return Deferred().resolve();
    }
    return this._list._selection.deselectAll("page" === this._list.option("selectAllMode"));
  }
  _isSelected($itemElement) {
    return this._list.isItemSelected($itemElement);
  }
  dispose() {
    this._disposeSelectAll();
    this._list.$element().removeClass(SELECT_DECORATOR_ENABLED_CLASS);
    super.dispose.apply(this, arguments);
  }
  _disposeSelectAll() {
    if (this._$selectAll) {
      this._$selectAll.remove();
      this._$selectAll = null;
    }
  }
};
register("selection", "default", EditDecoratorSelection);

// node_modules/devextreme/esm/__internal/ui/editor/m_data_expression.js
var DataExpressionMixin = extend({}, data_helper_default, {
  _dataExpressionDefaultOptions: () => ({
    items: [],
    dataSource: null,
    itemTemplate: "item",
    value: null,
    valueExpr: "this",
    displayExpr: void 0
  }),
  _initDataExpressions() {
    this._compileValueGetter();
    this._compileDisplayGetter();
    this._initDynamicTemplates();
    this._initDataSource();
    this._itemsToDataSource();
  },
  _itemsToDataSource() {
    if (!this.option("dataSource")) {
      this._dataSource = new data_source_default({
        store: new m_array_store_default(this.option("items")),
        pageSize: 0
      });
      this._initDataController();
    }
  },
  _compileDisplayGetter() {
    this._displayGetter = compileGetter(this._displayGetterExpr());
  },
  _displayGetterExpr() {
    return this.option("displayExpr");
  },
  _compileValueGetter() {
    this._valueGetter = compileGetter(this._valueGetterExpr());
  },
  _valueGetterExpr() {
    return this.option("valueExpr") || "this";
  },
  _loadValue(value2) {
    const deferred = Deferred();
    value2 = this._unwrappedValue(value2);
    if (!isDefined(value2)) {
      return deferred.reject().promise();
    }
    this._loadSingle(this._valueGetterExpr(), value2).done((item) => {
      this._isValueEquals(this._valueGetter(item), value2) ? deferred.resolve(item) : deferred.reject();
    }).fail(() => {
      deferred.reject();
    });
    this._loadValueDeferred = deferred;
    return deferred.promise();
  },
  _rejectValueLoading() {
    var _this$_loadValueDefer;
    null === (_this$_loadValueDefer = this._loadValueDeferred) || void 0 === _this$_loadValueDefer || _this$_loadValueDefer.reject({
      shouldSkipCallback: true
    });
  },
  _getCurrentValue() {
    return this.option("value");
  },
  _unwrappedValue(value2) {
    value2 = value2 ?? this._getCurrentValue();
    if (value2 && this._dataSource && "this" === this._valueGetterExpr()) {
      value2 = this._getItemKey(value2);
    }
    return variable_wrapper_default.unwrap(value2);
  },
  _getItemKey(value2) {
    const key = this._dataSource.key();
    if (Array.isArray(key)) {
      const result2 = {};
      for (let i = 0, n = key.length; i < n; i++) {
        result2[key[i]] = value2[key[i]];
      }
      return result2;
    }
    if (key && "object" === typeof value2) {
      value2 = value2[key];
    }
    return value2;
  },
  _isValueEquals(value1, value2) {
    const dataSourceKey = this._dataSource && this._dataSource.key();
    let result2 = this._compareValues(value1, value2);
    if (!result2 && dataSourceKey && isDefined(value1) && isDefined(value2)) {
      if (Array.isArray(dataSourceKey)) {
        result2 = this._compareByCompositeKey(value1, value2, dataSourceKey);
      } else {
        result2 = this._compareByKey(value1, value2, dataSourceKey);
      }
    }
    return result2;
  },
  _compareByCompositeKey(value1, value2, key) {
    const isObject2 = isObject;
    if (!isObject2(value1) || !isObject2(value2)) {
      return false;
    }
    for (let i = 0, n = key.length; i < n; i++) {
      if (value1[key[i]] !== value2[key[i]]) {
        return false;
      }
    }
    return true;
  },
  _compareByKey(value1, value2, key) {
    const unwrapObservable = variable_wrapper_default.unwrap;
    const valueKey1 = ensureDefined(unwrapObservable(value1[key]), value1);
    const valueKey2 = ensureDefined(unwrapObservable(value2[key]), value2);
    return this._compareValues(valueKey1, valueKey2);
  },
  _compareValues: (value1, value2) => toComparable(value1, true) === toComparable(value2, true),
  _initDynamicTemplates: noop2,
  _setCollectionWidgetItemTemplate() {
    this._initDynamicTemplates();
    this._setCollectionWidgetOption("itemTemplate", this.option("itemTemplate"));
  },
  _getCollectionKeyExpr() {
    const valueExpr = this.option("valueExpr");
    const isValueExprField = isString(valueExpr) && "this" !== valueExpr || isFunction(valueExpr);
    return isValueExprField ? valueExpr : null;
  },
  _dataExpressionOptionChanged(args) {
    switch (args.name) {
      case "items":
        this._itemsToDataSource();
        this._setCollectionWidgetOption("items");
        break;
      case "dataSource":
        this._initDataSource();
        break;
      case "itemTemplate":
        this._setCollectionWidgetItemTemplate();
        break;
      case "valueExpr":
        this._compileValueGetter();
        break;
      case "displayExpr":
        this._compileDisplayGetter();
        this._initDynamicTemplates();
        this._setCollectionWidgetOption("displayExpr");
    }
  }
});
var m_data_expression_default = DataExpressionMixin;

// node_modules/devextreme/esm/ui/editor/ui.data_expression.js
var ui_data_expression_default = m_data_expression_default;

// node_modules/devextreme/esm/__internal/ui/list/m_list.edit.provider.js
var editOptionsRegistry = [];
var registerOption = function(enabledFunc, decoratorTypeFunc, decoratorSubTypeFunc) {
  editOptionsRegistry.push({
    enabled: enabledFunc,
    decoratorType: decoratorTypeFunc,
    decoratorSubType: decoratorSubTypeFunc
  });
};
registerOption(function() {
  return this.option("menuItems").length;
}, () => "menu", function() {
  return this.option("menuMode");
});
registerOption(function() {
  return !this.option("menuItems").length && this.option("allowItemDeleting");
}, function() {
  const mode = this.option("itemDeleteMode");
  return "toggle" === mode || "slideButton" === mode || "swipe" === mode || "static" === mode ? "delete" : "menu";
}, function() {
  let mode = this.option("itemDeleteMode");
  if ("slideItem" === mode) {
    mode = "slide";
  }
  return mode;
});
registerOption(function() {
  return "none" !== this.option("selectionMode") && this.option("showSelectionControls");
}, () => "selection", () => "default");
registerOption(function() {
  return this.option("itemDragging.allowReordering") || this.option("itemDragging.allowDropInsideItem") || this.option("itemDragging.group");
}, () => "reorder", () => "default");
var EditProvider = class extends class_default.inherit({}) {
  ctor(list) {
    this._list = list;
    this._fetchRequiredDecorators();
  }
  dispose() {
    var _this$_decorators;
    if (null !== (_this$_decorators = this._decorators) && void 0 !== _this$_decorators && _this$_decorators.length) {
      each(this._decorators, (_, decorator) => {
        decorator.dispose();
      });
    }
  }
  _fetchRequiredDecorators() {
    this._decorators = [];
    each(editOptionsRegistry, (_, option) => {
      const optionEnabled = option.enabled.call(this._list);
      if (optionEnabled) {
        const decoratorType = option.decoratorType.call(this._list);
        const decoratorSubType = option.decoratorSubType.call(this._list);
        const decorator = this._createDecorator(decoratorType, decoratorSubType);
        this._decorators.push(decorator);
      }
    });
  }
  _createDecorator(type2, subType) {
    const decoratorClass = this._findDecorator(type2, subType);
    return new decoratorClass(this._list);
  }
  _findDecorator(type2, subType) {
    var _registry$type;
    const foundDecorator = null === (_registry$type = registry[type2]) || void 0 === _registry$type ? void 0 : _registry$type[subType];
    if (!foundDecorator) {
      throw ui_errors_default.Error("E1012", type2, subType);
    }
    return foundDecorator;
  }
  modifyItemElement(args) {
    const $itemElement = renderer_default(args.itemElement);
    const config3 = {
      $itemElement
    };
    this._prependBeforeBags($itemElement, config3);
    this._appendAfterBags($itemElement, config3);
    this._applyDecorators("modifyElement", config3);
  }
  afterItemsRendered() {
    this._applyDecorators("afterRender");
  }
  _prependBeforeBags($itemElement, config3) {
    const $beforeBags = this._collectDecoratorsMarkup("beforeBag", config3, "dx-list-item-before-bag");
    $itemElement.prepend($beforeBags);
  }
  _appendAfterBags($itemElement, config3) {
    const $afterBags = this._collectDecoratorsMarkup("afterBag", config3, "dx-list-item-after-bag");
    $itemElement.append($afterBags);
  }
  _collectDecoratorsMarkup(method, config3, containerClass) {
    const $collector = renderer_default("<div>");
    each(this._decorators, function() {
      const $container = renderer_default("<div>").addClass(containerClass);
      this[method](extend({
        $container
      }, config3));
      if ($container.children().length) {
        $collector.append($container);
      }
    });
    return $collector.children();
  }
  _applyDecorators(method, config3) {
    each(this._decorators, function() {
      this[method](config3);
    });
  }
  _handlerExists(name2) {
    if (!this._decorators) {
      return false;
    }
    const decorators = this._decorators;
    const {
      length
    } = decorators;
    for (let i = 0; i < length; i++) {
      if (decorators[i][name2] !== noop2) {
        return true;
      }
    }
    return false;
  }
  _eventHandler(name2, $itemElement, e) {
    if (!this._decorators) {
      return false;
    }
    let response = false;
    const decorators = this._decorators;
    const {
      length
    } = decorators;
    for (let i = 0; i < length; i++) {
      response = decorators[i][name2]($itemElement, e);
      if (response) {
        break;
      }
    }
    return response;
  }
  handleClick($itemElement, e) {
    return this._eventHandler("handleClick", $itemElement, e);
  }
  handleKeyboardEvents(currentFocusedIndex, moveFocusUp) {
    return this._eventHandler("handleKeyboardEvents", currentFocusedIndex, moveFocusUp);
  }
  handleEnterPressing(e) {
    return this._eventHandler("handleEnterPressing", e);
  }
  contextMenuHandlerExists() {
    return this._handlerExists("handleContextMenu");
  }
  handleContextMenu($itemElement, e) {
    return this._eventHandler("handleContextMenu", $itemElement, e);
  }
  getExcludedItemSelectors() {
    const excludedSelectors = [];
    this._applyDecorators("getExcludedSelectors", excludedSelectors);
    return excludedSelectors.join(",");
  }
};
var m_list_edit_provider_default = EditProvider;

// node_modules/devextreme/esm/__internal/ui/list/m_list.edit.strategy.grouped.js
var combineIndex = (indices) => (indices.group << 20) + indices.item;
var splitIndex = (combinedIndex) => ({
  group: combinedIndex >> 20,
  item: 1048575 & combinedIndex
});
var GroupedEditStrategy = class extends m_collection_widget_edit_strategy_plain_default {
  _groupElements() {
    return this._collectionWidget._itemContainer().find(".dx-list-group");
  }
  _groupItemElements($group) {
    return $group.find(".dx-list-item");
  }
  getIndexByItemData(itemData) {
    var _itemData$items;
    const groups = this._collectionWidget.option("items");
    let index2 = false;
    if (!itemData) {
      return false;
    }
    if (null !== (_itemData$items = itemData.items) && void 0 !== _itemData$items && _itemData$items.length) {
      itemData = itemData.items[0];
    }
    each(groups, (groupIndex, group) => {
      if (!group.items) {
        return false;
      }
      each(group.items, (itemIndex, item) => {
        if (item !== itemData) {
          return true;
        }
        index2 = {
          group: groupIndex,
          item: itemIndex
        };
        return false;
      });
      if (index2) {
        return false;
      }
    });
    return index2;
  }
  getItemDataByIndex(index2) {
    var _items$index$group;
    const items = this._collectionWidget.option("items");
    if (isNumeric(index2)) {
      return this.itemsGetter()[index2];
    }
    return index2 && (null === (_items$index$group = items[index2.group]) || void 0 === _items$index$group ? void 0 : _items$index$group.items[index2.item]) || null;
  }
  itemsGetter() {
    let resultItems = [];
    const {
      items
    } = this._collectionWidget.option();
    for (let i = 0; i < items.length; i++) {
      var _items$i;
      if (null !== (_items$i = items[i]) && void 0 !== _items$i && _items$i.items) {
        resultItems = resultItems.concat(items[i].items);
      } else {
        resultItems.push(items[i]);
      }
    }
    return resultItems;
  }
  deleteItemAtIndex(index2) {
    const indices = splitIndex(index2);
    const itemGroup = this._collectionWidget.option("items")[indices.group].items;
    itemGroup.splice(indices.item, 1);
  }
  getKeysByItems(items) {
    let plainItems = [];
    let i;
    for (i = 0; i < items.length; i++) {
      var _items$i2;
      if (null !== (_items$i2 = items[i]) && void 0 !== _items$i2 && _items$i2.items) {
        plainItems = plainItems.concat(items[i].items);
      } else {
        plainItems.push(items[i]);
      }
    }
    const result2 = [];
    for (i = 0; i < plainItems.length; i++) {
      result2.push(this._collectionWidget.keyOf(plainItems[i]));
    }
    return result2;
  }
  getIndexByKey(key, items) {
    const groups = items || this._collectionWidget.option("items");
    let index2 = -1;
    const that = this;
    each(groups, (groupIndex, group) => {
      if (!group.items) {
        return;
      }
      each(group.items, (itemIndex, item) => {
        const itemKey = that._collectionWidget.keyOf(item);
        if (that._equalKeys(itemKey, key)) {
          index2 = {
            group: groupIndex,
            item: itemIndex
          };
          return false;
        }
      });
      if (-1 !== index2) {
        return false;
      }
    });
    return index2;
  }
  _getGroups(items) {
    const dataController2 = this._collectionWidget._dataController;
    const group = dataController2.group();
    if (group) {
      return m_store_helper_default.queryByOptions(m_query_default(items), {
        group
      }).toArray();
    }
    return this._collectionWidget.option("items");
  }
  getItemsByKeys(keys, items) {
    const result2 = [];
    const groups = this._getGroups(items);
    const groupItemByKeyMap = {};
    const getItemMeta = (key) => {
      const index2 = this.getIndexByKey(key, groups);
      const group = index2 && groups[index2.group];
      if (!group) {
        return;
      }
      return {
        groupKey: group.key,
        item: group.items[index2.item]
      };
    };
    each(keys, (_, key) => {
      const itemMeta = getItemMeta(key);
      if (!itemMeta) {
        return;
      }
      const {
        groupKey
      } = itemMeta;
      const {
        item
      } = itemMeta;
      let selectedGroup = groupItemByKeyMap[groupKey];
      if (!selectedGroup) {
        selectedGroup = {
          key: groupKey,
          items: []
        };
        groupItemByKeyMap[groupKey] = selectedGroup;
        result2.push(selectedGroup);
      }
      selectedGroup.items.push(item);
    });
    return result2;
  }
  moveItemAtIndexToIndex(movingIndex, destinationIndex) {
    const items = this._collectionWidget.option("items");
    const movingIndices = splitIndex(movingIndex);
    const destinationIndices = splitIndex(destinationIndex);
    const movingItemGroup = items[movingIndices.group].items;
    const destinationItemGroup = items[destinationIndices.group].items;
    const movedItemData = movingItemGroup[movingIndices.item];
    movingItemGroup.splice(movingIndices.item, 1);
    destinationItemGroup.splice(destinationIndices.item, 0, movedItemData);
  }
  _isItemIndex(index2) {
    return index2 && isNumeric(index2.group) && isNumeric(index2.item);
  }
  _getNormalizedItemIndex(itemElement) {
    const $item = renderer_default(itemElement);
    const $group = $item.closest(".dx-list-group");
    if (!$group.length) {
      return -1;
    }
    return combineIndex({
      group: this._groupElements().index($group),
      item: this._groupItemElements($group).index($item)
    });
  }
  _normalizeItemIndex(index2) {
    return combineIndex(index2);
  }
  _denormalizeItemIndex(index2) {
    return splitIndex(index2);
  }
  _getItemByNormalizedIndex(index2) {
    const indices = splitIndex(index2);
    const $group = this._groupElements().eq(indices.group);
    return this._groupItemElements($group).eq(indices.item);
  }
  _itemsFromSameParent(firstIndex, secondIndex) {
    return splitIndex(firstIndex).group === splitIndex(secondIndex).group;
  }
};
var m_list_edit_strategy_grouped_default = GroupedEditStrategy;

// node_modules/devextreme/esm/__internal/ui/list/m_list.edit.js
var ListEdit = class extends ListBase {
  _supportedKeys() {
    const that = this;
    const parent = super._supportedKeys();
    const moveFocusedItem = (e, moveUp) => {
      const editStrategy = this._editStrategy;
      const {
        focusedElement
      } = this.option();
      const focusedItemIndex = editStrategy.getNormalizedIndex(focusedElement);
      const isLastIndexFocused = focusedItemIndex === this._getLastItemIndex();
      if (isLastIndexFocused && this._dataController.isLoading()) {
        return;
      }
      if (e.shiftKey && that.option("itemDragging.allowReordering")) {
        const nextItemIndex = focusedItemIndex + (moveUp ? -1 : 1);
        const $nextItem = editStrategy.getItemElement(nextItemIndex);
        const isMoveFromGroup = this.option("grouped") && renderer_default(focusedElement).parent().get(0) !== $nextItem.parent().get(0);
        if (!isMoveFromGroup) {
          this.reorderItem(focusedElement, $nextItem);
          this.scrollToItem(focusedElement);
        }
        e.preventDefault();
      } else {
        const editProvider = this._editProvider;
        const isInternalMoving = editProvider.handleKeyboardEvents(focusedItemIndex, moveUp);
        if (!isInternalMoving) {
          moveUp ? parent.upArrow(e) : parent.downArrow(e);
        }
      }
    };
    return _extends({}, parent, {
      del: (e) => {
        if (that.option("allowItemDeleting")) {
          e.preventDefault();
          that.deleteItem(that.option("focusedElement"));
        }
      },
      upArrow: (e) => moveFocusedItem(e, true),
      downArrow: (e) => moveFocusedItem(e),
      enter: function(e) {
        if (!this._editProvider.handleEnterPressing(e)) {
          parent.enter.apply(this, arguments);
        }
      },
      space: function(e) {
        if (!this._editProvider.handleEnterPressing(e)) {
          parent.space.apply(this, arguments);
        }
      }
    });
  }
  _updateSelection() {
    this._editProvider.afterItemsRendered();
    super._updateSelection();
  }
  _getLastItemIndex() {
    return this._itemElements().length - 1;
  }
  _refreshItemElements() {
    super._refreshItemElements();
    const excludedSelectors = this._editProvider.getExcludedItemSelectors();
    if (excludedSelectors.length) {
      this._itemElementsCache = this._itemElementsCache.not(excludedSelectors);
    }
  }
  _isItemStrictEquals(item1, item2) {
    const privateKey = null === item1 || void 0 === item1 ? void 0 : item1.__dx_key__;
    if (privateKey && !this.key() && this._selection.isItemSelected(privateKey)) {
      return false;
    }
    return super._isItemStrictEquals(item1, item2);
  }
  _getDefaultOptions() {
    return extend(super._getDefaultOptions(), {
      showSelectionControls: false,
      selectionMode: "none",
      selectAllMode: "page",
      onSelectAllValueChanged: null,
      selectAllText: message_default.format("dxList-selectAll"),
      menuItems: [],
      menuMode: "context",
      allowItemDeleting: false,
      itemDeleteMode: "static",
      itemDragging: {}
    });
  }
  _defaultOptionsRules() {
    return super._defaultOptionsRules().concat([{
      device: (device) => "ios" === device.platform,
      options: {
        menuMode: "slide",
        itemDeleteMode: "slideItem"
      }
    }, {
      device: {
        platform: "android"
      },
      options: {
        itemDeleteMode: "swipe"
      }
    }]);
  }
  _init() {
    super._init();
    this._initEditProvider();
  }
  _initDataSource() {
    super._initDataSource();
    if (!this._isPageSelectAll()) {
      var _this$_dataSource;
      null === (_this$_dataSource = this._dataSource) || void 0 === _this$_dataSource || _this$_dataSource.requireTotalCount(true);
    }
  }
  _isPageSelectAll() {
    const {
      selectAllMode
    } = this.option();
    return "page" === selectAllMode;
  }
  _initEditProvider() {
    this._editProvider = new m_list_edit_provider_default(this);
  }
  _disposeEditProvider() {
    if (this._editProvider) {
      this._editProvider.dispose();
    }
  }
  _refreshEditProvider() {
    this._disposeEditProvider();
    this._initEditProvider();
  }
  _initEditStrategy() {
    if (this.option("grouped")) {
      this._editStrategy = new m_list_edit_strategy_grouped_default(this);
    } else {
      super._initEditStrategy();
    }
  }
  _initMarkup() {
    this._refreshEditProvider();
    super._initMarkup();
  }
  _renderItems() {
    super._renderItems(...arguments);
    this._editProvider.afterItemsRendered();
  }
  _renderItem(index2, itemData, $container, $itemToReplace) {
    const {
      showSelectionControls,
      selectionMode
    } = this.option();
    const $itemFrame = super._renderItem(index2, itemData, $container, $itemToReplace);
    if (showSelectionControls && "none" !== selectionMode) {
      this._updateItemAriaLabel($itemFrame, itemData);
    }
    return $itemFrame;
  }
  _updateItemAriaLabel($itemFrame, itemData) {
    var _this$_displayGetter;
    const label = (null === (_this$_displayGetter = this._displayGetter) || void 0 === _this$_displayGetter ? void 0 : _this$_displayGetter.call(this, itemData)) ?? (null === itemData || void 0 === itemData ? void 0 : itemData.text) ?? itemData;
    this.setAria("label", isObject(label) ? message_default.format("dxList-listAriaLabel-itemContent") : label, $itemFrame);
  }
  _selectedItemClass() {
    return "dx-list-item-selected";
  }
  _itemResponseWaitClass() {
    return "dx-list-item-response-wait";
  }
  _itemClickHandler(e) {
    const $itemElement = renderer_default(e.currentTarget);
    if ($itemElement.is(".dx-state-disabled, .dx-state-disabled *")) {
      return;
    }
    const handledByEditProvider = this._editProvider.handleClick($itemElement, e);
    if (handledByEditProvider) {
      return;
    }
    this._saveSelectionChangeEvent(e);
    super._itemClickHandler(...arguments);
  }
  _shouldFireContextMenuEvent() {
    return super._shouldFireContextMenuEvent(...arguments) || this._editProvider.contextMenuHandlerExists();
  }
  _itemHoldHandler(e) {
    const $itemElement = renderer_default(e.currentTarget);
    if ($itemElement.is(".dx-state-disabled, .dx-state-disabled *")) {
      return;
    }
    const handledByEditProvider = isTouchEvent(e) && this._editProvider.handleContextMenu($itemElement, e);
    if (handledByEditProvider) {
      e.handledByEditProvider = true;
      return;
    }
    super._itemHoldHandler(...arguments);
  }
  _itemContextMenuHandler(e) {
    const $itemElement = renderer_default(e.currentTarget);
    if ($itemElement.is(".dx-state-disabled, .dx-state-disabled *")) {
      return;
    }
    const handledByEditProvider = !e.handledByEditProvider && this._editProvider.handleContextMenu($itemElement, e);
    if (handledByEditProvider) {
      e.preventDefault();
      return;
    }
    super._itemContextMenuHandler(...arguments);
  }
  _postprocessRenderItem(args) {
    super._postprocessRenderItem(...arguments);
    this._editProvider.modifyItemElement(args);
  }
  _clean() {
    this._disposeEditProvider();
    super._clean();
  }
  focusListItem(index2) {
    const $item = this._editStrategy.getItemElement(index2);
    this.option("focusedElement", $item);
    this.focus();
    this.scrollToItem(this.option("focusedElement"));
  }
  _getFlatIndex() {
    const {
      selectedIndex = NOT_EXISTING_INDEX
    } = this.option();
    if (isNumeric(selectedIndex) || !selectedIndex) {
      return selectedIndex;
    }
    const $item = this._editStrategy.getItemElement(selectedIndex);
    const index2 = this.getFlatIndexByItemElement($item);
    return index2;
  }
  _optionChanged(args) {
    switch (args.name) {
      case "selectAllMode":
        this._initDataSource();
        this._dataController.pageIndex(0);
        this._dataController.load();
        break;
      case "grouped":
        this._clearSelectedItems();
        this._initEditStrategy();
        super._optionChanged(args);
        break;
      case "showSelectionControls":
      case "menuItems":
      case "menuMode":
      case "allowItemDeleting":
      case "itemDeleteMode":
      case "itemDragging":
      case "selectAllText":
        this._invalidate();
        break;
      case "onSelectAllValueChanged":
        break;
      default:
        super._optionChanged(args);
    }
  }
  selectAll() {
    return this._selection.selectAll(this._isPageSelectAll());
  }
  unselectAll() {
    return this._selection.deselectAll(this._isPageSelectAll());
  }
  isSelectAll() {
    return this._selection.getSelectAllState(this._isPageSelectAll());
  }
  getFlatIndexByItemElement(itemElement) {
    return this._itemElements().index(itemElement);
  }
  getItemElementByFlatIndex(flatIndex) {
    const $itemElements = this._itemElements();
    if (flatIndex < 0 || flatIndex >= $itemElements.length) {
      return renderer_default();
    }
    return $itemElements.eq(flatIndex);
  }
  getItemByIndex(index2) {
    return this._editStrategy.getItemDataByIndex(index2);
  }
  deleteItem(itemElement) {
    const editStrategy = this._editStrategy;
    const deletingElementIndex = editStrategy.getNormalizedIndex(itemElement);
    const {
      focusedElement,
      focusStateEnabled
    } = this.option();
    const focusedItemIndex = focusedElement ? editStrategy.getNormalizedIndex(focusedElement) : deletingElementIndex;
    const isLastIndexFocused = focusedItemIndex === this._getLastItemIndex();
    const nextFocusedItem = isLastIndexFocused || deletingElementIndex < focusedItemIndex ? focusedItemIndex - 1 : focusedItemIndex;
    const promise = super.deleteItem(itemElement);
    return promise.done(function() {
      if (focusStateEnabled) {
        this.focusListItem(nextFocusedItem);
      }
    });
  }
};
var m_list_edit_default = ListEdit;

// node_modules/devextreme/esm/__internal/ui/list/m_list.edit.search.js
var ListSearch = m_list_edit_default.inherit(ui_search_box_mixin_default).inherit({
  _addWidgetPrefix: (className) => `dx-list-${className}`,
  _getCombinedFilter() {
    const dataController2 = this._dataController;
    const storeLoadOptions = {
      filter: dataController2.filter()
    };
    dataController2.addSearchFilter(storeLoadOptions);
    const {
      filter
    } = storeLoadOptions;
    return filter;
  },
  _initDataSource() {
    const value2 = this.option("searchValue");
    const expr = this.option("searchExpr");
    const mode = this.option("searchMode");
    this.callBase();
    const dataController2 = this._dataController;
    (null === value2 || void 0 === value2 ? void 0 : value2.length) && dataController2.searchValue(value2);
    mode.length && dataController2.searchOperation(ui_search_box_mixin_default.getOperationBySearchMode(mode));
    expr && dataController2.searchExpr(expr);
  }
});
var m_list_edit_search_default = ListSearch;

// node_modules/devextreme/esm/ui/list_light.js
component_registrator_default("dxList", m_list_edit_search_default);
var list_light_default = m_list_edit_search_default;

// node_modules/devextreme/esm/__internal/ui/drop_down_editor/m_drop_down_button.js
var DROP_DOWN_EDITOR_BUTTON_VISIBLE = "dx-dropdowneditor-button-visible";
var BUTTON_MESSAGE = "dxDropDownEditor-selectLabel";
var DropDownButton = class extends TextEditorButton {
  constructor(name2, editor, options2) {
    super(name2, editor, options2);
    this.currentTemplate = null;
  }
  _attachEvents(instance) {
    const {
      editor
    } = this;
    instance.option("onClick", (e) => {
      var _editor$_shouldCallOp;
      if (null !== (_editor$_shouldCallOp = editor._shouldCallOpenHandler) && void 0 !== _editor$_shouldCallOp && _editor$_shouldCallOp.call(editor)) {
        editor._openHandler(e);
        return;
      }
      !editor.option("openOnFieldClick") && editor._openHandler(e);
    });
    m_events_engine_default.on(instance.$element(), "mousedown", (e) => {
      if (editor.$element().is(".dx-state-focused")) {
        e.preventDefault();
      }
    });
  }
  _create() {
    const {
      editor
    } = this;
    const $element = renderer_default("<div>");
    const options2 = this._getOptions();
    this._addToContainer($element);
    const instance = editor._createComponent($element, button_default2, extend({}, options2, {
      elementAttr: {
        "aria-label": message_default.format(BUTTON_MESSAGE)
      }
    }));
    this._legacyRender(editor.$element(), $element, options2.visible);
    return {
      $element,
      instance
    };
  }
  _getOptions() {
    const {
      editor
    } = this;
    const visible2 = this._isVisible();
    const isReadOnly = editor.option("readOnly");
    const options2 = {
      focusStateEnabled: false,
      hoverStateEnabled: false,
      activeStateEnabled: false,
      useInkRipple: false,
      disabled: isReadOnly,
      visible: visible2
    };
    this._addTemplate(options2);
    return options2;
  }
  _isVisible() {
    const {
      editor
    } = this;
    return super._isVisible() && editor.option("showDropDownButton");
  }
  _legacyRender($editor, $element, isVisible2) {
    $editor.toggleClass(DROP_DOWN_EDITOR_BUTTON_VISIBLE, isVisible2);
    if ($element) {
      $element.removeClass("dx-button").removeClass("dx-button-mode-contained").addClass("dx-dropdowneditor-button");
    }
  }
  _isSameTemplate() {
    return this.editor.option("dropDownButtonTemplate") === this.currentTemplate;
  }
  _addTemplate(options2) {
    if (!this._isSameTemplate()) {
      options2.template = this.editor._getTemplateByOption("dropDownButtonTemplate");
      this.currentTemplate = this.editor.option("dropDownButtonTemplate");
    }
  }
  update() {
    const shouldUpdate = super.update();
    if (shouldUpdate) {
      const {
        editor,
        instance
      } = this;
      const $editor = editor.$element();
      const options2 = this._getOptions();
      null === instance || void 0 === instance || instance.option(options2);
      this._legacyRender($editor, null === instance || void 0 === instance ? void 0 : instance.$element(), options2.visible);
    }
  }
};

// node_modules/devextreme/esm/__internal/ui/drop_down_editor/m_utils.js
var getElementWidth = function($element) {
  if (hasWindow()) {
    return getOuterWidth($element);
  }
};
var getSizeValue = function(size) {
  if (null === size) {
    size = void 0;
  }
  if ("function" === typeof size) {
    size = size();
  }
  return size;
};

// node_modules/devextreme/esm/__internal/ui/drop_down_editor/m_drop_down_editor.js
var DROP_DOWN_EDITOR_CLASS = "dx-dropdowneditor";
var DROP_DOWN_EDITOR_INPUT_WRAPPER = "dx-dropdowneditor-input-wrapper";
var DROP_DOWN_EDITOR_OVERLAY = "dx-dropdowneditor-overlay";
var DROP_DOWN_EDITOR_OVERLAY_FLIPPED = "dx-dropdowneditor-overlay-flipped";
var DROP_DOWN_EDITOR_ACTIVE = "dx-dropdowneditor-active";
var DROP_DOWN_EDITOR_FIELD_CLICKABLE = "dx-dropdowneditor-field-clickable";
var DROP_DOWN_EDITOR_FIELD_TEMPLATE_WRAPPER = "dx-dropdowneditor-field-template-wrapper";
var isIOs = "ios" === devices_default.current().platform;
function createTemplateWrapperElement() {
  return renderer_default("<div>").addClass(DROP_DOWN_EDITOR_FIELD_TEMPLATE_WRAPPER);
}
var DropDownEditor = class extends m_text_box_default {
  _supportedKeys() {
    return _extends({}, super._supportedKeys(), {
      tab: (e) => {
        if (!this.option("opened")) {
          return;
        }
        if (!this._popup.getFocusableElements().length) {
          this.close();
          return;
        }
        const $focusableElement = e.shiftKey ? this._getLastPopupElement() : this._getFirstPopupElement();
        if ($focusableElement) {
          m_events_engine_default.trigger($focusableElement, "focus");
          $focusableElement.select();
        }
        e.preventDefault();
      },
      escape: (e) => {
        if (this.option("opened")) {
          e.preventDefault();
        }
        this.close();
        return true;
      },
      upArrow: (e) => {
        if (!isCommandKeyPressed(e)) {
          e.preventDefault();
          e.stopPropagation();
          if (e.altKey) {
            this.close();
            return false;
          }
        }
        return true;
      },
      downArrow: (e) => {
        if (!isCommandKeyPressed(e)) {
          e.preventDefault();
          e.stopPropagation();
          if (e.altKey) {
            this._validatedOpening();
            return false;
          }
        }
        return true;
      },
      enter: (e) => {
        if (this.option("opened")) {
          e.preventDefault();
          this._valueChangeEventHandler(e);
        }
        return true;
      }
    });
  }
  _getDefaultButtons() {
    return super._getDefaultButtons().concat([{
      name: "dropDown",
      Ctor: DropDownButton
    }]);
  }
  _getDefaultOptions() {
    return _extends({}, super._getDefaultOptions(), {
      value: null,
      onOpened: null,
      onClosed: null,
      opened: false,
      acceptCustomValue: true,
      applyValueMode: "instantly",
      deferRendering: true,
      activeStateEnabled: true,
      dropDownButtonTemplate: "dropDownButton",
      fieldTemplate: null,
      openOnFieldClick: false,
      showDropDownButton: true,
      buttons: void 0,
      dropDownOptions: {
        showTitle: false
      },
      popupPosition: this._getDefaultPopupPosition(),
      onPopupInitialized: null,
      applyButtonText: message_default.format("OK"),
      cancelButtonText: message_default.format("Cancel"),
      buttonsLocation: "default",
      useHiddenSubmitElement: false,
      validationMessagePosition: "auto"
    });
  }
  _useTemplates() {
    return true;
  }
  _getDefaultPopupPosition(isRtlEnabled) {
    const position3 = getDefaultAlignment(isRtlEnabled);
    return {
      offset: {
        h: 0,
        v: -1
      },
      my: `${position3} top`,
      at: `${position3} bottom`,
      collision: "flip flip"
    };
  }
  _defaultOptionsRules() {
    return super._defaultOptionsRules().concat([{
      device(device) {
        const isGeneric2 = "generic" === device.platform;
        return isGeneric2;
      },
      options: {
        popupPosition: {
          offset: {
            v: 0
          }
        }
      }
    }]);
  }
  _inputWrapper() {
    return this.$element().find(`.${DROP_DOWN_EDITOR_INPUT_WRAPPER}`).first();
  }
  _init() {
    super._init();
    this._initVisibilityActions();
    this._initPopupInitializedAction();
    const {
      rtlEnabled,
      dropDownOptions
    } = this.option();
    this._updatePopupPosition(rtlEnabled);
    this._options.cache("dropDownOptions", dropDownOptions);
  }
  _updatePopupPosition(isRtlEnabled) {
    const {
      my,
      at
    } = this._getDefaultPopupPosition(isRtlEnabled);
    const currentPosition = this.option("popupPosition");
    this.option("popupPosition", extend({}, currentPosition, {
      my,
      at
    }));
  }
  _initVisibilityActions() {
    this._openAction = this._createActionByOption("onOpened", {
      excludeValidators: ["disabled", "readOnly"]
    });
    this._closeAction = this._createActionByOption("onClosed", {
      excludeValidators: ["disabled", "readOnly"]
    });
  }
  _initPopupInitializedAction() {
    this._popupInitializedAction = this._createActionByOption("onPopupInitialized", {
      excludeValidators: ["disabled", "readOnly"]
    });
  }
  _initMarkup() {
    this._renderSubmitElement();
    super._initMarkup();
    this.$element().addClass("dx-dropdowneditor");
    this.setAria("role", this._getAriaRole());
  }
  _render() {
    this._detachFocusEvents();
    super._render();
    this._renderOpenHandler();
    this._attachFocusOutHandler();
    this._renderOpenedState();
  }
  _renderContentImpl() {
    if (!this.option("deferRendering")) {
      this._createPopup();
    }
  }
  _renderInput() {
    super._renderInput();
    this._renderTemplateWrapper();
    this._wrapInput();
    this._setDefaultAria();
  }
  _wrapInput() {
    this._$container = this.$element().wrapInner(renderer_default("<div>").addClass(DROP_DOWN_EDITOR_INPUT_WRAPPER)).children().eq(0);
  }
  _getAriaHasPopup() {
    return "true";
  }
  _getAriaAutocomplete() {
    return "none";
  }
  _getAriaRole() {
    return "combobox";
  }
  _setDefaultAria() {
    this.setAria({
      haspopup: this._getAriaHasPopup(),
      autocomplete: this._getAriaAutocomplete(),
      role: this._getAriaRole()
    });
  }
  _readOnlyPropValue() {
    return !this._isEditable() || super._readOnlyPropValue();
  }
  _cleanFocusState() {
    super._cleanFocusState();
    if (this.option("fieldTemplate")) {
      this._detachFocusEvents();
    }
  }
  _getFieldTemplate() {
    return this.option("fieldTemplate") && this._getTemplateByOption("fieldTemplate");
  }
  _renderMask() {
    if (this.option("fieldTemplate")) {
      return;
    }
    super._renderMask();
  }
  _renderField() {
    const fieldTemplate = this._getFieldTemplate();
    if (fieldTemplate) {
      this._renderTemplatedField(fieldTemplate, this._fieldRenderData());
    }
  }
  _renderPlaceholder() {
    const hasFieldTemplate = !!this._getFieldTemplate();
    if (!hasFieldTemplate) {
      super._renderPlaceholder();
    }
  }
  _renderValue() {
    if (this.option("useHiddenSubmitElement")) {
      this._setSubmitValue();
    }
    const promise = super._renderValue();
    return promise.always(this._renderField.bind(this));
  }
  _getButtonsContainer() {
    const fieldTemplate = this._getFieldTemplate();
    return fieldTemplate ? this._$container : this._$textEditorContainer;
  }
  _renderTemplateWrapper() {
    const fieldTemplate = this._getFieldTemplate();
    if (!fieldTemplate) {
      return;
    }
    if (!this._$templateWrapper) {
      this._$templateWrapper = createTemplateWrapperElement().prependTo(this.$element());
    }
  }
  _renderTemplatedField(fieldTemplate, data17) {
    const isFocused = focused(this._input());
    this._detachKeyboardEvents();
    this._detachFocusEvents();
    this._$textEditorContainer.remove();
    const $newTemplateWrapper = createTemplateWrapperElement();
    this._$templateWrapper.replaceWith($newTemplateWrapper);
    this._$templateWrapper = $newTemplateWrapper;
    const currentRenderContext = Symbol("renderContext");
    this._activeRenderContext = currentRenderContext;
    fieldTemplate.render({
      model: data17,
      container: getPublicElement(this._$templateWrapper),
      onRendered: () => {
        if (this._activeRenderContext !== currentRenderContext) {
          return;
        }
        const $input = this._input();
        if (!$input.length) {
          throw ui_errors_default.Error("E1010");
        }
        this._integrateInput();
        if (!isFocused) {
          return;
        }
        if (browser_default.mozilla) {
          const inputElement = $input.get(0);
          inputElement.focus({
            preventScroll: true
          });
        } else {
          m_events_engine_default.trigger($input, "focus");
        }
      }
    });
  }
  _integrateInput() {
    const {
      isValid
    } = this.option();
    this._renderFocusState();
    this._refreshValueChangeEvent();
    this._refreshEvents();
    this._refreshEmptinessEvent();
    this._setDefaultAria();
    this._setFieldAria();
    this._toggleValidationClasses(!isValid);
    const {
      _onMarkupRendered: markupRendered
    } = this.option();
    null === markupRendered || void 0 === markupRendered || markupRendered();
  }
  _refreshEmptinessEvent() {
    m_events_engine_default.off(this._input(), "input blur", this._toggleEmptinessEventHandler);
    this._renderEmptinessEvent();
  }
  _fieldRenderData() {
    return this.option("value");
  }
  _initTemplates() {
    this._templateManager.addDefaultTemplates({
      dropDownButton: new FunctionTemplate((options2) => {
        const $icon = renderer_default("<div>").addClass("dx-dropdowneditor-icon");
        renderer_default(options2.container).append($icon);
      })
    });
    super._initTemplates();
  }
  _renderOpenHandler() {
    const $inputWrapper = this._inputWrapper();
    const eventName = addNamespace2(CLICK_EVENT_NAME, this.NAME);
    const {
      openOnFieldClick
    } = this.option();
    m_events_engine_default.off($inputWrapper, eventName);
    m_events_engine_default.on($inputWrapper, eventName, this._getInputClickHandler(openOnFieldClick));
    this.$element().toggleClass(DROP_DOWN_EDITOR_FIELD_CLICKABLE, openOnFieldClick);
    if (openOnFieldClick) {
      this._openOnFieldClickAction = this._createAction(this._openHandler.bind(this));
    }
  }
  _attachFocusOutHandler() {
    if (isIOs) {
      this._detachFocusOutEvents();
      m_events_engine_default.on(this._inputWrapper(), addNamespace2("focusout", this.NAME), (event) => {
        const newTarget = event.relatedTarget;
        if (newTarget && this.option("opened")) {
          const isNewTargetOutside = this._isTargetOutOfComponent(newTarget);
          if (isNewTargetOutside) {
            this.close();
          }
        }
      });
    }
  }
  _isTargetOutOfComponent(newTarget) {
    const popupWrapper = this.content ? renderer_default(this.content()).closest(`.${DROP_DOWN_EDITOR_OVERLAY}`) : this._$popup;
    const isTargetOutsidePopup = 0 === renderer_default(newTarget).closest(`.${DROP_DOWN_EDITOR_OVERLAY}`, popupWrapper).length;
    return isTargetOutsidePopup;
  }
  _detachFocusOutEvents() {
    isIOs && m_events_engine_default.off(this._inputWrapper(), addNamespace2("focusout", this.NAME));
  }
  _getInputClickHandler(openOnFieldClick) {
    return openOnFieldClick ? (e) => {
      this._executeOpenAction(e);
    } : () => {
      this._focusInput();
    };
  }
  _openHandler() {
    this._toggleOpenState();
  }
  _executeOpenAction(e) {
    var _this$_openOnFieldCli;
    null === (_this$_openOnFieldCli = this._openOnFieldClickAction) || void 0 === _this$_openOnFieldCli || _this$_openOnFieldCli.call(this, {
      event: e
    });
  }
  _keyboardEventBindingTarget() {
    return this._input();
  }
  _focusInput() {
    if (this.option("disabled")) {
      return false;
    }
    if (this.option("focusStateEnabled") && !focused(this._input())) {
      this._resetCaretPosition();
      m_events_engine_default.trigger(this._input(), "focus");
    }
    return true;
  }
  _resetCaretPosition() {
    let ignoreEditable = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : false;
    const inputElement = this._input().get(0);
    if (inputElement) {
      const {
        value: value2
      } = inputElement;
      const caretPosition = isDefined(value2) && (ignoreEditable || this._isEditable()) ? value2.length : 0;
      this._caret({
        start: caretPosition,
        end: caretPosition
      }, true);
    }
  }
  _isEditable() {
    const {
      acceptCustomValue
    } = this.option();
    return acceptCustomValue;
  }
  _toggleOpenState(isVisible2) {
    if (!this._focusInput()) {
      return;
    }
    if (!this.option("readOnly")) {
      isVisible2 = arguments.length ? isVisible2 : !this.option("opened");
      this.option("opened", isVisible2);
    }
  }
  _getControlsAria() {
    return this._popup && this._popupContentId;
  }
  _renderOpenedState() {
    const opened = this.option("opened");
    if (opened) {
      this._createPopup();
    }
    this.$element().toggleClass(DROP_DOWN_EDITOR_ACTIVE, opened);
    this._setPopupOption("visible", opened);
    const arias = {
      expanded: opened,
      controls: this._getControlsAria()
    };
    this.setAria(arias);
    this.setAria("owns", opened ? this._popupContentId : void 0, this.$element());
  }
  _createPopup() {
    if (this._$popup) {
      return;
    }
    this._$popup = renderer_default("<div>").addClass(DROP_DOWN_EDITOR_OVERLAY).appendTo(this.$element());
    this._renderPopup();
    this._renderPopupContent();
    this._setPopupAriaLabel();
  }
  _setPopupAriaLabel() {
    const $overlayContent = this._popup.$overlayContent();
    this.setAria("label", "Dropdown", $overlayContent);
  }
  _renderPopupContent() {
  }
  _renderPopup() {
    const popupConfig = extend(this._popupConfig(), this._options.cache("dropDownOptions"));
    this._popup = this._createComponent(this._$popup, ui_popup_default, popupConfig);
    this._popup.on({
      showing: this._popupShowingHandler.bind(this),
      shown: this._popupShownHandler.bind(this),
      hiding: this._popupHidingHandler.bind(this),
      hidden: this._popupHiddenHandler.bind(this),
      contentReady: this._contentReadyHandler.bind(this)
    });
    this._attachPopupKeyHandler();
    this._contentReadyHandler();
    this._setPopupContentId(this._popup.$content());
    this._bindInnerWidgetOptions(this._popup, "dropDownOptions");
  }
  _attachPopupKeyHandler() {
    m_events_engine_default.on(this._popup.$overlayContent(), addNamespace2("keydown", this.NAME), (e) => this._popupKeyHandler(e));
  }
  _popupKeyHandler(e) {
    switch (normalizeKeyName(e)) {
      case "tab":
        this._popupTabHandler(e);
        break;
      case "escape":
        this._popupEscHandler();
    }
  }
  _popupTabHandler(e) {
    const $target = renderer_default(e.target);
    const moveBackward = e.shiftKey && $target.is(this._getFirstPopupElement());
    const moveForward = !e.shiftKey && $target.is(this._getLastPopupElement());
    if (moveForward || moveBackward) {
      m_events_engine_default.trigger(this.field(), "focus");
      e.preventDefault();
    }
  }
  _popupEscHandler() {
    m_events_engine_default.trigger(this._input(), "focus");
    this.close();
  }
  _setPopupContentId($popupContent) {
    this._popupContentId = `dx-${new guid_default2()}`;
    this.setAria("id", this._popupContentId, $popupContent);
  }
  _contentReadyHandler() {
  }
  _popupConfig() {
    return {
      onInitialized: this._getPopupInitializedHandler(),
      position: extend(this.option("popupPosition"), {
        of: this.$element()
      }),
      showTitle: this.option("dropDownOptions.showTitle"),
      _ignoreFunctionValueDeprecation: true,
      width: () => getElementWidth(this.$element()),
      height: "auto",
      shading: false,
      hideOnParentScroll: true,
      hideOnOutsideClick: (e) => this._closeOutsideDropDownHandler(e),
      animation: {
        show: {
          type: "fade",
          duration: 0,
          from: 0,
          to: 1
        },
        hide: {
          type: "fade",
          duration: 400,
          from: 1,
          to: 0
        }
      },
      deferRendering: false,
      focusStateEnabled: false,
      showCloseButton: false,
      dragEnabled: false,
      toolbarItems: this._getPopupToolbarItems(),
      onPositioned: this._popupPositionedHandler.bind(this),
      fullScreen: false,
      contentTemplate: null,
      _hideOnParentScrollTarget: this.$element(),
      _wrapperClassExternal: DROP_DOWN_EDITOR_OVERLAY,
      _ignorePreventScrollEventsDeprecation: true
    };
  }
  _popupInitializedHandler() {
  }
  _getPopupInitializedHandler() {
    const onPopupInitialized = this.option("onPopupInitialized");
    return (e) => {
      this._popupInitializedHandler();
      if (onPopupInitialized) {
        this._popupInitializedAction({
          popup: e.component
        });
      }
    };
  }
  _dimensionChanged() {
    if (hasWindow() && !this.$element().is(":visible")) {
      this.close();
      return;
    }
    this._updatePopupWidth();
  }
  _updatePopupWidth() {
    const popupWidth = getSizeValue(this.option("dropDownOptions.width"));
    if (void 0 === popupWidth) {
      this._setPopupOption("width", () => getElementWidth(this.$element()));
    }
  }
  _popupPositionedHandler(e) {
    var _e$position;
    const {
      labelMode,
      stylingMode
    } = this.option();
    if (!this._popup) {
      return;
    }
    const $popupOverlayContent = this._popup.$overlayContent();
    const isOverlayFlipped = null === (_e$position = e.position) || void 0 === _e$position || null === (_e$position = _e$position.v) || void 0 === _e$position ? void 0 : _e$position.flip;
    const shouldIndentForLabel = "hidden" !== labelMode && "outside" !== labelMode && "outlined" === stylingMode;
    if (e.position) {
      $popupOverlayContent.toggleClass(DROP_DOWN_EDITOR_OVERLAY_FLIPPED, isOverlayFlipped);
    }
    if (isOverlayFlipped && shouldIndentForLabel && this._label.isVisible()) {
      const $label = this._label.$element();
      move($popupOverlayContent, {
        top: locate($popupOverlayContent).top - parseInt($label.css("fontSize"))
      });
    }
  }
  _popupShowingHandler() {
  }
  _popupHidingHandler() {
    this.option("opened", false);
  }
  _popupShownHandler() {
    var _this$_validationMess;
    this._openAction();
    null === (_this$_validationMess = this._validationMessage) || void 0 === _this$_validationMess || _this$_validationMess.option("positionSide", this._getValidationMessagePositionSide());
  }
  _popupHiddenHandler() {
    var _this$_validationMess2;
    this._closeAction();
    null === (_this$_validationMess2 = this._validationMessage) || void 0 === _this$_validationMess2 || _this$_validationMess2.option("positionSide", this._getValidationMessagePositionSide());
  }
  _getValidationMessagePositionSide() {
    var _this$_popup;
    const {
      validationMessagePosition
    } = this.option();
    if ("auto" !== validationMessagePosition) {
      return validationMessagePosition;
    }
    let positionSide = "bottom";
    if (null !== (_this$_popup = this._popup) && void 0 !== _this$_popup && _this$_popup.option("visible")) {
      const {
        top: myTop
      } = position_default.setup(this.$element());
      const {
        top: popupTop
      } = position_default.setup(this._popup.$content());
      positionSide = myTop + this.option("popupPosition").offset.v > popupTop ? "bottom" : "top";
    }
    return positionSide;
  }
  _closeOutsideDropDownHandler(event) {
    const {
      target
    } = event;
    const $target = renderer_default(target);
    const dropDownButton = this.getButton("dropDown");
    const $dropDownButton = null === dropDownButton || void 0 === dropDownButton ? void 0 : dropDownButton.$element();
    const isInputClicked = !!$target.closest(this.$element()).length;
    const isDropDownButtonClicked = !!$target.closest($dropDownButton).length;
    const isOutsideClick = !isInputClicked && !isDropDownButtonClicked;
    return isOutsideClick;
  }
  _clean() {
    delete this._openOnFieldClickAction;
    delete this._$templateWrapper;
    if (this._$popup) {
      this._$popup.remove();
      delete this._$popup;
      delete this._popup;
    }
    super._clean();
  }
  _setPopupOption(optionName, value2) {
    this._setWidgetOption("_popup", arguments);
  }
  _validatedOpening() {
    if (!this.option("readOnly")) {
      this._toggleOpenState(true);
    }
  }
  _getPopupToolbarItems() {
    const {
      applyValueMode
    } = this.option();
    return "useButtons" === applyValueMode ? this._popupToolbarItemsConfig() : [];
  }
  _getFirstPopupElement() {
    return renderer_default(this._popup.getFocusableElements()).first();
  }
  _getLastPopupElement() {
    return renderer_default(this._popup.getFocusableElements()).last();
  }
  _popupToolbarItemsConfig() {
    const buttonsConfig = [{
      shortcut: "done",
      options: {
        onClick: this._applyButtonHandler.bind(this),
        text: this.option("applyButtonText")
      }
    }, {
      shortcut: "cancel",
      options: {
        onClick: this._cancelButtonHandler.bind(this),
        text: this.option("cancelButtonText")
      }
    }];
    return this._applyButtonsLocation(buttonsConfig);
  }
  _applyButtonsLocation(buttonsConfig) {
    const {
      buttonsLocation
    } = this.option();
    const resultConfig = buttonsConfig;
    if ("default" !== buttonsLocation) {
      const position3 = splitPair(buttonsLocation);
      each(resultConfig, (_, element) => {
        extend(element, {
          toolbar: position3[0],
          location: position3[1]
        });
      });
    }
    return resultConfig;
  }
  _applyButtonHandler(args) {
    this.close();
    if (this.option("focusStateEnabled")) {
      this.focus();
    }
  }
  _cancelButtonHandler() {
    this.close();
    if (this.option("focusStateEnabled")) {
      this.focus();
    }
  }
  _popupOptionChanged(args) {
    const options2 = ui_widget_default.getOptionsFromContainer(args);
    this._setPopupOption(options2);
    const optionsKeys = Object.keys(options2);
    if (optionsKeys.includes("width") || optionsKeys.includes("height")) {
      this._dimensionChanged();
    }
  }
  _renderSubmitElement() {
    if (this.option("useHiddenSubmitElement")) {
      this._$submitElement = renderer_default("<input>").attr("type", "hidden").appendTo(this.$element());
    }
  }
  _setSubmitValue() {
    const {
      value: value2
    } = this.option();
    this._getSubmitElement().val(value2);
  }
  _getSubmitElement() {
    if (this.option("useHiddenSubmitElement")) {
      return this._$submitElement;
    }
    return super._getSubmitElement();
  }
  _dispose() {
    this._detachFocusOutEvents();
    super._dispose();
  }
  _optionChanged(args) {
    var _this$_popup2;
    const {
      name: name2,
      value: value2
    } = args;
    switch (name2) {
      case "width":
      case "height":
        super._optionChanged(args);
        null === (_this$_popup2 = this._popup) || void 0 === _this$_popup2 || _this$_popup2.repaint();
        break;
      case "opened":
        this._renderOpenedState();
        break;
      case "onOpened":
      case "onClosed":
        this._initVisibilityActions();
        break;
      case "onPopupInitialized":
        this._initPopupInitializedAction();
        break;
      case "fieldTemplate":
      case "acceptCustomValue":
      case "openOnFieldClick":
        this._invalidate();
        break;
      case "dropDownButtonTemplate":
      case "showDropDownButton":
        this._updateButtons(["dropDown"]);
        break;
      case "dropDownOptions": {
        this._popupOptionChanged(args);
        const {
          dropDownOptions
        } = this.option();
        this._options.cache("dropDownOptions", dropDownOptions);
        break;
      }
      case "popupPosition":
        break;
      case "deferRendering":
        if (hasWindow()) {
          this._createPopup();
        }
        break;
      case "applyValueMode":
      case "applyButtonText":
      case "cancelButtonText":
      case "buttonsLocation":
        this._setPopupOption("toolbarItems", this._getPopupToolbarItems());
        break;
      case "useHiddenSubmitElement":
        if (this._$submitElement) {
          this._$submitElement.remove();
          this._$submitElement = void 0;
        }
        this._renderSubmitElement();
        break;
      case "rtlEnabled":
        this._updatePopupPosition(value2);
        super._optionChanged(args);
        break;
      default:
        super._optionChanged(args);
    }
  }
  open() {
    this.option("opened", true);
  }
  close() {
    this.option("opened", false);
  }
  field() {
    return getPublicElement(this._input());
  }
  content() {
    return this._popup ? this._popup.content() : null;
  }
};
component_registrator_default("dxDropDownEditor", DropDownEditor);
var m_drop_down_editor_default = DropDownEditor;

// node_modules/devextreme/esm/__internal/ui/drop_down_editor/m_drop_down_list.js
var window23 = getWindow();
var SEARCH_MODES = ["startswith", "contains", "endwith", "notcontains"];
var useCompositionEvents = "android" !== devices_default.real().platform;
var DropDownList = class extends m_drop_down_editor_default {
  _supportedKeys() {
    const parentSupportedKeys = super._supportedKeys();
    return _extends({}, parentSupportedKeys, {
      tab(e) {
        if (this._allowSelectItemByTab()) {
          this._saveValueChangeEvent(e);
          const $focusedItem = renderer_default(this._list.option("focusedElement"));
          $focusedItem.length && this._setSelectedElement($focusedItem);
        }
        parentSupportedKeys.tab(e);
      },
      space: noop2,
      home: noop2,
      end: noop2
    });
  }
  _allowSelectItemByTab() {
    const {
      opened,
      applyValueMode
    } = this.option();
    return opened && "instantly" === applyValueMode;
  }
  _setSelectedElement($element) {
    const value2 = this._valueGetter(this._list._getItemData($element));
    this._setValue(value2);
  }
  _setValue(value2) {
    this.option("value", value2);
  }
  _getDefaultOptions() {
    return _extends({}, super._getDefaultOptions(), ui_data_expression_default._dataExpressionDefaultOptions(), {
      displayValue: void 0,
      searchEnabled: false,
      searchMode: "contains",
      searchTimeout: 500,
      minSearchLength: 0,
      searchExpr: null,
      valueChangeEvent: "input change keyup",
      selectedItem: null,
      noDataText: message_default.format("dxCollectionWidget-noDataText"),
      encodeNoDataText: false,
      onSelectionChanged: null,
      onItemClick: noop2,
      showDataBeforeSearch: false,
      grouped: false,
      groupTemplate: "group",
      popupPosition: {
        my: "left top",
        at: "left bottom",
        offset: {
          h: 0,
          v: 0
        },
        collision: "flip"
      },
      wrapItemText: false,
      useItemTextAsTitle: false
    });
  }
  _defaultOptionsRules() {
    return super._defaultOptionsRules().concat([{
      device: {
        platform: "ios"
      },
      options: {
        popupPosition: {
          offset: {
            v: -1
          }
        }
      }
    }, {
      device: {
        platform: "generic"
      },
      options: {
        buttonsLocation: "bottom center"
      }
    }]);
  }
  _setOptionsByReference() {
    super._setOptionsByReference();
    extend(this._optionsByReference, {
      value: true,
      selectedItem: true,
      displayValue: true
    });
  }
  _init() {
    super._init();
    this._initDataExpressions();
    this._initActions();
    this._setListDataSource();
    this._validateSearchMode();
    this._clearSelectedItem();
    this._initItems();
  }
  _setListFocusedElementOptionChange() {
    this._list._updateParentActiveDescendant = this._updateActiveDescendant.bind(this);
  }
  _initItems() {
    const {
      items
    } = this.option();
    if (items && !items.length && this._dataSource) {
      this.option().items = this._dataSource.items();
    }
  }
  _initActions() {
    this._initContentReadyAction();
    this._initSelectionChangedAction();
    this._initItemClickAction();
  }
  _initContentReadyAction() {
    this._contentReadyAction = this._createActionByOption("onContentReady", {
      excludeValidators: ["disabled", "readOnly"]
    });
  }
  _initSelectionChangedAction() {
    this._selectionChangedAction = this._createActionByOption("onSelectionChanged", {
      excludeValidators: ["disabled", "readOnly"]
    });
  }
  _initItemClickAction() {
    this._itemClickAction = this._createActionByOption("onItemClick");
  }
  _initTemplates() {
    super._initTemplates();
    this._templateManager.addDefaultTemplates({
      item: new ChildDefaultTemplate("item")
    });
  }
  _isEditable() {
    const {
      searchEnabled
    } = this.option();
    return super._isEditable() || searchEnabled;
  }
  _saveFocusOnWidget() {
    var _this$_list;
    if (null !== (_this$_list = this._list) && void 0 !== _this$_list && _this$_list.initialOption("focusStateEnabled")) {
      this._focusInput();
    }
  }
  _fitIntoRange(value2, start, end) {
    if (value2 > end) {
      return start;
    }
    if (value2 < start) {
      return end;
    }
    return value2;
  }
  _items() {
    const items = this._getPlainItems(!this._list && this._dataSource.items());
    const availableItems = new m_query_default(items).filter("disabled", "<>", true).toArray();
    return availableItems;
  }
  _calcNextItem(step) {
    const items = this._items();
    const nextIndex = this._fitIntoRange(this._getSelectedIndex() + step, 0, items.length - 1);
    return items[nextIndex];
  }
  _getSelectedIndex() {
    const items = this._items();
    const selectedItem = this.option("selectedItem");
    let result2 = -1;
    each(items, (index2, item) => {
      if (this._isValueEquals(item, selectedItem)) {
        result2 = index2;
        return false;
      }
    });
    return result2;
  }
  _createPopup() {
    super._createPopup();
    this._updateCustomBoundaryContainer();
    this._popup.$wrapper().addClass(this._popupWrapperClass());
    const $popupContent = this._popup.$content();
    m_events_engine_default.off($popupContent, "mouseup");
    m_events_engine_default.on($popupContent, "mouseup", this._saveFocusOnWidget.bind(this));
  }
  _updateCustomBoundaryContainer() {
    const customContainer = this.option("dropDownOptions.container");
    const $container = customContainer && renderer_default(customContainer);
    if ($container && $container.length && !isWindow($container.get(0))) {
      const $containerWithParents = [].slice.call($container.parents());
      $containerWithParents.unshift($container.get(0));
      each($containerWithParents, (i, parent) => {
        if (parent === renderer_default("body").get(0)) {
          return false;
        }
        if ("hidden" === window23.getComputedStyle(parent).overflowY) {
          this._$customBoundaryContainer = renderer_default(parent);
          return false;
        }
      });
    }
  }
  _popupWrapperClass() {
    return "dx-dropdownlist-popup-wrapper";
  }
  _renderInputValue() {
    var _this = this;
    let {
      value: value2,
      renderOnly
    } = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
    const currentValue = value2 ?? this._getCurrentValue();
    this._rejectValueLoading();
    if (renderOnly) {
      return super._renderInputValue(currentValue);
    }
    return this._loadInputValue(currentValue, function() {
      _this._setSelectedItem(...arguments);
    }).always(super._renderInputValue.bind(this, currentValue));
  }
  _loadInputValue(value2, callback) {
    return this._loadItem(value2).always(callback);
  }
  _getItemFromPlain(value2, cache) {
    let plainItems;
    let selectedItem;
    if (cache && "object" !== typeof value2) {
      if (!cache.itemByValue) {
        cache.itemByValue = {};
        plainItems = this._getPlainItems();
        plainItems.forEach(function(item) {
          cache.itemByValue[this._valueGetter(item)] = item;
        }, this);
      }
      selectedItem = cache.itemByValue[value2];
    }
    if (!selectedItem) {
      plainItems = this._getPlainItems();
      selectedItem = grep(plainItems, (item) => this._isValueEquals(this._valueGetter(item), value2))[0];
    }
    return selectedItem;
  }
  _resetInputText() {
    this._renderInputValue({
      renderOnly: true
    });
  }
  _loadItem(value2, cache) {
    const selectedItem = this._getItemFromPlain(value2, cache);
    return void 0 !== selectedItem ? Deferred().resolve(selectedItem).promise() : this._loadValue(value2);
  }
  _getPlainItems(items) {
    let plainItems = [];
    const grouped = this._getGroupedOption();
    items = items || this.option("items") || this._dataSource.items() || [];
    for (let i = 0; i < items.length; i++) {
      var _items$i;
      if (grouped && null !== (_items$i = items[i]) && void 0 !== _items$i && _items$i.items) {
        plainItems = plainItems.concat(items[i].items);
      } else {
        plainItems.push(items[i]);
      }
    }
    return plainItems;
  }
  _updateActiveDescendant($target) {
    var _this$_list2;
    const opened = this.option("opened");
    const listFocusedItemId = null === (_this$_list2 = this._list) || void 0 === _this$_list2 ? void 0 : _this$_list2.getFocusedItemId();
    const isElementOnDom = renderer_default(`#${listFocusedItemId}`).length > 0;
    const activedescendant = opened && isElementOnDom && listFocusedItemId;
    this.setAria({
      activedescendant: activedescendant || null
    }, $target);
  }
  _setSelectedItem(item) {
    const displayValue = this._displayValue(item);
    this.option("selectedItem", ensureDefined(item, null));
    this.option("displayValue", displayValue);
  }
  _displayValue(item) {
    return this._displayGetter(item);
  }
  _refreshSelected() {
    const cache = {};
    this._listItemElements().each((_, itemElement) => {
      const $itemElement = renderer_default(itemElement);
      const itemValue = this._valueGetter($itemElement.data("dxListItemData"));
      const isItemSelected = this._isSelectedValue(itemValue, cache);
      if (isItemSelected) {
        this._list.selectItem($itemElement);
      } else {
        this._list.unselectItem($itemElement);
      }
    });
  }
  _popupShownHandler() {
    super._popupShownHandler();
    this._setFocusPolicy();
  }
  _setFocusPolicy() {
    if (!this.option("focusStateEnabled") || !this._list) {
      return;
    }
    this._list.option("focusedElement", null);
  }
  _isSelectedValue(value2, cache) {
    return this._isValueEquals(value2, this.option("value"));
  }
  _validateSearchMode() {
    const searchMode = this.option("searchMode");
    const normalizedSearchMode = searchMode.toLowerCase();
    if (!SEARCH_MODES.includes(normalizedSearchMode)) {
      throw ui_errors_default.Error("E1019", searchMode);
    }
  }
  _clearSelectedItem() {
    this.option("selectedItem", null);
  }
  _processDataSourceChanging() {
    this._initDataController();
    this._setListOption("_dataController", this._dataController);
    this._setListDataSource();
    this._renderInputValue().fail(() => {
      if (this._isCustomValueAllowed()) {
        return;
      }
      this._clearSelectedItem();
    });
  }
  _isCustomValueAllowed() {
    return this.option("displayCustomValue");
  }
  clear() {
    super.clear();
    this._clearFilter();
    this._clearSelectedItem();
  }
  _listItemElements() {
    return this._$list ? this._$list.find(".dx-list-item") : renderer_default();
  }
  _popupConfig() {
    return _extends({}, super._popupConfig(), {
      templatesRenderAsynchronously: false,
      autoResizeEnabled: false,
      maxHeight: this._getMaxHeight.bind(this)
    });
  }
  _renderPopupContent() {
    super._renderPopupContent();
    this._renderList();
  }
  _getKeyboardListeners() {
    const canListHaveFocus = this._canListHaveFocus();
    return super._getKeyboardListeners().concat([!canListHaveFocus && this._list]);
  }
  _renderList() {
    this._listId = `dx-${new guid_default2()._value}`;
    const $list = renderer_default("<div>").attr("id", this._listId).appendTo(this._popup.$content());
    this._$list = $list;
    this._list = this._createComponent($list, list_light_default, this._listConfig());
    this._refreshList();
    this._renderPreventBlurOnListClick();
    this._setListFocusedElementOptionChange();
  }
  _renderPreventBlurOnListClick() {
    const eventName = addNamespace2("mousedown", "dxDropDownList");
    m_events_engine_default.off(this._$list, eventName);
    m_events_engine_default.on(this._$list, eventName, (e) => e.preventDefault());
  }
  _getControlsAria() {
    return this._list && this._listId;
  }
  _renderOpenedState() {
    super._renderOpenedState();
    this._list && this._updateActiveDescendant();
    this.setAria("owns", this._popup && this._popupContentId);
  }
  _getAriaHasPopup() {
    return "listbox";
  }
  _refreshList() {
    if (this._list && this._shouldRefreshDataSource()) {
      this._setListDataSource();
    }
  }
  _shouldRefreshDataSource() {
    const dataSourceProvided = !!this._list.option("dataSource");
    return dataSourceProvided !== this._needPassDataSourceToList();
  }
  _isDesktopDevice() {
    return "desktop" === devices_default.real().deviceType;
  }
  _listConfig() {
    const options2 = {
      selectionMode: "single",
      _templates: this.option("_templates"),
      templateProvider: this.option("templateProvider"),
      noDataText: this.option("noDataText"),
      encodeNoDataText: this.option("encodeNoDataText"),
      grouped: this.option("grouped"),
      wrapItemText: this.option("wrapItemText"),
      useItemTextAsTitle: this.option("useItemTextAsTitle"),
      onContentReady: this._listContentReadyHandler.bind(this),
      itemTemplate: this.option("itemTemplate"),
      indicateLoading: false,
      keyExpr: this._getCollectionKeyExpr(),
      displayExpr: this._displayGetterExpr(),
      groupTemplate: this.option("groupTemplate"),
      onItemClick: this._listItemClickAction.bind(this),
      dataSource: this._getDataSource(),
      _dataController: this._dataController,
      hoverStateEnabled: this._isDesktopDevice() ? this.option("hoverStateEnabled") : false,
      focusStateEnabled: this._isDesktopDevice() ? this.option("focusStateEnabled") : false,
      _onItemsRendered: () => {
        this._popup.repaint();
      }
    };
    if (!this._canListHaveFocus()) {
      options2.tabIndex = null;
    }
    return options2;
  }
  _canListHaveFocus() {
    return false;
  }
  _getDataSource() {
    return this._needPassDataSourceToList() ? this._dataSource : null;
  }
  _dataSourceOptions() {
    return {
      paginate: false
    };
  }
  _getGroupedOption() {
    return this.option("grouped");
  }
  _dataSourceFromUrlLoadMode() {
    return "raw";
  }
  _listContentReadyHandler() {
    this._list = this._list || this._$list.dxList("instance");
    if (!this.option("deferRendering")) {
      this._refreshSelected();
    }
    this._updatePopupWidth();
    this._updateListDimensions();
    this._contentReadyAction();
  }
  _setListOption(optionName, value2) {
    this._setWidgetOption("_list", arguments);
  }
  _listItemClickAction(e) {
    this._listItemClickHandler(e);
    this._itemClickAction(e);
  }
  _listItemClickHandler(e) {
  }
  _setListDataSource() {
    if (!this._list) {
      return;
    }
    this._setListOption("dataSource", this._getDataSource());
    if (!this._needPassDataSourceToList()) {
      this._setListOption("items", []);
    }
  }
  _needPassDataSourceToList() {
    const {
      showDataBeforeSearch
    } = this.option();
    return showDataBeforeSearch || this._isMinSearchLengthExceeded();
  }
  _isMinSearchLengthExceeded() {
    return this._searchValue().toString().length >= this.option("minSearchLength");
  }
  _needClearFilter() {
    return this._canKeepDataSource() ? false : this._needPassDataSourceToList();
  }
  _canKeepDataSource() {
    const isMinSearchLengthExceeded = this._isMinSearchLengthExceeded();
    return this._dataController.isLoaded() && this.option("showDataBeforeSearch") && this.option("minSearchLength") && !isMinSearchLengthExceeded && !this._isLastMinSearchLengthExceeded;
  }
  _searchValue() {
    return this._input().val() || "";
  }
  _getSearchEvent() {
    return addNamespace2("input", `${this.NAME}Search`);
  }
  _getCompositionStartEvent() {
    return addNamespace2("compositionstart", `${this.NAME}CompositionStart`);
  }
  _getCompositionEndEvent() {
    return addNamespace2("compositionend", `${this.NAME}CompositionEnd`);
  }
  _getSetFocusPolicyEvent() {
    return addNamespace2("input", `${this.NAME}FocusPolicy`);
  }
  _renderEvents() {
    super._renderEvents();
    m_events_engine_default.on(this._input(), this._getSetFocusPolicyEvent(), () => {
      this._setFocusPolicy();
    });
    if (this._shouldRenderSearchEvent()) {
      m_events_engine_default.on(this._input(), this._getSearchEvent(), (e) => {
        this._searchHandler(e);
      });
      if (useCompositionEvents) {
        m_events_engine_default.on(this._input(), this._getCompositionStartEvent(), () => {
          this._isTextCompositionInProgress(true);
        });
        m_events_engine_default.on(this._input(), this._getCompositionEndEvent(), (e) => {
          this._isTextCompositionInProgress(void 0);
          this._searchHandler(e, this._searchValue());
        });
      }
    }
  }
  _shouldRenderSearchEvent() {
    return this.option("searchEnabled");
  }
  _refreshEvents() {
    m_events_engine_default.off(this._input(), this._getSearchEvent());
    m_events_engine_default.off(this._input(), this._getSetFocusPolicyEvent());
    if (useCompositionEvents) {
      m_events_engine_default.off(this._input(), this._getCompositionStartEvent());
      m_events_engine_default.off(this._input(), this._getCompositionEndEvent());
    }
    super._refreshEvents();
  }
  _isTextCompositionInProgress(value2) {
    if (arguments.length) {
      this._isTextComposition = value2;
    } else {
      return this._isTextComposition;
    }
  }
  _searchHandler(e, searchValue) {
    if (this._isTextCompositionInProgress()) {
      return;
    }
    if (!this._isMinSearchLengthExceeded()) {
      this._searchCanceled();
      return;
    }
    const {
      searchTimeout
    } = this.option();
    if (searchTimeout) {
      this._clearSearchTimer();
      this._searchTimer = setTimeout(() => {
        this._searchDataSource(searchValue);
      }, searchTimeout);
    } else {
      this._searchDataSource(searchValue);
    }
  }
  _searchCanceled() {
    this._clearSearchTimer();
    if (this._needClearFilter()) {
      this._filterDataSource(null);
    }
    this._refreshList();
  }
  _searchDataSource() {
    let searchValue = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this._searchValue();
    this._filterDataSource(searchValue);
  }
  _filterDataSource(searchValue) {
    this._clearSearchTimer();
    const dataController2 = this._dataController;
    dataController2.searchExpr(this.option("searchExpr") || this._displayGetterExpr());
    dataController2.searchOperation(this.option("searchMode"));
    dataController2.searchValue(searchValue);
    dataController2.load().done(this._dataSourceFiltered.bind(this, searchValue));
  }
  _clearFilter() {
    const dataController2 = this._dataController;
    dataController2.searchValue() && dataController2.searchValue(null);
  }
  _dataSourceFiltered(searchValue) {
    this._isLastMinSearchLengthExceeded = this._isMinSearchLengthExceeded();
    this._refreshList();
    this._refreshPopupVisibility();
  }
  _shouldOpenPopup() {
    return this._hasItemsToShow();
  }
  _refreshPopupVisibility() {
    if (this.option("readOnly") || !this._searchValue()) {
      return;
    }
    const shouldOpenPopup = this._shouldOpenPopup();
    if (shouldOpenPopup && !this._isFocused()) {
      return;
    }
    this.option("opened", shouldOpenPopup);
    if (shouldOpenPopup) {
      this._updatePopupWidth();
      this._updateListDimensions();
    }
  }
  _dataSourceChangedHandler(newItems) {
    if (0 === this._dataController.pageIndex()) {
      this.option().items = newItems;
    } else {
      this.option().items = this.option().items.concat(newItems);
    }
  }
  _hasItemsToShow() {
    const dataController2 = this._dataController;
    const resultItems = dataController2.items() || [];
    const resultAmount = resultItems.length;
    const isMinSearchLengthExceeded = this._needPassDataSourceToList();
    return !!(isMinSearchLengthExceeded && resultAmount);
  }
  _clearSearchTimer() {
    clearTimeout(this._searchTimer);
    delete this._searchTimer;
  }
  _popupShowingHandler() {
    this._updatePopupWidth();
    this._updateListDimensions();
  }
  _dimensionChanged() {
    super._dimensionChanged();
    this._updateListDimensions();
  }
  _needPopupRepaint() {
    const dataController2 = this._dataController;
    const currentPageIndex = dataController2.pageIndex();
    const needRepaint = isDefined(this._pageIndex) && currentPageIndex <= this._pageIndex || dataController2.isLastPage() && !this._list._scrollViewIsFull();
    this._pageIndex = currentPageIndex;
    return needRepaint;
  }
  _updateListDimensions() {
    if (!this._popup) {
      return;
    }
    if (this._needPopupRepaint()) {
      this._popup.repaint();
    }
    if (this._list) {
      this._list.updateDimensions();
    }
  }
  _getMaxHeight() {
    const $element = this.$element();
    const $customBoundaryContainer = this._$customBoundaryContainer;
    const offsetTop = $element.offset().top - ($customBoundaryContainer ? $customBoundaryContainer.offset().top : 0);
    const windowHeight = getOuterHeight(window23);
    const containerHeight = $customBoundaryContainer ? Math.min(getOuterHeight($customBoundaryContainer), windowHeight) : windowHeight;
    const maxHeight = Math.max(offsetTop, containerHeight - offsetTop - getOuterHeight($element));
    return Math.min(0.5 * containerHeight, maxHeight);
  }
  _clean() {
    if (this._list) {
      delete this._list;
    }
    delete this._isLastMinSearchLengthExceeded;
    super._clean();
  }
  _dispose() {
    this._clearSearchTimer();
    super._dispose();
  }
  _setCollectionWidgetOption() {
    this._setListOption.apply(this, arguments);
  }
  _setSubmitValue() {
    const value2 = this.option("value");
    const submitValue = this._shouldUseDisplayValue(value2) ? this._displayGetter(value2) : value2;
    this._getSubmitElement().val(submitValue);
  }
  _shouldUseDisplayValue(value2) {
    return "this" === this.option("valueExpr") && isObject(value2);
  }
  _optionChanged(args) {
    this._dataExpressionOptionChanged(args);
    switch (args.name) {
      case "hoverStateEnabled":
      case "focusStateEnabled":
        this._isDesktopDevice() && this._setListOption(args.name, args.value);
        super._optionChanged(args);
        break;
      case "items":
        if (!this.option("dataSource")) {
          this._processDataSourceChanging();
        }
        break;
      case "dataSource":
        this._processDataSourceChanging();
        break;
      case "valueExpr":
        this._renderValue();
        this._setListOption("keyExpr", this._getCollectionKeyExpr());
        break;
      case "displayExpr":
        this._renderValue();
        this._setListOption("displayExpr", this._displayGetterExpr());
        break;
      case "searchMode":
        this._validateSearchMode();
        break;
      case "minSearchLength":
        this._refreshList();
        break;
      case "searchEnabled":
      case "showDataBeforeSearch":
      case "searchExpr":
        this._invalidate();
        break;
      case "onContentReady":
        this._initContentReadyAction();
        break;
      case "onSelectionChanged":
        this._initSelectionChangedAction();
        break;
      case "onItemClick":
        this._initItemClickAction();
        break;
      case "grouped":
      case "groupTemplate":
      case "wrapItemText":
      case "noDataText":
      case "encodeNoDataText":
      case "useItemTextAsTitle":
        this._setListOption(args.name);
        break;
      case "displayValue":
        this.option("text", args.value);
        break;
      case "itemTemplate":
      case "searchTimeout":
        break;
      case "selectedItem":
        if (args.previousValue !== args.value) {
          this._selectionChangedAction({
            selectedItem: args.value
          });
        }
        break;
      default:
        super._optionChanged(args);
    }
  }
};
DropDownList.include(ui_data_expression_default, m_grouped_data_converter_mixin_default);
component_registrator_default("dxDropDownList", DropDownList);
var m_drop_down_list_default = DropDownList;

// node_modules/devextreme/esm/__internal/ui/m_select_box.js
var SelectBox = class extends m_drop_down_list_default {
  _supportedKeys() {
    const that = this;
    const parent = super._supportedKeys();
    const clearSelectBox = function(e) {
      const isEditable2 = this._isEditable();
      if (!isEditable2) {
        if (this.option("showClearButton")) {
          e.preventDefault();
          this.clear();
        }
      } else if (this._valueSubstituted()) {
        this._preventFiltering = true;
      }
      this._savedTextRemoveEvent = e;
      this._preventSubstitution = true;
    };
    const searchIfNeeded = function() {
      if (that.option("searchEnabled") && that._valueSubstituted()) {
        that._searchHandler();
      }
    };
    return _extends({}, parent, {
      tab() {
        const {
          opened
        } = this.option();
        const popupHasFocusableElements = opened && !!this._popup.getFocusableElements().length;
        if (!popupHasFocusableElements) {
          this._resetCaretPosition(true);
        }
        parent.tab && parent.tab.apply(this, arguments);
        if (!popupHasFocusableElements) {
          this._cancelSearchIfNeed();
        }
      },
      upArrow(e) {
        if (parent.upArrow.apply(this, arguments)) {
          if (!this.option("opened")) {
            this._setNextValue(e);
          }
          return true;
        }
        return;
      },
      downArrow(e) {
        if (parent.downArrow.apply(this, arguments)) {
          if (!this.option("opened")) {
            this._setNextValue(e);
          }
          return true;
        }
        return;
      },
      leftArrow() {
        var _parent$leftArrow;
        searchIfNeeded();
        null === (_parent$leftArrow = parent.leftArrow) || void 0 === _parent$leftArrow || _parent$leftArrow.apply(this, arguments);
      },
      rightArrow() {
        var _parent$rightArrow;
        searchIfNeeded();
        null === (_parent$rightArrow = parent.rightArrow) || void 0 === _parent$rightArrow || _parent$rightArrow.apply(this, arguments);
      },
      home() {
        var _parent$home;
        searchIfNeeded();
        null === (_parent$home = parent.home) || void 0 === _parent$home || _parent$home.apply(this, arguments);
      },
      end() {
        var _parent$end;
        searchIfNeeded();
        null === (_parent$end = parent.end) || void 0 === _parent$end || _parent$end.apply(this, arguments);
      },
      escape() {
        var _parent$escape;
        const result2 = null === (_parent$escape = parent.escape) || void 0 === _parent$escape ? void 0 : _parent$escape.apply(this, arguments);
        this._cancelEditing();
        return result2 ?? true;
      },
      enter(e) {
        const isOpened = this.option("opened");
        const inputText = this._input().val().trim();
        const isCustomText = inputText && this._list && !this._list.option("focusedElement");
        if (!inputText && isDefined(this.option("value")) && this.option("allowClearing")) {
          this._saveValueChangeEvent(e);
          this.option({
            selectedItem: null,
            value: null
          });
          this.close();
        } else {
          var _parent$enter;
          if (this.option("acceptCustomValue")) {
            e.preventDefault();
            if (isCustomText) {
              if (isOpened) {
                this._toggleOpenState();
              }
              this._valueChangeEventHandler(e);
            }
            return isOpened;
          }
          if (null !== (_parent$enter = parent.enter) && void 0 !== _parent$enter && _parent$enter.apply(this, arguments)) {
            return isOpened;
          }
        }
      },
      space(e) {
        const isOpened = this.option("opened");
        const isSearchEnabled = this.option("searchEnabled");
        const acceptCustomValue = this.option("acceptCustomValue");
        if (!isOpened || isSearchEnabled || acceptCustomValue) {
          return;
        }
        e.preventDefault();
        this._valueChangeEventHandler(e);
        return true;
      },
      backspace: clearSelectBox,
      del: clearSelectBox
    });
  }
  _getDefaultOptions() {
    return _extends({}, super._getDefaultOptions(), {
      placeholder: message_default.format("Select"),
      fieldTemplate: null,
      customItemCreateEvent: "change",
      acceptCustomValue: false,
      onCustomItemCreating(e) {
        if (!isDefined(e.customItem)) {
          e.customItem = e.text;
        }
      },
      showSelectionControls: false,
      allowClearing: true,
      tooltipEnabled: false,
      openOnFieldClick: true,
      showDropDownButton: true,
      displayCustomValue: false,
      useHiddenSubmitElement: true
    });
  }
  _init() {
    super._init();
    this._initCustomItemCreatingAction();
  }
  _initMarkup() {
    this.$element().addClass("dx-selectbox");
    this._renderTooltip();
    super._initMarkup();
    this._$container.addClass("dx-selectbox-container");
  }
  _createPopup() {
    super._createPopup();
    this._popup.$element().addClass("dx-selectbox-popup");
    this._popup.$overlayContent().attr("tabindex", -1);
  }
  _popupWrapperClass() {
    return `${super._popupWrapperClass()} dx-selectbox-popup-wrapper`;
  }
  _cancelEditing() {
    if (!this.option("searchEnabled") && this._list) {
      this._focusListElement(null);
      this._updateField(this.option("selectedItem"));
    }
  }
  _renderOpenedState() {
    super._renderOpenedState();
    if (this.option("opened")) {
      this._scrollToSelectedItem();
      this._focusSelectedElement();
    }
  }
  _focusSelectedElement() {
    const searchValue = this._searchValue();
    if (!searchValue) {
      this._focusListElement(null);
      return;
    }
    const {
      items,
      selectedItem
    } = this.option();
    const $listItems = this._list._itemElements();
    const index2 = (null === items || void 0 === items ? void 0 : items.indexOf(selectedItem)) ?? -1;
    const focusedElement = -1 !== index2 && !this._isCustomItemSelected() ? $listItems.eq(index2) : null;
    this._focusListElement(focusedElement);
  }
  _renderFocusedElement() {
    if (!this._list) {
      return;
    }
    const searchValue = this._searchValue();
    if (!searchValue || this.option("acceptCustomValue")) {
      this._focusListElement(null);
      return;
    }
    const $listItems = this._list._itemElements();
    const focusedElement = $listItems.not(".dx-state-disabled").eq(0);
    this._focusListElement(focusedElement);
  }
  _focusListElement(element) {
    this._preventInputValueRender = true;
    this._list.option("focusedElement", getPublicElement(element));
    delete this._preventInputValueRender;
  }
  _scrollToSelectedItem() {
    var _this$_list;
    null === (_this$_list = this._list) || void 0 === _this$_list || _this$_list.scrollToItem(this._list.option("selectedItem"));
  }
  _listContentReadyHandler() {
    super._listContentReadyHandler();
    const isPaginate = this._dataController.paginate();
    if (isPaginate && this._needPopupRepaint()) {
      return;
    }
    this._scrollToSelectedItem();
  }
  _renderValue() {
    this._renderInputValue();
    this._setSubmitValue();
    return Deferred().resolve();
  }
  _renderInputValue() {
    return super._renderInputValue(...arguments).always(() => {
      this._renderInputValueAsync();
    });
  }
  _renderInputValueAsync() {
    this._renderTooltip();
    this._renderInputValueImpl().always(() => {
      this._refreshSelected();
    });
  }
  _renderInputValueImpl() {
    this._renderField();
    return Deferred().resolve();
  }
  _setNextItem(step) {
    const item = this._calcNextItem(step);
    const value2 = this._valueGetter(item);
    this._setValue(value2);
  }
  _setNextValue(e) {
    const dataSourceIsLoaded = this._dataController.isLoaded() ? Deferred().resolve() : this._dataController.load();
    dataSourceIsLoaded.done(() => {
      const selectedIndex = this._getSelectedIndex();
      const hasPages = this._dataController.pageSize();
      const isLastPage = this._dataController.isLastPage();
      const isLastItem = selectedIndex === this._items().length - 1;
      this._saveValueChangeEvent(e);
      const step = "downArrow" === normalizeKeyName(e) ? 1 : -1;
      if (hasPages && !isLastPage && isLastItem && step > 0) {
        if (!this._popup) {
          this._createPopup();
        }
        if (!this._dataController.isLoading()) {
          this._list._loadNextPage().done(this._setNextItem.bind(this, step));
        }
      } else {
        this._setNextItem(step);
      }
    });
  }
  _setSelectedItem(item) {
    const isUnknownItem = !this._isCustomValueAllowed() && void 0 === item;
    super._setSelectedItem(isUnknownItem ? null : item);
    if (!isUnknownItem && (!this._isEditable() || this._isCustomItemSelected())) {
      this._setListOption("selectedItem", this.option("selectedItem"));
    }
  }
  _isCustomValueAllowed() {
    return this.option("acceptCustomValue") || super._isCustomValueAllowed();
  }
  _displayValue(item) {
    item = !isDefined(item) && this._isCustomValueAllowed() ? this.option("value") : item;
    return super._displayValue(item);
  }
  _listConfig() {
    const result2 = extend(super._listConfig(), {
      pageLoadMode: "scrollBottom",
      onSelectionChanged: this._getSelectionChangeHandler(),
      selectedItem: this.option("selectedItem"),
      onFocusedItemChanged: this._listFocusedItemChangeHandler.bind(this),
      _onItemsRendered: () => {
        this._popup.repaint();
        if (this.option("opened")) {
          this._scrollToSelectedItem();
        }
      }
    });
    if (this.option("showSelectionControls")) {
      extend(result2, {
        showSelectionControls: true,
        selectByClick: true
      });
    }
    return result2;
  }
  _listFocusedItemChangeHandler(e) {
    if (this._preventInputValueRender) {
      return;
    }
    const list = e.component;
    const focusedElement = renderer_default(list.option("focusedElement"));
    const focusedItem = list._getItemData(focusedElement);
    this._updateField(focusedItem);
  }
  _updateField(item) {
    const fieldTemplate = this._getTemplateByOption("fieldTemplate");
    if (!(fieldTemplate && this.option("fieldTemplate"))) {
      const text = this._displayGetter(item);
      this.option("text", text);
      this._renderDisplayText(text);
      return;
    }
    this._renderField();
  }
  _getSelectionChangeHandler() {
    return this.option("showSelectionControls") ? this._selectionChangeHandler.bind(this) : noop2;
  }
  _selectionChangeHandler(e) {
    each(e.addedItems || [], (_, addedItem) => {
      this._setValue(this._valueGetter(addedItem));
    });
  }
  _getActualSearchValue() {
    return this._dataController.searchValue();
  }
  _isInlineAutocompleteEnabled() {
    const {
      searchEnabled,
      acceptCustomValue,
      searchMode
    } = this.option();
    return searchEnabled && !acceptCustomValue && "startswith" === searchMode;
  }
  _getAriaAutocomplete() {
    const {
      disabled,
      readOnly,
      searchEnabled
    } = this.option();
    const isInputEditable = !(readOnly || disabled);
    const hasAutocomplete = searchEnabled && isInputEditable;
    if (!hasAutocomplete) {
      return "none";
    }
    const isInlineAutocompleteEnabled = this._isInlineAutocompleteEnabled();
    const autocompleteAria = isInlineAutocompleteEnabled ? "both" : "list";
    return autocompleteAria;
  }
  _toggleOpenState(isVisible2) {
    if (this.option("disabled")) {
      return;
    }
    isVisible2 = arguments.length ? isVisible2 : !this.option("opened");
    if (!isVisible2 && !this._shouldClearFilter()) {
      this._restoreInputText(true);
    }
    if (this._wasSearch() && isVisible2) {
      this._wasSearch(false);
      const showDataImmediately = this.option("showDataBeforeSearch") || this._isMinSearchLengthExceeded();
      if (showDataImmediately && this._dataController.getDataSource()) {
        if (this._searchTimer) {
          return;
        }
        const searchValue = this._getActualSearchValue();
        searchValue && this._wasSearch(true);
        this._filterDataSource(searchValue || null);
      } else {
        this._setListOption("items", []);
      }
    }
    if (isVisible2) {
      this._scrollToSelectedItem();
    }
    super._toggleOpenState(isVisible2);
  }
  _renderTooltip() {
    const {
      tooltipEnabled,
      displayValue
    } = this.option();
    if (tooltipEnabled) {
      this.$element().attr("title", displayValue);
    }
  }
  _renderDimensions() {
    super._renderDimensions();
    this._updatePopupWidth();
    this._updateListDimensions();
  }
  _isValueEqualInputText() {
    const initialSelectedItem = this.option("selectedItem");
    if (null === initialSelectedItem) {
      return false;
    }
    const value2 = this._displayGetter(initialSelectedItem);
    const displayValue = value2 ? String(value2) : "";
    const inputText = this._searchValue();
    return displayValue === inputText;
  }
  _popupHidingHandler() {
    if (this._isValueEqualInputText()) {
      this._cancelEditing();
    }
    super._popupHidingHandler();
  }
  _popupHiddenHandler() {
    super._popupHiddenHandler();
    if (this._shouldCancelSearch()) {
      this._wasSearch(false);
      this._searchCanceled();
      this._shouldCancelSearch(false);
    }
  }
  _restoreInputText(saveEditingValue) {
    var _this$_loadItemDeferr;
    if (this.option("readOnly")) {
      return;
    }
    null === (_this$_loadItemDeferr = this._loadItemDeferred) || void 0 === _this$_loadItemDeferr || _this$_loadItemDeferr.always(() => {
      const {
        acceptCustomValue,
        text,
        selectedItem: initialSelectedItem,
        customItemCreateEvent
      } = this.option();
      if (acceptCustomValue) {
        if (!saveEditingValue && !this._isValueChanging) {
          let initialItem = null;
          if (isDefined(initialSelectedItem)) {
            initialItem = initialSelectedItem;
          } else if ("" !== customItemCreateEvent) {
            initialItem = this._createCustomItem(text);
          }
          this._updateField(initialItem);
          this._clearFilter();
        }
        return;
      }
      if (this.option("searchEnabled")) {
        if (!this._searchValue() && this.option("allowClearing")) {
          this._clearTextValue();
          return;
        }
      }
      if (this._isValueEqualInputText()) {
        return;
      }
      this._renderInputValue().always((selectedItem) => {
        const newSelectedItem = ensureDefined(selectedItem, initialSelectedItem);
        this._setSelectedItem(newSelectedItem);
        this._updateField(newSelectedItem);
        this._clearFilter();
      });
    });
  }
  _valueChangeEventIncludesBlur() {
    const valueChangeEvent = this.option(this._getValueChangeEventOptionName());
    return valueChangeEvent.includes("blur");
  }
  _isPreventedFocusOutEvent(e) {
    return this._preventNestedFocusEvent(e) || this._valueChangeEventIncludesBlur();
  }
  _focusOutHandler(e) {
    if (!this._isPreventedFocusOutEvent(e)) {
      const isOverlayTarget = this._isOverlayNestedTarget(e.relatedTarget);
      if (!isOverlayTarget) {
        this._restoreInputText();
        this._clearSearchTimer();
      }
      this._cancelSearchIfNeed(e);
    }
    e.target = this._input().get(0);
    super._focusOutHandler(e);
  }
  _cancelSearchIfNeed(e) {
    const {
      searchEnabled
    } = this.option();
    const isOverlayTarget = this._isOverlayNestedTarget(null === e || void 0 === e ? void 0 : e.relatedTarget);
    const shouldCancelSearch = this._wasSearch() && searchEnabled && !isOverlayTarget;
    if (shouldCancelSearch) {
      var _this$_popup;
      const isPopupVisible = null === (_this$_popup = this._popup) || void 0 === _this$_popup ? void 0 : _this$_popup._hideAnimationProcessing;
      this._clearSearchTimer();
      if (isPopupVisible) {
        this._shouldCancelSearch(true);
      } else {
        this._wasSearch(false);
        this._searchCanceled();
      }
    }
  }
  _shouldCancelSearch(value2) {
    if (!arguments.length) {
      return this._shouldCancelSearchValue;
    }
    this._shouldCancelSearchValue = value2;
  }
  _isOverlayNestedTarget(target) {
    return !!renderer_default(target).closest(".dx-selectbox-popup-wrapper").length;
  }
  _clearTextValue() {
    const selectedItem = this.option("selectedItem");
    const selectedItemText = this._displayGetter(selectedItem);
    const shouldRestoreValue = selectedItem && "" !== selectedItemText;
    if (shouldRestoreValue) {
      if (this._savedTextRemoveEvent) {
        this._saveValueChangeEvent(this._savedTextRemoveEvent);
      }
      this.option("value", null);
    }
    delete this._savedTextRemoveEvent;
  }
  _shouldOpenPopup() {
    return this._needPassDataSourceToList() && this._wasSearch();
  }
  _isFocused() {
    const activeElement = dom_adapter_default.getActiveElement(this.element());
    return super._isFocused() && renderer_default(activeElement).closest(this._input()).length > 0;
  }
  _getValueChangeEventOptionName() {
    return "customItemCreateEvent";
  }
  _renderValueChangeEvent() {
    if (this._isEditable()) {
      super._renderValueChangeEvent();
    }
  }
  _fieldRenderData() {
    const {
      focusedElement
    } = this.option();
    const $listFocused = this._list && this.option("opened") && renderer_default(focusedElement);
    if (null !== $listFocused && void 0 !== $listFocused && $listFocused.length) {
      return this._list._getItemData($listFocused);
    }
    return this.option("selectedItem");
  }
  _isSelectedValue(value2, cache) {
    return this._isValueEquals(value2, this.option("value"));
  }
  _shouldCloseOnItemClick() {
    const {
      selectionMode
    } = this.option();
    return !(this.option("showSelectionControls") && "single" !== selectionMode);
  }
  _listItemClickHandler(e) {
    const previousValue = this._getCurrentValue();
    this._focusListElement(renderer_default(e.itemElement));
    this._saveValueChangeEvent(e.event);
    this._completeSelection(this._valueGetter(e.itemData));
    if (this._shouldCloseOnItemClick()) {
      this.option("opened", false);
    }
    if (this.option("searchEnabled") && previousValue === this._valueGetter(e.itemData)) {
      this._updateField(e.itemData);
    }
    if (this._shouldClearFilter()) {
      this._cancelSearchIfNeed();
    }
  }
  _shouldClearFilter() {
    return this._wasSearch();
  }
  _completeSelection(value2) {
    this._setValue(value2);
  }
  _loadItem(value2, cache) {
    const that = this;
    const deferred = Deferred();
    super._loadItem(value2, cache).done((item) => {
      deferred.resolve(item);
    }).fail((args) => {
      if (null !== args && void 0 !== args && args.shouldSkipCallback) {
        return;
      }
      const selectedItem = that.option("selectedItem");
      if (that.option("acceptCustomValue") && value2 === that._valueGetter(selectedItem)) {
        deferred.resolve(selectedItem);
      } else {
        deferred.reject();
      }
    });
    return deferred.promise();
  }
  _loadInputValue(value2, callback) {
    this._loadItemDeferred = this._loadItem(value2).always(callback);
    return this._loadItemDeferred;
  }
  _isCustomItemSelected() {
    const selectedItem = this.option("selectedItem");
    const searchValue = this._searchValue();
    const selectedItemText = this._displayGetter(selectedItem);
    return !selectedItemText || searchValue !== selectedItemText.toString();
  }
  _valueChangeEventHandler(e) {
    if (this.option("acceptCustomValue") && this._isCustomItemSelected() && !this._isValueChanging) {
      this._isValueChanging = true;
      this._customItemAddedHandler(e);
    }
  }
  _initCustomItemCreatingAction() {
    this._customItemCreatingAction = this._createActionByOption("onCustomItemCreating");
  }
  _createCustomItem(text) {
    const params = {
      text
    };
    const actionResult = this._customItemCreatingAction(params);
    const item = ensureDefined(actionResult, params.customItem);
    if (isDefined(actionResult)) {
      errors_default.log("W0015", "onCustomItemCreating", "customItem");
    }
    return item;
  }
  _customItemAddedHandler(e) {
    const searchValue = this._searchValue();
    const item = this._createCustomItem(searchValue);
    this._saveValueChangeEvent(e);
    if (void 0 === item) {
      this._renderValue();
      throw errors_default.Error("E0121");
    }
    if (isPromise(item)) {
      fromPromise(item).done(this._setCustomItem.bind(this)).fail(this._setCustomItem.bind(this, null));
    } else {
      this._setCustomItem(item);
    }
  }
  _setCustomItem(item) {
    if (this._disposed) {
      return;
    }
    item = item || null;
    this.option("selectedItem", item);
    this._cancelSearchIfNeed();
    this._setValue(this._valueGetter(item));
    this._renderDisplayText(this._displayGetter(item));
    this._isValueChanging = false;
  }
  _clearValueHandler(e) {
    this._preventFiltering = true;
    super._clearValueHandler(e);
    this._searchCanceled();
    return false;
  }
  _wasSearch(value2) {
    if (!arguments.length) {
      return !!this._wasSearchValue;
    }
    this._wasSearchValue = value2;
    return;
  }
  _searchHandler(e) {
    if (this._preventFiltering) {
      delete this._preventFiltering;
      return;
    }
    if (this._needPassDataSourceToList()) {
      this._wasSearch(true);
    }
    super._searchHandler(arguments);
  }
  _dataSourceFiltered(searchValue) {
    super._dataSourceFiltered();
    if (null !== searchValue) {
      this._renderInputSubstitution();
      this._renderFocusedElement();
    }
  }
  _valueSubstituted() {
    const input = this._input().get(0);
    const currentSearchLength = this._searchValue().length;
    const isAllSelected = 0 === input.selectionStart && input.selectionEnd === currentSearchLength;
    const inputHasSelection = input.selectionStart !== input.selectionEnd;
    const isLastSymbolSelected = currentSearchLength === input.selectionEnd;
    return this._wasSearch() && inputHasSelection && !isAllSelected && isLastSymbolSelected && this._shouldSubstitutionBeRendered();
  }
  _shouldSubstitutionBeRendered() {
    return !this._preventSubstitution && this._isInlineAutocompleteEnabled();
  }
  _renderInputSubstitution() {
    if (!this._shouldSubstitutionBeRendered()) {
      delete this._preventSubstitution;
      return;
    }
    const item = this._list && this._getPlainItems(this._list.option("items"))[0];
    if (!item) {
      return;
    }
    const $input = this._input();
    const valueLength = $input.val().length;
    if (0 === valueLength) {
      return;
    }
    const inputElement = $input.get(0);
    const displayValue = this._displayGetter(item).toString();
    inputElement.value = displayValue;
    this._caret({
      start: valueLength,
      end: displayValue.length
    });
  }
  _dispose() {
    this._renderInputValueAsync = noop2;
    delete this._loadItemDeferred;
    super._dispose();
  }
  _optionChanged(args) {
    switch (args.name) {
      case "customItemCreateEvent":
        this._refreshValueChangeEvent();
        this._refreshFocusEvent();
        this._refreshEvents();
        break;
      case "onCustomItemCreating":
        this._initCustomItemCreatingAction();
        break;
      case "tooltipEnabled":
        this._renderTooltip();
        break;
      case "readOnly":
      case "disabled":
      case "searchMode":
        super._optionChanged(args);
        this._setDefaultAria();
        break;
      case "displayCustomValue":
      case "acceptCustomValue":
      case "showSelectionControls":
        this._invalidate();
        break;
      case "allowClearing":
        break;
      default:
        super._optionChanged(args);
    }
  }
};
component_registrator_default("dxSelectBox", SelectBox);
var m_select_box_default = SelectBox;

// node_modules/devextreme/esm/ui/select_box.js
var select_box_default = m_select_box_default;

// node_modules/devextreme/esm/__internal/events/gesture/m_swipeable.js
var DX_SWIPEABLE = "dxSwipeable";
var ACTION_TO_EVENT_MAP = {
  onStart: SWIPE_START_EVENT,
  onUpdated: SWIPE_EVENT,
  onEnd: SWIPE_END_EVENT,
  onCancel: "dxswipecancel"
};
var Swipeable = class extends dom_component_default {
  _getDefaultOptions() {
    return _extends({}, super._getDefaultOptions(), {
      elastic: true,
      immediate: false,
      immediateTimeout: 180,
      direction: "horizontal",
      itemSizeFunc: null,
      onStart: null,
      onUpdated: null,
      onEnd: null,
      onCancel: null
    });
  }
  _render() {
    super._render();
    this.$element().addClass("dx-swipeable");
    this._attachEventHandlers();
  }
  _attachEventHandlers() {
    this._detachEventHandlers();
    if (this.option("disabled")) {
      return;
    }
    const {
      NAME
    } = this;
    this._createEventData();
    each(ACTION_TO_EVENT_MAP, (actionName, eventName) => {
      const action = this._createActionByOption(actionName, {
        context: this
      });
      eventName = addNamespace2(eventName, NAME);
      m_events_engine_default.on(this.$element(), eventName, this._eventData, (e) => action({
        event: e
      }));
    });
  }
  _createEventData() {
    this._eventData = {
      elastic: this.option("elastic"),
      itemSizeFunc: this.option("itemSizeFunc"),
      direction: this.option("direction"),
      immediate: this.option("immediate"),
      immediateTimeout: this.option("immediateTimeout")
    };
  }
  _detachEventHandlers() {
    m_events_engine_default.off(this.$element(), `.${DX_SWIPEABLE}`);
  }
  _optionChanged(args) {
    switch (args.name) {
      case "disabled":
      case "onStart":
      case "onUpdated":
      case "onEnd":
      case "onCancel":
      case "elastic":
      case "immediate":
      case "itemSizeFunc":
      case "direction":
        this._detachEventHandlers();
        this._attachEventHandlers();
        break;
      case "rtlEnabled":
        break;
      default:
        super._optionChanged(args);
    }
  }
  _useTemplates() {
    return false;
  }
};
getName(Swipeable, DX_SWIPEABLE);
var m_swipeable_default = Swipeable;

// node_modules/devextreme/esm/__internal/ui/calendar/m_calendar.selection.strategy.js
var CalendarSelectionStrategy = class {
  constructor(component) {
    this.calendar = component;
  }
  dateOption(optionName) {
    return this.calendar._dateOption(optionName);
  }
  dateValue(value2, e) {
    this.calendar._dateValue(value2, e);
  }
  skipNavigate() {
    this.calendar._skipNavigate = true;
  }
  updateAriaSelected(value2, previousValue) {
    this.calendar._updateAriaSelected(value2, previousValue);
    if (value2[0] && this.calendar.option("currentDate").getTime() === value2[0].getTime()) {
      this.calendar._updateAriaId(value2[0]);
    }
  }
  processValueChanged(value2, previousValue) {
    var _value, _previousValue;
    if (isDefined(value2) && !Array.isArray(value2)) {
      value2 = [value2];
    }
    if (isDefined(previousValue) && !Array.isArray(previousValue)) {
      previousValue = [previousValue];
    }
    value2 = (null === (_value = value2) || void 0 === _value ? void 0 : _value.map((item) => this._convertToDate(item))) || [];
    previousValue = (null === (_previousValue = previousValue) || void 0 === _previousValue ? void 0 : _previousValue.map((item) => this._convertToDate(item))) || [];
    this._updateViewsValue(value2);
    this.updateAriaSelected(value2, previousValue);
    if (!this._currentDateChanged) {
      this.calendar._initCurrentDate();
    }
    this._currentDateChanged = false;
  }
  _isDateDisabled(date) {
    const min = this.calendar._dateOption("min");
    const max = this.calendar._dateOption("max");
    const isLessThanMin = isDefined(min) && date < min && !date_default.sameDate(min, date);
    const isBiggerThanMax = isDefined(max) && date > max && !date_default.sameDate(max, date);
    return this.calendar._view.isDateDisabled(date) || isLessThanMin || isBiggerThanMax;
  }
  _getLowestDateInArray(dates) {
    if (dates.length) {
      return new Date(Math.min(...dates));
    }
  }
  _convertToDate(value2) {
    return this.calendar._convertToDate(value2);
  }
  _isMaxZoomLevel() {
    return this.calendar._isMaxZoomLevel();
  }
  _updateViewsOption(optionName, optionValue) {
    this.calendar._updateViewsOption(optionName, optionValue);
  }
  _updateViewsValue(value2) {
    this._updateViewsOption("value", value2);
  }
  _updateCurrentDate(value2) {
    this.calendar.option("currentDate", value2 ?? /* @__PURE__ */ new Date());
  }
  _shouldHandleWeekNumberClick() {
    const {
      selectionMode,
      selectWeekOnClick
    } = this.calendar.option();
    return selectWeekOnClick && "single" !== selectionMode;
  }
};
var m_calendar_selection_strategy_default = CalendarSelectionStrategy;

// node_modules/devextreme/esm/__internal/ui/calendar/m_calendar.multiple.selection.strategy.js
var CalendarMultiSelectionStrategy = class extends m_calendar_selection_strategy_default {
  constructor(component) {
    super(component);
    this.NAME = "MultiSelection";
  }
  getViewOptions() {
    return {
      value: this.dateOption("value"),
      range: [],
      selectionMode: "multiple",
      onWeekNumberClick: this._shouldHandleWeekNumberClick() ? this._weekNumberClickHandler.bind(this) : null
    };
  }
  selectValue(selectedValue, e) {
    const value2 = [...this.dateOption("value")];
    const alreadySelectedIndex = value2.findIndex((date) => (null === date || void 0 === date ? void 0 : date.toDateString()) === selectedValue.toDateString());
    if (alreadySelectedIndex > -1) {
      value2.splice(alreadySelectedIndex, 1);
    } else {
      value2.push(selectedValue);
    }
    this.skipNavigate();
    this._updateCurrentDate(selectedValue);
    this._currentDateChanged = true;
    this.dateValue(value2, e);
  }
  updateAriaSelected(value2, previousValue) {
    value2 ?? (value2 = this.dateOption("value"));
    previousValue ?? (previousValue = []);
    super.updateAriaSelected(value2, previousValue);
  }
  getDefaultCurrentDate() {
    const dates = this.dateOption("value").filter(Boolean);
    return this._getLowestDateInArray(dates);
  }
  restoreValue() {
    this.calendar.option("value", []);
  }
  _weekNumberClickHandler(_ref) {
    let {
      rowDates,
      event
    } = _ref;
    const selectedDates = rowDates.filter((date) => !this._isDateDisabled(date));
    this.dateValue(selectedDates, event);
  }
};
var m_calendar_multiple_selection_strategy_default = CalendarMultiSelectionStrategy;

// node_modules/devextreme/esm/__internal/ui/calendar/m_calendar.navigator.js
var Navigator = class extends widget_default {
  _getDefaultOptions() {
    return _extends({}, super._getDefaultOptions(), {
      onClick: void 0,
      onCaptionClick: void 0,
      type: "normal",
      stylingMode: "outlined",
      text: ""
    });
  }
  _defaultOptionsRules() {
    return super._defaultOptionsRules().concat([{
      device: () => isMaterial(),
      options: {
        type: "default",
        stylingMode: "text"
      }
    }, {
      device: () => isFluent(),
      options: {
        type: "normal",
        stylingMode: "text"
      }
    }]);
  }
  _init() {
    super._init();
    this._initActions();
  }
  _initActions() {
    this._clickAction = this._createActionByOption("onClick");
    this._captionClickAction = this._createActionByOption("onCaptionClick");
  }
  _initMarkup() {
    super._initMarkup();
    renderer_default(this.element()).addClass("dx-calendar-navigator");
    this._renderButtons();
    this._renderCaption();
  }
  _renderButtons() {
    const {
      rtlEnabled,
      type: type2,
      stylingMode,
      focusStateEnabled
    } = this.option();
    this._prevButton = this._createComponent(renderer_default("<div>"), button_default2, {
      focusStateEnabled,
      icon: rtlEnabled ? "chevronright" : "chevronleft",
      onClick: (e) => {
        var _this$_clickAction;
        null === (_this$_clickAction = this._clickAction) || void 0 === _this$_clickAction || _this$_clickAction.call(this, {
          direction: -1,
          event: e
        });
      },
      type: type2,
      stylingMode,
      integrationOptions: {}
    });
    const $prevButton = renderer_default(this._prevButton.element()).addClass("dx-calendar-navigator-previous-view").addClass("dx-calendar-navigator-previous-month");
    this._nextButton = this._createComponent(renderer_default("<div>"), button_default2, {
      focusStateEnabled,
      icon: rtlEnabled ? "chevronleft" : "chevronright",
      onClick: (e) => {
        var _this$_clickAction2;
        null === (_this$_clickAction2 = this._clickAction) || void 0 === _this$_clickAction2 || _this$_clickAction2.call(this, {
          direction: 1,
          event: e
        });
      },
      type: type2,
      stylingMode,
      integrationOptions: {}
    });
    const $nextButton = renderer_default(this._nextButton.element()).addClass("dx-calendar-navigator-next-view").addClass("dx-calendar-navigator-next-month");
    this._caption = this._createComponent(renderer_default("<div>").addClass("dx-calendar-caption-button"), button_default2, {
      focusStateEnabled,
      onClick: (e) => {
        var _this$_captionClickAc;
        null === (_this$_captionClickAc = this._captionClickAction) || void 0 === _this$_captionClickAc || _this$_captionClickAc.call(this, {
          event: e
        });
      },
      type: type2,
      stylingMode,
      template: (_, content) => {
        const {
          text
        } = this.option();
        const viewCaptionTexts = text.split(" - ");
        viewCaptionTexts.forEach((captionText) => {
          renderer_default(content).append(renderer_default("<span>").addClass("dx-button-text").text(captionText));
        });
      },
      integrationOptions: {}
    });
    const $caption = this._caption.$element();
    this.$element().append($prevButton).append($caption).append($nextButton);
  }
  _renderCaption() {
    var _this$_caption;
    const {
      text
    } = this.option();
    null === (_this$_caption = this._caption) || void 0 === _this$_caption || _this$_caption.option("text", text);
  }
  toggleButton(buttonPrefix, value2) {
    const buttonName = `_${buttonPrefix}Button`;
    const button = this[buttonName];
    if (button) {
      button.option("disabled", value2);
      button.$element().toggleClass("dx-calendar-disabled-navigator-link", value2);
    }
  }
  _optionChanged(args) {
    if ("text" === args.name) {
      this._renderCaption();
    } else {
      super._optionChanged(args);
    }
  }
};
var m_calendar_navigator_default = Navigator;

// node_modules/devextreme/esm/__internal/ui/calendar/m_calendar.range.selection.strategy.js
var CalendarRangeSelectionStrategy = class extends m_calendar_selection_strategy_default {
  constructor(component) {
    super(component);
    this.NAME = "RangeSelection";
  }
  getViewOptions() {
    const value2 = this._getValue();
    const range = this._getDaysInRange(value2[0], value2[1]);
    return {
      value: value2,
      range,
      selectionMode: "range",
      onCellHover: this._cellHoverHandler.bind(this),
      onWeekNumberClick: this._shouldHandleWeekNumberClick() ? this._weekNumberClickHandler.bind(this) : null
    };
  }
  selectValue(selectedValue, e) {
    const [startDate, endDate] = this._getValue();
    this.skipNavigate();
    this._updateCurrentDate(selectedValue);
    this._currentDateChanged = true;
    if (true === this.calendar.option("_allowChangeSelectionOrder")) {
      this.calendar._valueSelected = true;
      if ("startDate" === this.calendar.option("_currentSelection")) {
        if (this.calendar._convertToDate(selectedValue) > this.calendar._convertToDate(endDate)) {
          this.dateValue([selectedValue, null], e);
        } else {
          this.dateValue([selectedValue, endDate], e);
        }
      } else if (this.calendar._convertToDate(selectedValue) >= this.calendar._convertToDate(startDate)) {
        this.dateValue([startDate, selectedValue], e);
      } else {
        this.dateValue([selectedValue, null], e);
      }
    } else if (!startDate || endDate) {
      this.dateValue([selectedValue, null], e);
    } else {
      this.dateValue(startDate < selectedValue ? [startDate, selectedValue] : [selectedValue, startDate], e);
    }
  }
  updateAriaSelected(value2, previousValue) {
    value2 ?? (value2 = this._getValue());
    previousValue ?? (previousValue = []);
    super.updateAriaSelected(value2, previousValue);
  }
  processValueChanged(value2, previousValue) {
    super.processValueChanged(value2, previousValue);
    const range = this._getRange();
    this._updateViewsOption("range", range);
  }
  getDefaultCurrentDate() {
    const {
      _allowChangeSelectionOrder,
      _currentSelection
    } = this.calendar.option();
    const value2 = this.dateOption("value");
    if (_allowChangeSelectionOrder) {
      if ("startDate" === _currentSelection && value2[0]) {
        return value2[0];
      }
      if ("endDate" === _currentSelection && value2[1]) {
        return value2[1];
      }
    }
    const dates = value2.filter((value3) => value3);
    return this._getLowestDateInArray(dates);
  }
  restoreValue() {
    this.calendar.option("value", [null, null]);
  }
  _getValue() {
    const value2 = this.dateOption("value");
    if (!value2.length) {
      return value2;
    }
    let [startDate, endDate] = value2;
    if (startDate && endDate && startDate > endDate) {
      [startDate, endDate] = [endDate, startDate];
    }
    return [startDate, endDate];
  }
  _getRange() {
    const [startDate, endDate] = this._getValue();
    return this._getDaysInRange(startDate, endDate);
  }
  _getDaysInRange(startDate, endDate) {
    if (!startDate || !endDate) {
      return [];
    }
    const {
      currentDate,
      viewsCount
    } = this.calendar.option();
    const isAdditionalViewDate = this.calendar._isAdditionalViewDate(currentDate);
    const firstDateInViews = date_default.getFirstMonthDate(currentDate, isAdditionalViewDate ? -2 : -1);
    const lastDateInViews = date_default.getLastMonthDate(currentDate, isAdditionalViewDate ? 1 : viewsCount);
    const rangeStartDate = new Date(Math.max(firstDateInViews, startDate));
    const rangeEndDate = new Date(Math.min(lastDateInViews, endDate));
    return [...date_default.getDatesOfInterval(rangeStartDate, rangeEndDate, 864e5), rangeEndDate];
  }
  _cellHoverHandler(e) {
    const isMaxZoomLevel = this._isMaxZoomLevel();
    const [startDate, endDate] = this._getValue();
    const {
      _allowChangeSelectionOrder,
      _currentSelection
    } = this.calendar.option();
    if (isMaxZoomLevel) {
      const skipHoveredRange = _allowChangeSelectionOrder && "startDate" === _currentSelection;
      if (startDate && !endDate && !skipHoveredRange) {
        if (e.value > startDate) {
          this._updateViewsOption("hoveredRange", this._getDaysInRange(startDate, e.value));
          return;
        }
      } else if (!startDate && endDate && !(_allowChangeSelectionOrder && "endDate" === _currentSelection)) {
        if (e.value < endDate) {
          this._updateViewsOption("hoveredRange", this._getDaysInRange(e.value, endDate));
          return;
        }
      } else if (startDate && endDate) {
        if ("startDate" === _currentSelection && e.value < startDate) {
          this._updateViewsOption("hoveredRange", this._getDaysInRange(e.value, startDate));
          return;
        }
        if ("endDate" === _currentSelection && e.value > endDate) {
          this._updateViewsOption("hoveredRange", this._getDaysInRange(endDate, e.value));
          return;
        }
      }
      this._updateViewsOption("hoveredRange", []);
    }
  }
  _weekNumberClickHandler(_ref) {
    let {
      rowDates,
      event
    } = _ref;
    const selectedDates = rowDates.filter((date) => !this._isDateDisabled(date));
    const value2 = selectedDates.length ? [selectedDates[0], selectedDates[selectedDates.length - 1]] : [null, null];
    this.dateValue(value2, event);
  }
};
var m_calendar_range_selection_strategy_default = CalendarRangeSelectionStrategy;

// node_modules/devextreme/esm/__internal/ui/calendar/m_calendar.single.selection.strategy.js
var CalendarSingleSelectionStrategy = class extends m_calendar_selection_strategy_default {
  constructor(component) {
    super(component);
    this.NAME = "SingleSelection";
  }
  getViewOptions() {
    return {
      value: this.dateOption("value"),
      range: [],
      selectionMode: "single"
    };
  }
  selectValue(selectedValue, e) {
    this.skipNavigate();
    this.dateValue(selectedValue, e);
  }
  updateAriaSelected(value2, previousValue) {
    value2 ?? (value2 = [this.dateOption("value")]);
    previousValue ?? (previousValue = []);
    super.updateAriaSelected(value2, previousValue);
  }
  getDefaultCurrentDate() {
    const date = this.dateOption("value");
    if ("" === date) {
      return /* @__PURE__ */ new Date();
    }
    return date;
  }
  restoreValue() {
    this.calendar.option("value", null);
  }
  _updateViewsValue(value2) {
    this._updateViewsOption("value", value2[0]);
  }
};
var m_calendar_single_selection_strategy_default = CalendarSingleSelectionStrategy;

// node_modules/devextreme/esm/__internal/ui/calendar/m_calendar.base_view.js
var NOT_WEEK_CELL_SELECTOR = "td:not(.dx-calendar-week-number-cell)";
var CALENDAR_DXCLICK_EVENT_NAME = addNamespace2(CLICK_EVENT_NAME, "dxCalendar");
var CALENDAR_DXHOVERSTART_EVENT_NAME = addNamespace2(HOVERSTART, "dxCalendar");
var CURRENT_DATE_TEXT = {
  month: message_default.format("dxCalendar-currentDay"),
  year: message_default.format("dxCalendar-currentMonth"),
  decade: message_default.format("dxCalendar-currentYear"),
  century: message_default.format("dxCalendar-currentYearRange")
};
var SELECTION_MODE2 = {
  single: "single",
  multiple: "multiple",
  range: "range"
};
var BaseView = class extends widget_default {
  _getViewName() {
    return "base";
  }
  _getDefaultOptions() {
    return _extends({}, super._getDefaultOptions(), {
      date: /* @__PURE__ */ new Date(),
      focusStateEnabled: false,
      cellTemplate: null,
      disabledDates: null,
      onCellClick: null,
      onCellHover: null,
      onWeekNumberClick: null,
      rowCount: 3,
      colCount: 4,
      allowValueSelection: true,
      _todayDate: () => /* @__PURE__ */ new Date()
    });
  }
  _initMarkup() {
    super._initMarkup();
    this._renderImpl();
  }
  _renderImpl() {
    this.$element().append(this._createTable());
    this._createDisabledDatesHandler();
    this._renderBody();
    this._renderContouredDate();
    this._renderValue();
    this._renderRange();
    this._renderEvents();
    this._updateTableAriaLabel();
  }
  _getLocalizedWidgetName() {
    const localizedWidgetName = message_default.format("dxCalendar-ariaWidgetName");
    return localizedWidgetName;
  }
  _getSingleModeAriaLabel() {
    const {
      value: value2
    } = this.option();
    const localizedWidgetName = this._getLocalizedWidgetName();
    const formattedDate = date_default3.format(value2, "date");
    const selectedDatesText = message_default.format("dxCalendar-selectedDate", formattedDate);
    const ariaLabel = `${localizedWidgetName}. ${selectedDatesText}`;
    return ariaLabel;
  }
  _getRangeModeAriaLabel() {
    const {
      value: value2
    } = this.option();
    const localizedWidgetName = this._getLocalizedWidgetName();
    const [startDate, endDate] = value2;
    const formattedStartDate = date_default3.format(startDate, "date");
    const formattedEndDate = date_default3.format(endDate, "date");
    const selectedDatesText = startDate && endDate ? message_default.format("dxCalendar-selectedDateRange", formattedStartDate, formattedEndDate) : message_default.format("dxCalendar-selectedDate", formattedStartDate ?? formattedEndDate);
    const ariaLabel = `${localizedWidgetName}. ${selectedDatesText}`;
    return ariaLabel;
  }
  _getMultipleModeAriaLabel() {
    const localizedWidgetName = this._getLocalizedWidgetName();
    const selectedRangesText = this._getMultipleRangesText();
    const ariaLabel = `${localizedWidgetName}. ${selectedRangesText}`;
    return ariaLabel;
  }
  _getMultipleRangesText() {
    const {
      value: value2
    } = this.option();
    const ranges = date_default.getRangesByDates(value2.map((date) => new Date(date)));
    if (ranges.length > 2) {
      const dateRangeCountText = message_default.format("dxCalendar-selectedDateRangeCount", ranges.length);
      return dateRangeCountText;
    }
    const selectedDatesText = message_default.format("dxCalendar-selectedDates");
    const rangesText = ranges.map((range) => this._getRangeText(range)).join(", ");
    const result2 = `${selectedDatesText}: ${rangesText}`;
    return result2;
  }
  _getRangeText(range) {
    const [startDate, endDate] = range;
    const formattedStartDate = date_default3.format(startDate, "date");
    const formattedEndDate = date_default3.format(endDate, "date");
    const selectedDatesText = startDate && endDate ? message_default.format("dxCalendar-selectedMultipleDateRange", formattedStartDate, formattedEndDate) : formattedStartDate;
    return selectedDatesText;
  }
  _getTableAriaLabel() {
    const {
      value: value2,
      selectionMode
    } = this.option();
    const isValueEmpty = !value2 || Array.isArray(value2) && !value2.filter(Boolean).length;
    if (isValueEmpty) {
      return this._getLocalizedWidgetName();
    }
    switch (selectionMode) {
      case SELECTION_MODE2.single:
        return this._getSingleModeAriaLabel();
      case SELECTION_MODE2.range:
        return this._getRangeModeAriaLabel();
      case SELECTION_MODE2.multiple:
        return this._getMultipleModeAriaLabel();
    }
  }
  _updateTableAriaLabel() {
    const label = this._getTableAriaLabel();
    this.setAria({
      label
    }, this._$table);
  }
  _createTable() {
    this._$table = renderer_default("<table>");
    this.setAria({
      role: "grid"
    }, this._$table);
    return this._$table;
  }
  _renderBody() {
    this.$body = renderer_default("<tbody>").appendTo(this._$table);
    const rowData = {
      cellDate: this._getFirstCellData(),
      prevCellDate: null
    };
    const {
      rowCount: rowsCount,
      colCount: colsCount
    } = this.option();
    for (let rowIndex = 0, rowCount = rowsCount; rowIndex < rowCount; rowIndex++) {
      rowData.row = this._createRow();
      for (let colIndex = 0, colCount = colsCount; colIndex < colCount; colIndex++) {
        this._renderCell(rowData, colIndex);
      }
      this._renderWeekNumberCell(rowData);
    }
  }
  _renderWeekNumberCell(rowData) {
  }
  _createRow() {
    const row = dom_adapter_default.createElement("tr");
    this.setAria("role", "row", renderer_default(row));
    this.$body.get(0).appendChild(row);
    return row;
  }
  _createCell(cellDate, cellIndex) {
    const cell = dom_adapter_default.createElement("td");
    const $cell = renderer_default(cell);
    cell.className = this._getClassNameByDate(cellDate, cellIndex);
    cell.setAttribute("data-value", date_serialization_default.serializeDate(cellDate, date_default.getShortDateFormat()));
    data(cell, "dxDateValueKey", cellDate);
    this.setAria({
      role: "gridcell",
      selected: false,
      label: this.getCellAriaLabel(cellDate)
    }, $cell);
    return {
      cell,
      $cell
    };
  }
  _renderCell(params, cellIndex) {
    const {
      cellDate,
      prevCellDate,
      row
    } = params;
    if (prevCellDate) {
      date_default.fixTimezoneGap(prevCellDate, cellDate);
    }
    params.prevCellDate = cellDate;
    const {
      cell,
      $cell
    } = this._createCell(cellDate, cellIndex);
    const cellTemplate = this.option("cellTemplate");
    renderer_default(row).append(cell);
    if (cellTemplate) {
      cellTemplate.render(this._prepareCellTemplateData(cellDate, cellIndex, $cell));
    } else {
      cell.innerHTML = this._getCellText(cellDate);
    }
    params.cellDate = this._getNextCellData(cellDate);
  }
  _getClassNameByDate(cellDate, cellIndex) {
    let className = "dx-calendar-cell";
    if (this._isTodayCell(cellDate)) {
      className += " dx-calendar-today";
    }
    if (this._isDateOutOfRange(cellDate) || this.isDateDisabled(cellDate)) {
      className += " dx-calendar-empty-cell";
    }
    if (this._isOtherView(cellDate)) {
      className += " dx-calendar-other-view";
    }
    const {
      selectionMode
    } = this.option();
    if (selectionMode === SELECTION_MODE2.range) {
      if (0 === cellIndex) {
        className += " dx-calendar-cell-start-in-row";
      }
      const {
        colCount
      } = this.option();
      if (cellIndex === colCount - 1) {
        className += " dx-calendar-cell-end-in-row";
      }
      if (this._isStartDayOfMonth(cellDate)) {
        className += " dx-calendar-cell-start";
      }
      if (this._isEndDayOfMonth(cellDate)) {
        className += " dx-calendar-cell-end";
      }
    }
    return className;
  }
  _prepareCellTemplateData(cellDate, cellIndex, $cell) {
    const isDateCell = cellDate instanceof Date;
    const text = isDateCell ? this._getCellText(cellDate) : cellDate;
    const date = isDateCell ? cellDate : void 0;
    const view = this._getViewName();
    return {
      model: {
        text,
        date,
        view
      },
      container: getPublicElement($cell),
      index: cellIndex
    };
  }
  _renderEvents() {
    this._createCellClickAction();
    m_events_engine_default.off(this._$table, CALENDAR_DXCLICK_EVENT_NAME);
    m_events_engine_default.on(this._$table, CALENDAR_DXCLICK_EVENT_NAME, NOT_WEEK_CELL_SELECTOR, (e) => {
      if (!renderer_default(e.currentTarget).hasClass("dx-calendar-empty-cell")) {
        this._cellClickAction({
          event: e,
          value: renderer_default(e.currentTarget).data("dxDateValueKey")
        });
      }
    });
    const {
      selectionMode
    } = this.option();
    m_events_engine_default.off(this._$table, CALENDAR_DXHOVERSTART_EVENT_NAME);
    if (selectionMode === SELECTION_MODE2.range) {
      this._createCellHoverAction();
      m_events_engine_default.on(this._$table, CALENDAR_DXHOVERSTART_EVENT_NAME, NOT_WEEK_CELL_SELECTOR, (e) => {
        if (!renderer_default(e.currentTarget).hasClass("dx-calendar-empty-cell")) {
          this._cellHoverAction({
            event: e,
            value: renderer_default(e.currentTarget).data("dxDateValueKey")
          });
        }
      });
    }
    if (selectionMode !== SELECTION_MODE2.single) {
      this._createWeekNumberCellClickAction();
      m_events_engine_default.on(this._$table, CALENDAR_DXCLICK_EVENT_NAME, ".dx-calendar-week-number-cell", (e) => {
        const $row = renderer_default(e.currentTarget).closest("tr");
        const firstDateInRow = $row.find(".dx-calendar-cell").first().data("dxDateValueKey");
        const lastDateInRow = $row.find(".dx-calendar-cell").last().data("dxDateValueKey");
        const rowDates = [...date_default.getDatesOfInterval(firstDateInRow, lastDateInRow, 864e5), lastDateInRow];
        this._weekNumberCellClickAction({
          event: e,
          rowDates
        });
      });
    }
  }
  _createCellClickAction() {
    this._cellClickAction = this._createActionByOption("onCellClick");
  }
  _createCellHoverAction() {
    this._cellHoverAction = this._createActionByOption("onCellHover");
  }
  _createWeekNumberCellClickAction() {
    this._weekNumberCellClickAction = this._createActionByOption("onWeekNumberClick");
  }
  _createDisabledDatesHandler() {
    const {
      disabledDates
    } = this.option();
    this._disabledDatesHandler = Array.isArray(disabledDates) ? this._getDefaultDisabledDatesHandler(disabledDates) : disabledDates || noop2;
  }
  _getDefaultDisabledDatesHandler(disabledDates) {
    return noop2;
  }
  _isTodayCell(cellDate) {
    class_default.abstract();
  }
  _isDateOutOfRange(cellDate) {
    class_default.abstract();
  }
  isDateDisabled(cellDate) {
    const dateParts = {
      date: cellDate,
      view: this._getViewName()
    };
    return this._disabledDatesHandler(dateParts);
  }
  _isOtherView(cellDate) {
    class_default.abstract();
  }
  _isStartDayOfMonth(cellDate) {
    class_default.abstract();
  }
  _isEndDayOfMonth(cellDate) {
    class_default.abstract();
  }
  _getCellText(cellDate) {
    class_default.abstract();
  }
  _getFirstCellData() {
    class_default.abstract();
  }
  _getNextCellData(date) {
    class_default.abstract();
  }
  _renderContouredDate(contouredDate) {
    if (!this.option("focusStateEnabled")) {
      return;
    }
    contouredDate = contouredDate || this.option("contouredDate");
    const $oldContouredCell = this._getContouredCell();
    const $newContouredCell = this._getCellByDate(contouredDate);
    $oldContouredCell.removeClass("dx-calendar-contoured-date");
    if (contouredDate) {
      $newContouredCell.addClass("dx-calendar-contoured-date");
    }
  }
  _getContouredCell() {
    return this._$table.find(".dx-calendar-contoured-date");
  }
  _renderValue() {
    if (!this.option("allowValueSelection")) {
      return;
    }
    let value2 = this.option("value");
    if (!Array.isArray(value2)) {
      value2 = [value2];
    }
    this._updateSelectedClass(value2);
  }
  _updateSelectedClass(value2) {
    var _this$_$selectedCells;
    if (this._isRangeMode() && !this._isMonthView()) {
      return;
    }
    null === (_this$_$selectedCells = this._$selectedCells) || void 0 === _this$_$selectedCells || _this$_$selectedCells.forEach(($cell) => {
      $cell.removeClass("dx-calendar-selected-date");
    });
    this._$selectedCells = value2.map((value3) => this._getCellByDate(value3));
    this._$selectedCells.forEach(($cell) => {
      $cell.addClass("dx-calendar-selected-date");
    });
  }
  _renderRange() {
    var _this$_$rangeCells, _this$_$hoveredRangeC, _this$_$rangeStartHov, _this$_$rangeEndHover, _this$_$rangeStartDat, _this$_$rangeEndDateC, _this$_$rangeStartDat2, _this$_$rangeEndDateC2;
    const {
      allowValueSelection,
      value: value2,
      range
    } = this.option();
    if (!allowValueSelection || !this._isRangeMode() || !this._isMonthView()) {
      return;
    }
    null === (_this$_$rangeCells = this._$rangeCells) || void 0 === _this$_$rangeCells || _this$_$rangeCells.forEach(($cell) => {
      $cell.removeClass("dx-calendar-cell-in-range");
    });
    null === (_this$_$hoveredRangeC = this._$hoveredRangeCells) || void 0 === _this$_$hoveredRangeC || _this$_$hoveredRangeC.forEach(($cell) => {
      $cell.removeClass("dx-calendar-cell-range-hover");
    });
    null === (_this$_$rangeStartHov = this._$rangeStartHoverCell) || void 0 === _this$_$rangeStartHov || _this$_$rangeStartHov.removeClass("dx-calendar-cell-range-hover-start");
    null === (_this$_$rangeEndHover = this._$rangeEndHoverCell) || void 0 === _this$_$rangeEndHover || _this$_$rangeEndHover.removeClass("dx-calendar-cell-range-hover-end");
    null === (_this$_$rangeStartDat = this._$rangeStartDateCell) || void 0 === _this$_$rangeStartDat || _this$_$rangeStartDat.removeClass("dx-calendar-range-start-date");
    null === (_this$_$rangeEndDateC = this._$rangeEndDateCell) || void 0 === _this$_$rangeEndDateC || _this$_$rangeEndDateC.removeClass("dx-calendar-range-end-date");
    this._$rangeCells = range.map((value3) => this._getCellByDate(value3));
    this._$rangeStartDateCell = this._getCellByDate(value2[0]);
    this._$rangeEndDateCell = this._getCellByDate(value2[1]);
    this._$rangeCells.forEach(($cell) => {
      $cell.addClass("dx-calendar-cell-in-range");
    });
    null === (_this$_$rangeStartDat2 = this._$rangeStartDateCell) || void 0 === _this$_$rangeStartDat2 || _this$_$rangeStartDat2.addClass("dx-calendar-range-start-date");
    null === (_this$_$rangeEndDateC2 = this._$rangeEndDateCell) || void 0 === _this$_$rangeEndDateC2 || _this$_$rangeEndDateC2.addClass("dx-calendar-range-end-date");
  }
  _renderHoveredRange() {
    var _this$_$hoveredRangeC2, _this$_$rangeStartHov2, _this$_$rangeEndHover2, _this$_$rangeStartHov3, _this$_$rangeEndHover3;
    const {
      allowValueSelection,
      hoveredRange
    } = this.option();
    if (!allowValueSelection || !this._isRangeMode() || !this._isMonthView()) {
      return;
    }
    null === (_this$_$hoveredRangeC2 = this._$hoveredRangeCells) || void 0 === _this$_$hoveredRangeC2 || _this$_$hoveredRangeC2.forEach(($cell) => {
      $cell.removeClass("dx-calendar-cell-range-hover");
    });
    null === (_this$_$rangeStartHov2 = this._$rangeStartHoverCell) || void 0 === _this$_$rangeStartHov2 || _this$_$rangeStartHov2.removeClass("dx-calendar-cell-range-hover-start");
    null === (_this$_$rangeEndHover2 = this._$rangeEndHoverCell) || void 0 === _this$_$rangeEndHover2 || _this$_$rangeEndHover2.removeClass("dx-calendar-cell-range-hover-end");
    this._$hoveredRangeCells = hoveredRange.map((value2) => this._getCellByDate(value2));
    this._$rangeStartHoverCell = this._getCellByDate(hoveredRange[0]);
    this._$rangeEndHoverCell = this._getCellByDate(hoveredRange[hoveredRange.length - 1]);
    this._$hoveredRangeCells.forEach(($cell) => {
      $cell.addClass("dx-calendar-cell-range-hover");
    });
    null === (_this$_$rangeStartHov3 = this._$rangeStartHoverCell) || void 0 === _this$_$rangeStartHov3 || _this$_$rangeStartHov3.addClass("dx-calendar-cell-range-hover-start");
    null === (_this$_$rangeEndHover3 = this._$rangeEndHoverCell) || void 0 === _this$_$rangeEndHover3 || _this$_$rangeEndHover3.addClass("dx-calendar-cell-range-hover-end");
  }
  _isMonthView() {
    const {
      zoomLevel
    } = this.option();
    return "month" === zoomLevel;
  }
  _isRangeMode() {
    const {
      selectionMode
    } = this.option();
    return selectionMode === SELECTION_MODE2.range;
  }
  _getCurrentDateFormat() {
    return null;
  }
  getCellAriaLabel(date) {
    const viewName2 = this._getViewName();
    const isToday = this._isTodayCell(date);
    const format2 = this._getCurrentDateFormat();
    const dateRangeText = format2 ? date_default3.format(date, format2) : this._getCellText(date);
    const ariaLabel = isToday ? `${dateRangeText}. ${CURRENT_DATE_TEXT[viewName2]}` : dateRangeText;
    return ariaLabel;
  }
  _getFirstAvailableDate() {
    let date = this.option("date");
    const min = this.option("min");
    date = date_default.getViewFirstCellDate(this._getViewName(), date);
    return new Date(min && date < min ? min : date);
  }
  _getCellByDate(contouredDate) {
    class_default.abstract();
  }
  isBoundary(date) {
    class_default.abstract();
  }
  _optionChanged(args) {
    const {
      name: name2,
      value: value2
    } = args;
    switch (name2) {
      case "value":
        this._renderValue();
        this._updateTableAriaLabel();
        break;
      case "range":
        this._renderRange();
        break;
      case "hoveredRange":
        this._renderHoveredRange();
        break;
      case "contouredDate":
        this._renderContouredDate(value2);
        break;
      case "onCellClick":
        this._createCellClickAction();
        break;
      case "onCellHover":
        this._createCellHoverAction();
        break;
      case "min":
      case "max":
      case "disabledDates":
      case "cellTemplate":
      case "selectionMode":
        this._invalidate();
        break;
      case "_todayDate":
        this._renderBody();
        break;
      default:
        super._optionChanged(args);
    }
  }
};
var m_calendar_base_view_default = BaseView;

// node_modules/devextreme/esm/__internal/ui/calendar/m_calendar.views.js
var MonthView = class extends m_calendar_base_view_default {
  _getViewName() {
    return "month";
  }
  _getCurrentDateFormat() {
    return "longdate";
  }
  _getDefaultOptions() {
    return _extends({}, super._getDefaultOptions(), {
      firstDayOfWeek: 0,
      rowCount: 6,
      colCount: 7
    });
  }
  _renderImpl() {
    super._renderImpl();
    this._renderHeader();
  }
  _renderBody() {
    super._renderBody();
    this._$table.find(".dx-calendar-other-view").addClass("dx-calendar-other-month");
  }
  _renderFocusTarget() {
  }
  _renderHeader() {
    const $headerRow = renderer_default("<tr>");
    const $header = renderer_default("<thead>").append($headerRow);
    this._$table.prepend($header);
    const {
      colCount: columnsCount,
      showWeekNumbers
    } = this.option();
    for (let colIndex = 0, colCount = columnsCount; colIndex < colCount; colIndex++) {
      this._renderHeaderCell(colIndex, $headerRow);
    }
    if (showWeekNumbers) {
      this._renderWeekHeaderCell($headerRow);
    }
  }
  _renderHeaderCell(cellIndex, $headerRow) {
    const {
      firstDayOfWeek
    } = this.option();
    const {
      full: fullCaption,
      abbreviated: abbrCaption
    } = this._getDayCaption(firstDayOfWeek + cellIndex);
    const $cell = renderer_default("<th>").attr({
      scope: "col",
      abbr: fullCaption
    }).text(abbrCaption);
    $headerRow.append($cell);
  }
  _renderWeekHeaderCell($headerRow) {
    const $weekNumberHeaderCell = renderer_default("<th>").attr({
      scope: "col",
      abbr: "WeekNumber",
      class: "dx-week-number-header"
    });
    $headerRow.prepend($weekNumberHeaderCell);
  }
  _renderWeekNumberCell(rowData) {
    const {
      showWeekNumbers,
      cellTemplate,
      selectionMode,
      selectWeekOnClick
    } = this.option();
    if (!showWeekNumbers) {
      return;
    }
    const weekNumber = this._getWeekNumber(rowData.prevCellDate);
    const cell = dom_adapter_default.createElement("td");
    const $cell = renderer_default(cell);
    cell.className = "dx-calendar-week-number-cell";
    if ("single" !== selectionMode && selectWeekOnClick) {
      $cell.addClass("dx-calendar-week-selection");
    }
    if (cellTemplate) {
      cellTemplate.render(this._prepareCellTemplateData(weekNumber, -1, $cell));
    } else {
      cell.innerHTML = weekNumber;
    }
    rowData.row.prepend(cell);
    this.setAria({
      role: "gridcell",
      label: `Week ${weekNumber}`
    }, $cell);
  }
  _getWeekNumber(date) {
    const {
      weekNumberRule,
      firstDayOfWeek
    } = this.option();
    if ("auto" === weekNumberRule) {
      return date_default.getWeekNumber(date, firstDayOfWeek, 1 === firstDayOfWeek ? "firstFourDays" : "firstDay");
    }
    return date_default.getWeekNumber(date, firstDayOfWeek, weekNumberRule);
  }
  getNavigatorCaption() {
    const {
      date
    } = this.option();
    return date_default3.format(date, "monthandyear");
  }
  _isTodayCell(cellDate) {
    const {
      _todayDate: today
    } = this.option();
    return date_default.sameDate(cellDate, today());
  }
  _isDateOutOfRange(cellDate) {
    const minDate = this.option("min");
    const maxDate = this.option("max");
    return !date_default.dateInRange(cellDate, minDate, maxDate, "date");
  }
  _isOtherView(cellDate) {
    const {
      date
    } = this.option();
    return cellDate.getMonth() !== date.getMonth();
  }
  _isStartDayOfMonth(cellDate) {
    return date_default.sameDate(cellDate, date_default.getFirstMonthDate(this.option("date")));
  }
  _isEndDayOfMonth(cellDate) {
    return date_default.sameDate(cellDate, date_default.getLastMonthDate(this.option("date")));
  }
  _getCellText(cellDate) {
    return date_default3.format(cellDate, "d");
  }
  _getDayCaption(day) {
    const {
      colCount: daysInWeek
    } = this.option();
    const dayIndex = day % daysInWeek;
    return {
      full: date_default3.getDayNames()[dayIndex],
      abbreviated: date_default3.getDayNames("abbreviated")[dayIndex]
    };
  }
  _getFirstCellData() {
    const {
      firstDayOfWeek
    } = this.option();
    const firstDay = date_default.getFirstMonthDate(this.option("date"));
    let firstMonthDayOffset = firstDayOfWeek - firstDay.getDay();
    const {
      colCount: daysInWeek
    } = this.option();
    if (firstMonthDayOffset >= 0) {
      firstMonthDayOffset -= daysInWeek;
    }
    firstDay.setDate(firstDay.getDate() + firstMonthDayOffset);
    return firstDay;
  }
  _getNextCellData(date) {
    date = new Date(date);
    date.setDate(date.getDate() + 1);
    return date;
  }
  _getCellByDate(date) {
    return this._$table.find(`td[data-value='${date_serialization_default.serializeDate(date, date_default.getShortDateFormat())}']`);
  }
  isBoundary(date) {
    return date_default.sameMonthAndYear(date, this.option("min")) || date_default.sameMonthAndYear(date, this.option("max"));
  }
  _getDefaultDisabledDatesHandler(disabledDates) {
    return function(args) {
      const isDisabledDate = disabledDates.some((item) => date_default.sameDate(item, args.date));
      if (isDisabledDate) {
        return true;
      }
    };
  }
};
var YearView = class extends m_calendar_base_view_default {
  _getViewName() {
    return "year";
  }
  _getCurrentDateFormat() {
    return "monthandyear";
  }
  _isTodayCell(cellDate) {
    const {
      _todayDate: today
    } = this.option();
    return date_default.sameMonthAndYear(cellDate, today());
  }
  _isDateOutOfRange(cellDate) {
    return !date_default.dateInRange(cellDate, date_default.getFirstMonthDate(this.option("min")), date_default.getLastMonthDate(this.option("max")));
  }
  _isOtherView() {
    return false;
  }
  _isStartDayOfMonth() {
    return false;
  }
  _isEndDayOfMonth() {
    return false;
  }
  _getCellText(cellDate) {
    return date_default3.getMonthNames("abbreviated")[cellDate.getMonth()];
  }
  _getFirstCellData() {
    const {
      date: currentDate
    } = this.option();
    const data17 = new Date(currentDate);
    data17.setDate(1);
    data17.setMonth(0);
    return data17;
  }
  _getNextCellData(date) {
    date = new Date(date);
    date.setMonth(date.getMonth() + 1);
    return date;
  }
  _getCellByDate(date) {
    const foundDate = new Date(date);
    foundDate.setDate(1);
    return this._$table.find(`td[data-value='${date_serialization_default.serializeDate(foundDate, date_default.getShortDateFormat())}']`);
  }
  getNavigatorCaption() {
    const {
      date
    } = this.option();
    return date_default3.format(date, "yyyy");
  }
  isBoundary(date) {
    return date_default.sameYear(date, this.option("min")) || date_default.sameYear(date, this.option("max"));
  }
  _renderWeekNumberCell() {
  }
};
var DecadeView = class extends m_calendar_base_view_default {
  _getViewName() {
    return "decade";
  }
  _isTodayCell(cellDate) {
    const {
      _todayDate: today
    } = this.option();
    return date_default.sameYear(cellDate, today());
  }
  _isDateOutOfRange(cellDate) {
    const min = this.option("min");
    const max = this.option("max");
    return !date_default.dateInRange(cellDate.getFullYear(), null === min || void 0 === min ? void 0 : min.getFullYear(), null === max || void 0 === max ? void 0 : max.getFullYear());
  }
  _isOtherView(cellDate) {
    const date = new Date(cellDate);
    date.setMonth(1);
    return !date_default.sameDecade(date, this.option("date"));
  }
  _isStartDayOfMonth() {
    return false;
  }
  _isEndDayOfMonth() {
    return false;
  }
  _getCellText(cellDate) {
    return date_default3.format(cellDate, "yyyy");
  }
  _getFirstCellData() {
    const year = date_default.getFirstYearInDecade(this.option("date")) - 1;
    return date_default.createDateWithFullYear(year, 0, 1);
  }
  _getNextCellData(date) {
    date = new Date(date);
    date.setFullYear(date.getFullYear() + 1);
    return date;
  }
  getNavigatorCaption() {
    const {
      date: currentDate
    } = this.option();
    const firstYearInDecade = date_default.getFirstYearInDecade(currentDate);
    const startDate = new Date(currentDate);
    const endDate = new Date(currentDate);
    startDate.setFullYear(firstYearInDecade);
    endDate.setFullYear(firstYearInDecade + 9);
    return `${date_default3.format(startDate, "yyyy")}-${date_default3.format(endDate, "yyyy")}`;
  }
  _isValueOnCurrentView(currentDate, value2) {
    return date_default.sameDecade(currentDate, value2);
  }
  _getCellByDate(date) {
    const foundDate = new Date(date);
    foundDate.setDate(1);
    foundDate.setMonth(0);
    return this._$table.find(`td[data-value='${date_serialization_default.serializeDate(foundDate, date_default.getShortDateFormat())}']`);
  }
  isBoundary(date) {
    return date_default.sameDecade(date, this.option("min")) || date_default.sameDecade(date, this.option("max"));
  }
  _renderWeekNumberCell() {
  }
};
var CenturyView = class extends m_calendar_base_view_default {
  _getViewName() {
    return "century";
  }
  _isTodayCell(cellDate) {
    const {
      _todayDate: today
    } = this.option();
    return date_default.sameDecade(cellDate, today());
  }
  _isDateOutOfRange(cellDate) {
    const decade = date_default.getFirstYearInDecade(cellDate);
    const minDecade = date_default.getFirstYearInDecade(this.option("min"));
    const maxDecade = date_default.getFirstYearInDecade(this.option("max"));
    return !date_default.dateInRange(decade, minDecade, maxDecade);
  }
  _isOtherView(cellDate) {
    const date = new Date(cellDate);
    date.setMonth(1);
    return !date_default.sameCentury(date, this.option("date"));
  }
  _isStartDayOfMonth() {
    return false;
  }
  _isEndDayOfMonth() {
    return false;
  }
  _getCellText(cellDate) {
    const startDate = date_default3.format(cellDate, "yyyy");
    const endDate = new Date(cellDate);
    endDate.setFullYear(endDate.getFullYear() + 9);
    return `${startDate} - ${date_default3.format(endDate, "yyyy")}`;
  }
  _getFirstCellData() {
    const decade = date_default.getFirstDecadeInCentury(this.option("date")) - 10;
    return date_default.createDateWithFullYear(decade, 0, 1);
  }
  _getNextCellData(date) {
    date = new Date(date);
    date.setFullYear(date.getFullYear() + 10);
    return date;
  }
  _getCellByDate(date) {
    const foundDate = new Date(date);
    foundDate.setDate(1);
    foundDate.setMonth(0);
    foundDate.setFullYear(date_default.getFirstYearInDecade(foundDate));
    return this._$table.find(`td[data-value='${date_serialization_default.serializeDate(foundDate, date_default.getShortDateFormat())}']`);
  }
  getNavigatorCaption() {
    const {
      date: currentDate
    } = this.option();
    const firstDecadeInCentury = date_default.getFirstDecadeInCentury(currentDate);
    const startDate = new Date(currentDate);
    const endDate = new Date(currentDate);
    startDate.setFullYear(firstDecadeInCentury);
    endDate.setFullYear(firstDecadeInCentury + 99);
    return `${date_default3.format(startDate, "yyyy")}-${date_default3.format(endDate, "yyyy")}`;
  }
  isBoundary(date) {
    return date_default.sameCentury(date, this.option("min")) || date_default.sameCentury(date, this.option("max"));
  }
  _renderWeekNumberCell() {
  }
};
var m_calendar_views_default = {
  month: MonthView,
  year: YearView,
  decade: DecadeView,
  century: CenturyView
};

// node_modules/devextreme/esm/__internal/ui/calendar/m_calendar.js
var CALENDAR_DXHOVEREND_EVENT_NAME = addNamespace2(HOVEREND, "dxCalendar");
var LEVEL_COMPARE_MAP = {
  month: 3,
  year: 2,
  decade: 1,
  century: 0
};
var ZOOM_LEVEL = {
  MONTH: "month",
  YEAR: "year",
  DECADE: "decade",
  CENTURY: "century"
};
var SELECTION_STRATEGIES = {
  SingleSelection: m_calendar_single_selection_strategy_default,
  MultipleSelection: m_calendar_multiple_selection_strategy_default,
  RangeSelection: m_calendar_range_selection_strategy_default
};
var Calendar = class extends editor_default {
  _getDefaultOptions() {
    return _extends({}, super._getDefaultOptions(), {
      hoverStateEnabled: true,
      activeStateEnabled: true,
      currentDate: /* @__PURE__ */ new Date(),
      value: null,
      min: new Date(1e3, 0),
      max: new Date(3e3, 0),
      viewsCount: 1,
      zoomLevel: ZOOM_LEVEL.MONTH,
      maxZoomLevel: ZOOM_LEVEL.MONTH,
      minZoomLevel: ZOOM_LEVEL.CENTURY,
      selectionMode: "single",
      selectWeekOnClick: true,
      showTodayButton: false,
      showWeekNumbers: false,
      weekNumberRule: "auto",
      cellTemplate: "cell",
      disabledDates: null,
      onCellClick: null,
      onContouredChanged: null,
      skipFocusCheck: false,
      _todayDate: () => /* @__PURE__ */ new Date()
    });
  }
  _defaultOptionsRules() {
    return super._defaultOptionsRules().concat([{
      device: () => "desktop" === devices_default.real().deviceType && !devices_default.isSimulator(),
      options: {
        focusStateEnabled: true
      }
    }]);
  }
  _supportedKeys() {
    return _extends({}, super._supportedKeys(), {
      rightArrow(e) {
        e.preventDefault();
        if (isCommandKeyPressed(e)) {
          this._waitRenderView(1);
        } else {
          this._moveCurrentDateByOffset(1 * this._getRtlCorrection());
        }
      },
      leftArrow(e) {
        e.preventDefault();
        if (isCommandKeyPressed(e)) {
          this._waitRenderView(-1);
        } else {
          this._moveCurrentDateByOffset(-1 * this._getRtlCorrection());
        }
      },
      upArrow(e) {
        e.preventDefault();
        if (isCommandKeyPressed(e)) {
          this._navigateUp();
        } else {
          if (fx_default.isAnimating(this._view.$element())) {
            return;
          }
          this._moveCurrentDateByOffset(-1 * this._view.option("colCount"));
        }
      },
      downArrow(e) {
        e.preventDefault();
        if (isCommandKeyPressed(e)) {
          this._navigateDown();
        } else {
          if (fx_default.isAnimating(this._view.$element())) {
            return;
          }
          this._moveCurrentDateByOffset(1 * this._view.option("colCount"));
        }
      },
      home(e) {
        e.preventDefault();
        const zoomLevel = this.option("zoomLevel");
        const currentDate = this.option("currentDate");
        const min = this._dateOption("min");
        if (this._view.isDateDisabled(currentDate)) {
          return;
        }
        const date = date_default.sameView(zoomLevel, currentDate, min) ? min : date_default.getViewFirstCellDate(zoomLevel, currentDate);
        this._moveToClosestAvailableDate(date);
      },
      end(e) {
        e.preventDefault();
        const zoomLevel = this.option("zoomLevel");
        const currentDate = this.option("currentDate");
        const max = this._dateOption("max");
        if (this._view.isDateDisabled(currentDate)) {
          return;
        }
        const date = date_default.sameView(zoomLevel, currentDate, max) ? max : date_default.getViewLastCellDate(zoomLevel, currentDate);
        this._moveToClosestAvailableDate(date);
      },
      pageUp(e) {
        e.preventDefault();
        this._waitRenderView(-1 * this._getRtlCorrection());
      },
      pageDown(e) {
        e.preventDefault();
        this._waitRenderView(1 * this._getRtlCorrection());
      },
      tab() {
      },
      enter: this._enterKeyHandler
    });
  }
  _enterKeyHandler(e) {
    if (!this._isMaxZoomLevel()) {
      this._navigateDown();
    } else if (!this._view.isDateDisabled(this.option("currentDate"))) {
      const value2 = this._updateTimeComponent(this.option("currentDate"));
      this._selectionStrategy.selectValue(value2, e);
    }
  }
  _getSerializationFormat(optionName) {
    const value2 = this.option(optionName || "value");
    if (this.option("dateSerializationFormat")) {
      return this.option("dateSerializationFormat");
    }
    if (isNumeric(value2)) {
      return "number";
    }
    if (!isString(value2)) {
      return;
    }
    return date_serialization_default.getDateSerializationFormat(value2);
  }
  _convertToDate(value2) {
    return date_serialization_default.deserializeDate(value2);
  }
  _dateValue(value2, event) {
    if (event) {
      if ("keydown" === event.type) {
        const cellElement = this._view._getContouredCell().get(0);
        event.target = cellElement;
      }
      this._saveValueChangeEvent(event);
    }
    this._dateOption("value", value2);
  }
  _dateOption(optionName, optionValue) {
    const isArray2 = "value" === optionName && !this._isSingleMode();
    const value2 = this.option("value");
    if (1 === arguments.length) {
      return isArray2 ? (value2 ?? []).map((value3) => this._convertToDate(value3)) : this._convertToDate(this.option(optionName));
    }
    const serializationFormat = this._getSerializationFormat(optionName);
    const serializedValue = isArray2 ? (null === optionValue || void 0 === optionValue ? void 0 : optionValue.map((value3) => date_serialization_default.serializeDate(value3, serializationFormat))) || [] : date_serialization_default.serializeDate(optionValue, serializationFormat);
    this.option(optionName, serializedValue);
  }
  _isSingleMode() {
    const {
      selectionMode
    } = this.option();
    return "single" === selectionMode;
  }
  _shiftDate(zoomLevel, date, offset2, reverse) {
    switch (zoomLevel) {
      case ZOOM_LEVEL.MONTH:
        date.setDate(date.getDate() + offset2 * reverse);
        break;
      case ZOOM_LEVEL.YEAR:
        date.setMonth(date.getMonth() + offset2 * reverse);
        break;
      case ZOOM_LEVEL.DECADE:
        date.setFullYear(date.getFullYear() + offset2 * reverse);
        break;
      case ZOOM_LEVEL.CENTURY:
        date.setFullYear(date.getFullYear() + 10 * offset2 * reverse);
    }
  }
  _moveCurrentDateByOffset(offset2) {
    const baseDate = this.option("currentDate");
    let currentDate = new Date(baseDate);
    const zoomLevel = this.option("zoomLevel");
    this._shiftDate(zoomLevel, currentDate, offset2, 1);
    const maxDate = this._getMaxDate();
    const minDate = this._getMinDate();
    let isDateForwardInNeighborView = this._areDatesInNeighborView(zoomLevel, currentDate, baseDate);
    let isDateForwardInRange = inRange(currentDate, minDate, maxDate) && isDateForwardInNeighborView;
    const dateForward = new Date(currentDate);
    while (isDateForwardInRange) {
      if (!this._view.isDateDisabled(dateForward)) {
        currentDate = dateForward;
        break;
      }
      this._shiftDate(zoomLevel, dateForward, offset2, 1);
      isDateForwardInNeighborView = this._areDatesInNeighborView(zoomLevel, dateForward, baseDate);
      isDateForwardInRange = inRange(dateForward, minDate, maxDate) && isDateForwardInNeighborView;
    }
    if (this._view.isDateDisabled(baseDate) || this._view.isDateDisabled(currentDate)) {
      const direction = offset2 > 0 ? 1 : -1;
      const isViewDisabled = 1 === direction ? this._isNextViewDisabled() : this._isPrevViewDisabled();
      if (!isViewDisabled) {
        this._waitRenderView(direction);
      } else {
        this._moveToClosestAvailableDate(currentDate);
      }
    } else {
      this._skipNavigate = true;
      this.option("currentDate", currentDate);
    }
  }
  _isNextViewDisabled() {
    return this._navigator._nextButton.option("disabled");
  }
  _isPrevViewDisabled() {
    return this._navigator._prevButton.option("disabled");
  }
  _areDatesInSameView(zoomLevel, date1, date2) {
    switch (zoomLevel) {
      case ZOOM_LEVEL.MONTH:
        return date1.getMonth() === date2.getMonth();
      case ZOOM_LEVEL.YEAR:
        return date1.getYear() === date2.getYear();
      case ZOOM_LEVEL.DECADE:
        return parseInt(date1.getYear() / 10) === parseInt(date2.getYear() / 10);
      case ZOOM_LEVEL.CENTURY:
        return parseInt(date1.getYear() / 100) === parseInt(date2.getYear() / 100);
    }
  }
  _areDatesInNeighborView(zoomLevel, date1, date2) {
    switch (zoomLevel) {
      case ZOOM_LEVEL.MONTH:
        return ((a, b) => {
          const abs3 = Math.abs(a - b);
          return Math.min(abs3, 12 - abs3);
        })(date1.getMonth(), date2.getMonth()) <= 1;
      case ZOOM_LEVEL.YEAR:
        return Math.abs(date1.getYear() - date2.getYear()) <= 1;
      case ZOOM_LEVEL.DECADE:
        return Math.abs(date1.getYear() - date2.getYear()) <= 10;
      case ZOOM_LEVEL.CENTURY:
        return Math.abs(date1.getYear() - date2.getYear()) <= 100;
    }
  }
  _moveToClosestAvailableDate() {
    let baseDate = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.option("currentDate");
    let currentDate = new Date(baseDate);
    const zoomLevel = this.option("zoomLevel");
    const isCurrentDateAvailable = !this._isDateNotAvailable(currentDate);
    let isDateForwardAvailable = isCurrentDateAvailable;
    let isDateBackwardAvailable = isCurrentDateAvailable;
    let isDateForwardInStartView;
    let isDateBackwardInStartView;
    const dateForward = new Date(currentDate);
    const dateBackward = new Date(currentDate);
    do {
      if (isDateForwardAvailable) {
        currentDate = dateForward;
        break;
      }
      if (isDateBackwardAvailable) {
        currentDate = dateBackward;
        break;
      }
      this._shiftDate(zoomLevel, dateForward, 1, 1);
      this._shiftDate(zoomLevel, dateBackward, 1, -1);
      isDateForwardInStartView = this._areDatesInSameView(zoomLevel, dateForward, baseDate);
      isDateBackwardInStartView = this._areDatesInSameView(zoomLevel, dateBackward, baseDate);
      isDateForwardAvailable = isDateForwardInStartView && !this._isDateNotAvailable(dateForward);
      isDateBackwardAvailable = isDateBackwardInStartView && !this._isDateNotAvailable(dateBackward);
    } while (isDateForwardInStartView || isDateBackwardInStartView);
    this.option("currentDate", currentDate);
  }
  _isDateNotAvailable(date) {
    const maxDate = this._getMaxDate();
    const minDate = this._getMinDate();
    return !inRange(date, minDate, maxDate) || this._view.isDateDisabled(date);
  }
  _init() {
    super._init();
    this._activeStateUnit = ".dx-calendar-cell";
    this._initSelectionStrategy();
    this._correctZoomLevel();
    this._initCurrentDate();
    this._initActions();
  }
  _initSelectionStrategy() {
    const strategyName = this._getSelectionStrategyName();
    const strategy3 = SELECTION_STRATEGIES[strategyName];
    if (!this._selectionStrategy || this._selectionStrategy.NAME !== strategyName) {
      this._selectionStrategy = new strategy3(this);
    }
  }
  _refreshSelectionStrategy() {
    this._initSelectionStrategy();
    this._selectionStrategy.restoreValue();
    this._refresh();
  }
  _getSelectionStrategyName() {
    const {
      selectionMode
    } = this.option();
    switch (selectionMode) {
      case "multiple":
        return "MultipleSelection";
      case "range":
        return "RangeSelection";
      default:
        return "SingleSelection";
    }
  }
  _correctZoomLevel() {
    const {
      minZoomLevel,
      maxZoomLevel,
      zoomLevel
    } = this.option();
    if (LEVEL_COMPARE_MAP[maxZoomLevel] < LEVEL_COMPARE_MAP[minZoomLevel]) {
      return;
    }
    if (LEVEL_COMPARE_MAP[zoomLevel] > LEVEL_COMPARE_MAP[maxZoomLevel]) {
      this.option("zoomLevel", maxZoomLevel);
    } else if (LEVEL_COMPARE_MAP[zoomLevel] < LEVEL_COMPARE_MAP[minZoomLevel]) {
      this.option("zoomLevel", minZoomLevel);
    }
  }
  _initCurrentDate() {
    const currentDate = this._getNormalizedDate(this._selectionStrategy.getDefaultCurrentDate()) ?? this._getNormalizedDate(this.option("currentDate"));
    this.option("currentDate", currentDate);
  }
  _getNormalizedDate(date) {
    date = date_default.normalizeDate(date, this._getMinDate(), this._getMaxDate());
    return isDefined(date) ? this._getDate(date) : date;
  }
  _initActions() {
    this._cellClickAction = this._createActionByOption("onCellClick");
    this._onContouredChanged = this._createActionByOption("onContouredChanged");
  }
  _initTemplates() {
    this._templateManager.addDefaultTemplates({
      cell: new FunctionTemplate((options2) => {
        const data17 = options2.model;
        renderer_default(options2.container).append(renderer_default("<span>").text((null === data17 || void 0 === data17 ? void 0 : data17.text) || String(data17)));
      })
    });
    super._initTemplates();
  }
  _updateCurrentDate(date) {
    if (fx_default.isAnimating(this._$viewsWrapper)) {
      fx_default.stop(this._$viewsWrapper, true);
    }
    const min = this._getMinDate();
    const max = this._getMaxDate();
    if (min > max) {
      this.option("currentDate", /* @__PURE__ */ new Date());
      return;
    }
    const normalizedDate = this._getNormalizedDate(date);
    if (date.getTime() !== normalizedDate.getTime()) {
      this.option("currentDate", new Date(normalizedDate));
      return;
    }
    let offset2 = this._getViewsOffset(this._view.option("date"), normalizedDate);
    if (0 !== offset2 && !this._isMaxZoomLevel() && this._isOtherViewCellClicked) {
      offset2 = 0;
    }
    if (this._view && 0 !== offset2 && !this._suppressNavigation) {
      if (this._additionalView) {
        if (offset2 > 2 || offset2 < -1) {
          this._refreshViews();
          this._setViewContoured(normalizedDate);
          this._updateAriaId(normalizedDate);
          this._renderNavigator();
        } else if (1 === offset2 && this._skipNavigate) {
          this._setViewContoured(normalizedDate);
          this._updateAriaId(normalizedDate);
        } else {
          this._navigate(offset2, normalizedDate);
        }
      } else {
        this._navigate(offset2, normalizedDate);
      }
    } else {
      this._renderNavigator();
      this._setViewContoured(normalizedDate);
      this._updateAriaId(normalizedDate);
    }
    this._skipNavigate = false;
  }
  _isAdditionalViewDate(date) {
    if (!this._additionalView) {
      return false;
    }
    return date >= this._additionalView._getFirstAvailableDate();
  }
  _getActiveView(date) {
    return this._isAdditionalViewDate(date) ? this._additionalView : this._view;
  }
  _setViewContoured(date) {
    if (this.option("skipFocusCheck") || renderer_default(this._$viewsWrapper).is(":focus")) {
      var _this$_additionalView;
      this._view.option("contouredDate", null);
      null === (_this$_additionalView = this._additionalView) || void 0 === _this$_additionalView || _this$_additionalView.option("contouredDate", null);
      const view = this._isAdditionalViewDate(date) ? this._additionalView : this._view;
      view.option("contouredDate", date);
    }
  }
  _getMinDate() {
    const _rangeMin = this.option("_rangeMin");
    if (_rangeMin) {
      return _rangeMin;
    }
    if (this.min) {
      return this.min;
    }
    this.min = this._dateOption("min") || new Date(1e3, 0);
    return this.min;
  }
  _getMaxDate() {
    const _rangeMax = this.option("_rangeMax");
    if (_rangeMax) {
      return _rangeMax;
    }
    if (this.max) {
      return this.max;
    }
    this.max = this._dateOption("max") || new Date(3e3, 0);
    return this.max;
  }
  _getViewsOffset(startDate, endDate) {
    const {
      zoomLevel
    } = this.option();
    if (zoomLevel === ZOOM_LEVEL.MONTH) {
      return this._getMonthsOffset(startDate, endDate);
    }
    let zoomCorrection;
    switch (zoomLevel) {
      case ZOOM_LEVEL.CENTURY:
        zoomCorrection = 100;
        break;
      case ZOOM_LEVEL.DECADE:
        zoomCorrection = 10;
        break;
      default:
        zoomCorrection = 1;
    }
    return parseInt(endDate.getFullYear() / zoomCorrection) - parseInt(startDate.getFullYear() / zoomCorrection);
  }
  _getMonthsOffset(startDate, endDate) {
    const yearOffset = endDate.getFullYear() - startDate.getFullYear();
    const monthOffset = endDate.getMonth() - startDate.getMonth();
    return 12 * yearOffset + monthOffset;
  }
  _waitRenderView(offset2) {
    if (this._alreadyViewRender) {
      return;
    }
    this._alreadyViewRender = true;
    const date = this._getDateByOffset(offset2 * this._getRtlCorrection());
    this._moveToClosestAvailableDate(date);
    this._waitRenderViewTimeout = setTimeout(() => {
      this._alreadyViewRender = false;
    });
  }
  _getRtlCorrection() {
    return this.option("rtlEnabled") ? -1 : 1;
  }
  _getDateByOffset(offset2, date) {
    date = this._getDate(date ?? this.option("currentDate"));
    const currentDay = date.getDate();
    const difference = date_default.getDifferenceInMonth(this.option("zoomLevel")) * offset2;
    date.setDate(1);
    date.setMonth(date.getMonth() + difference);
    const lastDay = date_default.getLastMonthDate(date).getDate();
    date.setDate(currentDay > lastDay ? lastDay : currentDay);
    return date;
  }
  _focusTarget() {
    return this._$viewsWrapper;
  }
  _focusEventTarget() {
    return this.$element();
  }
  _initMarkup() {
    this._renderSubmitElement();
    const $element = this.$element();
    $element.addClass("dx-calendar");
    const {
      selectionMode
    } = this.option();
    $element.toggleClass("dx-calendar-range", "range" === selectionMode);
    this._renderBody();
    $element.append(this.$body);
    this._renderViews();
    this._renderNavigator();
    super._initMarkup();
    this._renderEvents();
    $element.prepend(this._navigator.$element());
    this._renderSwipeable();
    this._renderFooter();
    this._selectionStrategy.updateAriaSelected();
    this._updateAriaId();
    this._updateNavigatorLabels();
    this.setAria("role", "application");
    this._updateAriaLabelAndRole();
    this._moveToClosestAvailableDate();
  }
  _render() {
    super._render();
    this._setViewContoured(this.option("currentDate"));
  }
  _renderBody() {
    if (!this._$viewsWrapper) {
      this.$body = renderer_default("<div>").addClass("dx-calendar-body");
      this._$viewsWrapper = renderer_default("<div>").addClass("dx-calendar-views-wrapper");
      this.$body.append(this._$viewsWrapper);
    }
  }
  _updateAriaLabelAndRole() {
    const readOnly = this.option("readOnly");
    const $element = this.$element();
    const aria = {
      role: readOnly ? "group" : void 0,
      label: readOnly ? message_default.format("dxCalendar-readOnlyLabel") : void 0
    };
    this.setAria(aria, $element);
  }
  _setAriaReadonly() {
  }
  _getKeyboardListeners() {
    return super._getKeyboardListeners().concat([this._view]);
  }
  _renderViews() {
    const {
      zoomLevel
    } = this.option();
    this.$element().addClass(`dx-calendar-view-${zoomLevel}`);
    const {
      currentDate,
      viewsCount
    } = this.option();
    this.$element().toggleClass("dx-calendar-multiview", viewsCount > 1);
    this._view = this._renderSpecificView(currentDate);
    if (hasWindow()) {
      const beforeDate = this._getDateByOffset(-1, currentDate);
      this._beforeView = this._isViewAvailable(beforeDate) ? this._renderSpecificView(beforeDate) : null;
      const afterDate = this._getDateByOffset(viewsCount, currentDate);
      afterDate.setDate(1);
      this._afterView = this._isViewAvailable(afterDate) ? this._renderSpecificView(afterDate) : null;
    }
    if (viewsCount > 1) {
      this._additionalView = this._renderSpecificView(this._getDateByOffset(1, currentDate));
    }
    this._translateViews();
  }
  _renderSpecificView(date) {
    const {
      zoomLevel
    } = this.option();
    const specificView = m_calendar_views_default[zoomLevel];
    const $view = renderer_default("<div>").appendTo(this._$viewsWrapper);
    const config3 = this._viewConfig(date);
    const view = this._createComponent($view, specificView, config3);
    return view;
  }
  _viewConfig(date) {
    let disabledDates = this.option("disabledDates");
    disabledDates = isFunction(disabledDates) ? this._injectComponent(disabledDates.bind(this)) : disabledDates;
    return _extends({}, this._selectionStrategy.getViewOptions(), {
      date,
      min: this._getMinDate(),
      max: this._getMaxDate(),
      firstDayOfWeek: this.option("firstDayOfWeek") ?? date_default3.firstDayOfWeekIndex(),
      showWeekNumbers: this.option("showWeekNumbers"),
      selectWeekOnClick: this.option("selectWeekOnClick"),
      weekNumberRule: this.option("weekNumberRule"),
      zoomLevel: this.option("zoomLevel"),
      tabIndex: void 0,
      focusStateEnabled: this.option("focusStateEnabled"),
      hoverStateEnabled: this.option("hoverStateEnabled"),
      disabledDates,
      onCellClick: this._cellClickHandler.bind(this),
      cellTemplate: this._getTemplateByOption("cellTemplate"),
      allowValueSelection: this._isMaxZoomLevel(),
      _todayDate: this.option("_todayDate")
    });
  }
  _renderEvents() {
    m_events_engine_default.off(this._$viewsWrapper, CALENDAR_DXHOVEREND_EVENT_NAME);
    const {
      selectionMode
    } = this.option();
    if ("range" === selectionMode) {
      m_events_engine_default.on(this._$viewsWrapper, CALENDAR_DXHOVEREND_EVENT_NAME, null, () => {
        this._updateViewsOption("hoveredRange", []);
      });
    }
  }
  _injectComponent(func) {
    const that = this;
    return function(params) {
      extend(params, {
        component: that
      });
      return func(params);
    };
  }
  _isViewAvailable(date) {
    const zoomLevel = this.option("zoomLevel");
    const min = date_default.getViewMinBoundaryDate(zoomLevel, this._getMinDate());
    const max = date_default.getViewMaxBoundaryDate(zoomLevel, this._getMaxDate());
    return date_default.dateInRange(date, min, max);
  }
  _translateViews() {
    const {
      viewsCount
    } = this.option();
    move(this._view.$element(), {
      left: 0,
      top: 0
    });
    this._moveViewElement(this._beforeView, -1);
    this._moveViewElement(this._afterView, viewsCount);
    this._moveViewElement(this._additionalView, 1);
  }
  _moveViewElement(view, coefficient) {
    view && move(view.$element(), {
      left: this._getViewPosition(coefficient),
      top: 0
    });
  }
  _getViewPosition(coefficient) {
    const rtlCorrection = this.option("rtlEnabled") ? -1 : 1;
    return 100 * coefficient * rtlCorrection + "%";
  }
  _cellClickHandler(e) {
    const zoomLevel = this.option("zoomLevel");
    const nextView = date_default.getViewDown(zoomLevel);
    const isMaxZoomLevel = this._isMaxZoomLevel();
    if (nextView && !isMaxZoomLevel) {
      this._navigateDown(e.event.currentTarget);
    } else {
      var _this$_cellClickActio;
      const newValue = this._updateTimeComponent(e.value);
      this._selectionStrategy.selectValue(newValue, e.event);
      null === (_this$_cellClickActio = this._cellClickAction) || void 0 === _this$_cellClickActio || _this$_cellClickActio.call(this, e);
    }
  }
  _updateTimeComponent(date) {
    const result2 = new Date(date);
    const currentValue = this._dateOption("value");
    if (currentValue && this._isSingleMode()) {
      result2.setHours(currentValue.getHours());
      result2.setMinutes(currentValue.getMinutes());
      result2.setSeconds(currentValue.getSeconds());
      result2.setMilliseconds(currentValue.getMilliseconds());
    }
    return result2;
  }
  _isMaxZoomLevel() {
    return this.option("zoomLevel") === this.option("maxZoomLevel");
  }
  _navigateDown(cell) {
    const zoomLevel = this.option("zoomLevel");
    if (this._isMaxZoomLevel()) {
      return;
    }
    const nextView = date_default.getViewDown(zoomLevel);
    if (!nextView) {
      return;
    }
    let newCurrentDate = this._view.option("contouredDate") || this._view.option("date");
    if (cell) {
      newCurrentDate = renderer_default(cell).data("dxDateValueKey");
    }
    this._isOtherViewCellClicked = true;
    this.option("currentDate", newCurrentDate);
    this.option("zoomLevel", nextView);
    this._isOtherViewCellClicked = false;
    this._renderNavigator();
    this._animateShowView();
    this._moveToClosestAvailableDate();
    this._setViewContoured(this._getNormalizedDate(this.option("currentDate")));
  }
  _renderNavigator() {
    if (!this._navigator) {
      this._navigator = new m_calendar_navigator_default(renderer_default("<div>"), this._navigatorConfig());
    }
    this._navigator.option("text", this._getViewsCaption(this._view, this._additionalView));
    this._updateButtonsVisibility();
  }
  _navigatorConfig() {
    const {
      focusStateEnabled,
      rtlEnabled
    } = this.option();
    return {
      text: this._getViewsCaption(this._view, this._additionalView),
      onClick: this._navigatorClickHandler.bind(this),
      onCaptionClick: this._navigateUp.bind(this),
      focusStateEnabled,
      rtlEnabled,
      tabIndex: void 0
    };
  }
  _navigatorClickHandler(e) {
    const {
      currentDate,
      viewsCount
    } = this.option();
    let offset2 = e.direction;
    if (viewsCount > 1) {
      const additionalViewActive = this._isAdditionalViewDate(currentDate);
      const shouldDoubleOffset = additionalViewActive && offset2 < 0 || !additionalViewActive && offset2 > 0;
      if (shouldDoubleOffset) {
        offset2 *= 2;
      }
    }
    const newCurrentDate = this._getDateByOffset(offset2, currentDate);
    this._moveToClosestAvailableDate(newCurrentDate);
  }
  _navigateUp() {
    const zoomLevel = this.option("zoomLevel");
    const nextView = date_default.getViewUp(zoomLevel);
    if (!nextView || this._isMinZoomLevel(zoomLevel)) {
      return;
    }
    this.option("zoomLevel", nextView);
    this._renderNavigator();
    this._animateShowView();
    this._moveToClosestAvailableDate();
    this._setViewContoured(this._getNormalizedDate(this.option("currentDate")));
  }
  _isMinZoomLevel(zoomLevel) {
    const min = this._getMinDate();
    const max = this._getMaxDate();
    return date_default.sameView(zoomLevel, min, max) || this.option("minZoomLevel") === zoomLevel;
  }
  _updateButtonsVisibility() {
    this._navigator.toggleButton("next", !isDefined(this._afterView));
    this._navigator.toggleButton("prev", !isDefined(this._beforeView));
  }
  _renderSwipeable() {
    if (!this._swipeable) {
      this._swipeable = this._createComponent(this.$element(), m_swipeable_default, {
        onStart: this._swipeStartHandler.bind(this),
        onUpdated: this._swipeUpdateHandler.bind(this),
        onEnd: this._swipeEndHandler.bind(this),
        itemSizeFunc: this._viewWidth.bind(this)
      });
    }
  }
  _swipeStartHandler(e) {
    fx_default.stop(this._$viewsWrapper, true);
    const {
      viewsCount
    } = this.option();
    this._toggleGestureCoverCursor("grabbing");
    e.event.maxLeftOffset = this._getRequiredView("next") ? 1 / viewsCount : 0;
    e.event.maxRightOffset = this._getRequiredView("prev") ? 1 / viewsCount : 0;
  }
  _toggleGestureCoverCursor(cursor) {
    renderer_default(".dx-gesture-cover").css("cursor", cursor);
  }
  _getRequiredView(name2) {
    let view;
    const isRtl = this.option("rtlEnabled");
    if ("next" === name2) {
      view = isRtl ? this._beforeView : this._afterView;
    } else if ("prev" === name2) {
      view = isRtl ? this._afterView : this._beforeView;
    }
    return view;
  }
  _swipeUpdateHandler(e) {
    const {
      offset: offset2
    } = e.event;
    move(this._$viewsWrapper, {
      left: offset2 * this._viewWidth(),
      top: 0
    });
    this._updateNavigatorCaption(offset2);
  }
  _swipeEndHandler(e) {
    this._toggleGestureCoverCursor("auto");
    const {
      currentDate,
      rtlEnabled
    } = this.option();
    const {
      targetOffset
    } = e.event;
    const moveOffset = !targetOffset ? 0 : targetOffset / Math.abs(targetOffset);
    const isAdditionalViewActive = this._isAdditionalViewDate(currentDate);
    const shouldDoubleOffset = isAdditionalViewActive && (rtlEnabled ? -1 === moveOffset : 1 === moveOffset);
    if (0 === moveOffset) {
      this._animateWrapper(0, 250);
      return;
    }
    const offset2 = -moveOffset * this._getRtlCorrection() * (shouldDoubleOffset ? 2 : 1);
    let date = this._getDateByOffset(offset2);
    if (this._isDateInInvalidRange(date)) {
      if (moveOffset >= 0) {
        date = new Date(this._getMinDate());
      } else {
        date = new Date(this._getMaxDate());
      }
    }
    this.option("currentDate", date);
  }
  _viewWidth() {
    if (!this._viewWidthValue) {
      const {
        viewsCount
      } = this.option();
      this._viewWidthValue = getWidth(this.$element()) / viewsCount;
    }
    return this._viewWidthValue;
  }
  _updateNavigatorCaption(offset2) {
    offset2 *= this._getRtlCorrection();
    const {
      viewsCount
    } = this.option();
    const isMultiView = viewsCount > 1;
    let view;
    let additionalView;
    if (offset2 > 0.5 && this._beforeView) {
      view = this._beforeView;
      additionalView = isMultiView && this._view;
    } else if (offset2 < -0.5 && this._afterView) {
      view = isMultiView ? this._additionalView : this._afterView;
      additionalView = isMultiView ? this._afterView : null;
    } else {
      view = this._view;
      additionalView = isMultiView ? this._additionalView : null;
    }
    this._navigator.option("text", this._getViewsCaption(view, additionalView));
  }
  _getViewsCaption(view, additionalView) {
    let caption = view.getNavigatorCaption();
    const {
      viewsCount
    } = this.option();
    if (viewsCount > 1 && additionalView) {
      const additionalViewCaption = additionalView.getNavigatorCaption();
      caption = `${caption} - ${additionalViewCaption}`;
    }
    return caption;
  }
  _isDateInInvalidRange(date) {
    if (this._view.isBoundary(date)) {
      return;
    }
    const min = this._getMinDate();
    const max = this._getMaxDate();
    const normalizedDate = date_default.normalizeDate(date, min, max);
    return normalizedDate === min || normalizedDate === max;
  }
  _renderFooter() {
    const showTodayButton = this.option("showTodayButton");
    if (showTodayButton) {
      const $todayButton = this._createComponent(renderer_default("<div>"), button_default2, {
        focusStateEnabled: this.option("focusStateEnabled"),
        text: message_default.format("dxCalendar-todayButtonText"),
        onClick: (args) => {
          this._toTodayView(args);
        },
        type: isFluent() ? "normal" : "default",
        stylingMode: isFluent() ? "outlined" : "text",
        integrationOptions: {}
      }).$element().addClass("dx-calendar-today-button");
      this._$footer = renderer_default("<div>").addClass("dx-calendar-footer").append($todayButton);
      this.$element().append(this._$footer);
    }
    this.$element().toggleClass("dx-calendar-with-footer", showTodayButton);
  }
  _renderSubmitElement() {
    this._$submitElement = renderer_default("<input>").attr("type", "hidden").appendTo(this.$element());
    this._setSubmitValue(this.option("value"));
  }
  _setSubmitValue(value2) {
    const dateValue = this._convertToDate(value2);
    this._getSubmitElement().val(date_serialization_default.serializeDate(dateValue, "yyyy-MM-dd"));
  }
  _getSubmitElement() {
    return this._$submitElement;
  }
  _animateShowView() {
    fx_default.stop(this._view.$element(), true);
    this._popAnimationView(this._view, 0.6, 1, 250);
    const {
      viewsCount
    } = this.option();
    if (viewsCount > 1) {
      fx_default.stop(this._additionalView.$element(), true);
      this._popAnimationView(this._additionalView, 0.6, 1, 250);
    }
  }
  _popAnimationView(view, from, to, duration) {
    return fx_default.animate(view.$element(), {
      type: "pop",
      from: {
        scale: from,
        opacity: from
      },
      to: {
        scale: to,
        opacity: to
      },
      duration
    });
  }
  _navigate(offset2, value2) {
    if (0 !== offset2 && 1 !== Math.abs(offset2) && this._isViewAvailable(value2)) {
      const newView = this._renderSpecificView(value2);
      if (offset2 > 0) {
        var _this$_afterView;
        null === (_this$_afterView = this._afterView) || void 0 === _this$_afterView || _this$_afterView.$element().remove();
        this._afterView = newView;
      } else {
        var _this$_beforeView;
        null === (_this$_beforeView = this._beforeView) || void 0 === _this$_beforeView || _this$_beforeView.$element().remove();
        this._beforeView = newView;
      }
      this._translateViews();
    }
    const rtlCorrection = this._getRtlCorrection();
    const offsetSign = offset2 > 0 ? 1 : offset2 < 0 ? -1 : 0;
    const endPosition = -rtlCorrection * offsetSign * this._viewWidth();
    const viewsWrapperPosition = this._$viewsWrapper.position().left;
    if (viewsWrapperPosition !== endPosition) {
      if (this._preventViewChangeAnimation) {
        this._wrapperAnimationEndHandler(offset2, value2);
      } else {
        this._animateWrapper(endPosition, 250).done(this._wrapperAnimationEndHandler.bind(this, offset2, value2));
      }
    }
  }
  _animateWrapper(to, duration) {
    return fx_default.animate(this._$viewsWrapper, {
      type: "slide",
      from: {
        left: this._$viewsWrapper.position().left
      },
      to: {
        left: to
      },
      duration
    });
  }
  _getDate(value2) {
    return new Date(value2);
  }
  _toTodayView(args) {
    const today = /* @__PURE__ */ new Date();
    if (this._isMaxZoomLevel()) {
      this._selectionStrategy.selectValue(today, args.event);
      return;
    }
    this._preventViewChangeAnimation = true;
    this.option("zoomLevel", this.option("maxZoomLevel"));
    this._selectionStrategy.selectValue(today, args.event);
    this._animateShowView();
    this._preventViewChangeAnimation = false;
  }
  _wrapperAnimationEndHandler(offset2, newDate) {
    this._rearrangeViews(offset2);
    this._translateViews();
    this._resetLocation();
    this._renderNavigator();
    this._setViewContoured(newDate);
    this._updateAriaId(newDate);
    this._selectionStrategy.updateAriaSelected();
  }
  _rearrangeViews(offset2) {
    var _this$viewToRemoveKey;
    if (0 === offset2) {
      return;
    }
    const {
      viewsCount
    } = this.option();
    let viewOffset;
    let viewToCreateKey;
    let viewToRemoveKey;
    let viewBeforeCreateKey;
    let viewAfterRemoveKey;
    if (offset2 < 0) {
      viewOffset = 1;
      viewToCreateKey = "_beforeView";
      viewToRemoveKey = "_afterView";
      viewBeforeCreateKey = "_view";
      viewAfterRemoveKey = 1 === viewsCount ? "_view" : "_additionalView";
    } else {
      viewOffset = -1;
      viewToCreateKey = "_afterView";
      viewToRemoveKey = "_beforeView";
      viewBeforeCreateKey = 1 === viewsCount ? "_view" : "_additionalView";
      viewAfterRemoveKey = "_view";
    }
    if (!this[viewToCreateKey]) {
      return;
    }
    const destinationDate = this[viewToCreateKey].option("date");
    null === (_this$viewToRemoveKey = this[viewToRemoveKey]) || void 0 === _this$viewToRemoveKey || _this$viewToRemoveKey.$element().remove();
    this[viewToRemoveKey] = this._renderSpecificView(this._getDateByOffset(viewOffset * viewsCount, destinationDate));
    this[viewAfterRemoveKey].$element().remove();
    if (1 === viewsCount) {
      this[viewAfterRemoveKey] = this[viewToCreateKey];
    } else {
      this[viewAfterRemoveKey] = this[viewBeforeCreateKey];
      this[viewBeforeCreateKey] = this[viewToCreateKey];
    }
    const dateByOffset = this._getDateByOffset(-viewOffset, destinationDate);
    this[viewToCreateKey] = this._isViewAvailable(dateByOffset) ? this._renderSpecificView(dateByOffset) : null;
  }
  _resetLocation() {
    move(this._$viewsWrapper, {
      left: 0,
      top: 0
    });
  }
  _clean() {
    super._clean();
    this._clearViewWidthCache();
    delete this._$viewsWrapper;
    delete this._navigator;
    delete this._$footer;
  }
  _clearViewWidthCache() {
    delete this._viewWidthValue;
  }
  _disposeViews() {
    var _this$_beforeView2, _this$_additionalView2, _this$_afterView2;
    this._view.$element().remove();
    null === (_this$_beforeView2 = this._beforeView) || void 0 === _this$_beforeView2 || _this$_beforeView2.$element().remove();
    null === (_this$_additionalView2 = this._additionalView) || void 0 === _this$_additionalView2 || _this$_additionalView2.$element().remove();
    null === (_this$_afterView2 = this._afterView) || void 0 === _this$_afterView2 || _this$_afterView2.$element().remove();
    delete this._view;
    delete this._additionalView;
    delete this._beforeView;
    delete this._afterView;
    delete this._skipNavigate;
  }
  _dispose() {
    clearTimeout(this._waitRenderViewTimeout);
    super._dispose();
  }
  _refreshViews() {
    this._resetActiveState();
    this._disposeViews();
    this._renderViews();
  }
  _visibilityChanged() {
    this._translateViews();
  }
  _shouldSkipFocusEvent(event) {
    const {
      target,
      relatedTarget
    } = event;
    return renderer_default(target).parents(".dx-calendar").length && renderer_default(relatedTarget).parents(".dx-calendar").length;
  }
  _focusInHandler(event) {
    if (renderer_default(event.target).is(this._$viewsWrapper)) {
      this._setViewContoured(this.option("currentDate"));
    }
    if (this._shouldSkipFocusEvent(event)) {
      return;
    }
    super._focusInHandler.apply(this, arguments);
    this._toggleFocusClass(true, this.$element());
  }
  _focusOutHandler(event) {
    if (renderer_default(event.target).is(this._$viewsWrapper)) {
      var _this$_additionalView3;
      this._view.option("contouredDate", null);
      null === (_this$_additionalView3 = this._additionalView) || void 0 === _this$_additionalView3 || _this$_additionalView3.option("contouredDate", null);
    }
    if (this._shouldSkipFocusEvent(event)) {
      return;
    }
    super._focusOutHandler.apply(this, arguments);
    this._toggleFocusClass(false, this.$element());
  }
  _updateViewsOption(optionName, newValue) {
    var _this$_additionalView4, _this$_beforeView3, _this$_afterView3;
    this._view.option(optionName, newValue);
    null === (_this$_additionalView4 = this._additionalView) || void 0 === _this$_additionalView4 || _this$_additionalView4.option(optionName, newValue);
    null === (_this$_beforeView3 = this._beforeView) || void 0 === _this$_beforeView3 || _this$_beforeView3.option(optionName, newValue);
    null === (_this$_afterView3 = this._afterView) || void 0 === _this$_afterView3 || _this$_afterView3.option(optionName, newValue);
  }
  _setViewsMinOption(min) {
    this._restoreViewsMinMaxOptions();
    this.option("_rangeMin", this._convertToDate(min));
    this._updateViewsOption("min", this._getMinDate());
  }
  _setViewsMaxOption(max) {
    this._restoreViewsMinMaxOptions();
    this.option("_rangeMax", this._convertToDate(max));
    this._updateViewsOption("max", this._getMaxDate());
  }
  _restoreViewsMinMaxOptions() {
    this._resetActiveState();
    this.option({
      _rangeMin: null,
      _rangeMax: null
    });
    this._updateViewsOption("min", this._getMinDate());
    this._updateViewsOption("max", this._getMaxDate());
  }
  _updateNavigatorLabels() {
    let {
      zoomLevel
    } = this.option();
    zoomLevel = zoomLevel.charAt(0).toUpperCase() + zoomLevel.slice(1);
    const captionButtonText = this._navigator._caption.option("text");
    const localizedPrevButtonLabel = message_default.format(`dxCalendar-previous${zoomLevel}ButtonLabel`);
    const localizedCaptionLabel = message_default.format(`dxCalendar-caption${zoomLevel}Label`);
    const localizedNextButtonLabel = message_default.format(`dxCalendar-next${zoomLevel}ButtonLabel`);
    this.setAria("label", localizedPrevButtonLabel, this._navigator._prevButton.$element());
    this.setAria("label", `${captionButtonText}. ${localizedCaptionLabel}`, this._navigator._caption.$element());
    this.setAria("label", localizedNextButtonLabel, this._navigator._nextButton.$element());
  }
  _updateAriaSelected(value2, previousValue) {
    previousValue.forEach((item) => {
      this.setAria("selected", false, this._view._getCellByDate(item));
    });
    value2.forEach((item) => {
      this.setAria("selected", true, this._view._getCellByDate(item));
    });
    const {
      viewsCount
    } = this.option();
    if (viewsCount > 1) {
      previousValue.forEach((item) => {
        this.setAria("selected", false, this._additionalView._getCellByDate(item));
      });
      value2.forEach((item) => {
        this.setAria("selected", true, this._additionalView._getCellByDate(item));
      });
    }
  }
  _updateAriaId(value2) {
    var _this$_onContouredCha;
    value2 = value2 ?? this.option("currentDate");
    const ariaId = `dx-${new guid_default2()}`;
    const view = this._getActiveView(value2);
    const $newCell = view._getCellByDate(value2);
    this.setAria("id", ariaId, $newCell);
    this.setAria("activedescendant", ariaId);
    null === (_this$_onContouredCha = this._onContouredChanged) || void 0 === _this$_onContouredCha || _this$_onContouredCha.call(this, ariaId);
  }
  _suppressingNavigation(callback, args) {
    this._suppressNavigation = true;
    callback.apply(this, args);
    delete this._suppressNavigation;
  }
  _optionChanged(args) {
    const {
      value: value2,
      previousValue
    } = args;
    switch (args.name) {
      case "width":
        super._optionChanged(args);
        this._clearViewWidthCache();
        break;
      case "min":
      case "max":
        this.min = void 0;
        this.max = void 0;
        this._suppressingNavigation(this._updateCurrentDate, [this.option("currentDate")]);
        this._refreshViews();
        this._renderNavigator();
        break;
      case "selectionMode":
        this._refreshSelectionStrategy();
        this._initCurrentDate();
        break;
      case "selectWeekOnClick":
      case "_todayDate":
      case "showWeekNumbers":
      case "weekNumberRule":
        this._refreshViews();
        break;
      case "firstDayOfWeek":
        this._refreshViews();
        this._updateButtonsVisibility();
        break;
      case "focusStateEnabled":
      case "disabledDates":
      case "dateSerializationFormat":
      case "cellTemplate":
      case "showTodayButton":
        this._invalidate();
        break;
      case "currentDate":
        this.setAria("id", void 0, this._view._getCellByDate(previousValue));
        this._updateCurrentDate(value2);
        break;
      case "zoomLevel":
        this.$element().removeClass(`dx-calendar-view-${previousValue}`);
        this._correctZoomLevel();
        this._refreshViews();
        this._renderNavigator();
        this._updateAriaId();
        this._updateNavigatorLabels();
        break;
      case "minZoomLevel":
      case "maxZoomLevel":
        this._correctZoomLevel();
        this._updateButtonsVisibility();
        break;
      case "value": {
        const isSameValue = date_default.sameDatesArrays(value2, previousValue);
        if (!isSameValue) {
          this._selectionStrategy.processValueChanged(value2, previousValue);
        }
        this._setSubmitValue(value2);
        super._optionChanged(args);
        break;
      }
      case "viewsCount":
        this._refreshViews();
        this._renderNavigator();
        break;
      case "onCellClick":
        this._view.option("onCellClick", value2);
        break;
      case "onContouredChanged":
        this._onContouredChanged = this._createActionByOption("onContouredChanged");
        break;
      case "readOnly":
        super._optionChanged(args);
        this._updateAriaLabelAndRole();
        break;
      case "skipFocusCheck":
        break;
      default:
        super._optionChanged(args);
    }
  }
  getContouredDate() {
    const {
      contouredDate
    } = this._view.option();
    return contouredDate;
  }
};
component_registrator_default("dxCalendar", Calendar);
var m_calendar_default = Calendar;

// node_modules/devextreme/esm/ui/calendar.js
var calendar_default = m_calendar_default;

// node_modules/devextreme/esm/__internal/ui/date_box/m_date_box.strategy.js
var DateBoxStrategy = class extends class_default.inherit({}) {
  ctor(dateBox) {
    this.dateBox = dateBox;
  }
  widgetOption(option) {
    var _this$_widget;
    return null === (_this$_widget = this._widget) || void 0 === _this$_widget ? void 0 : _this$_widget.option.apply(this._widget, arguments);
  }
  _renderWidget(element) {
    element = element || renderer_default("<div>");
    this._widget = this._createWidget(element);
    this._widget.$element().appendTo(this._getWidgetContainer());
  }
  _createWidget(element) {
    const widgetName = this._getWidgetName();
    const widgetOptions = this._getWidgetOptions();
    return this.dateBox._createComponent(element, widgetName, widgetOptions);
  }
  _getWidgetOptions() {
    class_default.abstract();
  }
  _getWidgetName() {
    class_default.abstract();
  }
  getDefaultOptions() {
    return {
      mode: "text"
    };
  }
  getDisplayFormat(displayFormat) {
    class_default.abstract();
  }
  supportedKeys() {
  }
  getKeyboardListener() {
  }
  customizeButtons() {
  }
  getParsedText(text, format2) {
    const value2 = date_default3.parse(text, format2);
    return value2 || date_default3.parse(text);
  }
  renderInputMinMax() {
  }
  renderOpenedState() {
    this._updateValue();
  }
  popupConfig(popupConfig) {
    class_default.abstract();
  }
  _dimensionChanged() {
    var _this$_getPopup;
    null === (_this$_getPopup = this._getPopup()) || void 0 === _this$_getPopup || _this$_getPopup.repaint();
  }
  renderPopupContent() {
    const popup = this._getPopup();
    this._renderWidget();
    const $popupContent = popup.$content().parent();
    m_events_engine_default.off($popupContent, "mousedown");
    m_events_engine_default.on($popupContent, "mousedown", this._preventFocusOnPopup.bind(this));
  }
  _preventFocusOnPopup(e) {
    e.preventDefault();
  }
  _getWidgetContainer() {
    return this._getPopup().$content();
  }
  _getPopup() {
    return this.dateBox._popup;
  }
  popupShowingHandler() {
  }
  popupHiddenHandler() {
  }
  _updateValue(preventDefaultValue) {
    var _this$_widget2;
    null === (_this$_widget2 = this._widget) || void 0 === _this$_widget2 || _this$_widget2.option("value", this.dateBoxValue());
  }
  useCurrentDateByDefault() {
  }
  getDefaultDate() {
    return /* @__PURE__ */ new Date();
  }
  textChangedHandler() {
  }
  renderValue() {
    if (this.dateBox.option("opened")) {
      this._updateValue();
    }
  }
  getValue() {
    return this._widget.option("value");
  }
  isAdaptivityChanged() {
    return false;
  }
  dispose() {
    const popup = this._getPopup();
    if (popup) {
      popup.$content().empty();
    }
  }
  dateBoxValue(value2, event) {
    if (arguments.length) {
      return this.dateBox.dateValue.apply(this.dateBox, arguments);
    }
    return this.dateBox.dateOption.apply(this.dateBox, ["value"]);
  }
};
var m_date_box_strategy_default = DateBoxStrategy;

// node_modules/devextreme/esm/__internal/ui/date_box/m_date_box.strategy.calendar.js
var CalendarStrategy = class extends m_date_box_strategy_default {
  ctor(dateBox) {
    super.ctor(dateBox);
    this.NAME = "Calendar";
  }
  getDefaultOptions() {
    return _extends({}, super.getDefaultOptions(), {
      todayButtonText: message_default.format("dxCalendar-todayButtonText")
    });
  }
  supportedKeys() {
    const homeEndHandler = function(e) {
      if (this.option("opened")) {
        e.preventDefault();
        return true;
      }
      return false;
    };
    return {
      rightArrow() {
        if (this.option("opened")) {
          return true;
        }
      },
      leftArrow() {
        if (this.option("opened")) {
          return true;
        }
      },
      enter: function(e) {
        if (this.dateBox.option("opened")) {
          e.preventDefault();
          if (this._widget.option("zoomLevel") === this._widget.option("maxZoomLevel")) {
            const viewValue = this._getContouredValue();
            const lastActionElement = this._lastActionElement;
            const shouldCloseDropDown = this._closeDropDownByEnter();
            if (shouldCloseDropDown && viewValue && "calendar" === lastActionElement) {
              this.dateBoxValue(viewValue, e);
            }
            shouldCloseDropDown && this.dateBox.close();
            this.dateBox._valueChangeEventHandler(e);
            return !shouldCloseDropDown;
          }
          return true;
        }
        this.dateBox._valueChangeEventHandler(e);
      }.bind(this),
      home: homeEndHandler,
      end: homeEndHandler
    };
  }
  getDisplayFormat(displayFormat) {
    return displayFormat || "shortdate";
  }
  _closeDropDownByEnter() {
    return true;
  }
  _getWidgetName() {
    return calendar_default;
  }
  _getContouredValue() {
    return this._widget._view.option("contouredDate");
  }
  getKeyboardListener() {
    return this._widget;
  }
  _getWidgetOptions() {
    const disabledDates = this.dateBox.option("disabledDates");
    return extend(this.dateBox.option("calendarOptions"), {
      value: this.dateBoxValue() || null,
      selectionMode: "single",
      dateSerializationFormat: null,
      min: this.dateBox.dateOption("min"),
      max: this.dateBox.dateOption("max"),
      onValueChanged: this._valueChangedHandler.bind(this),
      onCellClick: this._cellClickHandler.bind(this),
      disabledDates: isFunction(disabledDates) ? this._injectComponent(disabledDates.bind(this.dateBox)) : disabledDates,
      onContouredChanged: this._refreshActiveDescendant.bind(this),
      skipFocusCheck: true
    });
  }
  _injectComponent(func) {
    const that = this;
    return function(params) {
      extend(params, {
        component: that.dateBox
      });
      return func(params);
    };
  }
  _refreshActiveDescendant(e) {
    this._lastActionElement = "calendar";
    this.dateBox.setAria("activedescendant", e.actionValue);
  }
  _getTodayButtonConfig() {
    const buttonsLocation = this.dateBox.option("buttonsLocation");
    const isButtonsLocationDefault = "default" === buttonsLocation;
    const position3 = isButtonsLocationDefault ? ["bottom", "center"] : splitPair(buttonsLocation);
    const stylingMode = isMaterial() ? "text" : "outlined";
    return {
      widget: "dxButton",
      toolbar: position3[0],
      location: "after" === position3[1] ? "before" : position3[1],
      options: {
        onClick: (args) => {
          this._widget._toTodayView(args);
        },
        text: this.dateBox.option("todayButtonText"),
        elementAttr: {
          class: "dx-button-today"
        },
        stylingMode
      }
    };
  }
  _isCalendarVisible() {
    const {
      calendarOptions
    } = this.dateBox.option();
    return isEmptyObject(calendarOptions) || false !== calendarOptions.visible;
  }
  _getPopupToolbarItems(toolbarItems) {
    const useButtons = "useButtons" === this.dateBox.option("applyValueMode");
    const shouldRenderTodayButton = useButtons && this._isCalendarVisible();
    if (shouldRenderTodayButton) {
      const todayButton = this._getTodayButtonConfig();
      return [todayButton, ...toolbarItems];
    }
    return toolbarItems;
  }
  popupConfig(popupConfig) {
    return extend(true, popupConfig, {
      position: {
        collision: "flipfit flip"
      },
      width: "auto"
    });
  }
  _valueChangedHandler(e) {
    const {
      value: value2
    } = e;
    const prevValue = e.previousValue;
    if (date_default.sameDate(value2, prevValue) && date_default.sameHoursAndMinutes(value2, prevValue)) {
      return;
    }
    if ("instantly" === this.dateBox.option("applyValueMode")) {
      this.dateBoxValue(this.getValue(), e.event);
    }
  }
  _updateValue(preventDefaultValue) {
    if (!this._widget) {
      return;
    }
    this._widget.option("value", this.dateBoxValue());
  }
  textChangedHandler() {
    this._lastActionElement = "input";
    if (this.dateBox.option("opened") && this._widget) {
      this._updateValue(true);
    }
  }
  _cellClickHandler(e) {
    const {
      dateBox
    } = this;
    if ("instantly" === dateBox.option("applyValueMode")) {
      dateBox.option("opened", false);
      this.dateBoxValue(this.getValue(), e.event);
    }
  }
};
var m_date_box_strategy_calendar_default = CalendarStrategy;

// node_modules/devextreme/esm/ui/collection/ui.collection_widget.edit.js
var ui_collection_widget_edit_default = m_collection_widget_edit_default;

// node_modules/devextreme/esm/__internal/ui/m_box.js
var MINSIZE_MAP = {
  row: "minWidth",
  col: "minHeight"
};
var MAXSIZE_MAP = {
  row: "maxWidth",
  col: "maxHeight"
};
var FLEX_JUSTIFY_CONTENT_MAP = {
  start: "flex-start",
  end: "flex-end",
  center: "center",
  "space-between": "space-between",
  "space-around": "space-around"
};
var FLEX_ALIGN_ITEMS_MAP = {
  start: "flex-start",
  end: "flex-end",
  center: "center",
  stretch: "stretch"
};
var FLEX_DIRECTION_MAP = {
  row: "row",
  col: "column"
};
var setFlexProp = (element, prop, value2) => {
  value2 = normalizeStyleProp(prop, value2);
  element.style[styleProp(prop)] = value2;
  if (!hasWindow()) {
    if ("" === value2 || !isDefined(value2)) {
      return;
    }
    const cssName = dasherize(prop);
    const styleExpr = `${cssName}: ${value2};`;
    setStyle(element, styleExpr, false);
  }
};
var BoxItem = class extends item_default {
  _renderVisible(value2, oldValue) {
    super._renderVisible(value2);
    if (isDefined(oldValue)) {
      this._options.fireItemStateChangedAction({
        name: "visible",
        state: value2,
        oldState: oldValue
      });
    }
  }
};
var LayoutStrategy = class {
  constructor($element, option) {
    this._$element = $element;
    this._option = option;
  }
  renderBox() {
    this._$element.css({
      display: `${stylePropPrefix("flexDirection")}flex`
    });
    setFlexProp(this._$element.get(0), "flexDirection", FLEX_DIRECTION_MAP[this._option("direction")]);
  }
  renderAlign() {
    this._$element.css({
      justifyContent: this._normalizedAlign()
    });
  }
  _normalizedAlign() {
    const align = this._option("align");
    return align in FLEX_JUSTIFY_CONTENT_MAP ? FLEX_JUSTIFY_CONTENT_MAP[align] : align;
  }
  renderCrossAlign() {
    this._$element.css({
      alignItems: this._normalizedCrossAlign()
    });
  }
  _normalizedCrossAlign() {
    const crossAlign = this._option("crossAlign");
    return crossAlign in FLEX_ALIGN_ITEMS_MAP ? FLEX_ALIGN_ITEMS_MAP[crossAlign] : crossAlign;
  }
  renderItems($items) {
    const flexPropPrefix = stylePropPrefix("flexDirection");
    const direction = this._option("direction");
    each($items, function() {
      const $item = renderer_default(this);
      const item = $item.data("dxBoxItemData");
      $item.css({
        display: `${flexPropPrefix}flex`
      }).css(MAXSIZE_MAP[direction], item.maxSize || "none").css(MINSIZE_MAP[direction], item.minSize || "0");
      setFlexProp($item.get(0), "flexBasis", item.baseSize || 0);
      setFlexProp($item.get(0), "flexGrow", item.ratio);
      setFlexProp($item.get(0), "flexShrink", isDefined(item.shrink) ? item.shrink : 1);
      $item.children().each((_, itemContent) => {
        renderer_default(itemContent).css({
          width: "auto",
          height: "auto",
          display: `${stylePropPrefix("flexDirection")}flex`,
          flexBasis: 0
        });
        setFlexProp(itemContent, "flexGrow", 1);
        setFlexProp(itemContent, "flexDirection", renderer_default(itemContent)[0].style.flexDirection || "column");
      });
    });
  }
};
var Box = class _Box extends ui_collection_widget_edit_default {
  _getDefaultOptions() {
    return extend(super._getDefaultOptions(), {
      direction: "row",
      align: "start",
      crossAlign: "stretch",
      activeStateEnabled: false,
      focusStateEnabled: false,
      onItemStateChanged: void 0,
      _queue: void 0
    });
  }
  _itemClass() {
    return "dx-box-item";
  }
  _itemDataKey() {
    return "dxBoxItemData";
  }
  _itemElements() {
    return this._itemContainer().children(this._itemSelector());
  }
  _init() {
    super._init();
    this.$element().addClass("dx-box-flex");
    this._initLayout();
    this._initBoxQueue();
  }
  _initLayout() {
    this._layout = new LayoutStrategy(this.$element(), this.option.bind(this));
  }
  _initBoxQueue() {
    this._queue = this.option("_queue") || [];
  }
  _queueIsNotEmpty() {
    return this.option("_queue") ? false : !!this._queue.length;
  }
  _pushItemToQueue($item, config3) {
    this._queue.push({
      $item,
      config: config3
    });
  }
  _shiftItemFromQueue() {
    return this._queue.shift();
  }
  _initMarkup() {
    this.$element().addClass("dx-box");
    this._layout.renderBox();
    super._initMarkup();
    this._renderAlign();
    this._renderActions();
  }
  _renderActions() {
    this._onItemStateChanged = this._createActionByOption("onItemStateChanged");
  }
  _renderAlign() {
    this._layout.renderAlign();
    this._layout.renderCrossAlign();
  }
  _renderItems(items) {
    super._renderItems(items);
    while (this._queueIsNotEmpty()) {
      const item = this._shiftItemFromQueue();
      this._createComponent(item.$item, _Box, extend({
        itemTemplate: this.option("itemTemplate"),
        itemHoldTimeout: this.option("itemHoldTimeout"),
        onItemHold: this.option("onItemHold"),
        onItemClick: this.option("onItemClick"),
        onItemContextMenu: this.option("onItemContextMenu"),
        onItemRendered: this.option("onItemRendered"),
        _queue: this._queue
      }, item.config));
    }
    this._layout.renderItems(this._itemElements());
  }
  _renderItemContent(args) {
    const $itemNode = args.itemData && args.itemData.node;
    if ($itemNode) {
      return this._renderItemContentByNode(args, $itemNode);
    }
    return super._renderItemContent(args);
  }
  _postprocessRenderItem(args) {
    const boxConfig = args.itemData.box;
    if (!boxConfig) {
      return;
    }
    this._pushItemToQueue(args.itemContent, boxConfig);
  }
  _createItemByTemplate(itemTemplate, args) {
    if (args.itemData.box) {
      return itemTemplate.source ? itemTemplate.source() : renderer_default();
    }
    return super._createItemByTemplate(itemTemplate, args);
  }
  _itemOptionChanged(item, property, value2, prevValue) {
    if ("visible" === property) {
      this._onItemStateChanged({
        name: property,
        state: value2,
        oldState: false !== prevValue
      });
    }
    super._itemOptionChanged(item, property, value2);
  }
  _optionChanged(args) {
    switch (args.name) {
      case "_queue":
      case "direction":
        this._invalidate();
        break;
      case "align":
        this._layout.renderAlign();
        break;
      case "crossAlign":
        this._layout.renderCrossAlign();
        break;
      default:
        super._optionChanged(args);
    }
  }
  _itemOptions() {
    const options2 = super._itemOptions();
    options2.fireItemStateChangedAction = (e) => {
      this._onItemStateChanged(e);
    };
    return options2;
  }
};
Box.ItemClass = BoxItem;
component_registrator_default("dxBox", Box);
var m_box_default = Box;

// node_modules/devextreme/esm/__internal/ui/date_box/m_date_utils.js
var DATE_COMPONENTS = ["year", "day", "month", "day"];
var TIME_COMPONENTS = ["hours", "minutes", "seconds", "milliseconds"];
var ONE_DAY = 864e5;
var ONE_YEAR = 31536e6;
var getStringFormat = function(format2) {
  const formatType = typeof format2;
  if ("string" === formatType) {
    return "format";
  }
  if ("object" === formatType && void 0 !== format2.type) {
    return format2.type;
  }
  return null;
};
var dateUtils2 = {
  SUPPORTED_FORMATS: ["date", "time", "datetime"],
  ONE_MINUTE: 6e4,
  ONE_DAY,
  ONE_YEAR,
  MIN_DATEVIEW_DEFAULT_DATE: new Date(1900, 0, 1),
  MAX_DATEVIEW_DEFAULT_DATE: function() {
    const newDate = /* @__PURE__ */ new Date();
    return new Date(newDate.getFullYear() + 50, newDate.getMonth(), newDate.getDate(), 23, 59, 59);
  }(),
  FORMATS_INFO: {
    date: {
      getStandardPattern: () => "yyyy-MM-dd",
      components: DATE_COMPONENTS
    },
    time: {
      getStandardPattern: () => "HH:mm",
      components: TIME_COMPONENTS
    },
    datetime: {
      getStandardPattern() {
        let standardPattern;
        !function() {
          const $input = renderer_default("<input>").attr("type", "datetime");
          $input.val("2000-01-01T01:01Z");
          if ($input.val()) {
            standardPattern = "yyyy-MM-ddTHH:mmZ";
          }
        }();
        if (!standardPattern) {
          standardPattern = "yyyy-MM-ddTHH:mm:ssZ";
        }
        dateUtils2.FORMATS_INFO.datetime.getStandardPattern = function() {
          return standardPattern;
        };
        return standardPattern;
      },
      components: [...DATE_COMPONENTS, ...TIME_COMPONENTS]
    },
    "datetime-local": {
      getStandardPattern: () => "yyyy-MM-ddTHH:mm:ss",
      components: [...DATE_COMPONENTS, "hours", "minutes", "seconds"]
    }
  },
  FORMATS_MAP: {
    date: "shortdate",
    time: "shorttime",
    datetime: "shortdateshorttime"
  },
  SUBMIT_FORMATS_MAP: {
    date: "date",
    time: "time",
    datetime: "datetime-local"
  },
  toStandardDateFormat(date, type2) {
    const pattern = dateUtils2.FORMATS_INFO[type2].getStandardPattern();
    return date_serialization_default.serializeDate(date, pattern);
  },
  fromStandardDateFormat(text) {
    const date = date_serialization_default.dateParser(text);
    return isDate(date) ? date : void 0;
  },
  getMaxMonthDay: (year, month) => new Date(year, month + 1, 0).getDate(),
  mergeDates(oldValue, newValue, format2) {
    if (!newValue) {
      return newValue || null;
    }
    if (!oldValue || isNaN(oldValue.getTime())) {
      const now = /* @__PURE__ */ new Date(null);
      oldValue = new Date(now.getFullYear(), now.getMonth(), now.getDate());
    }
    const result2 = new Date(oldValue.valueOf());
    const formatInfo = dateUtils2.FORMATS_INFO[format2];
    each(formatInfo.components, function() {
      const componentInfo = dateUtils2.DATE_COMPONENTS_INFO[this];
      result2[componentInfo.setter](newValue[componentInfo.getter]());
    });
    return result2;
  },
  getLongestCaptionIndex(captionArray) {
    let longestIndex = 0;
    let longestCaptionLength = 0;
    let i;
    for (i = 0; i < captionArray.length; ++i) {
      if (captionArray[i].length > longestCaptionLength) {
        longestIndex = i;
        longestCaptionLength = captionArray[i].length;
      }
    }
    return longestIndex;
  },
  formatUsesMonthName: (format2) => date_default3.formatUsesMonthName(format2),
  formatUsesDayName: (format2) => date_default3.formatUsesDayName(format2),
  getLongestDate(format2, monthNames, dayNames) {
    const stringFormat = getStringFormat(format2);
    let month = 9;
    if (!stringFormat || dateUtils2.formatUsesMonthName(stringFormat)) {
      month = dateUtils2.getLongestCaptionIndex(monthNames);
    }
    const longestDate = new Date(1888, month, 21, 23, 59, 59, 999);
    if (!stringFormat || dateUtils2.formatUsesDayName(stringFormat)) {
      const date = longestDate.getDate() - longestDate.getDay() + dateUtils2.getLongestCaptionIndex(dayNames);
      longestDate.setDate(date);
    }
    return longestDate;
  },
  normalizeTime(date) {
    date.setSeconds(0);
    date.setMilliseconds(0);
  }
};
dateUtils2.DATE_COMPONENTS_INFO = {
  year: {
    getter: "getFullYear",
    setter: "setFullYear",
    formatter(value2, date) {
      const formatDate = new Date(date.getTime());
      formatDate.setFullYear(value2);
      return date_default3.format(formatDate, "yyyy");
    },
    startValue: void 0,
    endValue: void 0
  },
  day: {
    getter: "getDate",
    setter: "setDate",
    formatter(value2, date) {
      const formatDate = new Date(date.getTime());
      formatDate.setDate(value2);
      return date_default3.format(formatDate, "d");
    },
    startValue: 1,
    endValue: void 0
  },
  month: {
    getter: "getMonth",
    setter: "setMonth",
    formatter: (value2) => date_default3.getMonthNames()[value2],
    startValue: 0,
    endValue: 11
  },
  hours: {
    getter: "getHours",
    setter: "setHours",
    formatter: (value2) => date_default3.format(new Date(0, 0, 0, value2), "hour"),
    startValue: 0,
    endValue: 23
  },
  minutes: {
    getter: "getMinutes",
    setter: "setMinutes",
    formatter: (value2) => date_default3.format(new Date(0, 0, 0, 0, value2), "minute"),
    startValue: 0,
    endValue: 59
  },
  seconds: {
    getter: "getSeconds",
    setter: "setSeconds",
    formatter: (value2) => date_default3.format(new Date(0, 0, 0, 0, 0, value2), "second"),
    startValue: 0,
    endValue: 59
  },
  milliseconds: {
    getter: "getMilliseconds",
    setter: "setMilliseconds",
    formatter: (value2) => date_default3.format(new Date(0, 0, 0, 0, 0, 0, value2), "millisecond"),
    startValue: 0,
    endValue: 999
  }
};
var m_date_utils_default = dateUtils2;

// node_modules/devextreme/esm/__internal/ui/date_box/m_time_view.js
var rotateArrow = function($arrow, angle, offset2) {
  cssRotate($arrow, angle, offset2);
};
var cssRotate = function($arrow, angle, offset2) {
  $arrow.css("transform", `rotate(${angle}deg) translate(0,${offset2}px)`);
};
var TimeView = class extends editor_default {
  _getDefaultOptions() {
    return _extends({}, super._getDefaultOptions(), {
      value: new Date(Date.now()),
      use24HourFormat: true,
      _showClock: true,
      _arrowOffset: 5
    });
  }
  _getValue() {
    const {
      value: value2
    } = this.option();
    return value2 || /* @__PURE__ */ new Date();
  }
  _init() {
    super._init();
    this.$element().addClass("dx-timeview");
  }
  _render() {
    super._render();
    this._renderBox();
    this._updateTime();
  }
  _renderBox() {
    const $box = renderer_default("<div>").appendTo(this.$element());
    const items = [];
    if (this.option("_showClock")) {
      items.push({
        ratio: 1,
        shrink: 0,
        baseSize: "auto",
        template: this._renderClock.bind(this)
      });
    }
    items.push({
      ratio: 0,
      shrink: 0,
      baseSize: "auto",
      template: this._renderField.bind(this)
    });
    this._createComponent($box, m_box_default, {
      height: "100%",
      width: "100%",
      direction: "col",
      items
    });
  }
  _renderClock(_, __, container) {
    this._$hourArrow = renderer_default("<div>").addClass("dx-timeview-hourarrow");
    this._$minuteArrow = renderer_default("<div>").addClass("dx-timeview-minutearrow");
    const $container = renderer_default(container);
    $container.addClass("dx-timeview-clock").append(this._$hourArrow).append(this._$minuteArrow);
    this.setAria("role", "presentation", $container);
  }
  _updateClock() {
    const time = this._getValue();
    const hourArrowAngle = time.getHours() / 12 * 360 + time.getMinutes() / 60 * 30;
    const minuteArrowAngle = time.getMinutes() / 60 * 360;
    rotateArrow(this._$hourArrow, hourArrowAngle, this.option("_arrowOffset"));
    rotateArrow(this._$minuteArrow, minuteArrowAngle, this.option("_arrowOffset"));
  }
  _getBoxItems(is12HourFormat) {
    const items = [{
      ratio: 0,
      shrink: 0,
      baseSize: "auto",
      template: () => this._hourBox.$element()
    }, {
      ratio: 0,
      shrink: 0,
      baseSize: "auto",
      template: renderer_default("<div>").addClass("dx-timeview-time-separator").text(date_default3.getTimeSeparator())
    }, {
      ratio: 0,
      shrink: 0,
      baseSize: "auto",
      template: () => this._minuteBox.$element()
    }];
    if (is12HourFormat) {
      items.push({
        ratio: 0,
        shrink: 0,
        baseSize: "auto",
        template: () => this._format12.$element()
      });
    }
    return items;
  }
  _renderField() {
    const is12HourFormat = !this.option("use24HourFormat");
    this._createHourBox(is12HourFormat);
    this._createMinuteBox();
    if (is12HourFormat) {
      this._createFormat12Box();
    }
    return this._createComponent(renderer_default("<div>").addClass("dx-timeview-field"), m_box_default, {
      direction: "row",
      align: "center",
      crossAlign: "center",
      items: this._getBoxItems(is12HourFormat)
    }).$element();
  }
  _createHourBox(is12HourFormat) {
    this._hourBox = this._createComponent(renderer_default("<div>"), m_number_box_default, _extends({
      min: -1,
      max: is12HourFormat ? 13 : 24,
      value: this._getValue().getHours(),
      onValueChanged: this._onHourBoxValueChanged.bind(this),
      onKeyboardHandled: (opts) => this._keyboardHandler(opts)
    }, this._getNumberBoxConfig()));
    this._hourBox.setAria("label", "hours");
  }
  _isPM() {
    return !this.option("use24HourFormat") && 1 === this._format12.option("value");
  }
  _onHourBoxValueChanged(_ref) {
    let {
      value: value2,
      component
    } = _ref;
    const currentValue = this._getValue();
    const newValue = new Date(currentValue);
    let newHours = this._convertMaxHourToMin(value2);
    component.option("value", newHours);
    if (this._isPM()) {
      newHours += 12;
    }
    newValue.setHours(newHours);
    m_date_utils_default.normalizeTime(newValue);
    this.option("value", newValue);
  }
  _convertMaxHourToMin(hours) {
    const maxHoursValue = this.option("use24HourFormat") ? 24 : 12;
    return (maxHoursValue + hours) % maxHoursValue;
  }
  _createMinuteBox() {
    this._minuteBox = this._createComponent(renderer_default("<div>"), m_number_box_default, _extends({
      min: -1,
      max: 60,
      value: this._getValue().getMinutes(),
      onKeyboardHandled: (opts) => this._keyboardHandler(opts),
      onValueChanged: (_ref2) => {
        let {
          value: value2,
          component
        } = _ref2;
        const newMinutes = (60 + value2) % 60;
        component.option("value", newMinutes);
        const time = new Date(this._getValue());
        time.setMinutes(newMinutes);
        m_date_utils_default.normalizeTime(time);
        this.option("value", time);
      }
    }, this._getNumberBoxConfig()));
    this._minuteBox.setAria("label", "minutes");
  }
  _createFormat12Box() {
    const periodNames = date_default3.getPeriodNames();
    this._format12 = this._createComponent(renderer_default("<div>").addClass("dx-timeview-format12"), m_select_box_default, {
      items: [{
        value: -1,
        text: periodNames[0]
      }, {
        value: 1,
        text: periodNames[1]
      }],
      valueExpr: "value",
      displayExpr: "text",
      onKeyboardHandled: (opts) => this._keyboardHandler(opts),
      onValueChanged: (_ref3) => {
        let {
          value: value2
        } = _ref3;
        const hours = this._getValue().getHours();
        const time = new Date(this._getValue());
        const newHours = (hours + 12 * value2) % 24;
        time.setHours(newHours);
        this.option("value", time);
      },
      value: this._getValue().getHours() >= 12 ? 1 : -1,
      stylingMode: this.option("stylingMode")
    });
    this._format12.setAria("label", "type");
  }
  _refreshFormat12() {
    if (this.option("use24HourFormat")) {
      return;
    }
    const value2 = this._getValue();
    const hours = value2.getHours();
    const isPM = hours >= 12;
    const newValue = isPM ? 1 : -1;
    this._silentEditorValueUpdate(this._format12, newValue);
  }
  _silentEditorValueUpdate(editor, value2) {
    if (editor) {
      editor._suppressValueChangeAction();
      editor.option("value", value2);
      editor._resumeValueChangeAction();
    }
  }
  _getNumberBoxConfig() {
    const {
      stylingMode
    } = this.option();
    return {
      showSpinButtons: true,
      displayValueFormatter: (value2) => (value2 < 10 ? "0" : "") + value2,
      stylingMode
    };
  }
  _normalizeHours(hours) {
    return this.option("use24HourFormat") ? hours : hours % 12 || 12;
  }
  _updateField() {
    const hours = this._normalizeHours(this._getValue().getHours());
    this._silentEditorValueUpdate(this._hourBox, hours);
    this._silentEditorValueUpdate(this._minuteBox, this._getValue().getMinutes());
    this._refreshFormat12();
  }
  _updateTime() {
    if (this.option("_showClock")) {
      this._updateClock();
    }
    this._updateField();
  }
  _visibilityChanged(visible2) {
    if (visible2) {
      this._updateTime();
    }
  }
  _optionChanged(args) {
    switch (args.name) {
      case "value":
        this._updateTime();
        super._optionChanged(args);
        break;
      case "_arrowOffset":
        break;
      case "use24HourFormat":
      case "_showClock":
      case "stylingMode":
        this._invalidate();
        break;
      default:
        super._optionChanged(args);
    }
  }
};
component_registrator_default("dxTimeView", TimeView);
var m_time_view_default = TimeView;

// node_modules/devextreme/esm/__internal/ui/date_box/m_date_box.strategy.calendar_with_time.js
var window24 = getWindow();
var DATEBOX_TIMEVIEW_SIDE_CLASS = "dx-datebox-datetime-time-side";
var CalendarWithTimeStrategy = class extends m_date_box_strategy_calendar_default {
  ctor(dateBox) {
    super.ctor(dateBox);
    this.NAME = "CalendarWithTime";
  }
  getDefaultOptions() {
    return _extends({}, super.getDefaultOptions(), {
      applyValueMode: "useButtons",
      buttonsLocation: "bottom after",
      "dropDownOptions.showTitle": false
    });
  }
  _closeDropDownByEnter() {
    return date_default.sameDate(this._getContouredValue(), this.widgetOption("value"));
  }
  getDisplayFormat(displayFormat) {
    return displayFormat || "shortdateshorttime";
  }
  _is24HourFormat() {
    return date_default3.is24HourFormat(this.getDisplayFormat(this.dateBox.option("displayFormat")));
  }
  _getContouredValue() {
    const viewDate = super._getContouredValue();
    return this._updateDateTime(viewDate);
  }
  _renderWidget() {
    super._renderWidget();
    this._timeView = this.dateBox._createComponent(renderer_default("<div>"), m_time_view_default, {
      value: this.dateBoxValue(),
      _showClock: !this._isShrinkView(),
      use24HourFormat: this._is24HourFormat(),
      onValueChanged: this._valueChangedHandler.bind(this),
      stylingMode: this.dateBox.option("stylingMode")
    });
  }
  renderOpenedState() {
    super.renderOpenedState();
    const popup = this._getPopup();
    if (popup) {
      popup.$wrapper().toggleClass("dx-datebox-adaptivity-mode", this._isSmallScreen());
    }
    clearTimeout(this._repaintTimer);
    this._repaintTimer = setTimeout(() => {
      var _this$_getPopup;
      null === (_this$_getPopup = this._getPopup()) || void 0 === _this$_getPopup || _this$_getPopup.repaint();
    }, 0);
  }
  isAdaptivityChanged() {
    const isAdaptiveMode = this._isShrinkView();
    const currentAdaptiveMode = this._currentAdaptiveMode;
    if (isAdaptiveMode !== currentAdaptiveMode) {
      this._currentAdaptiveMode = isAdaptiveMode;
      return void 0 !== currentAdaptiveMode;
    }
    return super.isAdaptivityChanged();
  }
  _updateValue(preventDefaultValue) {
    let date = this.dateBoxValue();
    if (!date && !preventDefaultValue) {
      date = /* @__PURE__ */ new Date();
      m_date_utils_default.normalizeTime(date);
    }
    super._updateValue();
    if (this._timeView) {
      date && this._timeView.option("value", date);
      this._timeView.option("use24HourFormat", this._is24HourFormat());
    }
  }
  _isSmallScreen() {
    return getWidth(window24) <= 573;
  }
  _isShrinkView() {
    return !this.dateBox.option("showAnalogClock") || this.dateBox.option("adaptivityEnabled") && this._isSmallScreen();
  }
  _getBoxItems() {
    const items = [{
      ratio: 0,
      shrink: 0,
      baseSize: "auto",
      name: "calendar"
    }];
    if (!this._isShrinkView()) {
      items.push({
        ratio: 0,
        shrink: 0,
        baseSize: "auto",
        name: "time"
      });
    }
    return items;
  }
  renderPopupContent() {
    super.renderPopupContent();
    this._currentAdaptiveMode = this._isShrinkView();
    const $popupContent = this._getPopup().$content();
    this._box = this.dateBox._createComponent(renderer_default("<div>").appendTo($popupContent), m_box_default, {
      direction: "row",
      crossAlign: "stretch",
      items: this._getBoxItems(),
      itemTemplate: function(data17, i, element) {
        const $container = renderer_default("<div>");
        switch (data17.name) {
          case "calendar":
            $container.append(this._widget.$element());
            if (this._isShrinkView()) {
              this._timeView.$element().addClass(DATEBOX_TIMEVIEW_SIDE_CLASS);
              $container.append(this._timeView.$element());
            }
            break;
          case "time":
            $container.append(this._timeView.$element());
            renderer_default(element).addClass(DATEBOX_TIMEVIEW_SIDE_CLASS);
        }
        return $container;
      }.bind(this)
    });
  }
  popupConfig(popupConfig) {
    const calendarPopupConfig = super.popupConfig(popupConfig);
    return extend(calendarPopupConfig, {
      width: "auto"
    });
  }
  _preventFocusOnPopup(e) {
    if (!renderer_default(e.target).hasClass("dx-texteditor-input")) {
      super._preventFocusOnPopup.apply(this, arguments);
      if (!this.dateBox._hasFocusClass()) {
        this.dateBox.focus();
      }
    }
  }
  _updateDateTime(date) {
    const {
      value: time
    } = this._timeView.option();
    date.setHours(time.getHours(), time.getMinutes(), time.getSeconds(), time.getMilliseconds());
    return date;
  }
  getValue() {
    let date = this._widget.option("value") ?? this._widget.getContouredDate();
    date = date ? new Date(date) : /* @__PURE__ */ new Date();
    return this._updateDateTime(date);
  }
  dispose() {
    clearTimeout(this._removeMinWidthTimer);
    clearTimeout(this._repaintTimer);
    super.dispose();
  }
};
var m_date_box_strategy_calendar_with_time_default = CalendarWithTimeStrategy;

// node_modules/devextreme/esm/__internal/ui/scroll_view/utils/scroll_direction.js
var ScrollDirection = class {
  constructor(direction) {
    this.DIRECTION_HORIZONTAL = "horizontal";
    this.DIRECTION_VERTICAL = "vertical";
    this.DIRECTION_BOTH = "both";
    this.direction = direction ?? DIRECTION_VERTICAL;
  }
  get isHorizontal() {
    return this.direction === DIRECTION_HORIZONTAL || this.direction === DIRECTION_BOTH;
  }
  get isVertical() {
    return this.direction === DIRECTION_VERTICAL || this.direction === DIRECTION_BOTH;
  }
  get isBoth() {
    return this.direction === DIRECTION_BOTH;
  }
};

// node_modules/devextreme/esm/__internal/ui/scroll_view/utils/convert_location.js
function convertToLocation(location, direction) {
  if (isPlainObject(location)) {
    const left = ensureDefined(location.left, location.x);
    const top = ensureDefined(location.top, location.y);
    return {
      left: isDefined(left) ? left : void 0,
      top: isDefined(top) ? top : void 0
    };
  }
  const {
    isVertical,
    isHorizontal
  } = new ScrollDirection(direction);
  return {
    left: isHorizontal && isDefined(location) ? location : void 0,
    top: isVertical && isDefined(location) ? location : void 0
  };
}

// node_modules/devextreme/esm/__internal/ui/date_box/m_date_view_roller.js
var DateViewRoller = class extends m_scrollable_default {
  _getDefaultOptions() {
    return _extends({}, super._getDefaultOptions(), {
      showScrollbar: "never",
      useNative: false,
      selectedIndex: 0,
      bounceEnabled: false,
      items: [],
      showOnClick: false,
      onClick: null,
      onSelectedIndexChanged: null,
      scrollByContent: true
    });
  }
  _init() {
    super._init();
    this.option("onVisibilityChange", this._visibilityChangedHandler.bind(this));
    this.option("onEnd", this._endActionHandler.bind(this));
  }
  _render() {
    super._render();
    this._renderSelectedItemFrame();
    this.$element().addClass("dx-dateviewroller");
    this._renderContainerClick();
    this._renderItems();
    this._renderSelectedValue();
    this._renderItemsClick();
    this._renderWheelEvent();
    this._renderSelectedIndexChanged();
  }
  _renderSelectedIndexChanged() {
    this._selectedIndexChanged = this._createActionByOption("onSelectedIndexChanged");
  }
  _renderWheelEvent() {
    m_events_engine_default.on(renderer_default(this.container()), "dxmousewheel", (e) => {
      this._isWheelScrolled = true;
    });
  }
  _renderContainerClick() {
    if (!this.option("showOnClick")) {
      return;
    }
    const eventName = addNamespace2(CLICK_EVENT_NAME, this.NAME);
    const clickAction = this._createActionByOption("onClick");
    m_events_engine_default.off(renderer_default(this.container()), eventName);
    m_events_engine_default.on(renderer_default(this.container()), eventName, (e) => {
      clickAction({
        event: e
      });
    });
  }
  _renderItems() {
    const items = this.option("items") || [];
    let $items = renderer_default();
    renderer_default(this.content()).empty();
    items.forEach((item) => {
      $items = $items.add(renderer_default("<div>").addClass("dx-dateview-item").append(item));
    });
    renderer_default(this.content()).append($items);
    this._$items = $items;
    this.update();
  }
  _renderSelectedItemFrame() {
    renderer_default("<div>").addClass("dx-dateview-item-selected-frame").append(renderer_default("<div>").addClass("dx-dateview-item-selected-border")).appendTo(renderer_default(this.container()));
  }
  _renderSelectedValue(selectedIndex) {
    const index2 = this._fitIndex(selectedIndex ?? this.option("selectedIndex"));
    this._moveTo({
      top: this._getItemPosition(index2)
    });
    this._renderActiveStateItem();
  }
  _fitIndex(index2) {
    const items = this.option("items") || [];
    const itemCount = items.length;
    if (index2 >= itemCount) {
      return itemCount - 1;
    }
    if (index2 < 0) {
      return 0;
    }
    return index2;
  }
  _getItemPosition(index2) {
    return Math.round(this._itemHeight() * index2);
  }
  _renderItemsClick() {
    const itemSelector = this._getItemSelector();
    const eventName = addNamespace2(CLICK_EVENT_NAME, this.NAME);
    m_events_engine_default.off(this.$element(), eventName, itemSelector);
    m_events_engine_default.on(this.$element(), eventName, itemSelector, this._itemClickHandler.bind(this));
  }
  _getItemSelector() {
    return ".dx-dateview-item";
  }
  _itemClickHandler(e) {
    this.option("selectedIndex", this._itemElementIndex(e.currentTarget));
  }
  _itemElementIndex(itemElement) {
    return this._itemElements().index(itemElement);
  }
  _itemElements() {
    return this.$element().find(this._getItemSelector());
  }
  _renderActiveStateItem() {
    const selectedIndex = this.option("selectedIndex");
    each(this._$items, function(index2) {
      renderer_default(this).toggleClass("dx-dateview-item-selected", selectedIndex === index2);
    });
  }
  _shouldScrollToNeighborItem() {
    return "desktop" === devices_default.real().deviceType && this._isWheelScrolled;
  }
  _moveTo(targetLocation) {
    const {
      top,
      left
    } = convertToLocation(targetLocation);
    const location = this.scrollOffset();
    const delta = {
      x: location.left - left,
      y: location.top - top
    };
    if (this._isVisible() && (delta.x || delta.y)) {
      this._prepareDirections(true);
      if (this._animation && !this._shouldScrollToNeighborItem()) {
        const that = this;
        fx_default.stop(renderer_default(this.content()));
        fx_default.animate(renderer_default(this.content()), {
          duration: 200,
          type: "slide",
          to: {
            top: Math.floor(delta.y)
          },
          complete() {
            resetPosition(renderer_default(that.content()));
            that.handleMove({
              delta
            });
          }
        });
        delete this._animation;
      } else {
        this.handleMove({
          delta
        });
      }
    }
  }
  _validate(e) {
    return this._moveIsAllowed(e);
  }
  _fitSelectedIndexInRange(index2) {
    const itemsCount = this.option("items").length;
    return Math.max(Math.min(index2, itemsCount - 1), 0);
  }
  _isInNullNeighborhood(x) {
    return -0.1 <= x && x <= 0.1;
  }
  _getSelectedIndexAfterScroll(currentSelectedIndex) {
    const locationTop = this.scrollOffset().top;
    const currentSelectedIndexPosition = currentSelectedIndex * this._itemHeight();
    const dy = locationTop - currentSelectedIndexPosition;
    if (this._isInNullNeighborhood(dy)) {
      return currentSelectedIndex;
    }
    const direction = dy > 0 ? 1 : -1;
    const newSelectedIndex = this._fitSelectedIndexInRange(currentSelectedIndex + direction);
    return newSelectedIndex;
  }
  _getNewSelectedIndex(currentSelectedIndex) {
    if (this._shouldScrollToNeighborItem()) {
      return this._getSelectedIndexAfterScroll(currentSelectedIndex);
    }
    this._animation = true;
    const ratio = this.scrollOffset().top / this._itemHeight();
    return Math.round(ratio);
  }
  _endActionHandler() {
    const currentSelectedIndex = this.option("selectedIndex");
    const newSelectedIndex = this._getNewSelectedIndex(currentSelectedIndex);
    if (newSelectedIndex === currentSelectedIndex) {
      this._renderSelectedValue(newSelectedIndex);
    } else {
      this.option("selectedIndex", newSelectedIndex);
    }
    this._isWheelScrolled = false;
  }
  _itemHeight() {
    const $item = this._$items.first();
    return getHeight($item);
  }
  _toggleActive(state) {
    this.$element().toggleClass("dx-state-active", state);
  }
  _isVisible() {
    return renderer_default(this.container()).is(":visible");
  }
  _fireSelectedIndexChanged(value2, previousValue) {
    var _this$_selectedIndexC;
    null === (_this$_selectedIndexC = this._selectedIndexChanged) || void 0 === _this$_selectedIndexC || _this$_selectedIndexC.call(this, {
      value: value2,
      previousValue,
      event: void 0
    });
  }
  _visibilityChanged(visible2) {
    super._visibilityChanged(visible2);
    this._visibilityChangedHandler(visible2);
  }
  _visibilityChangedHandler(visible2) {
    if (visible2) {
      this._visibilityTimer = setTimeout(() => {
        this._renderSelectedValue(this.option("selectedIndex"));
      });
    }
    this.toggleActiveState(false);
  }
  toggleActiveState(state) {
    this.$element().toggleClass("dx-dateviewroller-current", state);
  }
  _refreshSelectedIndex() {
    const selectedIndex = this.option("selectedIndex");
    const fitIndex = this._fitIndex(selectedIndex);
    if (fitIndex === selectedIndex) {
      this._renderActiveStateItem();
    } else {
      this.option("selectedIndex", fitIndex);
    }
  }
  _optionChanged(args) {
    switch (args.name) {
      case "selectedIndex":
        this._fireSelectedIndexChanged(args.value, args.previousValue);
        this._renderSelectedValue(args.value);
        break;
      case "items":
        this._renderItems();
        this._refreshSelectedIndex();
        break;
      case "onClick":
      case "showOnClick":
        this._renderContainerClick();
        break;
      case "onSelectedIndexChanged":
        this._renderSelectedIndexChanged();
        break;
      default:
        super._optionChanged(args);
    }
  }
  _dispose() {
    clearTimeout(this._visibilityTimer);
    super._dispose();
  }
};
component_registrator_default("dxDateViewRoller", DateViewRoller);
var m_date_view_roller_default = DateViewRoller;

// node_modules/devextreme/esm/__internal/ui/date_box/m_date_view.js
var TYPE = {
  date: "date",
  datetime: "datetime",
  time: "time"
};
var ROLLER_TYPE = {
  year: "year",
  month: "month",
  day: "day",
  hours: "hours"
};
var DateView = class extends editor_default {
  _valueOption() {
    const {
      value: value2
    } = this.option();
    const date = new Date(value2);
    return !value2 || isNaN(date) ? this._getDefaultDate() : date;
  }
  _getDefaultDate() {
    const date = /* @__PURE__ */ new Date();
    const {
      type: type2
    } = this.option();
    if (type2 === TYPE.date) {
      return new Date(date.getFullYear(), date.getMonth(), date.getDate());
    }
    return date;
  }
  _getDefaultOptions() {
    return _extends({}, super._getDefaultOptions(), {
      minDate: m_date_utils_default.MIN_DATEVIEW_DEFAULT_DATE,
      maxDate: m_date_utils_default.MAX_DATEVIEW_DEFAULT_DATE,
      type: TYPE.date,
      value: /* @__PURE__ */ new Date(),
      applyCompactClass: false
    });
  }
  _defaultOptionsRules() {
    return super._defaultOptionsRules().concat([{
      device: (device) => "desktop" !== device.deviceType,
      options: {
        applyCompactClass: true
      }
    }]);
  }
  _render() {
    super._render();
    this.$element().addClass("dx-dateview");
    const {
      type: type2
    } = this.option();
    this._toggleFormatClasses(type2);
    this._toggleCompactClass();
  }
  _toggleFormatClasses(currentFormat, previousFormat) {
    this.$element().addClass(`dx-dateview-${currentFormat}`);
    previousFormat && this.$element().removeClass(`dx-dateview-${previousFormat}`);
  }
  _toggleCompactClass() {
    const {
      applyCompactClass
    } = this.option();
    this.$element().toggleClass("dx-dateview-compact", applyCompactClass);
  }
  _wrapper() {
    return this._$wrapper;
  }
  _renderContentImpl() {
    this._$wrapper = renderer_default("<div>").addClass("dx-dateview-wrapper");
    this._renderRollers();
    this._$wrapper.appendTo(this.$element());
  }
  _renderRollers() {
    if (!this._$rollersContainer) {
      this._$rollersContainer = renderer_default("<div>").addClass("dx-dateview-rollers");
    }
    this._$rollersContainer.empty();
    this._createRollerConfigs();
    this._rollers = {};
    const that = this;
    each(that._rollerConfigs, (name2) => {
      const $roller = renderer_default("<div>").appendTo(that._$rollersContainer).addClass(`dx-dateviewroller-${that._rollerConfigs[name2].type}`);
      that._rollers[that._rollerConfigs[name2].type] = that._createComponent($roller, m_date_view_roller_default, {
        items: that._rollerConfigs[name2].displayItems,
        selectedIndex: that._rollerConfigs[name2].selectedIndex,
        showScrollbar: "never",
        scrollByContent: true,
        onStart(e) {
          const roller = e.component;
          roller._toggleActive(true);
          that._setActiveRoller(that._rollerConfigs[name2]);
        },
        onEnd(e) {
          const roller = e.component;
          roller._toggleActive(false);
        },
        onClick(e) {
          const roller = e.component;
          roller._toggleActive(true);
          that._setActiveRoller(that._rollerConfigs[name2]);
          that._setRollerState(that._rollerConfigs[name2], roller.option("selectedIndex"));
          roller._toggleActive(false);
        },
        onSelectedIndexChanged(e) {
          const roller = e.component;
          that._setRollerState(that._rollerConfigs[name2], roller.option("selectedIndex"));
        }
      });
    });
    that._$rollersContainer.appendTo(that._wrapper());
  }
  _createRollerConfigs(type2) {
    const that = this;
    type2 = type2 || that.option("type");
    that._rollerConfigs = {};
    date_default3.getFormatParts(m_date_utils_default.FORMATS_MAP[type2]).forEach((partName) => {
      that._createRollerConfig(partName);
    });
  }
  _createRollerConfig(componentName) {
    const componentInfo = m_date_utils_default.DATE_COMPONENTS_INFO[componentName];
    const valueRange = this._calculateRollerConfigValueRange(componentName);
    const {
      startValue
    } = valueRange;
    const {
      endValue
    } = valueRange;
    const {
      formatter
    } = componentInfo;
    const curDate = this._getCurrentDate();
    const config3 = {
      type: componentName,
      setValue: componentInfo.setter,
      valueItems: [],
      displayItems: [],
      getIndex: (value2) => value2[componentInfo.getter]() - startValue
    };
    for (let i = startValue; i <= endValue; i++) {
      config3.valueItems.push(i);
      config3.displayItems.push(formatter(i, curDate));
    }
    config3.selectedIndex = config3.getIndex(curDate);
    this._rollerConfigs[componentName] = config3;
  }
  _setActiveRoller(currentRoller) {
    const activeRoller = currentRoller && this._rollers[currentRoller.type];
    each(this._rollers, function() {
      this.toggleActiveState(this === activeRoller);
    });
  }
  _updateRollersPosition() {
    const that = this;
    each(this._rollers, function(type2) {
      const correctIndex = that._rollerConfigs[type2].getIndex(that._getCurrentDate());
      this.option("selectedIndex", correctIndex);
    });
  }
  _setRollerState(roller, selectedIndex) {
    if (selectedIndex !== roller.selectedIndex) {
      const rollerValue = roller.valueItems[selectedIndex];
      const {
        setValue
      } = roller;
      let currentValue = new Date(this._getCurrentDate());
      let currentDate = currentValue.getDate();
      const minDate = this.option("minDate");
      const maxDate = this.option("maxDate");
      if (roller.type === ROLLER_TYPE.month) {
        currentDate = Math.min(currentDate, m_date_utils_default.getMaxMonthDay(currentValue.getFullYear(), rollerValue));
      } else if (roller.type === ROLLER_TYPE.year) {
        currentDate = Math.min(currentDate, m_date_utils_default.getMaxMonthDay(rollerValue, currentValue.getMonth()));
      }
      currentValue.setDate(currentDate);
      currentValue[setValue](rollerValue);
      const normalizedDate = date_default.normalizeDate(currentValue, minDate, maxDate);
      currentValue = m_date_utils_default.mergeDates(normalizedDate, currentValue, "time");
      currentValue = date_default.normalizeDate(currentValue, minDate, maxDate);
      this.option("value", currentValue);
      roller.selectedIndex = selectedIndex;
    }
    if (roller.type === ROLLER_TYPE.year) {
      this._refreshRollers();
    }
    if (roller.type === ROLLER_TYPE.month) {
      this._refreshRoller(ROLLER_TYPE.day);
      this._refreshRoller(ROLLER_TYPE.hours);
    }
  }
  _refreshRoller(rollerType) {
    const roller = this._rollers[rollerType];
    if (roller) {
      this._createRollerConfig(rollerType);
      const rollerConfig = this._rollerConfigs[rollerType];
      if (rollerType === ROLLER_TYPE.day || rollerConfig.displayItems.toString() !== roller.option("items").toString()) {
        roller.option({
          items: rollerConfig.displayItems,
          selectedIndex: rollerConfig.selectedIndex
        });
      }
    }
  }
  _getCurrentDate() {
    const curDate = this._valueOption();
    const minDate = this.option("minDate");
    const maxDate = this.option("maxDate");
    return date_default.normalizeDate(curDate, minDate, maxDate);
  }
  _calculateRollerConfigValueRange(componentName) {
    const curDate = this._getCurrentDate();
    const {
      minDate,
      maxDate
    } = this.option();
    const minYear = date_default.sameYear(curDate, minDate);
    const minMonth = minYear && curDate.getMonth() === minDate.getMonth();
    const maxYear = date_default.sameYear(curDate, maxDate);
    const maxMonth = maxYear && curDate.getMonth() === maxDate.getMonth();
    const minHour = minMonth && curDate.getDate() === minDate.getDate();
    const maxHour = maxMonth && curDate.getDate() === maxDate.getDate();
    const componentInfo = m_date_utils_default.DATE_COMPONENTS_INFO[componentName];
    let {
      startValue
    } = componentInfo;
    let {
      endValue
    } = componentInfo;
    if (componentName === ROLLER_TYPE.year) {
      startValue = minDate.getFullYear();
      endValue = maxDate.getFullYear();
    }
    if (componentName === ROLLER_TYPE.month) {
      if (minYear) {
        startValue = minDate.getMonth();
      }
      if (maxYear) {
        endValue = maxDate.getMonth();
      }
    }
    if (componentName === ROLLER_TYPE.day) {
      endValue = m_date_utils_default.getMaxMonthDay(curDate.getFullYear(), curDate.getMonth());
      if (minYear && minMonth) {
        startValue = minDate.getDate();
      }
      if (maxYear && maxMonth) {
        endValue = maxDate.getDate();
      }
    }
    if (componentName === ROLLER_TYPE.hours) {
      startValue = minHour ? minDate.getHours() : startValue;
      endValue = maxHour ? maxDate.getHours() : endValue;
    }
    return {
      startValue,
      endValue
    };
  }
  _refreshRollers() {
    this._refreshRoller(ROLLER_TYPE.month);
    this._refreshRoller(ROLLER_TYPE.day);
    this._refreshRoller(ROLLER_TYPE.hours);
  }
  _optionChanged(args) {
    switch (args.name) {
      case "minDate":
      case "maxDate":
      case "type":
        this._renderRollers();
        this._toggleFormatClasses(args.value, args.previousValue);
        break;
      case "visible":
        super._optionChanged(args);
        if (args.value) {
          this._renderRollers();
        }
        break;
      case "value":
        this.option("value", this._valueOption());
        this._refreshRollers();
        this._updateRollersPosition();
        break;
      default:
        super._optionChanged(args);
    }
  }
  _clean() {
    super._clean();
    delete this._$rollersContainer;
  }
};
component_registrator_default("dxDateView", DateView);
var m_date_view_default = DateView;

// node_modules/devextreme/esm/__internal/ui/date_box/m_date_box.strategy.date_view.js
var window25 = getWindow();
var DateViewStrategy = class extends m_date_box_strategy_default {
  ctor(dateBox) {
    super.ctor(dateBox);
    this.NAME = "DateView";
  }
  getDefaultOptions() {
    return _extends({}, super.getDefaultOptions(), {
      openOnFieldClick: true,
      applyButtonText: message_default.format("OK"),
      "dropDownOptions.showTitle": true
    });
  }
  getDisplayFormat(displayFormat) {
    return displayFormat || m_date_utils_default.FORMATS_MAP[this.dateBox.option("type")];
  }
  popupConfig(config3) {
    return {
      toolbarItems: this.dateBox._popupToolbarItemsConfig(),
      onInitialized: config3.onInitialized,
      defaultOptionsRules: [{
        device: {
          platform: "android"
        },
        options: {
          width: 333,
          height: 331
        }
      }, {
        device(device) {
          const {
            platform
          } = device;
          return "generic" === platform || "ios" === platform;
        },
        options: {
          width: "auto",
          height: "auto"
        }
      }, {
        device(device) {
          const {
            platform
          } = device;
          const {
            phone
          } = device;
          return "generic" === platform && phone;
        },
        options: {
          width: 333,
          maxWidth: "100%",
          maxHeight: "100%",
          height: "auto",
          position: {
            collision: "flipfit flip"
          }
        }
      }, {
        device: {
          platform: "ios",
          phone: true
        },
        options: {
          width: "100%",
          position: {
            my: "bottom",
            at: "bottom",
            of: window25
          }
        }
      }]
    };
  }
  _renderWidget() {
    if (inputType(this.dateBox.option("mode")) && this.dateBox._isNativeType() || this.dateBox.option("readOnly")) {
      if (this._widget) {
        this._widget.$element().remove();
        this._widget = null;
      }
      return;
    }
    const popup = this._getPopup();
    if (this._widget) {
      this._widget.option(this._getWidgetOptions());
    } else {
      const element = renderer_default("<div>").appendTo(popup.$content());
      this._widget = this._createWidget(element);
    }
    this._widget.$element().appendTo(this._getWidgetContainer());
  }
  _getWidgetName() {
    return m_date_view_default;
  }
  renderOpenedState() {
    super.renderOpenedState();
    if (this._widget) {
      this._widget.option("value", this._widget._getCurrentDate());
    }
  }
  _getWidgetOptions() {
    return {
      value: this.dateBoxValue() || /* @__PURE__ */ new Date(),
      type: this.dateBox.option("type"),
      minDate: this.dateBox.dateOption("min") || new Date(1900, 0, 1),
      maxDate: this.dateBox.dateOption("max") || new Date(Date.now() + 50 * m_date_utils_default.ONE_YEAR),
      onDisposing: function() {
        this._widget = null;
      }.bind(this)
    };
  }
};
var m_date_box_strategy_date_view_default = DateViewStrategy;

// node_modules/devextreme/esm/__internal/ui/date_box/m_date_box.strategy.list.js
var window26 = getWindow();
var BOUNDARY_VALUES = {
  min: new Date(0, 0, 0, 0, 0),
  max: new Date(0, 0, 0, 23, 59)
};
var ListStrategy = class extends m_date_box_strategy_default {
  ctor(dateBox) {
    super.ctor(dateBox);
    this.NAME = "List";
  }
  supportedKeys() {
    return {
      space: noop2,
      home: noop2,
      end: noop2
    };
  }
  getDefaultOptions() {
    return _extends({}, super.getDefaultOptions(), {
      applyValueMode: "instantly"
    });
  }
  getDisplayFormat(displayFormat) {
    return displayFormat || "shorttime";
  }
  popupConfig(popupConfig) {
    return popupConfig;
  }
  getValue() {
    const selectedIndex = this._widget.option("selectedIndex");
    if (-1 === selectedIndex) {
      return this.dateBox.option("value");
    }
    const itemData = this._widgetItems[selectedIndex];
    return this._getDateByItemData(itemData);
  }
  useCurrentDateByDefault() {
    return true;
  }
  getDefaultDate() {
    return /* @__PURE__ */ new Date(null);
  }
  popupShowingHandler() {
    this.dateBox._dimensionChanged();
  }
  _renderWidget() {
    super._renderWidget();
    this._refreshItems();
  }
  _getWidgetName() {
    return list_light_default;
  }
  _getWidgetOptions() {
    return {
      itemTemplate: this._timeListItemTemplate.bind(this),
      onItemClick: this._listItemClickHandler.bind(this),
      tabIndex: -1,
      onFocusedItemChanged: this._refreshActiveDescendant.bind(this),
      selectionMode: "single"
    };
  }
  _refreshActiveDescendant(e) {
    this.dateBox.setAria("activedescendant", "");
    this.dateBox.setAria("activedescendant", e.actionValue);
  }
  _refreshItems() {
    this._widgetItems = this._getTimeListItems();
    this._widget.option("items", this._widgetItems);
  }
  renderOpenedState() {
    if (!this._widget) {
      return;
    }
    this._widget.option("focusedElement", null);
    this._setSelectedItemsByValue();
    if (this._widget.option("templatesRenderAsynchronously")) {
      this._asyncScrollTimeout = setTimeout(this._scrollToSelectedItem.bind(this));
    } else {
      this._scrollToSelectedItem();
    }
  }
  dispose() {
    super.dispose();
    clearTimeout(this._asyncScrollTimeout);
  }
  _updateValue() {
    if (!this._widget) {
      return;
    }
    this._refreshItems();
    this._setSelectedItemsByValue();
    this._scrollToSelectedItem();
  }
  _setSelectedItemsByValue() {
    const value2 = this.dateBoxValue();
    const dateIndex = this._getDateIndex(value2);
    if (-1 === dateIndex) {
      this._widget.option("selectedItems", []);
    } else {
      this._widget.option("selectedIndex", dateIndex);
    }
  }
  _scrollToSelectedItem() {
    this._widget.scrollToItem(this._widget.option("selectedIndex"));
  }
  _getDateIndex(date) {
    let result2 = -1;
    for (let i = 0, n = this._widgetItems.length; i < n; i++) {
      if (this._areDatesEqual(date, this._widgetItems[i])) {
        result2 = i;
        break;
      }
    }
    return result2;
  }
  _areDatesEqual(first, second) {
    return isDate(first) && isDate(second) && first.getHours() === second.getHours() && first.getMinutes() === second.getMinutes();
  }
  _getTimeListItems() {
    let min = this.dateBox.dateOption("min") || this._getBoundaryDate("min");
    const max = this.dateBox.dateOption("max") || this._getBoundaryDate("max");
    const value2 = this.dateBox.dateOption("value") || null;
    let delta = max - min;
    const minutes = min.getMinutes() % this.dateBox.option("interval");
    if (delta < 0) {
      return [];
    }
    if (delta > m_date_utils_default.ONE_DAY) {
      delta = m_date_utils_default.ONE_DAY;
    }
    if (value2 - min < m_date_utils_default.ONE_DAY) {
      return this._getRangeItems(min, new Date(min), delta);
    }
    min = this._getBoundaryDate("min");
    min.setMinutes(minutes);
    if (value2 && Math.abs(value2 - max) < m_date_utils_default.ONE_DAY) {
      delta = (60 * max.getHours() + Math.abs(max.getMinutes() - minutes)) * m_date_utils_default.ONE_MINUTE;
    }
    return this._getRangeItems(min, new Date(min), delta);
  }
  _getRangeItems(startValue, currentValue, rangeDuration) {
    const rangeItems = [];
    const interval = this.dateBox.option("interval");
    while (currentValue - startValue <= rangeDuration) {
      rangeItems.push(new Date(currentValue));
      currentValue.setMinutes(currentValue.getMinutes() + interval);
    }
    return rangeItems;
  }
  _getBoundaryDate(boundary) {
    const boundaryValue = BOUNDARY_VALUES[boundary];
    const currentValue = new Date(ensureDefined(this.dateBox.dateOption("value"), 0));
    return new Date(currentValue.getFullYear(), currentValue.getMonth(), currentValue.getDate(), boundaryValue.getHours(), boundaryValue.getMinutes());
  }
  _timeListItemTemplate(itemData) {
    const displayFormat = this.dateBox.option("displayFormat");
    return date_default3.format(itemData, this.getDisplayFormat(displayFormat));
  }
  _listItemClickHandler(e) {
    if ("useButtons" === this.dateBox.option("applyValueMode")) {
      return;
    }
    const date = this._getDateByItemData(e.itemData);
    this.dateBox.option("opened", false);
    this.dateBoxValue(date, e.event);
  }
  _getDateByItemData(itemData) {
    let date = this.dateBox.option("value");
    const hours = itemData.getHours();
    const minutes = itemData.getMinutes();
    const seconds = itemData.getSeconds();
    const year = itemData.getFullYear();
    const month = itemData.getMonth();
    const day = itemData.getDate();
    if (date) {
      if (this.dateBox.option("dateSerializationFormat")) {
        date = date_serialization_default.deserializeDate(date);
      } else {
        date = new Date(date);
      }
      date.setHours(hours);
      date.setMinutes(minutes);
      date.setSeconds(seconds);
      date.setFullYear(year);
      date.setMonth(month);
      date.setDate(day);
    } else {
      date = new Date(year, month, day, hours, minutes, 0, 0);
    }
    return date;
  }
  getKeyboardListener() {
    return this._widget;
  }
  _updatePopupHeight() {
    var _this$dateBox$_timeLi;
    const dropDownOptionsHeight = getSizeValue(this.dateBox.option("dropDownOptions.height"));
    if (void 0 === dropDownOptionsHeight || "auto" === dropDownOptionsHeight) {
      this.dateBox._setPopupOption("height", "auto");
      const popupHeight = getOuterHeight(this._widget.$element());
      const maxHeight = 0.45 * getHeight(window26);
      this.dateBox._setPopupOption("height", Math.min(popupHeight, maxHeight));
    }
    null === (_this$dateBox$_timeLi = this.dateBox._timeList) || void 0 === _this$dateBox$_timeLi || _this$dateBox$_timeLi.updateDimensions();
  }
  getParsedText(text, format2) {
    let value2 = super.getParsedText(text, format2);
    if (value2) {
      value2 = m_date_utils_default.mergeDates(value2, /* @__PURE__ */ new Date(null), "date");
    }
    return value2;
  }
};
var m_date_box_strategy_list_default = ListStrategy;

// node_modules/devextreme/esm/__internal/ui/date_box/m_date_box.strategy.native.js
var NativeStrategy2 = class extends m_date_box_strategy_default {
  ctor(dateBox) {
    super.ctor(dateBox);
    this.NAME = "Native";
  }
  popupConfig(popupConfig) {
    return _extends({}, popupConfig, {
      width: "auto"
    });
  }
  getParsedText(text) {
    if (!text) {
      return null;
    }
    if ("datetime" === this.dateBox.option("type")) {
      return new Date(text.replace(/-/g, "/").replace("T", " ").split(".")[0]);
    }
    return m_date_utils_default.fromStandardDateFormat(text);
  }
  renderPopupContent() {
  }
  _getWidgetName() {
  }
  _getWidgetOptions() {
  }
  _getDateBoxType() {
    let {
      type: type2
    } = this.dateBox.option();
    if (!m_date_utils_default.SUPPORTED_FORMATS.includes(type2)) {
      type2 = "date";
    } else if ("datetime" === type2 && !inputType(type2)) {
      type2 = "datetime-local";
    }
    return type2;
  }
  customizeButtons() {
    const dropDownButton = this.dateBox.getButton("dropDown");
    if (devices_default.real().android && dropDownButton) {
      dropDownButton.on("click", () => {
        this.dateBox._input().get(0).click();
      });
    }
  }
  getDefaultOptions() {
    return {
      mode: this._getDateBoxType()
    };
  }
  getDisplayFormat(displayFormat) {
    const type2 = this._getDateBoxType();
    return displayFormat || m_date_utils_default.FORMATS_MAP[type2];
  }
  renderInputMinMax($input) {
    const type2 = this.dateBox.option("type");
    const format2 = {
      datetime: "yyyy-MM-ddTHH:mm:ss",
      date: "yyyy-MM-dd",
      time: "HH:mm:ss"
    }[type2] ?? "yyyy-MM-dd";
    $input.attr({
      min: date_serialization_default.serializeDate(this.dateBox.dateOption("min"), format2),
      max: date_serialization_default.serializeDate(this.dateBox.dateOption("max"), format2)
    });
  }
};
var m_date_box_strategy_native_default = NativeStrategy2;

// node_modules/devextreme/esm/__internal/ui/date_box/m_date_box.base.js
var window27 = getWindow();
var DX_INVALID_BADGE_CLASS2 = "dx-show-invalid-badge";
var DX_CLEAR_BUTTON_CLASS = "dx-clear-button-area";
var PICKER_TYPE = {
  calendar: "calendar",
  rollers: "rollers",
  list: "list",
  native: "native"
};
var TYPE2 = {
  date: "date",
  datetime: "datetime",
  time: "time"
};
var STRATEGY_NAME = {
  calendar: "Calendar",
  dateView: "DateView",
  native: "Native",
  calendarWithTime: "CalendarWithTime",
  list: "List"
};
var STRATEGY_CLASSES = {
  Calendar: m_date_box_strategy_calendar_default,
  DateView: m_date_box_strategy_date_view_default,
  Native: m_date_box_strategy_native_default,
  CalendarWithTime: m_date_box_strategy_calendar_with_time_default,
  List: m_date_box_strategy_list_default
};
var DateBox = class extends m_drop_down_editor_default {
  _supportedKeys() {
    return _extends({}, super._supportedKeys(), this._strategy.supportedKeys());
  }
  _renderButtonContainers() {
    super._renderButtonContainers.apply(this, arguments);
    this._strategy.customizeButtons();
  }
  _getDefaultOptions() {
    return _extends({}, super._getDefaultOptions(), {
      type: "date",
      showAnalogClock: true,
      value: null,
      displayFormat: null,
      interval: 30,
      disabledDates: null,
      pickerType: PICKER_TYPE.calendar,
      invalidDateMessage: message_default.format("dxDateBox-validation-datetime"),
      dateOutOfRangeMessage: message_default.format("validation-range"),
      applyButtonText: message_default.format("OK"),
      adaptivityEnabled: false,
      calendarOptions: {},
      useHiddenSubmitElement: true,
      _showValidationIcon: true
    });
  }
  _defaultOptionsRules() {
    return super._defaultOptionsRules().concat([{
      device: {
        platform: "ios"
      },
      options: {
        "dropDownOptions.showTitle": true
      }
    }, {
      device: {
        platform: "android"
      },
      options: {
        buttonsLocation: "bottom after"
      }
    }, {
      device() {
        const realDevice2 = devices_default.real();
        const {
          platform
        } = realDevice2;
        return "ios" === platform || "android" === platform;
      },
      options: {
        pickerType: PICKER_TYPE.native
      }
    }, {
      device: {
        platform: "generic",
        deviceType: "desktop"
      },
      options: {
        buttonsLocation: "bottom after"
      }
    }]);
  }
  _initOptions(options2) {
    this._userOptions = extend({}, options2);
    super._initOptions(options2);
    this._updatePickerOptions();
  }
  _updatePickerOptions() {
    let {
      pickerType
    } = this.option();
    const {
      type: type2
    } = this.option();
    if (pickerType === PICKER_TYPE.list && (type2 === TYPE2.datetime || type2 === TYPE2.date)) {
      pickerType = PICKER_TYPE.calendar;
    }
    if (type2 === TYPE2.time && pickerType === PICKER_TYPE.calendar) {
      pickerType = PICKER_TYPE.list;
    }
    this._pickerType = pickerType;
    this._setShowDropDownButtonOption();
  }
  _setShowDropDownButtonOption() {
    const {
      platform
    } = devices_default.real();
    const isMozillaOnAndroid = "android" === platform && browser_default.mozilla;
    const isNativePickerType = this._isNativeType();
    let showDropDownButton = "generic" !== platform || !isNativePickerType;
    if (isNativePickerType && isMozillaOnAndroid) {
      showDropDownButton = false;
    }
    this.option({
      showDropDownButton
    });
  }
  _init() {
    this._initStrategy();
    this.option(extend({}, this._strategy.getDefaultOptions(), this._userOptions));
    delete this._userOptions;
    super._init();
  }
  _toLowerCaseFirstLetter(string) {
    return string.charAt(0).toLowerCase() + string.substr(1);
  }
  _initStrategy() {
    const strategyName = this._getStrategyName(this._getFormatType());
    const strategy3 = STRATEGY_CLASSES[strategyName];
    if (!(this._strategy && this._strategy.NAME === strategyName)) {
      this._strategy = new strategy3(this);
    }
  }
  _getFormatType() {
    const currentType = this.option("type");
    const isTime = /h|m|s/g.test(currentType);
    const isDate2 = /d|M|Y/g.test(currentType);
    let type2 = "";
    if (isDate2) {
      type2 += TYPE2.date;
    }
    if (isTime) {
      type2 += TYPE2.time;
    }
    return type2;
  }
  _getStrategyName(type2) {
    const pickerType = this._pickerType;
    if (pickerType === PICKER_TYPE.rollers) {
      return STRATEGY_NAME.dateView;
    }
    if (pickerType === PICKER_TYPE.native) {
      return STRATEGY_NAME.native;
    }
    if (type2 === TYPE2.date) {
      return STRATEGY_NAME.calendar;
    }
    if (type2 === TYPE2.datetime) {
      return STRATEGY_NAME.calendarWithTime;
    }
    return STRATEGY_NAME.list;
  }
  _initMarkup() {
    this.$element().addClass("dx-datebox");
    super._initMarkup();
    this._refreshFormatClass();
    this._refreshPickerTypeClass();
    this._strategy.renderInputMinMax(this._input());
  }
  _render() {
    super._render();
    this._formatValidationIcon();
  }
  _renderDimensions() {
    super._renderDimensions();
    this.$element().toggleClass("dx-auto-width", !this.option("width"));
    this._updatePopupWidth();
    this._updatePopupHeight();
  }
  _dimensionChanged() {
    super._dimensionChanged();
    this._updatePopupHeight();
  }
  _updatePopupHeight() {
    if (this._popup) {
      var _this$_strategy$_upda, _this$_strategy;
      null === (_this$_strategy$_upda = (_this$_strategy = this._strategy)._updatePopupHeight) || void 0 === _this$_strategy$_upda || _this$_strategy$_upda.call(_this$_strategy);
    }
  }
  _refreshFormatClass() {
    const $element = this.$element();
    each(TYPE2, (_, item) => {
      $element.removeClass(`dx-datebox-${item}`);
    });
    const {
      type: type2
    } = this.option();
    $element.addClass(`dx-datebox-${type2}`);
  }
  _refreshPickerTypeClass() {
    const $element = this.$element();
    each(PICKER_TYPE, (_, item) => {
      $element.removeClass(`dx-datebox-${item}`);
    });
    $element.addClass(`dx-datebox-${this._pickerType}`);
  }
  _formatValidationIcon() {
    if (!hasWindow()) {
      return;
    }
    const inputElement = this._input().get(0);
    const isRtlEnabled = this.option("rtlEnabled");
    const clearButtonWidth = this._getClearButtonWidth();
    const longestElementDimensions = this._getLongestElementDimensions();
    const curWidth = parseFloat(window27.getComputedStyle(inputElement).width) - clearButtonWidth;
    const shouldHideValidationIcon = longestElementDimensions.width > curWidth;
    const {
      style
    } = inputElement;
    const {
      _showValidationIcon: showValidationIcon
    } = this.option();
    this.$element().toggleClass(DX_INVALID_BADGE_CLASS2, !shouldHideValidationIcon && showValidationIcon);
    if (shouldHideValidationIcon) {
      if (void 0 === this._storedPadding) {
        this._storedPadding = isRtlEnabled ? longestElementDimensions.leftPadding : longestElementDimensions.rightPadding;
      }
      isRtlEnabled ? style.paddingLeft = 0 : style.paddingRight = 0;
    } else {
      isRtlEnabled ? style.paddingLeft = `${this._storedPadding}px` : style.paddingRight = `${this._storedPadding}px`;
    }
  }
  _getClearButtonWidth() {
    let clearButtonWidth = 0;
    if (this._isClearButtonVisible() && "" === this._input().val()) {
      const clearButtonElement = this.$element().find(`.${DX_CLEAR_BUTTON_CLASS}`).get(0);
      clearButtonWidth = parseFloat(window27.getComputedStyle(clearButtonElement).width);
    }
    return clearButtonWidth;
  }
  _getLongestElementDimensions() {
    const format2 = this._strategy.getDisplayFormat(this.option("displayFormat"));
    const longestValue = date_default3.format(m_date_utils_default.getLongestDate(format2, date_default3.getMonthNames(), date_default3.getDayNames()), format2);
    const $input = this._input();
    const inputElement = $input.get(0);
    const $longestValueElement = createTextElementHiddenCopy($input, longestValue);
    const isPaddingStored = void 0 !== this._storedPadding;
    const storedPadding = !isPaddingStored ? 0 : this._storedPadding;
    $longestValueElement.appendTo(this.$element());
    const elementWidth = parseFloat(window27.getComputedStyle($longestValueElement.get(0)).width);
    const rightPadding = parseFloat(window27.getComputedStyle(inputElement).paddingRight);
    const leftPadding = parseFloat(window27.getComputedStyle(inputElement).paddingLeft);
    const necessaryWidth = elementWidth + leftPadding + rightPadding + storedPadding;
    $longestValueElement.remove();
    return {
      width: necessaryWidth,
      leftPadding,
      rightPadding
    };
  }
  _getKeyboardListeners() {
    var _this$_strategy2;
    return super._getKeyboardListeners().concat([null === (_this$_strategy2 = this._strategy) || void 0 === _this$_strategy2 ? void 0 : _this$_strategy2.getKeyboardListener()]);
  }
  _renderPopup() {
    var _this$_popup;
    super._renderPopup();
    null === (_this$_popup = this._popup) || void 0 === _this$_popup || _this$_popup.$wrapper().addClass("dx-datebox-wrapper");
    this._renderPopupWrapper();
  }
  _getPopupToolbarItems() {
    var _this$_strategy$_getP, _this$_strategy3;
    const defaultItems = super._getPopupToolbarItems();
    return (null === (_this$_strategy$_getP = (_this$_strategy3 = this._strategy)._getPopupToolbarItems) || void 0 === _this$_strategy$_getP ? void 0 : _this$_strategy$_getP.call(_this$_strategy3, defaultItems)) ?? defaultItems;
  }
  _popupConfig() {
    const popupConfig = super._popupConfig();
    return _extends({}, this._strategy.popupConfig(popupConfig), {
      title: this._getPopupTitle(),
      dragEnabled: false
    });
  }
  _renderPopupWrapper() {
    if (!this._popup) {
      return;
    }
    const $element = this.$element();
    const classPostfixes = extend({}, TYPE2, PICKER_TYPE);
    each(classPostfixes, (_, item) => {
      $element.removeClass(`dx-datebox-wrapper-${item}`);
    });
    const {
      type: type2
    } = this.option();
    this._popup.$wrapper().addClass(`dx-datebox-wrapper-${type2}`).addClass(`dx-datebox-wrapper-${this._pickerType}`).addClass("dx-dropdowneditor-overlay");
  }
  _renderPopupContent() {
    super._renderPopupContent();
    this._strategy.renderPopupContent();
  }
  _popupShowingHandler() {
    super._popupShowingHandler();
    this._strategy.popupShowingHandler();
  }
  _popupShownHandler() {
    super._popupShownHandler();
    this._strategy.renderOpenedState();
  }
  _popupHiddenHandler() {
    super._popupHiddenHandler();
    this._strategy.renderOpenedState();
    this._strategy.popupHiddenHandler();
  }
  _visibilityChanged(visible2) {
    if (visible2) {
      this._formatValidationIcon();
    }
  }
  _clearValueHandler(e) {
    this.option("text", "");
    super._clearValueHandler(e);
  }
  _readOnlyPropValue() {
    if (this._pickerType === PICKER_TYPE.rollers) {
      return true;
    }
    const {
      platform
    } = devices_default.real();
    const isCustomValueDisabled = this._isNativeType() && ("ios" === platform || "android" === platform);
    if (isCustomValueDisabled) {
      const {
        readOnly
      } = this.option();
      return readOnly;
    }
    return super._readOnlyPropValue();
  }
  _isClearButtonVisible() {
    return super._isClearButtonVisible() && !this._isNativeType();
  }
  _renderValue() {
    const value2 = this.dateOption("value");
    this.option("text", this._getDisplayedText(value2));
    this._strategy.renderValue();
    return super._renderValue();
  }
  _setSubmitValue() {
    const value2 = this.dateOption("value");
    const {
      type: type2,
      dateSerializationFormat
    } = this.option();
    const submitFormat = m_date_utils_default.SUBMIT_FORMATS_MAP[type2];
    const submitValue = dateSerializationFormat ? date_serialization_default.serializeDate(value2, dateSerializationFormat) : m_date_utils_default.toStandardDateFormat(value2, submitFormat);
    this._getSubmitElement().val(submitValue);
  }
  _getDisplayedText(value2) {
    const {
      mode
    } = this.option();
    let displayedText;
    if ("text" === mode) {
      const displayFormat = this._strategy.getDisplayFormat(this.option("displayFormat"));
      displayedText = date_default3.format(value2, displayFormat);
    } else {
      const format2 = this._getFormatByMode(mode);
      if (format2) {
        displayedText = date_default3.format(value2, format2);
      } else {
        displayedText = m_date_utils_default.toStandardDateFormat(value2, mode);
      }
    }
    return displayedText;
  }
  _getFormatByMode(mode) {
    return inputType(mode) ? null : m_date_utils_default.FORMATS_MAP[mode];
  }
  _valueChangeEventHandler(e) {
    const {
      text,
      type: type2,
      validationError
    } = this.option();
    const currentValue = this.dateOption("value");
    if (text === this._getDisplayedText(currentValue)) {
      this._recallInternalValidation(currentValue, validationError);
      return;
    }
    const parsedDate = this._getParsedDate(text);
    const value2 = currentValue ?? this._getDateByDefault();
    const newValue = m_date_utils_default.mergeDates(value2, parsedDate, type2);
    const date = parsedDate && "time" === type2 ? newValue : parsedDate;
    if (this._applyInternalValidation(date).isValid) {
      const displayedText = this._getDisplayedText(newValue);
      if (value2 && newValue && value2.getTime() === newValue.getTime() && displayedText !== text) {
        this._renderValue();
      } else {
        this.dateValue(newValue, e);
      }
    }
  }
  _recallInternalValidation(value2, validationError) {
    if (!validationError || validationError.editorSpecific) {
      this._applyInternalValidation(value2);
      this._applyCustomValidation(value2);
    }
  }
  _getDateByDefault() {
    return this._strategy.useCurrentDateByDefault() && this._strategy.getDefaultDate();
  }
  _getParsedDate(text) {
    const displayFormat = this._strategy.getDisplayFormat(this.option("displayFormat"));
    const parsedText = this._strategy.getParsedText(text, displayFormat);
    return parsedText ?? void 0;
  }
  _applyInternalValidation(value2) {
    const text = this.option("text");
    const hasText = !!text && null !== value2;
    const isDate2 = !!value2 && isDate(value2) && !isNaN(value2.getTime());
    const isDateInRange = isDate2 && date_default.dateInRange(value2, this.dateOption("min"), this.dateOption("max"), this.option("type"));
    const isValid = !hasText && !value2 || isDateInRange;
    let validationMessage = "";
    const {
      invalidDateMessage,
      dateOutOfRangeMessage
    } = this.option();
    if (!isDate2) {
      validationMessage = invalidDateMessage;
    } else if (!isDateInRange) {
      validationMessage = dateOutOfRangeMessage;
    }
    this._updateInternalValidationState(isValid, validationMessage);
    return {
      isValid,
      isDate: isDate2
    };
  }
  _updateInternalValidationState(isValid, validationMessage) {
    this.option({
      isValid,
      validationError: isValid ? null : {
        editorSpecific: true,
        message: validationMessage
      }
    });
  }
  _applyCustomValidation(value2) {
    this.validationRequest.fire({
      editor: this,
      value: this._serializeDate(value2)
    });
  }
  _isValueChanged(newValue) {
    const oldValue = this.dateOption("value");
    const oldTime = oldValue && oldValue.getTime();
    const newTime = newValue && newValue.getTime();
    return oldTime !== newTime;
  }
  _isTextChanged(newValue) {
    const oldText = this.option("text");
    const newText = newValue && this._getDisplayedText(newValue) || "";
    return oldText !== newText;
  }
  _renderProps() {
    super._renderProps();
    this._input().attr("autocomplete", "off");
  }
  _renderOpenedState() {
    if (!this._isNativeType()) {
      super._renderOpenedState();
    }
    if (this._strategy.isAdaptivityChanged()) {
      this._refreshStrategy();
    }
  }
  _getPopupTitle() {
    const {
      placeholder
    } = this.option();
    if (placeholder) {
      return placeholder;
    }
    const {
      type: type2
    } = this.option();
    if (type2 === TYPE2.time) {
      return message_default.format("dxDateBox-simulatedDataPickerTitleTime");
    }
    if (type2 === TYPE2.date || type2 === TYPE2.datetime) {
      return message_default.format("dxDateBox-simulatedDataPickerTitleDate");
    }
    return "";
  }
  _refreshStrategy() {
    this._strategy.dispose();
    this._initStrategy();
    this.option(this._strategy.getDefaultOptions());
    this._refresh();
  }
  _applyButtonHandler(e) {
    const value2 = this._strategy.getValue();
    this.dateValue(value2, e.event);
    super._applyButtonHandler();
  }
  _dispose() {
    var _this$_strategy4;
    super._dispose();
    null === (_this$_strategy4 = this._strategy) || void 0 === _this$_strategy4 || _this$_strategy4.dispose();
  }
  _isNativeType() {
    return this._pickerType === PICKER_TYPE.native;
  }
  _updatePopupTitle() {
    var _this$_popup2;
    null === (_this$_popup2 = this._popup) || void 0 === _this$_popup2 || _this$_popup2.option("title", this._getPopupTitle());
  }
  _optionChanged(args) {
    switch (args.name) {
      case "showClearButton":
      case "buttons":
      case "isValid":
      case "readOnly":
        super._optionChanged.apply(this, arguments);
        this._formatValidationIcon();
        break;
      case "pickerType":
        this._updatePickerOptions();
        this._refreshStrategy();
        this._refreshPickerTypeClass();
        this._invalidate();
        break;
      case "type":
        this._updatePickerOptions();
        this._refreshStrategy();
        this._refreshFormatClass();
        this._renderPopupWrapper();
        this._formatValidationIcon();
        this._updateValue();
        break;
      case "placeholder":
        super._optionChanged.apply(this, arguments);
        this._updatePopupTitle();
        break;
      case "min":
      case "max": {
        const isValid = this.option("isValid");
        this._applyInternalValidation(this.dateOption("value"));
        if (!isValid) {
          this._applyCustomValidation(this.dateOption("value"));
        }
        this._invalidate();
        break;
      }
      case "dateSerializationFormat":
      case "interval":
      case "disabledDates":
      case "calendarOptions":
        this._invalidate();
        break;
      case "displayFormat":
        this.option("text", this._getDisplayedText(this.dateOption("value")));
        this._renderInputValue();
        break;
      case "text":
        this._strategy.textChangedHandler(args.value);
        super._optionChanged.apply(this, arguments);
        break;
      case "showDropDownButton":
        this._formatValidationIcon();
        super._optionChanged.apply(this, arguments);
        break;
      case "todayButtonText":
        this._setPopupOption("toolbarItems", this._getPopupToolbarItems());
        break;
      case "invalidDateMessage":
      case "dateOutOfRangeMessage":
      case "adaptivityEnabled":
      case "showAnalogClock":
      case "_showValidationIcon":
        break;
      default:
        super._optionChanged.apply(this, arguments);
    }
  }
  _getSerializationFormat() {
    const value2 = this.option("value");
    if (this.option("dateSerializationFormat") && config_default2().forceIsoDateParsing) {
      return this.option("dateSerializationFormat");
    }
    if (isNumeric(value2)) {
      return "number";
    }
    if (!isString(value2)) {
      return;
    }
    return date_serialization_default.getDateSerializationFormat(value2);
  }
  _updateValue(value2) {
    super._updateValue();
    this._applyInternalValidation(value2 ?? this.dateOption("value"));
  }
  dateValue(value2, dxEvent) {
    const isValueChanged = this._isValueChanged(value2);
    if (isValueChanged && dxEvent) {
      this._saveValueChangeEvent(dxEvent);
    }
    if (!isValueChanged) {
      const {
        text
      } = this.option();
      if (this._isTextChanged(value2)) {
        this._updateValue(value2);
      } else if ("" === text) {
        this._applyCustomValidation(value2);
      }
    }
    return this.dateOption("value", value2);
  }
  dateOption(optionName, value2) {
    if (1 === arguments.length) {
      return date_serialization_default.deserializeDate(this.option(optionName));
    }
    this.option(optionName, this._serializeDate(value2));
  }
  _serializeDate(date) {
    const serializationFormat = this._getSerializationFormat();
    return date_serialization_default.serializeDate(date, serializationFormat);
  }
  _clearValue() {
    const value2 = this.option("value");
    super._clearValue();
    if (null === value2) {
      this._applyCustomValidation(null);
    }
  }
  clear() {
    const value2 = this.option("value");
    super.clear();
    if (null === value2) {
      this._applyInternalValidation(null);
    }
  }
};
var m_date_box_base_default = DateBox;

// node_modules/devextreme/esm/__internal/ui/date_box/m_date_box.mask.parts.js
var monthGetter = (date) => date.getMonth() + 1;
var monthSetter = (date, value2) => {
  const day = date.getDate();
  const monthLimits = getLimits("M", date);
  const newValue = fitIntoRange(parseInt(value2), monthLimits.min, monthLimits.max);
  date.setMonth(newValue - 1, 1);
  const {
    min,
    max
  } = getLimits("dM", date);
  const newDay = fitIntoRange(day, min, max);
  date.setDate(newDay);
};
var PATTERN_GETTERS = {
  a: (date) => date.getHours() < 12 ? 0 : 1,
  E: "getDay",
  y: "getFullYear",
  M: monthGetter,
  L: monthGetter,
  d: "getDate",
  H: "getHours",
  h: "getHours",
  m: "getMinutes",
  s: "getSeconds",
  S: "getMilliseconds",
  x: "getTimezoneOffset"
};
var PATTERN_SETTERS2 = extend({}, getPatternSetters(), {
  a: (date, value2) => {
    const hours = date.getHours();
    const current2 = hours >= 12;
    if (current2 === !!parseInt(value2)) {
      return;
    }
    date.setHours((hours + 12) % 24);
  },
  d: (date, value2) => {
    const lastDayInMonth = getLimits("dM", date).max;
    if (value2 > lastDayInMonth) {
      date.setMonth(date.getMonth() + 1);
    }
    date.setDate(value2);
  },
  h: (date, value2) => {
    const isPM = date.getHours() >= 12;
    date.setHours(+value2 % 12 + (isPM ? 12 : 0));
  },
  M: monthSetter,
  L: monthSetter,
  E: (date, value2) => {
    if (value2 < 0) {
      return;
    }
    date.setDate(date.getDate() - date.getDay() + parseInt(value2));
  },
  y: (date, value2) => {
    const currentYear = date.getFullYear();
    const valueLength = String(value2).length;
    const maxLimitLength = String(getLimits("y", date).max).length;
    const newValue = parseInt(String(currentYear).substr(0, maxLimitLength - valueLength) + value2);
    date.setFullYear(newValue);
  },
  x: (date) => date
});
var getPatternGetter = (patternChar) => PATTERN_GETTERS[patternChar] || (() => patternChar);
var renderDateParts = (text, regExpInfo) => {
  const result2 = regExpInfo.regexp.exec(text);
  let start = 0;
  let end = 0;
  const sections = [];
  for (let i = 1; i < result2.length; i++) {
    start = end;
    end = start + result2[i].length;
    const pattern = regExpInfo.patterns[i - 1].replace(/^'|'$/g, "");
    const getter = getPatternGetter(pattern[0]);
    sections.push({
      index: i - 1,
      isStub: pattern === result2[i],
      caret: {
        start,
        end
      },
      pattern,
      text: result2[i],
      limits: function() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        return getLimits(pattern[0], ...args);
      },
      setter: PATTERN_SETTERS2[pattern[0]] || noop2,
      getter
    });
  }
  return sections;
};
var getLimits = (pattern, date, forcedPattern) => {
  const limits = {
    y: {
      min: 0,
      max: 9999
    },
    M: {
      min: 1,
      max: 12
    },
    L: {
      min: 1,
      max: 12
    },
    d: {
      min: 1,
      max: 31
    },
    dM: {
      min: 1,
      max: new Date(date.getFullYear(), date.getMonth() + 1, 0).getDate()
    },
    E: {
      min: 0,
      max: 6
    },
    H: {
      min: 0,
      max: 23
    },
    h: {
      min: 1,
      max: 12
    },
    m: {
      min: 0,
      max: 59
    },
    s: {
      min: 0,
      max: 59
    },
    S: {
      min: 0,
      max: 999
    },
    a: {
      min: 0,
      max: 1
    },
    x: {
      min: 0,
      max: 0
    }
  };
  return limits[forcedPattern || pattern] || limits.getAmPm;
};
var getDatePartIndexByPosition = (dateParts, position3) => {
  for (let i = 0; i < dateParts.length; i++) {
    const caretInGroup = dateParts[i].caret.end >= position3;
    if (!dateParts[i].isStub && caretInGroup) {
      return i;
    }
  }
  return null;
};

// node_modules/devextreme/esm/__internal/ui/date_box/m_date_box.mask.js
var DateBoxMask = class extends m_date_box_base_default {
  _supportedKeys() {
    const originalHandlers = super._supportedKeys();
    const callOriginalHandler = (e) => {
      const originalHandler = originalHandlers[normalizeKeyName(e)];
      return null === originalHandler || void 0 === originalHandler ? void 0 : originalHandler.apply(this, [e]);
    };
    const applyHandler = (e, maskHandler) => {
      if (this._shouldUseOriginalHandler(e)) {
        return callOriginalHandler.apply(this, [e]);
      }
      return maskHandler.apply(this, [e]);
    };
    return _extends({}, originalHandlers, {
      del: (e) => applyHandler(e, (event) => {
        this._revertPart(1);
        this._isAllSelected() || event.preventDefault();
      }),
      backspace: (e) => applyHandler(e, (event) => {
        this._revertPart(-1);
        this._isAllSelected() || event.preventDefault();
      }),
      home: (e) => applyHandler(e, (event) => {
        this._selectFirstPart();
        event.preventDefault();
      }),
      end: (e) => applyHandler(e, (event) => {
        this._selectLastPart();
        event.preventDefault();
      }),
      escape: (e) => applyHandler(e, () => {
        this._revertChanges();
      }),
      enter: (e) => applyHandler(e, () => {
        this._enterHandler();
      }),
      leftArrow: (e) => applyHandler(e, (event) => {
        this._selectNextPart(-1);
        event.preventDefault();
      }),
      rightArrow: (e) => applyHandler(e, (event) => {
        this._selectNextPart(1);
        event.preventDefault();
      }),
      upArrow: (e) => applyHandler(e, (event) => {
        this._upDownArrowHandler(1);
        event.preventDefault();
      }),
      downArrow: (e) => applyHandler(e, (event) => {
        this._upDownArrowHandler(-1);
        event.preventDefault();
      })
    });
  }
  _shouldUseOriginalHandler(e) {
    const isNotDeletingInCalendar = this.option("opened") && e && !["backspace", "del"].includes(normalizeKeyName(e));
    return !this._useMaskBehavior() || isNotDeletingInCalendar || e && e.altKey;
  }
  _upDownArrowHandler(step) {
    this._setNewDateIfEmpty();
    const originalValue = this._getActivePartValue(this._initialMaskValue);
    const currentValue = this._getActivePartValue();
    const delta = currentValue - originalValue;
    this._loadMaskValue(this._initialMaskValue);
    this._changePartValue(delta + step, true);
  }
  _changePartValue(step, lockOtherParts) {
    const activePartPattern = this._getActivePartProp("pattern");
    const isAmPmPartActive = /^a{1,5}$/.test(activePartPattern);
    if (isAmPmPartActive) {
      this._toggleAmPm();
    } else {
      this._partIncrease(step, lockOtherParts);
    }
  }
  _toggleAmPm() {
    const currentValue = this._getActivePartProp("text");
    const indexOfCurrentValue = default_date_names_default.getPeriodNames().indexOf(currentValue);
    const newValue = 1 ^ indexOfCurrentValue;
    this._setActivePartValue(newValue);
  }
  _getDefaultOptions() {
    return _extends({}, super._getDefaultOptions(), {
      useMaskBehavior: false,
      emptyDateValue: new Date(2e3, 0, 1, 0, 0, 0)
    });
  }
  _isSingleCharKey(_ref) {
    let {
      originalEvent,
      alt
    } = _ref;
    const key = originalEvent.data || originalEvent.key;
    return "string" === typeof key && 1 === key.length && !alt && !isCommandKeyPressed(originalEvent);
  }
  _isSingleDigitKey(e) {
    var _e$originalEvent;
    const data17 = null === (_e$originalEvent = e.originalEvent) || void 0 === _e$originalEvent ? void 0 : _e$originalEvent.data;
    return 1 === (null === data17 || void 0 === data17 ? void 0 : data17.length) && parseInt(data17, 10);
  }
  _useBeforeInputEvent() {
    return devices_default.real().android;
  }
  _keyInputHandler(e, key) {
    const oldInputValue = this._input().val();
    this._processInputKey(key);
    e.preventDefault();
    const isValueChanged = oldInputValue !== this._input().val();
    isValueChanged && m_events_engine_default.trigger(this._input(), "input");
  }
  _keyboardHandler(e) {
    let {
      key
    } = e.originalEvent;
    const result2 = super._keyboardHandler(e);
    if (!this._useMaskBehavior() || this._useBeforeInputEvent()) {
      return result2;
    }
    if (browser_default.chrome && "Process" === e.key && 0 === e.code.indexOf("Digit")) {
      key = e.code.replace("Digit", "");
      this._processInputKey(key);
      this._maskInputHandler = () => {
        this._renderSelectedPart();
      };
    } else if (this._isSingleCharKey(e)) {
      this._keyInputHandler(e.originalEvent, key);
    }
    return result2;
  }
  _maskBeforeInputHandler(e) {
    this._maskInputHandler = null;
    const {
      inputType: inputType2
    } = e.originalEvent;
    if ("insertCompositionText" === inputType2) {
      this._maskInputHandler = () => {
        this._renderSelectedPart();
      };
    }
    const isBackwardDeletion = "deleteContentBackward" === inputType2;
    const isForwardDeletion = "deleteContentForward" === inputType2;
    if (isBackwardDeletion || isForwardDeletion) {
      const direction = isBackwardDeletion ? -1 : 1;
      this._maskInputHandler = () => {
        this._revertPart();
        this._selectNextPart(direction);
      };
    }
    if (!this._useMaskBehavior() || !this._isSingleCharKey(e)) {
      return;
    }
    const key = e.originalEvent.data;
    this._keyInputHandler(e, key);
    return true;
  }
  _keyPressHandler(e) {
    const {
      originalEvent: event
    } = e;
    if ("insertCompositionText" === (null === event || void 0 === event ? void 0 : event.inputType) && this._isSingleDigitKey(e)) {
      this._processInputKey(event.data);
      this._renderDisplayText(this._getDisplayedText(this._maskValue));
      this._selectNextPart();
    }
    super._keyPressHandler(e);
    if (this._maskInputHandler) {
      this._maskInputHandler();
      this._maskInputHandler = null;
    }
  }
  _processInputKey(key) {
    if (this._isAllSelected()) {
      this._activePartIndex = 0;
    }
    this._setNewDateIfEmpty();
    if (isNaN(parseInt(key))) {
      this._searchString(key);
    } else {
      this._searchNumber(key);
    }
  }
  _isAllSelected() {
    const caret3 = this._caret();
    const {
      text
    } = this.option();
    return caret3.end - caret3.start === text.length;
  }
  _getFormatPattern() {
    if (this._formatPattern) {
      return this._formatPattern;
    }
    const format2 = this._strategy.getDisplayFormat(this.option("displayFormat"));
    const isLDMLPattern = isString(format2) && !date_default3._getPatternByFormat(format2);
    if (isLDMLPattern) {
      this._formatPattern = format2;
    } else {
      this._formatPattern = getFormat2((value2) => date_default3.format(value2, format2));
    }
    return this._formatPattern;
  }
  _setNewDateIfEmpty() {
    if (!this._maskValue) {
      const {
        type: type2
      } = this.option();
      const value2 = "time" === type2 ? /* @__PURE__ */ new Date(null) : /* @__PURE__ */ new Date();
      this._maskValue = value2;
      this._initialMaskValue = value2;
      this._renderDateParts();
    }
  }
  _partLimitsReached(max) {
    const maxLimitLength = String(max).length;
    const formatLength = this._getActivePartProp("pattern").length;
    const isShortFormat = 1 === formatLength;
    const maxSearchLength = isShortFormat ? maxLimitLength : Math.min(formatLength, maxLimitLength);
    const isLengthExceeded = this._searchValue.length === maxSearchLength;
    const isValueOverflowed = parseInt(`${this._searchValue}0`) > max;
    return isLengthExceeded || isValueOverflowed;
  }
  _searchNumber(char) {
    const {
      max
    } = this._getActivePartLimits();
    const maxLimitLength = String(max).length;
    this._searchValue = (this._searchValue + char).substr(-maxLimitLength);
    if (isNaN(this._searchValue)) {
      this._searchValue = char;
    }
    this._setActivePartValue(this._searchValue);
    if (this._partLimitsReached(max)) {
      this._selectNextPart(1);
    }
  }
  _searchString(char) {
    if (!isNaN(parseInt(this._getActivePartProp("text")))) {
      return;
    }
    const limits = this._getActivePartProp("limits")(this._maskValue);
    const startString = this._searchValue + char.toLowerCase();
    const endLimit = limits.max - limits.min;
    for (let i = 0; i <= endLimit; i++) {
      this._loadMaskValue(this._initialMaskValue);
      this._changePartValue(i + 1);
      if (0 === this._getActivePartProp("text").toLowerCase().indexOf(startString)) {
        this._searchValue = startString;
        return;
      }
    }
    this._setNewDateIfEmpty();
    if (this._searchValue) {
      this._clearSearchValue();
      this._searchString(char);
    }
  }
  _clearSearchValue() {
    this._searchValue = "";
  }
  _revertPart(direction) {
    if (!this._isAllSelected()) {
      const actual = this._getActivePartValue(this.option("emptyDateValue"));
      this._setActivePartValue(actual);
      this._selectNextPart(direction);
    }
    this._clearSearchValue();
  }
  _useMaskBehavior() {
    const {
      mode
    } = this.option();
    return this.option("useMaskBehavior") && "text" === mode;
  }
  _prepareRegExpInfo() {
    this._regExpInfo = getRegExpInfo(this._getFormatPattern(), date_default3);
    const {
      regexp
    } = this._regExpInfo;
    const {
      source
    } = regexp;
    const {
      flags
    } = regexp;
    const quantifierRegexp = new RegExp(/(\{[0-9]+,?[0-9]*\})/);
    const convertedSource = source.split(quantifierRegexp).map((sourcePart) => quantifierRegexp.test(sourcePart) ? sourcePart : number_default2.convertDigits(sourcePart, false)).join("");
    this._regExpInfo.regexp = new RegExp(convertedSource, flags);
  }
  _initMaskState() {
    this._activePartIndex = 0;
    this._formatPattern = null;
    this._prepareRegExpInfo();
    this._loadMaskValue();
  }
  _renderMask() {
    super._renderMask();
    this._detachMaskEvents();
    this._clearMaskState();
    if (this._useMaskBehavior()) {
      this._attachMaskEvents();
      this._initMaskState();
      this._renderDateParts();
    }
  }
  _renderDateParts() {
    if (!this._useMaskBehavior()) {
      return;
    }
    const text = this.option("text") || this._getDisplayedText(this._maskValue);
    if (text) {
      this._dateParts = renderDateParts(text, this._regExpInfo);
      if (!this._input().is(":hidden")) {
        this._selectNextPart();
      }
    }
  }
  _detachMaskEvents() {
    m_events_engine_default.off(this._input(), ".dateBoxMask");
  }
  _attachMaskEvents() {
    m_events_engine_default.on(this._input(), addNamespace2("dxclick", "dateBoxMask"), this._maskClickHandler.bind(this));
    m_events_engine_default.on(this._input(), addNamespace2("paste", "dateBoxMask"), this._maskPasteHandler.bind(this));
    m_events_engine_default.on(this._input(), addNamespace2("drop", "dateBoxMask"), () => {
      this._renderSelectedPart();
    });
    m_events_engine_default.on(this._input(), addNamespace2("compositionend", "dateBoxMask"), this._maskCompositionEndHandler.bind(this));
    if (this._useBeforeInputEvent()) {
      m_events_engine_default.on(this._input(), addNamespace2("beforeinput", "dateBoxMask"), this._maskBeforeInputHandler.bind(this));
    }
  }
  _renderSelectedPart() {
    this._renderDisplayText(this._getDisplayedText(this._maskValue));
    this._selectNextPart();
  }
  _selectLastPart() {
    if (this.option("text")) {
      this._activePartIndex = this._dateParts.length;
      this._selectNextPart(-1);
    }
  }
  _selectFirstPart() {
    if (this.option("text") && this._dateParts) {
      this._activePartIndex = -1;
      this._selectNextPart(1);
    }
  }
  _hasMouseWheelHandler() {
    return true;
  }
  _onMouseWheel(e) {
    if (this._useMaskBehavior()) {
      this._partIncrease(e.delta > 0 ? 1 : -1, e);
    }
  }
  _selectNextPart() {
    let step = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0;
    if (!this.option("text") || this._disposed) {
      return;
    }
    if (step) {
      this._initialMaskValue = new Date(this._maskValue);
    }
    let index2 = fitIntoRange(this._activePartIndex + step, 0, this._dateParts.length - 1);
    if (this._dateParts[index2].isStub) {
      const isBoundaryIndex = 0 === index2 && step < 0 || index2 === this._dateParts.length - 1 && step > 0;
      if (!isBoundaryIndex) {
        this._selectNextPart(step >= 0 ? step + 1 : step - 1);
        return;
      }
      index2 = this._activePartIndex;
    }
    if (this._activePartIndex !== index2) {
      this._clearSearchValue();
    }
    this._activePartIndex = index2;
    this._caret(this._getActivePartProp("caret"));
  }
  _getRealLimitsPattern() {
    if ("d" === this._getActivePartProp("pattern")[0]) {
      return "dM";
    }
  }
  _getActivePartLimits(lockOtherParts) {
    const limitFunction = this._getActivePartProp("limits");
    return limitFunction(this._maskValue, lockOtherParts && this._getRealLimitsPattern());
  }
  _getActivePartValue(dateValue) {
    dateValue = dateValue || this._maskValue;
    const getter = this._getActivePartProp("getter");
    return isFunction(getter) ? getter(dateValue) : dateValue[getter]();
  }
  _addLeadingZeroes(value2) {
    const zeroes = /^0+/.exec(this._searchValue);
    const limits = this._getActivePartLimits();
    const maxLimitLength = String(limits.max).length;
    return ((zeroes && zeroes[0] || "") + String(value2)).substr(-maxLimitLength);
  }
  _setActivePartValue(value2, dateValue) {
    dateValue = dateValue || this._maskValue;
    const setter = this._getActivePartProp("setter");
    const limits = this._getActivePartLimits();
    value2 = inRange(value2, limits.min, limits.max) ? value2 : value2 % 10;
    value2 = this._addLeadingZeroes(fitIntoRange(value2, limits.min, limits.max));
    isFunction(setter) ? setter(dateValue, value2) : dateValue[setter](value2);
    this._renderDisplayText(this._getDisplayedText(dateValue));
    this._renderDateParts();
  }
  _getActivePartProp(property) {
    if (!this._dateParts || !this._dateParts[this._activePartIndex]) {
      return;
    }
    return this._dateParts[this._activePartIndex][property];
  }
  _loadMaskValue() {
    let value2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.dateOption("value");
    this._maskValue = value2 && new Date(value2);
    this._initialMaskValue = value2 && new Date(value2);
  }
  _saveMaskValue() {
    const value2 = this._maskValue && new Date(this._maskValue);
    const {
      type: type2
    } = this.option();
    if (value2 && "date" === type2) {
      value2.setHours(0, 0, 0, 0);
    }
    this._initialMaskValue = new Date(value2);
    this.dateOption("value", value2);
  }
  _revertChanges() {
    this._loadMaskValue();
    this._renderDisplayText(this._getDisplayedText(this._maskValue));
    this._renderDateParts();
  }
  _renderDisplayText(text) {
    super._renderDisplayText(text);
    if (this._useMaskBehavior()) {
      this.option("text", text);
    }
  }
  _partIncrease(step, lockOtherParts) {
    this._setNewDateIfEmpty();
    const {
      max,
      min
    } = this._getActivePartLimits(lockOtherParts);
    let newValue = step + this._getActivePartValue();
    if (newValue > max) {
      newValue = this._applyLimits(newValue, {
        limitBase: min,
        limitClosest: max,
        max
      });
    } else if (newValue < min) {
      newValue = this._applyLimits(newValue, {
        limitBase: max,
        limitClosest: min,
        max
      });
    }
    this._setActivePartValue(newValue);
  }
  _applyLimits(newValue, _ref2) {
    let {
      limitBase,
      limitClosest,
      max
    } = _ref2;
    const delta = (newValue - limitClosest) % max;
    return delta ? limitBase + delta - 1 * sign(delta) : limitClosest;
  }
  _maskClickHandler() {
    this._loadMaskValue(this._maskValue);
    if (this.option("text")) {
      this._activePartIndex = getDatePartIndexByPosition(this._dateParts, this._caret().start);
      if (!this._isAllSelected()) {
        this._clearSearchValue();
        if (isDefined(this._activePartIndex)) {
          this._caret(this._getActivePartProp("caret"));
        } else {
          this._selectLastPart();
        }
      }
    }
  }
  _maskCompositionEndHandler(e) {
    this._input().val(this._getDisplayedText(this._maskValue));
    this._selectNextPart();
    this._maskInputHandler = () => {
      this._renderSelectedPart();
    };
  }
  _maskPasteHandler(e) {
    const newText = this._replaceSelectedText(this.option("text"), this._caret(), clipboardText(e));
    const date = date_default3.parse(newText, this._getFormatPattern());
    if (date && this._isDateValid(date)) {
      this._maskValue = date;
      this._renderDisplayText(this._getDisplayedText(this._maskValue));
      this._renderDateParts();
      this._selectNextPart();
    }
    e.preventDefault();
  }
  _isDateValid(date) {
    return isDate(date) && !isNaN(date);
  }
  _isValueDirty() {
    const value2 = this.dateOption("value");
    return (this._maskValue && this._maskValue.getTime()) !== (value2 && value2.getTime());
  }
  _fireChangeEvent() {
    this._clearSearchValue();
    if (this._isValueDirty()) {
      m_events_engine_default.trigger(this._input(), "change");
    }
  }
  _enterHandler() {
    this._fireChangeEvent();
    this._selectNextPart(1);
  }
  _focusOutHandler(e) {
    const shouldFireChangeEvent = this._useMaskBehavior() && !e.isDefaultPrevented();
    if (shouldFireChangeEvent) {
      this._fireChangeEvent();
      super._focusOutHandler(e);
      this._selectFirstPart();
    } else {
      super._focusOutHandler(e);
    }
  }
  _valueChangeEventHandler(e) {
    const text = this.option("text");
    if (this._useMaskBehavior()) {
      this._saveValueChangeEvent(e);
      if (!text) {
        this._maskValue = null;
      } else if (null === this._maskValue) {
        this._loadMaskValue(text);
      }
      this._saveMaskValue();
    } else {
      super._valueChangeEventHandler(e);
    }
  }
  _optionChanged(args) {
    switch (args.name) {
      case "useMaskBehavior":
        this._renderMask();
        break;
      case "displayFormat":
      case "mode":
        super._optionChanged(args);
        this._renderMask();
        break;
      case "value":
        this._loadMaskValue();
        super._optionChanged(args);
        this._renderDateParts();
        break;
      case "emptyDateValue":
        break;
      default:
        super._optionChanged(args);
    }
  }
  _clearMaskState() {
    this._clearSearchValue();
    delete this._dateParts;
    delete this._activePartIndex;
    delete this._maskValue;
  }
  clear() {
    this._clearMaskState();
    this._activePartIndex = 0;
    super.clear();
  }
  _clean() {
    super._clean();
    this._detachMaskEvents();
    this._clearMaskState();
  }
};
var m_date_box_mask_default = DateBoxMask;

// node_modules/devextreme/esm/__internal/ui/date_box/m_date_box.js
component_registrator_default("dxDateBox", m_date_box_mask_default);

// node_modules/devextreme/esm/ui/shared/ui.editor_factory_mixin.js
var {
  isWrapped: isWrapped2
} = variable_wrapper_default;
var EDITOR_INLINE_BLOCK = "dx-editor-inline-block";
var getResultConfig = function(config3, options2) {
  return extend(config3, {
    readOnly: options2.readOnly,
    placeholder: options2.placeholder,
    inputAttr: {
      id: options2.id,
      "aria-labelledby": options2["aria-labelledby"]
    },
    tabIndex: options2.tabIndex
  }, options2.editorOptions);
};
var checkEnterBug = function() {
  return browser_default.mozilla || devices_default.real().ios;
};
var getTextEditorConfig = function(options2) {
  const data17 = {};
  const isEnterBug = checkEnterBug();
  const sharedData = options2.sharedData || data17;
  return getResultConfig({
    placeholder: options2.placeholder,
    width: options2.width,
    value: options2.value,
    onValueChanged: function(e) {
      const needDelayedUpdate = "filterRow" === options2.parentType || "searchPanel" === options2.parentType;
      const isInputOrKeyUpEvent = e.event && ("input" === e.event.type || "keyup" === e.event.type);
      const updateValue = function(e2, notFireEvent) {
        options2 && options2.setValue(e2.value, notFireEvent);
      };
      clearTimeout(data17.valueChangeTimeout);
      if (isInputOrKeyUpEvent && needDelayedUpdate) {
        sharedData.valueChangeTimeout = data17.valueChangeTimeout = setTimeout(function() {
          updateValue(e, data17.valueChangeTimeout !== sharedData.valueChangeTimeout);
        }, isDefined(options2.updateValueTimeout) ? options2.updateValueTimeout : 0);
      } else {
        updateValue(e);
      }
    },
    onKeyDown: function(e) {
      if (isEnterBug && "enter" === normalizeKeyName(e.event)) {
        m_events_engine_default.trigger(renderer_default(e.component._input()), "change");
      }
    },
    valueChangeEvent: "change" + ("filterRow" === options2.parentType ? " keyup input" : "")
  }, options2);
};
var prepareDateBox = function(options2) {
  options2.editorName = "dxDateBox";
  options2.editorOptions = getResultConfig({
    value: options2.value,
    onValueChanged: function(args) {
      options2.setValue(args.value);
    },
    onKeyDown: function(_ref) {
      let {
        component,
        event
      } = _ref;
      const useMaskBehavior = component.option("useMaskBehavior");
      if ((checkEnterBug() || useMaskBehavior) && "enter" === normalizeKeyName(event)) {
        component.blur();
        component.focus();
      }
    },
    displayFormat: options2.format,
    type: options2.dataType,
    dateSerializationFormat: null,
    width: "filterBuilder" === options2.parentType ? void 0 : "auto"
  }, options2);
};
var prepareTextBox = function(options2) {
  const config3 = getTextEditorConfig(options2);
  const isSearching = "searchPanel" === options2.parentType;
  if (options2.editorType && "dxTextBox" !== options2.editorType) {
    config3.value = options2.value;
  } else {
    config3.value = (value2 = options2.value, isDefined(value2) ? value2.toString() : "");
  }
  var value2;
  config3.valueChangeEvent += isSearching ? " keyup input search" : "";
  config3.mode = config3.mode || (isSearching ? "search" : "text");
  options2.editorName = "dxTextBox";
  options2.editorOptions = config3;
};
var prepareNumberBox = function(options2) {
  const config3 = getTextEditorConfig(options2);
  config3.value = isDefined(options2.value) ? options2.value : null;
  options2.editorName = "dxNumberBox";
  options2.editorOptions = config3;
};
var prepareBooleanEditor = function(options2) {
  if ("filterRow" === options2.parentType || "filterBuilder" === options2.parentType) {
    prepareLookupEditor(extend(options2, {
      lookup: {
        displayExpr: function(data17) {
          if (true === data17) {
            return options2.trueText || "true";
          } else if (false === data17) {
            return options2.falseText || "false";
          }
        },
        dataSource: [true, false]
      }
    }));
  } else {
    prepareCheckBox(options2);
  }
};
function watchLookupDataSource(options2) {
  if (options2.row && options2.row.watch && "dataRow" === options2.parentType) {
    const editorOptions = options2.editorOptions || {};
    options2.editorOptions = editorOptions;
    let selectBox;
    const onInitialized = editorOptions.onInitialized;
    editorOptions.onInitialized = function(e) {
      onInitialized && onInitialized.apply(this, arguments);
      selectBox = e.component;
      selectBox.on("disposing", stopWatch);
    };
    let dataSource;
    const stopWatch = options2.row.watch(() => {
      dataSource = options2.lookup.dataSource(options2.row);
      return dataSource && dataSource.filter;
    }, () => {
      selectBox.option("dataSource", dataSource);
    }, (row) => {
      options2.row = row;
    });
  }
}
function prepareLookupEditor(options2) {
  const lookup = options2.lookup;
  let displayGetter;
  let dataSource;
  let postProcess2;
  const isFilterRow = "filterRow" === options2.parentType;
  if (lookup) {
    displayGetter = compileGetter(lookup.displayExpr);
    dataSource = lookup.dataSource;
    if (isFunction(dataSource) && !isWrapped2(dataSource)) {
      dataSource = dataSource(options2.row || {});
      watchLookupDataSource(options2);
    }
    if (isObject(dataSource) || Array.isArray(dataSource)) {
      dataSource = normalizeDataSourceOptions(dataSource);
      if (isFilterRow) {
        postProcess2 = dataSource.postProcess;
        dataSource.postProcess = function(items) {
          if (0 === this.pageIndex()) {
            items = items.slice(0);
            items.unshift(null);
          }
          if (postProcess2) {
            return postProcess2.call(this, items);
          }
          return items;
        };
      }
    }
    const allowClearing = Boolean(lookup.allowClearing && !isFilterRow);
    options2.editorName = options2.editorType ?? "dxSelectBox";
    options2.editorOptions = getResultConfig({
      searchEnabled: true,
      value: options2.value,
      valueExpr: options2.lookup.valueExpr,
      searchExpr: options2.lookup.searchExpr || options2.lookup.displayExpr,
      allowClearing,
      showClearButton: allowClearing,
      displayExpr: function(data17) {
        if (null === data17) {
          return options2.showAllText;
        }
        return displayGetter(data17);
      },
      dataSource,
      onValueChanged: function(e) {
        const params = [e.value];
        !isFilterRow && params.push(e.component.option("text"));
        options2.setValue.apply(this, params);
      }
    }, options2);
  }
}
function prepareCheckBox(options2) {
  options2.editorName = "dxCheckBox";
  options2.editorOptions = getResultConfig({
    elementAttr: {
      id: options2.id
    },
    value: isDefined(options2.value) ? options2.value : void 0,
    hoverStateEnabled: !options2.readOnly,
    focusStateEnabled: !options2.readOnly,
    activeStateEnabled: false,
    onValueChanged: function(e) {
      options2.setValue && options2.setValue(e.value, e);
    }
  }, options2);
}
var createEditorCore = function(that, options2) {
  const $editorElement = renderer_default(options2.editorElement);
  if (options2.editorName && options2.editorOptions && $editorElement[options2.editorName]) {
    if ("dxCheckBox" === options2.editorName || "dxSwitch" === options2.editorName) {
      if (!options2.isOnForm) {
        $editorElement.addClass(that.addWidgetPrefix("checkbox-size"));
        $editorElement.parent().addClass(EDITOR_INLINE_BLOCK);
      }
    }
    that._createComponent($editorElement, options2.editorName, options2.editorOptions);
    if ("dxDateBox" === options2.editorName) {
      const dateBox = $editorElement.dxDateBox("instance");
      const defaultEnterKeyHandler = dateBox._supportedKeys().enter;
      dateBox.registerKeyHandler("enter", (e) => {
        if (dateBox.option("opened")) {
          defaultEnterKeyHandler(e);
        }
        return true;
      });
    }
    if ("dxTextArea" === options2.editorName) {
      $editorElement.dxTextArea("instance").registerKeyHandler("enter", function(event) {
        if ("enter" === normalizeKeyName(event) && !event.ctrlKey && !event.shiftKey) {
          event.stopPropagation();
        }
      });
    }
  }
};
var prepareCustomEditor = (options2) => {
  options2.editorName = options2.editorType;
  options2.editorOptions = getResultConfig({
    value: options2.value,
    onValueChanged: function(args) {
      options2.setValue(args.value);
    }
  }, options2);
};
var prepareEditor = (options2) => {
  const prepareDefaultEditor = {
    dxDateBox: prepareDateBox,
    dxCheckBox: prepareCheckBox,
    dxNumberBox: prepareNumberBox,
    dxTextBox: prepareTextBox
  };
  if (options2.lookup) {
    prepareLookupEditor(options2);
  } else if (options2.editorType) {
    (prepareDefaultEditor[options2.editorType] ?? prepareCustomEditor)(options2);
  } else {
    switch (options2.dataType) {
      case "date":
      case "datetime":
        prepareDateBox(options2);
        break;
      case "boolean":
        prepareBooleanEditor(options2);
        break;
      case "number":
        prepareNumberBox(options2);
        break;
      default:
        prepareTextBox(options2);
    }
  }
};
var EditorFactoryMixin = (Base) => class extends Base {
  createEditor($container, options2) {
    options2.cancel = false;
    options2.editorElement = getPublicElement($container);
    if (!isDefined(options2.tabIndex)) {
      options2.tabIndex = this.option("tabIndex");
    }
    prepareEditor(options2);
    this.executeAction("onEditorPreparing", options2);
    if (options2.cancel) {
      return;
    }
    if ("dataRow" === options2.parentType && !options2.isOnForm && !isDefined(options2.editorOptions.showValidationMark)) {
      options2.editorOptions.showValidationMark = false;
    }
    createEditorCore(this, options2);
    this.executeAction("onEditorPrepared", options2);
  }
};
var ui_editor_factory_mixin_default = EditorFactoryMixin;

// node_modules/devextreme/esm/__internal/grids/grid_core/editor_factory/m_editor_factory.js
var EDITOR_INLINE_BLOCK2 = "dx-editor-inline-block";
var MODULE_NAMESPACE = "dxDataGridEditorFactory";
var UPDATE_FOCUS_EVENTS = addNamespace2([CLICK_EVENT_NAME, "focusin"].join(" "), MODULE_NAMESPACE);
var DX_HIDDEN = "dx-hidden";
var ViewControllerWithMixin = ui_editor_factory_mixin_default(m_modules_default.ViewController);
var EditorFactory = class extends ViewControllerWithMixin {
  init() {
    this.createAction("onEditorPreparing", {
      excludeValidators: ["disabled", "readOnly"],
      category: "rendering"
    });
    this.createAction("onEditorPrepared", {
      excludeValidators: ["disabled", "readOnly"],
      category: "rendering"
    });
    this._columnsResizerController = this.getController("columnsResizer");
    this._editingController = this.getController("editing");
    this._keyboardNavigationController = this.getController("keyboardNavigation");
    this._columnsController = this.getController("columns");
    this._validatingController = this.getController("validating");
    this._columnHeadersView = this.getView("columnHeadersView");
    this._rowsView = this.getView("rowsView");
    this._updateFocusHandler = this._updateFocusHandler || this.createAction(this._updateFocus.bind(this));
    this._subscribedContainerRoot = this._getContainerRoot();
    m_events_engine_default.on(this._subscribedContainerRoot, UPDATE_FOCUS_EVENTS, this._updateFocusHandler);
    this._attachContainerEventHandlers();
  }
  dispose() {
    clearTimeout(this._focusTimeoutID);
    clearTimeout(this._updateFocusTimeoutID);
    m_events_engine_default.off(this._subscribedContainerRoot, UPDATE_FOCUS_EVENTS, this._updateFocusHandler);
  }
  _getFocusedElement($dataGridElement) {
    const rowSelector = this.option("focusedRowEnabled") ? "tr[tabindex]:focus" : "tr[tabindex]:not(.dx-data-row):focus";
    const focusedElementSelector = ["td[tabindex]:focus", `${rowSelector}`, "input:focus", "button:focus", "textarea:focus", "div[tabindex]:focus", ".dx-lookup-field:focus", ".dx-checkbox:focus", ".dx-switch:focus", ".dx-dropdownbutton .dx-buttongroup:focus", ".dx-adaptive-item-text:focus"].join(",");
    const $focusedElement = $dataGridElement.find(focusedElementSelector);
    return this.elementIsInsideGrid($focusedElement) && $focusedElement;
  }
  _getFocusCellSelector() {
    return ".dx-row > td";
  }
  _updateFocusCore() {
    const $dataGridElement = this.component && this.component.$element();
    if ($dataGridElement) {
      let $focus = this._getFocusedElement($dataGridElement);
      if ($focus && $focus.length) {
        let isHideBorder;
        if (!$focus.hasClass("dx-cell-focus-disabled") && !$focus.hasClass("dx-row")) {
          const $focusCell = $focus.closest(`${this._getFocusCellSelector()}, .dx-cell-focus-disabled`);
          if ($focusCell.get(0) !== $focus.get(0)) {
            isHideBorder = this._needHideBorder($focusCell);
            $focus = $focusCell;
          }
        }
        if ($focus.length && !$focus.hasClass("dx-cell-focus-disabled")) {
          this.focus($focus, isHideBorder);
          return;
        }
      }
    }
    this.loseFocus();
  }
  _needHideBorder($element) {
    const rowsViewElement = this._rowsView.element();
    const isRowsView = $element.closest(rowsViewElement).length > 0;
    const isEditing = this._editingController.isEditing();
    return $element.hasClass(EDITOR_INLINE_BLOCK2) || isRowsView && !isEditing;
  }
  _updateFocus(e) {
    const that = this;
    const isFocusOverlay = e && e.event && renderer_default(e.event.target).hasClass(that.addWidgetPrefix("focus-overlay"));
    that._isFocusOverlay = that._isFocusOverlay || isFocusOverlay;
    clearTimeout(that._updateFocusTimeoutID);
    that._updateFocusTimeoutID = setTimeout(() => {
      delete that._updateFocusTimeoutID;
      if (!that._isFocusOverlay) {
        that._updateFocusCore();
      }
      that._isFocusOverlay = false;
    });
  }
  updateFocusOverlaySize($element, position3) {
    $element.hide();
    const location = position_default.calculate($element, extend({
      collision: "fit"
    }, position3));
    if (location.h.oversize > 0) {
      setOuterWidth($element, getOuterWidth($element) - location.h.oversize);
    }
    if (location.v.oversize > 0) {
      setOuterHeight($element, getOuterHeight($element) - location.v.oversize);
    }
    $element.show();
  }
  callbackNames() {
    return ["focused"];
  }
  getFocusOverlayContainer($focusedElement) {
    return $focusedElement.closest(`.${this.addWidgetPrefix("content")}`);
  }
  getFocusOverlaySize($element) {
    const elementRect = getBoundingRect($element.get(0));
    return {
      width: elementRect.right - elementRect.left + 1,
      height: elementRect.bottom - elementRect.top + 1
    };
  }
  updateFocusOverlay($element) {
    let isHideBorder = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : false;
    if (isHideBorder) {
      this._$focusOverlay.addClass(DX_HIDDEN);
    } else if ($element.length) {
      const align = browser_default.mozilla ? "right bottom" : "left top";
      const isFocusedCellInvalid = $element.hasClass(this.addWidgetPrefix("invalid"));
      const isFocusedCellModified = $element.hasClass("dx-cell-modified") && !isFocusedCellInvalid;
      const $content = this.getFocusOverlayContainer($element);
      const focusOverlaySize = this.getFocusOverlaySize($element);
      this._$focusOverlay.removeClass(DX_HIDDEN).toggleClass("dx-focused-cell-invalid", isFocusedCellInvalid).toggleClass("dx-focused-cell-modified", isFocusedCellModified).appendTo($content);
      setOuterHeight(this._$focusOverlay, focusOverlaySize.height);
      setOuterWidth(this._$focusOverlay, focusOverlaySize.width);
      const focusOverlayPosition = {
        precise: true,
        my: align,
        at: align,
        of: $element,
        boundary: $content.length && $content
      };
      this.updateFocusOverlaySize(this._$focusOverlay, focusOverlayPosition);
      position_default.setup(this._$focusOverlay, focusOverlayPosition);
      this._$focusOverlay.css("visibility", "visible");
    }
  }
  renderFocusOverlay($element, isHideBorder) {
    if (!m_utils_default.isElementInCurrentGrid(this, $element)) {
      return;
    }
    if (!this._$focusOverlay) {
      this._$focusOverlay = renderer_default("<div>").addClass(this.addWidgetPrefix("focus-overlay"));
    }
    this.updateFocusOverlay($element, isHideBorder);
  }
  focus($element, isHideBorder) {
    const that = this;
    if (void 0 === $element) {
      return that._$focusedElement;
    }
    if ($element) {
      if (!$element.is(that._$focusedElement)) {
        that._$focusedElement && that._$focusedElement.removeClass("dx-focused");
      }
      that._$focusedElement = $element;
      clearTimeout(that._focusTimeoutID);
      that._focusTimeoutID = setTimeout(() => {
        delete that._focusTimeoutID;
        that.renderFocusOverlay($element, isHideBorder);
        $element.addClass("dx-focused");
        that.focused.fire($element);
      });
    }
  }
  refocus() {
    const $focus = this.focus();
    this.focus($focus);
  }
  resize() {
    const $focusedElement = this._$focusedElement;
    if ($focusedElement) {
      this.focus($focusedElement);
    }
  }
  loseFocus(skipValidator) {
    this._$focusedElement && this._$focusedElement.removeClass("dx-focused");
    this._$focusedElement = null;
    this._$focusOverlay && this._$focusOverlay.addClass(DX_HIDDEN);
  }
  _getContainerRoot() {
    var _this$component;
    const $container = null === (_this$component = this.component) || void 0 === _this$component ? void 0 : _this$component.$element();
    const root = dom_adapter_default.getRootNode(null === $container || void 0 === $container ? void 0 : $container.get(0));
    if (root.nodeType === Node.DOCUMENT_FRAGMENT_NODE && !root.host) {
      return dom_adapter_default.getDocument();
    }
    return root;
  }
  _attachContainerEventHandlers() {
    const that = this;
    const $container = that.component && that.component.$element();
    if ($container) {
      m_events_engine_default.on($container, addNamespace2("keydown", MODULE_NAMESPACE), (e) => {
        if ("tab" === normalizeKeyName(e)) {
          that._updateFocusHandler(e);
        }
      });
    }
  }
  getFocusOverlay() {
    return this._$focusOverlay;
  }
  hasOverlayElements() {
    var _this$_$focusOverlay;
    return !!(null !== (_this$_$focusOverlay = this._$focusOverlay) && void 0 !== _this$_$focusOverlay && _this$_$focusOverlay.length) && !this._$focusOverlay.hasClass(DX_HIDDEN);
  }
};
var editorFactoryModule = {
  defaultOptions: () => ({}),
  controllers: {
    editorFactory: EditorFactory
  }
};

// node_modules/devextreme/esm/__internal/grids/data_grid/module_not_extended/editor_factory.js
m_core_default.registerModule("editorFactory", editorFactoryModule);

// node_modules/devextreme/esm/__internal/ui/m_dialog.js
var window28 = getWindow();
var DEFAULT_BUTTON = {
  text: "OK",
  onClick: () => true
};
var getApplyButtonConfig = () => {
  if (isFluent()) {
    return {
      stylingMode: "contained",
      type: "default"
    };
  }
  return {};
};
var getCancelButtonConfig = () => {
  if (isFluent()) {
    return {
      stylingMode: "outlined",
      type: "default"
    };
  }
  return {};
};
var custom = function(options2) {
  const deferred = Deferred();
  options2 = options2 || {};
  const $element = renderer_default("<div>").addClass("dx-dialog").appendTo(value());
  const isMessageDefined = "message" in options2;
  const isMessageHtmlDefined = "messageHtml" in options2;
  if (isMessageDefined) {
    ui_errors_default.log("W1013");
  }
  const messageHtml = String(isMessageHtmlDefined ? options2.messageHtml : options2.message);
  const messageId = options2.title ? null : new guid_default2();
  const $message = renderer_default("<div>").addClass("dx-dialog-message").html(messageHtml).attr("id", messageId);
  const popupToolbarItems = [];
  const popupInstance = new ui_popup_default($element, extend({
    title: options2.title ?? "",
    showTitle: ensureDefined(options2.showTitle, true),
    dragEnabled: ensureDefined(options2.dragEnabled, true),
    height: "auto",
    width: options2.width,
    showCloseButton: options2.showCloseButton || false,
    ignoreChildEvents: false,
    container: $element,
    visualContainer: window28,
    dragAndResizeArea: window28,
    onContentReady(args) {
      args.component.$content().addClass("dx-dialog-content").append($message);
      if (messageId) {
        args.component.$overlayContent().attr("aria-labelledby", messageId);
      }
    },
    onShowing(e) {
      e.component.bottomToolbar().addClass("dx-dialog-buttons").find(".dx-button").addClass("dx-dialog-button");
      m_dom_default.resetActiveElement();
    },
    onShown(e) {
      const $firstButton = e.component.bottomToolbar().find(".dx-button").first();
      m_events_engine_default.trigger($firstButton, "focus");
    },
    onHiding() {
      deferred.reject();
    },
    onHidden(_ref) {
      let {
        element
      } = _ref;
      renderer_default(element).remove();
    },
    animation: {
      show: {
        type: "pop",
        duration: 400
      },
      hide: {
        type: "pop",
        duration: 400,
        to: {
          opacity: 0,
          scale: 0
        },
        from: {
          opacity: 1,
          scale: 1
        }
      }
    },
    rtlEnabled: config_default2().rtlEnabled,
    position: {
      boundaryOffset: {
        h: 10,
        v: 0
      }
    }
  }, options2.popupOptions));
  const buttonOptions = options2.buttons || [DEFAULT_BUTTON];
  buttonOptions.forEach((options3) => {
    const action = new action_default(options3.onClick, {
      context: popupInstance
    });
    popupToolbarItems.push({
      toolbar: "bottom",
      location: devices_default.current().android ? "after" : "center",
      widget: "dxButton",
      options: _extends({}, options3, {
        onClick() {
          const result2 = action.execute(...arguments);
          hide(result2);
        }
      })
    });
  });
  popupInstance.option("toolbarItems", popupToolbarItems);
  popupInstance.$wrapper().addClass("dx-dialog-wrapper");
  if (options2.position) {
    popupInstance.option("position", options2.position);
  }
  popupInstance.$wrapper().addClass("dx-dialog-root");
  function hide(value2) {
    deferred.resolve(value2);
    popupInstance.hide();
  }
  return {
    show: function() {
      if ("phone" === devices_default.real().deviceType) {
        const isPortrait = getHeight(window28) > getWidth(window28);
        const width = isPortrait ? "90%" : "60%";
        popupInstance.option({
          width
        });
      }
      popupInstance.show();
      return deferred.promise();
    },
    hide
  };
};
var confirm = function(messageHtml) {
  let title = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "";
  let showTitle = arguments.length > 2 ? arguments[2] : void 0;
  const options2 = isPlainObject(messageHtml) ? messageHtml : {
    title,
    messageHtml,
    showTitle,
    buttons: [_extends({
      text: message_default.format("Yes"),
      onClick: () => true
    }, getApplyButtonConfig()), _extends({
      text: message_default.format("No"),
      onClick: () => false
    }, getCancelButtonConfig())],
    dragEnabled: showTitle
  };
  return custom(options2).show();
};

// node_modules/devextreme/esm/__internal/grids/grid_core/editing/const.js
var EDITOR_CELL_CLASS = "dx-editor-cell";
var ROW_CLASS = "dx-row";
var CELL_MODIFIED_CLASS = "dx-cell-modified";
var ROW_SELECTED_CLASS = "dx-selection";
var EDIT_FORM_CLASS2 = "edit-form";
var DATA_EDIT_DATA_INSERT_TYPE = "insert";
var DATA_EDIT_DATA_REMOVE_TYPE = "remove";
var EDITING_POPUP_OPTION_NAME = "editing.popup";
var EDITING_FORM_OPTION_NAME = "editing.form";
var EDITING_EDITROWKEY_OPTION_NAME = "editing.editRowKey";
var EDITING_EDITCOLUMNNAME_OPTION_NAME = "editing.editColumnName";
var TARGET_COMPONENT_NAME = "targetComponent";
var EDITORS_INPUT_SELECTOR = "input:not([type='hidden'])";
var FOCUSABLE_ELEMENT_SELECTOR = `[tabindex]:not([disabled]), ${EDITORS_INPUT_SELECTOR}:not([disabled])`;
var EDIT_MODE_BATCH = "batch";
var EDIT_MODE_ROW = "row";
var EDIT_MODE_CELL = "cell";
var EDIT_MODE_FORM = "form";
var EDIT_MODE_POPUP = "popup";
var FIRST_NEW_ROW_POSITION = "first";
var LAST_NEW_ROW_POSITION = "last";
var PAGE_BOTTOM_NEW_ROW_POSITION = "pageBottom";
var PAGE_TOP_NEW_ROW_POSITION = "pageTop";
var VIEWPORT_BOTTOM_NEW_ROW_POSITION = "viewportBottom";
var VIEWPORT_TOP_NEW_ROW_POSITION = "viewportTop";
var EDIT_MODES = ["batch", "row", "cell", "form", "popup"];
var ROW_BASED_MODES = ["row", "form", "popup"];
var CELL_BASED_MODES = ["batch", "cell"];
var REQUIRED_EDITOR_LABELLEDBY_MODES = ["batch", "row", "cell"];
var MODES_WITH_DELAYED_FOCUS = ["row", "form"];
var READONLY_CLASS = "readonly";
var LINK_CLASS = "dx-link";
var LINK_ICON_CLASS = "dx-link-icon";
var ROW_SELECTED = "dx-selection";
var EDIT_BUTTON_CLASS = "dx-edit-button";
var COMMAND_EDIT_CLASS2 = "dx-command-edit";
var COMMAND_EDIT_WITH_ICONS_CLASS = "dx-command-edit-with-icons";
var INSERT_INDEX = "__DX_INSERT_INDEX__";
var ROW_INSERTED = "dx-row-inserted";
var ROW_MODIFIED = "dx-row-modified";
var CELL_MODIFIED = "dx-cell-modified";
var EDITING_NAMESPACE = "dxDataGridEditing";
var CELL_FOCUS_DISABLED_CLASS2 = "dx-cell-focus-disabled";
var DATA_EDIT_DATA_UPDATE_TYPE = "update";
var DEFAULT_START_EDIT_ACTION = "click";
var EDIT_LINK_CLASS = {
  save: "dx-link-save",
  cancel: "dx-link-cancel",
  edit: "dx-link-edit",
  undelete: "dx-link-undelete",
  delete: "dx-link-delete",
  add: "dx-link-add"
};
var EDIT_ICON_CLASS = {
  save: "save",
  cancel: "revert",
  edit: "edit",
  undelete: "revert",
  delete: "trash",
  add: "add"
};
var METHOD_NAMES = {
  edit: "editRow",
  delete: "deleteRow",
  undelete: "undeleteRow",
  save: "saveEditData",
  cancel: "cancelEditData",
  add: "addRowByRowIndex"
};
var ACTION_OPTION_NAMES = {
  add: "allowAdding",
  edit: "allowUpdating",
  delete: "allowDeleting"
};
var BUTTON_NAMES = ["edit", "save", "cancel", "delete", "undelete"];
var EDITING_CHANGES_OPTION_NAME = "editing.changes";
var FOCUS_OVERLAY_CLASS = "focus-overlay";
var ADD_ROW_BUTTON_CLASS = "addrow-button";
var DROPDOWN_EDITOR_OVERLAY_CLASS2 = "dx-dropdowneditor-overlay";
var DATA_ROW_CLASS2 = "dx-data-row";
var ROW_REMOVED = "dx-row-removed";
var FILTER_ROW_CLASS = "filter-row";
var isRenovatedScrollable = !!ui_scrollable_default.IS_RENOVATED_WIDGET;
var EDIT_FORM_ITEM_CLASS2 = "edit-form-item";
var EDIT_POPUP_CLASS = "edit-popup";
var EDIT_POPUP_FORM_CLASS = "edit-popup-form";
var FOCUSABLE_ELEMENT_CLASS = isRenovatedScrollable ? "dx-scrollable" : "dx-scrollable-container";
var BUTTON_CLASS2 = "dx-button";
var FORM_BUTTONS_CONTAINER_CLASS = "form-buttons-container";
var EDIT_ROW = "dx-edit-row";

// node_modules/devextreme/esm/__internal/grids/grid_core/editing/m_editing_utils.js
var createFailureHandler = function(deferred) {
  return function(arg) {
    const error2 = arg instanceof Error ? arg : new Error(arg && String(arg) || "Unknown error");
    deferred.reject(error2);
  };
};
var isEditingCell = function(isEditRow, cellOptions) {
  return cellOptions.isEditing || isEditRow && cellOptions.column.allowEditing;
};
var isEditingOrShowEditorAlwaysDataCell = function(isEditRow, cellOptions) {
  const isCommandCell = !!cellOptions.column.command;
  const isEditing = isEditingCell(isEditRow, cellOptions);
  const isEditorCell2 = !isCommandCell && (isEditing || cellOptions.column.showEditorAlways);
  return "data" === cellOptions.rowType && isEditorCell2;
};
var getEditingTexts = (options2) => {
  const editingTexts = options2.component.option("editing.texts") || {};
  return {
    save: editingTexts.saveRowChanges,
    cancel: editingTexts.cancelRowChanges,
    edit: editingTexts.editRow,
    undelete: editingTexts.undeleteRow,
    delete: editingTexts.deleteRow,
    add: editingTexts.addRowToNode
  };
};
var generateNewRowTempKey = () => `_DX_KEY_${new guid_default2()}`;
var isNewRowTempKey = (key) => "string" === typeof key && key.startsWith("_DX_KEY_") && 44 === key.length;
var getButtonIndex = (buttons, name2) => {
  let result2 = -1;
  buttons.some((button, index2) => {
    if (getButtonName(button) === name2) {
      result2 = index2;
      return true;
    }
  });
  return result2;
};
function getButtonName(button) {
  return isObject(button) ? button.name : button;
}
function isEditable($element) {
  return $element && ($element.is("input") || $element.is("textarea"));
}
var getEditorType = (item) => {
  var _column$formItem;
  const {
    column
  } = item;
  return item.isCustomEditorType ? item.editorType : null === (_column$formItem = column.formItem) || void 0 === _column$formItem ? void 0 : _column$formItem.editorType;
};
var forEachFormItems = (items, callBack) => {
  items.forEach((item) => {
    if (item.items || item.tabs) {
      forEachFormItems(item.items || item.tabs, callBack);
    } else {
      callBack(item);
    }
  });
};

// node_modules/devextreme/esm/__internal/grids/grid_core/editing/m_editing.js
var EditingControllerImpl = class extends m_modules_default.ViewController {
  init() {
    this._columnsController = this.getController("columns");
    this._dataController = this.getController("data");
    this._adaptiveColumnsController = this.getController("adaptiveColumns");
    this._validatingController = this.getController("validating");
    this._editorFactoryController = this.getController("editorFactory");
    this._focusController = this.getController("focus");
    this._keyboardNavigationController = this.getController("keyboardNavigation");
    this._columnsResizerController = this.getController("columnsResizer");
    this._errorHandlingController = this.getController("errorHandling");
    this._rowsView = this.getView("rowsView");
    this._headerPanelView = this.getView("headerPanel");
    this._lastOperation = null;
    this._changes = [];
    if (this._deferreds) {
      this._deferreds.forEach((d) => {
        d.reject("cancel");
      });
    }
    this._deferreds = [];
    if (!this._dataChangedHandler) {
      this._dataChangedHandler = this._handleDataChanged.bind(this);
      this._dataController.changed.add(this._dataChangedHandler);
    }
    if (!this._saveEditorHandler) {
      this.createAction("onInitNewRow", {
        excludeValidators: ["disabled", "readOnly"]
      });
      this.createAction("onRowInserting", {
        excludeValidators: ["disabled", "readOnly"]
      });
      this.createAction("onRowInserted", {
        excludeValidators: ["disabled", "readOnly"]
      });
      this.createAction("onEditingStart", {
        excludeValidators: ["disabled", "readOnly"]
      });
      this.createAction("onRowUpdating", {
        excludeValidators: ["disabled", "readOnly"]
      });
      this.createAction("onRowUpdated", {
        excludeValidators: ["disabled", "readOnly"]
      });
      this.createAction("onRowRemoving", {
        excludeValidators: ["disabled", "readOnly"]
      });
      this.createAction("onRowRemoved", {
        excludeValidators: ["disabled", "readOnly"]
      });
      this.createAction("onSaved", {
        excludeValidators: ["disabled", "readOnly"]
      });
      this.createAction("onSaving", {
        excludeValidators: ["disabled", "readOnly"]
      });
      this.createAction("onEditCanceling", {
        excludeValidators: ["disabled", "readOnly"]
      });
      this.createAction("onEditCanceled", {
        excludeValidators: ["disabled", "readOnly"]
      });
    }
    this._updateEditColumn();
    this._updateEditButtons();
    if (!this._internalState) {
      this._internalState = /* @__PURE__ */ new Map();
    }
    this.component._optionsByReference[EDITING_EDITROWKEY_OPTION_NAME] = true;
    this.component._optionsByReference[EDITING_CHANGES_OPTION_NAME] = true;
  }
  getEditMode() {
    const editMode = this.option("editing.mode") ?? EDIT_MODE_ROW;
    if (EDIT_MODES.includes(editMode)) {
      return editMode;
    }
    return EDIT_MODE_ROW;
  }
  isCellBasedEditMode() {
    const editMode = this.getEditMode();
    return CELL_BASED_MODES.includes(editMode);
  }
  _getDefaultEditorTemplate() {
    return (container, options2) => {
      const $editor = renderer_default("<div>").appendTo(container);
      const editorOptions = extend({}, options2.column, {
        value: options2.value,
        setValue: options2.setValue,
        row: options2.row,
        parentType: "dataRow",
        width: null,
        readOnly: !options2.setValue,
        isOnForm: options2.isOnForm,
        id: options2.id
      });
      const needLabel = REQUIRED_EDITOR_LABELLEDBY_MODES.includes(this.getEditMode());
      if (needLabel) {
        editorOptions["aria-labelledby"] = options2.column.headerId;
      }
      this._editorFactoryController.createEditor($editor, editorOptions);
    };
  }
  _getNewRowPosition() {
    const newRowPosition = this.option("editing.newRowPosition");
    const scrollingMode = this.option("scrolling.mode");
    if ("virtual" === scrollingMode) {
      switch (newRowPosition) {
        case PAGE_TOP_NEW_ROW_POSITION:
          return VIEWPORT_TOP_NEW_ROW_POSITION;
        case PAGE_BOTTOM_NEW_ROW_POSITION:
          return VIEWPORT_BOTTOM_NEW_ROW_POSITION;
        default:
          return newRowPosition;
      }
    }
    return newRowPosition;
  }
  getChanges() {
    return this.option(EDITING_CHANGES_OPTION_NAME);
  }
  getInsertRowCount() {
    const changes = this.option(EDITING_CHANGES_OPTION_NAME);
    return changes.filter((change) => "insert" === change.type).length;
  }
  resetChanges() {
    const changes = this.getChanges();
    const needReset = null === changes || void 0 === changes ? void 0 : changes.length;
    if (needReset) {
      this._silentOption(EDITING_CHANGES_OPTION_NAME, []);
      this._internalState.clear();
    }
  }
  _getInternalData(key) {
    return this._internalState.get(getKeyHash(key));
  }
  _addInternalData(params) {
    const internalData = this._getInternalData(params.key);
    if (internalData) {
      return extend(internalData, params);
    }
    this._internalState.set(getKeyHash(params.key), params);
    return params;
  }
  _getOldData(key) {
    var _this$_getInternalDat;
    return null === (_this$_getInternalDat = this._getInternalData(key)) || void 0 === _this$_getInternalDat ? void 0 : _this$_getInternalDat.oldData;
  }
  getUpdatedData(data17) {
    const key = this._dataController.keyOf(data17);
    const changes = this.getChanges();
    const editIndex = m_utils_default.getIndexByKey(key, changes);
    if (changes[editIndex]) {
      return createObjectWithChanges(data17, changes[editIndex].data);
    }
    return data17;
  }
  getInsertedData() {
    return this.getChanges().filter((change) => change.data && change.type === DATA_EDIT_DATA_INSERT_TYPE).map((change) => change.data);
  }
  getRemovedData() {
    return this.getChanges().filter((change) => this._getOldData(change.key) && change.type === DATA_EDIT_DATA_REMOVE_TYPE).map((change) => this._getOldData(change.key));
  }
  _fireDataErrorOccurred(arg) {
    if ("cancel" === arg) {
      return;
    }
    const $popupContent = this.getPopupContent();
    this._dataController.dataErrorOccurred.fire(arg, $popupContent);
  }
  _needToCloseEditableCell($targetElement) {
  }
  _closeEditItem($targetElement) {
  }
  _handleDataChanged(args) {
  }
  _isDefaultButtonVisible(button, options2) {
    let result2 = true;
    switch (button.name) {
      case "delete":
        result2 = this.allowDeleting(options2);
        break;
      case "undelete":
        result2 = false;
    }
    return result2;
  }
  isPopupEditMode() {
    const editMode = this.option("editing.mode");
    return editMode === EDIT_MODE_POPUP;
  }
  _isButtonVisible(button, options2) {
    const {
      visible: visible2
    } = button;
    if (!isDefined(visible2)) {
      return this._isDefaultButtonVisible(button, options2);
    }
    return isFunction(visible2) ? visible2.call(button, {
      component: options2.component,
      row: options2.row,
      column: options2.column
    }) : visible2;
  }
  _isButtonDisabled(button, options2) {
    const {
      disabled
    } = button;
    return isFunction(disabled) ? disabled.call(button, {
      component: options2.component,
      row: options2.row,
      column: options2.column
    }) : !!disabled;
  }
  _getButtonConfig(button, options2) {
    const config3 = isObject(button) ? button : {};
    const buttonName = getButtonName(button);
    const editingTexts = getEditingTexts(options2);
    const methodName = METHOD_NAMES[buttonName];
    const editingOptions = this.option("editing");
    const actionName = ACTION_OPTION_NAMES[buttonName];
    const allowAction = actionName ? editingOptions[actionName] : true;
    return extend({
      name: buttonName,
      text: editingTexts[buttonName],
      cssClass: EDIT_LINK_CLASS[buttonName]
    }, {
      onClick: methodName && ((e) => {
        const {
          event
        } = e;
        event.stopPropagation();
        event.preventDefault();
        setTimeout(() => {
          options2.row && allowAction && this[methodName] && this[methodName](options2.row.rowIndex);
        });
      })
    }, config3);
  }
  _getEditingButtons(options2) {
    let buttonIndex;
    const haveCustomButtons = !!options2.column.buttons;
    let buttons = (options2.column.buttons || []).slice();
    if (haveCustomButtons) {
      buttonIndex = getButtonIndex(buttons, "edit");
      if (buttonIndex >= 0) {
        if (getButtonIndex(buttons, "save") < 0) {
          buttons.splice(buttonIndex + 1, 0, "save");
        }
        if (getButtonIndex(buttons, "cancel") < 0) {
          buttons.splice(getButtonIndex(buttons, "save") + 1, 0, "cancel");
        }
      }
      buttonIndex = getButtonIndex(buttons, "delete");
      if (buttonIndex >= 0 && getButtonIndex(buttons, "undelete") < 0) {
        buttons.splice(buttonIndex + 1, 0, "undelete");
      }
    } else {
      buttons = BUTTON_NAMES.slice();
    }
    return buttons.map((button) => this._getButtonConfig(button, options2));
  }
  _renderEditingButtons($container, buttons, options2, change) {
    buttons.forEach((button) => {
      if (this._isButtonVisible(button, options2)) {
        this._createButton($container, button, options2, change);
      }
    });
  }
  _getEditCommandCellTemplate() {
    return (container, options2, change) => {
      const $container = renderer_default(container);
      if ("data" === options2.rowType) {
        const buttons = this._getEditingButtons(options2);
        this._renderEditingButtons($container, buttons, options2, change);
        if (options2.watch) {
          const dispose2 = options2.watch(() => buttons.map((button) => ({
            visible: this._isButtonVisible(button, options2),
            disabled: this._isButtonDisabled(button, options2)
          })), () => {
            $container.empty();
            this._renderEditingButtons($container, buttons, options2);
          });
          m_events_engine_default.on($container, removeEvent, dispose2);
        }
      } else {
        m_utils_default.setEmptyText($container);
      }
    };
  }
  isRowBasedEditMode() {
    const editMode = this.getEditMode();
    return ROW_BASED_MODES.includes(editMode);
  }
  getFirstEditableColumnIndex() {
    let columnIndex;
    const visibleColumns = this._columnsController.getVisibleColumns();
    each(visibleColumns, (index2, column) => {
      if (column.allowEditing) {
        columnIndex = index2;
        return false;
      }
    });
    return columnIndex;
  }
  getFirstEditableCellInRow(rowIndex) {
    var _this$_rowsView;
    const columnIndex = this.getFirstEditableColumnIndex();
    return null === (_this$_rowsView = this._rowsView) || void 0 === _this$_rowsView ? void 0 : _this$_rowsView._getCellElement(rowIndex || 0, columnIndex);
  }
  getFocusedCellInRow(rowIndex) {
    return this.getFirstEditableCellInRow(rowIndex);
  }
  getIndexByKey(key, items) {
    return m_utils_default.getIndexByKey(key, items);
  }
  hasChanges(rowIndex) {
    const changes = this.getChanges();
    let result2 = false;
    for (let i = 0; i < (null === changes || void 0 === changes ? void 0 : changes.length); i++) {
      if (changes[i].type && (!isDefined(rowIndex) || this._dataController.getRowIndexByKey(changes[i].key) === rowIndex)) {
        result2 = true;
        break;
      }
    }
    return result2;
  }
  dispose() {
    super.dispose();
    clearTimeout(this._inputFocusTimeoutID);
    m_events_engine_default.off(dom_adapter_default.getDocument(), m_pointer_default.up, this._pointerUpEditorHandler);
    m_events_engine_default.off(dom_adapter_default.getDocument(), m_pointer_default.down, this._pointerDownEditorHandler);
    m_events_engine_default.off(dom_adapter_default.getDocument(), CLICK_EVENT_NAME, this._saveEditorHandler);
  }
  _silentOption(name2, value2) {
    if ("editing.changes" === name2) {
      this._changes = deepExtendArraySafe([], value2);
    }
    super._silentOption(name2, value2);
  }
  optionChanged(args) {
    if ("editing" === args.name) {
      const {
        fullName
      } = args;
      if (fullName === EDITING_EDITROWKEY_OPTION_NAME) {
        this._handleEditRowKeyChange(args);
      } else if (fullName === EDITING_CHANGES_OPTION_NAME) {
        const isEqual2 = equalByValue(args.value, this._changes, {
          maxDepth: 4
        });
        if (!isEqual2) {
          this._changes = deepExtendArraySafe([], args.value);
          this._handleChangesChange(args);
        }
      } else if (!args.handled) {
        this._columnsController.reinit();
        this.init();
        this.resetChanges();
        this._resetEditColumnName();
        this._resetEditRowKey();
      }
      args.handled = true;
    } else {
      super.optionChanged(args);
    }
  }
  _handleEditRowKeyChange(args) {
    const rowIndex = this._dataController.getRowIndexByKey(args.value);
    const oldRowIndexCorrection = this._getEditRowIndexCorrection();
    const oldRowIndex = this._dataController.getRowIndexByKey(args.previousValue) + oldRowIndexCorrection;
    if (isDefined(args.value)) {
      if (args.value !== args.previousValue) {
        this._editRowFromOptionChanged(rowIndex, oldRowIndex);
      }
    } else {
      this.cancelEditData();
    }
  }
  _handleChangesChange(args) {
    const dataController2 = this._dataController;
    const changes = args.value;
    if (!args.value.length && !args.previousValue.length) {
      return;
    }
    changes.forEach((change) => {
      if ("insert" === change.type) {
        this._addInsertInfo(change);
      } else {
        var _dataController$items;
        const items = dataController2.getCachedStoreData() || (null === (_dataController$items = dataController2.items()) || void 0 === _dataController$items ? void 0 : _dataController$items.map((item) => item.data));
        const rowIndex = m_utils_default.getIndexByKey(change.key, items, dataController2.key());
        this._addInternalData({
          key: change.key,
          oldData: items[rowIndex]
        });
      }
    });
    dataController2.updateItems({
      repaintChangesOnly: true,
      isLiveUpdate: false,
      isOptionChanged: true
    });
  }
  publicMethods() {
    return ["addRow", "deleteRow", "undeleteRow", "editRow", "saveEditData", "cancelEditData", "hasEditData"];
  }
  refresh() {
    if (!isDefined(this._pageIndex)) {
      return;
    }
    this._refreshCore.apply(this, arguments);
  }
  _refreshCore(params) {
  }
  isEditing() {
    const isEditRowKeyDefined = isDefined(this.option(EDITING_EDITROWKEY_OPTION_NAME));
    return isEditRowKeyDefined;
  }
  isEditRow(rowIndex) {
    return false;
  }
  _setEditRowKey(value2, silent) {
    if (silent) {
      this._silentOption(EDITING_EDITROWKEY_OPTION_NAME, value2);
    } else {
      this.option(EDITING_EDITROWKEY_OPTION_NAME, value2);
    }
    if (this._refocusEditCell) {
      this._refocusEditCell = false;
      this._focusEditingCell();
    }
  }
  _setEditRowKeyByIndex(rowIndex, silent) {
    const key = this._dataController.getKeyByRowIndex(rowIndex);
    if (void 0 === key) {
      this._dataController.fireError("E1043");
      return;
    }
    this._setEditRowKey(key, silent);
  }
  getEditRowIndex() {
    return this._getVisibleEditRowIndex();
  }
  getEditFormRowIndex() {
    return -1;
  }
  isEditRowByIndex(rowIndex) {
    const key = this._dataController.getKeyByRowIndex(rowIndex);
    const isKeyEqual = isDefined(key) && equalByValue(this.option(EDITING_EDITROWKEY_OPTION_NAME), key);
    if (isKeyEqual) {
      return this._getVisibleEditRowIndex() === rowIndex;
    }
    return isKeyEqual;
  }
  isEditCell(visibleRowIndex, columnIndex) {
    return this.isEditRowByIndex(visibleRowIndex) && this._getVisibleEditColumnIndex() === columnIndex;
  }
  getPopupContent() {
  }
  _isProcessedItem(item) {
    return false;
  }
  _getInsertRowIndex(items, change, isProcessedItems) {
    let result2 = -1;
    const dataController2 = this._dataController;
    const key = this._getInsertAfterOrBeforeKey(change);
    if (!isDefined(key) && 0 === items.length) {
      result2 = 0;
    } else if (isDefined(key)) {
      items.some((item, index2) => {
        const isProcessedItem = isProcessedItems || this._isProcessedItem(item);
        if (isObject(item)) {
          if (isProcessedItem || isDefined(item[INSERT_INDEX])) {
            if (equalByValue(item.key, key)) {
              result2 = index2;
            }
          } else if (equalByValue(dataController2.keyOf(item), key)) {
            result2 = index2;
          }
        }
        if (result2 >= 0) {
          const nextItem = items[result2 + 1];
          if (nextItem && ("detail" === nextItem.rowType || "detailAdaptive" === nextItem.rowType) && isDefined(change.insertAfterKey)) {
            return;
          }
          if (isDefined(change.insertAfterKey)) {
            result2 += 1;
          }
          return true;
        }
      });
    }
    return result2;
  }
  _generateNewItem(key) {
    var _this$_getInternalDat2;
    const item = {
      key
    };
    const insertInfo = null === (_this$_getInternalDat2 = this._getInternalData(key)) || void 0 === _this$_getInternalDat2 ? void 0 : _this$_getInternalDat2.insertInfo;
    if (null !== insertInfo && void 0 !== insertInfo && insertInfo[INSERT_INDEX]) {
      item[INSERT_INDEX] = insertInfo[INSERT_INDEX];
    }
    return item;
  }
  _getLoadedRowIndex(items, change, isProcessedItems) {
    let loadedRowIndex = this._getInsertRowIndex(items, change, isProcessedItems);
    const dataController2 = this._dataController;
    if (loadedRowIndex < 0) {
      const newRowPosition = this._getNewRowPosition();
      const pageIndex = dataController2.pageIndex();
      const insertAfterOrBeforeKey = this._getInsertAfterOrBeforeKey(change);
      if (newRowPosition !== LAST_NEW_ROW_POSITION && 0 === pageIndex && !isDefined(insertAfterOrBeforeKey)) {
        loadedRowIndex = 0;
      } else if (newRowPosition === LAST_NEW_ROW_POSITION && dataController2.isLastPageLoaded()) {
        loadedRowIndex = items.length;
      }
    }
    return loadedRowIndex;
  }
  processItems(items, e) {
    const {
      changeType
    } = e;
    this.update(changeType);
    const changes = this.getChanges();
    changes.forEach((change) => {
      var _this$_getInternalDat3;
      const isInsert = change.type === DATA_EDIT_DATA_INSERT_TYPE;
      if (!isInsert) {
        return;
      }
      let {
        key
      } = change;
      let insertInfo = null === (_this$_getInternalDat3 = this._getInternalData(key)) || void 0 === _this$_getInternalDat3 ? void 0 : _this$_getInternalDat3.insertInfo;
      if (!isDefined(key) || !isDefined(insertInfo)) {
        insertInfo = this._addInsertInfo(change);
        key = insertInfo.key;
      }
      const loadedRowIndex = this._getLoadedRowIndex(items, change);
      const item = this._generateNewItem(key);
      if (loadedRowIndex >= 0) {
        items.splice(loadedRowIndex, 0, item);
      }
    });
    return items;
  }
  processDataItem(item, options2, generateDataValues) {
    const columns7 = options2.visibleColumns;
    const key = item.data[INSERT_INDEX] ? item.data.key : item.key;
    const changes = this.getChanges();
    const editIndex = m_utils_default.getIndexByKey(key, changes);
    item.isEditing = false;
    if (editIndex >= 0) {
      this._processDataItemCore(item, changes[editIndex], key, columns7, generateDataValues);
    }
  }
  _processDataItemCore(item, change, key, columns7, generateDataValues) {
    const {
      data: data17,
      type: type2
    } = change;
    switch (type2) {
      case DATA_EDIT_DATA_INSERT_TYPE:
        item.isNewRow = true;
        item.key = key;
        item.data = data17;
        break;
      case DATA_EDIT_DATA_UPDATE_TYPE:
        item.modified = true;
        item.oldData = item.data;
        item.data = createObjectWithChanges(item.data, data17);
        item.modifiedValues = generateDataValues(data17, columns7, true);
        break;
      case DATA_EDIT_DATA_REMOVE_TYPE:
        item.removed = true;
    }
  }
  _initNewRow(options2) {
    this.executeAction("onInitNewRow", options2);
    if (options2.promise) {
      const deferred = new Deferred();
      when(fromPromise(options2.promise)).done(deferred.resolve).fail(createFailureHandler(deferred)).fail((arg) => this._fireDataErrorOccurred(arg));
      return deferred;
    }
  }
  _createInsertInfo() {
    const insertInfo = {};
    insertInfo[INSERT_INDEX] = this._getInsertIndex();
    return insertInfo;
  }
  _addInsertInfo(change, parentKey) {
    var _this$_getInternalDat4;
    let insertInfo;
    change.key = this.getChangeKeyValue(change);
    const {
      key
    } = change;
    insertInfo = null === (_this$_getInternalDat4 = this._getInternalData(key)) || void 0 === _this$_getInternalDat4 ? void 0 : _this$_getInternalDat4.insertInfo;
    if (!isDefined(insertInfo)) {
      const insertAfterOrBeforeKey = this._getInsertAfterOrBeforeKey(change);
      insertInfo = this._createInsertInfo();
      if (!isDefined(insertAfterOrBeforeKey)) {
        this._setInsertAfterOrBeforeKey(change, parentKey);
      }
    }
    this._addInternalData({
      insertInfo,
      key
    });
    return {
      insertInfo,
      key
    };
  }
  getChangeKeyValue(change) {
    if (isDefined(change.key)) {
      return change.key;
    }
    const keyExpr = this._dataController.key();
    let keyValue;
    if (change.data && keyExpr && !Array.isArray(keyExpr)) {
      keyValue = change.data[keyExpr];
    }
    if (!isDefined(keyValue)) {
      keyValue = generateNewRowTempKey();
    }
    return keyValue;
  }
  _setInsertAfterOrBeforeKey(change, parentKey) {
    const rowsView18 = this.getView("rowsView");
    const dataController2 = this._dataController;
    const allItems = dataController2.items(true);
    const newRowPosition = this._getNewRowPosition();
    switch (newRowPosition) {
      case FIRST_NEW_ROW_POSITION:
      case LAST_NEW_ROW_POSITION:
        break;
      case PAGE_TOP_NEW_ROW_POSITION:
        if (allItems.length) {
          change.insertBeforeKey = allItems[0].key;
        }
        break;
      case PAGE_BOTTOM_NEW_ROW_POSITION:
        if (allItems.length) {
          change.insertAfterKey = allItems[allItems.length - 1].key;
        }
        break;
      default: {
        const isViewportBottom = newRowPosition === VIEWPORT_BOTTOM_NEW_ROW_POSITION;
        let visibleItemIndex = isViewportBottom ? null === rowsView18 || void 0 === rowsView18 ? void 0 : rowsView18.getBottomVisibleItemIndex() : null === rowsView18 || void 0 === rowsView18 ? void 0 : rowsView18.getTopVisibleItemIndex();
        const row = dataController2.getVisibleRows()[visibleItemIndex];
        if (row && (!row.isEditing && "detail" === row.rowType || "detailAdaptive" === row.rowType)) {
          visibleItemIndex++;
        }
        const insertKey = dataController2.getKeyByRowIndex(visibleItemIndex);
        if (isDefined(insertKey)) {
          change.insertBeforeKey = insertKey;
        }
      }
    }
  }
  _getInsertIndex() {
    let maxInsertIndex = 0;
    this.getChanges().forEach((editItem) => {
      var _this$_getInternalDat5;
      const insertInfo = null === (_this$_getInternalDat5 = this._getInternalData(editItem.key)) || void 0 === _this$_getInternalDat5 ? void 0 : _this$_getInternalDat5.insertInfo;
      if (isDefined(insertInfo) && editItem.type === DATA_EDIT_DATA_INSERT_TYPE && insertInfo[INSERT_INDEX] > maxInsertIndex) {
        maxInsertIndex = insertInfo[INSERT_INDEX];
      }
    });
    return maxInsertIndex + 1;
  }
  _getInsertAfterOrBeforeKey(insertChange) {
    return insertChange.insertAfterKey ?? insertChange.insertBeforeKey;
  }
  _getPageIndexToInsertRow() {
    const newRowPosition = this._getNewRowPosition();
    const dataController2 = this._dataController;
    const pageIndex = dataController2.pageIndex();
    const lastPageIndex = dataController2.pageCount() - 1;
    if (newRowPosition === FIRST_NEW_ROW_POSITION && 0 !== pageIndex) {
      return 0;
    }
    if (newRowPosition === LAST_NEW_ROW_POSITION && pageIndex !== lastPageIndex) {
      return lastPageIndex;
    }
    return -1;
  }
  addRow(parentKey) {
    const dataController2 = this._dataController;
    const store = dataController2.store();
    if (!store) {
      dataController2.fireError("E1052", this.component.NAME);
      return new Deferred().reject();
    }
    return this._addRow(parentKey);
  }
  _addRow(parentKey) {
    const dataController2 = this._dataController;
    const store = dataController2.store();
    const key = store && store.key();
    const param = {
      data: {}
    };
    const oldEditRowIndex = this._getVisibleEditRowIndex();
    const deferred = new Deferred();
    this.refresh({
      allowCancelEditing: true
    });
    if (!this._allowRowAdding()) {
      when(this._navigateToNewRow(oldEditRowIndex)).done(deferred.resolve).fail(deferred.reject);
      return deferred.promise();
    }
    if (!key) {
      param.data.__KEY__ = String(new guid_default2());
    }
    when(this._initNewRow(param, parentKey)).done(() => {
      if (this._allowRowAdding()) {
        when(this._addRowCore(param.data, parentKey, oldEditRowIndex)).done(deferred.resolve).fail(deferred.reject);
      } else {
        deferred.reject("cancel");
      }
    }).fail(deferred.reject);
    return deferred.promise();
  }
  _allowRowAdding(params) {
    const insertIndex = this._getInsertIndex();
    if (insertIndex > 1) {
      return false;
    }
    return true;
  }
  _addRowCore(data17, parentKey, initialOldEditRowIndex) {
    const change = {
      data: data17,
      type: DATA_EDIT_DATA_INSERT_TYPE
    };
    const editRowIndex = this._getVisibleEditRowIndex();
    const insertInfo = this._addInsertInfo(change, parentKey);
    const {
      key
    } = insertInfo;
    this._setEditRowKey(key, true);
    this._addChange(change);
    return this._navigateToNewRow(initialOldEditRowIndex, change, editRowIndex);
  }
  _navigateToNewRow(oldEditRowIndex, change, editRowIndex) {
    const d = new Deferred();
    const dataController2 = this._dataController;
    editRowIndex = editRowIndex ?? -1;
    change = change ?? this.getChanges().filter((c) => c.type === DATA_EDIT_DATA_INSERT_TYPE)[0];
    if (!change) {
      return d.reject("cancel").promise();
    }
    const pageIndexToInsertRow = this._getPageIndexToInsertRow();
    let rowIndex = this._getLoadedRowIndex(dataController2.items(), change, true);
    const navigateToRowByKey = (key) => {
      var _this$_focusControlle;
      when(null === (_this$_focusControlle = this._focusController) || void 0 === _this$_focusControlle ? void 0 : _this$_focusControlle.navigateToRow(key)).done(() => {
        rowIndex = dataController2.getRowIndexByKey(change.key);
        d.resolve();
      });
    };
    const insertAfterOrBeforeKey = this._getInsertAfterOrBeforeKey(change);
    if (pageIndexToInsertRow >= 0) {
      dataController2.pageIndex(pageIndexToInsertRow).done(() => {
        navigateToRowByKey(change.key);
      }).fail(d.reject);
    } else if (rowIndex < 0 && isDefined(insertAfterOrBeforeKey)) {
      navigateToRowByKey(insertAfterOrBeforeKey);
    } else {
      dataController2.updateItems({
        changeType: "update",
        rowIndices: [oldEditRowIndex, editRowIndex, rowIndex]
      });
      rowIndex = dataController2.getRowIndexByKey(change.key);
      if (rowIndex < 0) {
        navigateToRowByKey(change.key);
      } else {
        d.resolve();
      }
    }
    d.done(() => {
      var _this$_rowsView2;
      null === (_this$_rowsView2 = this._rowsView) || void 0 === _this$_rowsView2 || _this$_rowsView2.waitAsyncTemplates(true).done(() => {
        this._showAddedRow(rowIndex);
        this._afterInsertRow(change.key);
      });
    });
    return d.promise();
  }
  _showAddedRow(rowIndex) {
    this._focusFirstEditableCellInRow(rowIndex);
  }
  _beforeFocusElementInRow(rowIndex) {
  }
  _focusFirstEditableCellInRow(rowIndex) {
    var _this$_keyboardNaviga;
    const dataController2 = this._dataController;
    const key = dataController2.getKeyByRowIndex(rowIndex);
    const $firstCell = this.getFirstEditableCellInRow(rowIndex);
    null === (_this$_keyboardNaviga = this._keyboardNavigationController) || void 0 === _this$_keyboardNaviga || _this$_keyboardNaviga.focus($firstCell);
    this.option("focusedRowKey", key);
    this._editCellInProgress = true;
    this._delayedInputFocus($firstCell, () => {
      rowIndex = dataController2.getRowIndexByKey(key);
      this._editCellInProgress = false;
      this._beforeFocusElementInRow(rowIndex);
    });
  }
  _isEditingStart(options2) {
    this.executeAction("onEditingStart", options2);
    return options2.cancel;
  }
  _beforeUpdateItems(rowIndices, rowIndex) {
  }
  _getVisibleEditColumnIndex() {
    const editColumnName = this.option(EDITING_EDITCOLUMNNAME_OPTION_NAME);
    if (!isDefined(editColumnName)) {
      return -1;
    }
    return this._columnsController.getVisibleColumnIndex(editColumnName);
  }
  _setEditColumnNameByIndex(index2, silent) {
    var _visibleColumns$index;
    const visibleColumns = this._columnsController.getVisibleColumns();
    this._setEditColumnName(null === (_visibleColumns$index = visibleColumns[index2]) || void 0 === _visibleColumns$index ? void 0 : _visibleColumns$index.name, silent);
  }
  _setEditColumnName(name2, silent) {
    if (silent) {
      this._silentOption(EDITING_EDITCOLUMNNAME_OPTION_NAME, name2);
    } else {
      this.option(EDITING_EDITCOLUMNNAME_OPTION_NAME, name2);
    }
  }
  _resetEditColumnName() {
    this._setEditColumnName(null, true);
  }
  _getEditColumn() {
    const editColumnName = this.option(EDITING_EDITCOLUMNNAME_OPTION_NAME);
    return this._getColumnByName(editColumnName);
  }
  _getColumnByName(name2) {
    const visibleColumns = this._columnsController.getVisibleColumns();
    let editColumn;
    isDefined(name2) && visibleColumns.some((column) => {
      if (column.name === name2) {
        editColumn = column;
        return true;
      }
    });
    return editColumn;
  }
  _getVisibleEditRowIndex(columnName) {
    const dataController2 = this._dataController;
    const editRowKey = this.option(EDITING_EDITROWKEY_OPTION_NAME);
    const rowIndex = dataController2.getRowIndexByKey(editRowKey);
    if (-1 === rowIndex) {
      return rowIndex;
    }
    return rowIndex + this._getEditRowIndexCorrection(columnName);
  }
  _getEditRowIndexCorrection(columnName) {
    const editColumn = columnName ? this._getColumnByName(columnName) : this._getEditColumn();
    const isColumnHidden = "adaptiveHidden" === (null === editColumn || void 0 === editColumn ? void 0 : editColumn.visibleWidth);
    return isColumnHidden ? 1 : 0;
  }
  _resetEditRowKey() {
    this._refocusEditCell = false;
    this._setEditRowKey(null, true);
  }
  _resetEditIndices() {
    this._resetEditColumnName();
    this._resetEditRowKey();
  }
  editRow(rowIndex) {
    const dataController2 = this._dataController;
    const items = dataController2.items();
    const item = items[rowIndex];
    const params = {
      data: item && item.data,
      cancel: false
    };
    const oldRowIndex = this._getVisibleEditRowIndex();
    if (!item) {
      return;
    }
    if (rowIndex === oldRowIndex) {
      return true;
    }
    if (void 0 === item.key) {
      this._dataController.fireError("E1043");
      return;
    }
    if (!item.isNewRow) {
      params.key = item.key;
    }
    if (this._isEditingStart(params)) {
      return;
    }
    this.resetChanges();
    this.init();
    this._resetEditColumnName();
    this._pageIndex = dataController2.pageIndex();
    this._addInternalData({
      key: item.key,
      oldData: item.oldData ?? item.data
    });
    this._setEditRowKey(item.key);
  }
  _editRowFromOptionChanged(rowIndex, oldRowIndex) {
    const rowIndices = [oldRowIndex, rowIndex];
    this._beforeUpdateItems(rowIndices, rowIndex, oldRowIndex);
    this._editRowFromOptionChangedCore(rowIndices, rowIndex);
  }
  _editRowFromOptionChangedCore(rowIndices, rowIndex, preventRendering) {
    this._needFocusEditor = true;
    this._dataController.updateItems({
      changeType: "update",
      rowIndices,
      cancel: preventRendering
    });
  }
  _focusEditorIfNeed() {
  }
  _showEditPopup(rowIndex, repaintForm) {
  }
  _repaintEditPopup() {
  }
  _getEditPopupHiddenHandler() {
    return (e) => {
      if (this.isEditing()) {
        this.cancelEditData();
      }
    };
  }
  _getPopupEditFormTemplate(rowIndex) {
  }
  _getSaveButtonConfig() {
    const buttonConfig = {
      text: this.option("editing.texts.saveRowChanges"),
      onClick: this.saveEditData.bind(this)
    };
    if (isFluent(current())) {
      buttonConfig.stylingMode = "contained";
      buttonConfig.type = "default";
    }
    return buttonConfig;
  }
  _getCancelButtonConfig() {
    const buttonConfig = {
      text: this.option("editing.texts.cancelRowChanges"),
      onClick: this.cancelEditData.bind(this)
    };
    if (isFluent(current())) {
      buttonConfig.stylingMode = "outlined";
    }
    return buttonConfig;
  }
  _removeInternalData(key) {
    this._internalState.delete(getKeyHash(key));
  }
  _updateInsertAfterOrBeforeKeys(changes, index2) {
    const removeChange = changes[index2];
    changes.forEach((change) => {
      if (change.type === DATA_EDIT_DATA_INSERT_TYPE) {
        const insertAfterOrBeforeKey = this._getInsertAfterOrBeforeKey(change);
        if (equalByValue(insertAfterOrBeforeKey, removeChange.key)) {
          change[isDefined(change.insertAfterKey) ? "insertAfterKey" : "insertBeforeKey"] = this._getInsertAfterOrBeforeKey(removeChange);
        }
      }
    });
  }
  _removeChange(index2) {
    if (index2 >= 0) {
      const changes = [...this.getChanges()];
      const {
        key
      } = changes[index2];
      this._removeInternalData(key);
      this._updateInsertAfterOrBeforeKeys(changes, index2);
      changes.splice(index2, 1);
      this._silentOption(EDITING_CHANGES_OPTION_NAME, changes);
      if (equalByValue(this.option(EDITING_EDITROWKEY_OPTION_NAME), key)) {
        this._resetEditIndices();
      }
    }
  }
  executeOperation(deferred, func) {
    this._lastOperation && this._lastOperation.reject();
    this._lastOperation = deferred;
    this.waitForDeferredOperations().done(() => {
      if ("rejected" === deferred.state()) {
        return;
      }
      func();
      this._lastOperation = null;
    }).fail(() => {
      deferred.reject();
      this._lastOperation = null;
    });
  }
  waitForDeferredOperations() {
    return when(...this._deferreds);
  }
  _processCanceledEditingCell() {
  }
  _repaintEditCell(column, oldColumn, oldEditRowIndex) {
    if (!column || !column.showEditorAlways || oldColumn && !oldColumn.showEditorAlways) {
      this._editCellInProgress = true;
      this._needFocusEditor = true;
      this._editorFactoryController.loseFocus();
      this._dataController.updateItems({
        changeType: "update",
        rowIndices: [oldEditRowIndex, this._getVisibleEditRowIndex()]
      });
    } else if (column !== oldColumn) {
      this._needFocusEditor = true;
      this._dataController.updateItems({
        changeType: "update",
        rowIndices: []
      });
    }
  }
  _delayedInputFocus($cell, beforeFocusCallback, callBeforeFocusCallbackAlways) {
    const inputFocus = () => {
      if (beforeFocusCallback) {
        beforeFocusCallback();
      }
      if ($cell) {
        const $focusableElement = $cell.find(FOCUSABLE_ELEMENT_SELECTOR).first();
        m_utils_default.focusAndSelectElement(this, $focusableElement);
      }
      this._beforeFocusCallback = null;
    };
    if (devices_default.real().ios || devices_default.real().android) {
      inputFocus();
    } else {
      if (this._beforeFocusCallback) {
        this._beforeFocusCallback();
      }
      clearTimeout(this._inputFocusTimeoutID);
      if (callBeforeFocusCallbackAlways) {
        this._beforeFocusCallback = beforeFocusCallback;
      }
      this._inputFocusTimeoutID = setTimeout(inputFocus);
    }
  }
  _focusEditingCell(beforeFocusCallback, $editCell, callBeforeFocusCallbackAlways) {
    const editColumnIndex = this._getVisibleEditColumnIndex();
    $editCell = $editCell || this._rowsView && this._rowsView._getCellElement(this._getVisibleEditRowIndex(), editColumnIndex);
    if ($editCell) {
      this._delayedInputFocus($editCell, beforeFocusCallback, callBeforeFocusCallbackAlways);
    }
  }
  deleteRow(rowIndex) {
    this._checkAndDeleteRow(rowIndex);
  }
  _checkAndDeleteRow(rowIndex) {
    const editingOptions = this.option("editing");
    const editingTexts = null === editingOptions || void 0 === editingOptions ? void 0 : editingOptions.texts;
    const confirmDelete = null === editingOptions || void 0 === editingOptions ? void 0 : editingOptions.confirmDelete;
    const confirmDeleteMessage = null === editingTexts || void 0 === editingTexts ? void 0 : editingTexts.confirmDeleteMessage;
    const item = this._dataController.items()[rowIndex];
    const allowDeleting = !this.isEditing() || item.isNewRow;
    if (item && allowDeleting) {
      if (!confirmDelete || !confirmDeleteMessage) {
        this._deleteRowCore(rowIndex);
      } else {
        const confirmDeleteTitle = editingTexts && editingTexts.confirmDeleteTitle;
        const showDialogTitle = isDefined(confirmDeleteTitle) && confirmDeleteTitle.length > 0;
        confirm(confirmDeleteMessage, confirmDeleteTitle, showDialogTitle).done((confirmResult) => {
          if (confirmResult) {
            this._deleteRowCore(rowIndex);
          }
        });
      }
    }
  }
  _deleteRowCore(rowIndex) {
    const dataController2 = this._dataController;
    const item = dataController2.items()[rowIndex];
    const key = item && item.key;
    const oldEditRowIndex = this._getVisibleEditRowIndex();
    this.refresh();
    const changes = this.getChanges();
    const editIndex = m_utils_default.getIndexByKey(key, changes);
    if (editIndex >= 0) {
      if (changes[editIndex].type === DATA_EDIT_DATA_INSERT_TYPE) {
        this._removeChange(editIndex);
      } else {
        this._addChange({
          key,
          type: DATA_EDIT_DATA_REMOVE_TYPE
        });
      }
    } else {
      this._addChange({
        key,
        oldData: item.data,
        type: DATA_EDIT_DATA_REMOVE_TYPE
      });
    }
    return this._afterDeleteRow(rowIndex, oldEditRowIndex);
  }
  _afterDeleteRow(rowIndex, oldEditRowIndex) {
    return this.saveEditData();
  }
  undeleteRow(rowIndex) {
    const dataController2 = this._dataController;
    const item = dataController2.items()[rowIndex];
    const oldEditRowIndex = this._getVisibleEditRowIndex();
    const key = item && item.key;
    const changes = this.getChanges();
    if (item) {
      const editIndex = m_utils_default.getIndexByKey(key, changes);
      if (editIndex >= 0) {
        const {
          data: data17
        } = changes[editIndex];
        if (isEmptyObject(data17)) {
          this._removeChange(editIndex);
        } else {
          this._addChange({
            key,
            type: DATA_EDIT_DATA_UPDATE_TYPE
          });
        }
        dataController2.updateItems({
          changeType: "update",
          rowIndices: [oldEditRowIndex, rowIndex]
        });
      }
    }
  }
  _fireOnSaving() {
    const onSavingParams = {
      cancel: false,
      promise: null,
      changes: [...this.getChanges()]
    };
    this.executeAction("onSaving", onSavingParams);
    const d = new Deferred();
    when(fromPromise(onSavingParams.promise)).done(() => {
      d.resolve(onSavingParams);
    }).fail((arg) => {
      createFailureHandler(d);
      this._fireDataErrorOccurred(arg);
      d.resolve({
        cancel: true
      });
    });
    return d;
  }
  _executeEditingAction(actionName, params, func) {
    if (this.component._disposed) {
      return null;
    }
    const deferred = new Deferred();
    this.executeAction(actionName, params);
    when(fromPromise(params.cancel)).done((cancel2) => {
      if (cancel2) {
        setTimeout(() => {
          deferred.resolve("cancel");
        });
      } else {
        func(params).done(deferred.resolve).fail(createFailureHandler(deferred));
      }
    }).fail(createFailureHandler(deferred));
    return deferred;
  }
  _processChanges(deferreds, results, dataChanges, changes) {
    const store = this._dataController.store();
    each(changes, (index2, change) => {
      const oldData = this._getOldData(change.key);
      const {
        data: data17,
        type: type2
      } = change;
      const changeCopy = _extends({}, change);
      let deferred;
      let params;
      if (this._beforeSaveEditData(change, index2)) {
        return;
      }
      switch (type2) {
        case DATA_EDIT_DATA_REMOVE_TYPE:
          params = {
            data: oldData,
            key: change.key,
            cancel: false
          };
          deferred = this._executeEditingAction("onRowRemoving", params, () => store.remove(change.key).done((key) => {
            dataChanges.push({
              type: "remove",
              key
            });
          }));
          break;
        case DATA_EDIT_DATA_INSERT_TYPE:
          params = {
            data: data17,
            cancel: false
          };
          deferred = this._executeEditingAction("onRowInserting", params, () => store.insert(params.data).done((data18, key) => {
            if (isDefined(key)) {
              changeCopy.key = key;
            }
            if (data18 && isObject(data18) && data18 !== params.data) {
              changeCopy.data = data18;
            }
            dataChanges.push({
              type: "insert",
              data: data18,
              index: 0
            });
          }));
          break;
        case DATA_EDIT_DATA_UPDATE_TYPE:
          params = {
            newData: data17,
            oldData,
            key: change.key,
            cancel: false
          };
          deferred = this._executeEditingAction("onRowUpdating", params, () => store.update(change.key, params.newData).done((data18, key) => {
            if (data18 && isObject(data18) && data18 !== params.newData) {
              changeCopy.data = data18;
            }
            dataChanges.push({
              type: "update",
              key,
              data: data18
            });
          }));
      }
      changes[index2] = changeCopy;
      if (deferred) {
        const doneDeferred = new Deferred();
        deferred.always((data18) => {
          results.push({
            key: change.key,
            result: data18
          });
        }).always(doneDeferred.resolve);
        deferreds.push(doneDeferred.promise());
      }
    });
  }
  _processRemoveIfError(changes, editIndex) {
    const change = changes[editIndex];
    if ((null === change || void 0 === change ? void 0 : change.type) === DATA_EDIT_DATA_REMOVE_TYPE) {
      if (editIndex >= 0) {
        changes.splice(editIndex, 1);
      }
    }
    return true;
  }
  _processRemove(changes, editIndex, cancel2) {
    const change = changes[editIndex];
    if (!cancel2 || !change || change.type === DATA_EDIT_DATA_REMOVE_TYPE) {
      return this._processRemoveCore(changes, editIndex, !cancel2 || !change);
    }
  }
  _processRemoveCore(changes, editIndex, processIfBatch) {
    if (editIndex >= 0) {
      changes.splice(editIndex, 1);
    }
    return true;
  }
  _processSaveEditDataResult(results) {
    let hasSavedData = false;
    const originalChanges = this.getChanges();
    const changes = [...originalChanges];
    const changesLength = changes.length;
    for (let i = 0; i < results.length; i++) {
      const arg = results[i].result;
      const cancel2 = "cancel" === arg;
      const editIndex = m_utils_default.getIndexByKey(results[i].key, changes);
      const change = changes[editIndex];
      const isError = arg && arg instanceof Error;
      if (isError) {
        if (change) {
          this._addInternalData({
            key: change.key,
            error: arg
          });
        }
        this._fireDataErrorOccurred(arg);
        if (this._processRemoveIfError(changes, editIndex)) {
          break;
        }
      } else if (this._processRemove(changes, editIndex, cancel2)) {
        hasSavedData = !cancel2;
        const removedChangeIndex = m_utils_default.getIndexByKey(results[i].key, originalChanges);
        this._updateInsertAfterOrBeforeKeys(originalChanges, removedChangeIndex);
      }
    }
    if (changes.length < changesLength) {
      this._silentOption(EDITING_CHANGES_OPTION_NAME, changes);
    }
    return hasSavedData;
  }
  _fireSaveEditDataEvents(changes) {
    each(changes, (_, _ref) => {
      let {
        data: data17,
        key,
        type: type2
      } = _ref;
      const internalData = this._addInternalData({
        key
      });
      const params = {
        key,
        data: data17
      };
      if (internalData.error) {
        params.error = internalData.error;
      }
      switch (type2) {
        case DATA_EDIT_DATA_REMOVE_TYPE:
          this.executeAction("onRowRemoved", extend({}, params, {
            data: internalData.oldData
          }));
          break;
        case DATA_EDIT_DATA_INSERT_TYPE:
          this.executeAction("onRowInserted", params);
          break;
        case DATA_EDIT_DATA_UPDATE_TYPE:
          this.executeAction("onRowUpdated", params);
      }
    });
    this.executeAction("onSaved", {
      changes
    });
  }
  saveEditData() {
    const deferred = new Deferred();
    this.waitForDeferredOperations().done(() => {
      if (this.isSaving()) {
        this._resolveAfterSave(deferred);
        return;
      }
      when(this._beforeSaveEditData()).done((cancel2) => {
        if (cancel2) {
          this._resolveAfterSave(deferred, {
            cancel: cancel2
          });
          return;
        }
        this._saving = true;
        this._saveEditDataInner().always(() => {
          this._saving = false;
          if (this._refocusEditCell) {
            this._focusEditingCell();
          }
        }).done(deferred.resolve).fail(deferred.reject);
      }).fail(deferred.reject);
    }).fail(deferred.reject);
    return deferred.promise();
  }
  _resolveAfterSave(deferred) {
    let {
      cancel: cancel2,
      error: error2
    } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    when(this._afterSaveEditData(cancel2)).done(() => {
      deferred.resolve(error2);
    }).fail(deferred.reject);
  }
  _saveEditDataInner() {
    const result2 = new Deferred();
    const results = [];
    const deferreds = [];
    const dataChanges = [];
    const dataSource = this._dataController.dataSource();
    when(this._fireOnSaving()).done((_ref2) => {
      let {
        cancel: cancel2,
        changes
      } = _ref2;
      if (cancel2) {
        return result2.resolve().promise();
      }
      this._processChanges(deferreds, results, dataChanges, changes);
      if (deferreds.length) {
        this._refocusEditCell = true;
        null === dataSource || void 0 === dataSource || dataSource.beginLoading();
        when(...deferreds).done(() => {
          if (this._processSaveEditDataResult(results)) {
            this._endSaving(dataChanges, changes, result2);
          } else {
            null === dataSource || void 0 === dataSource || dataSource.endLoading();
            result2.resolve();
          }
        }).fail((error2) => {
          null === dataSource || void 0 === dataSource || dataSource.endLoading();
          result2.resolve(error2);
        });
        return result2.always(() => {
          this._refocusEditCell = true;
        }).promise();
      }
      this._cancelSaving(result2);
    }).fail(result2.reject);
    return result2.promise();
  }
  _beforeEndSaving(changes) {
    this._resetEditIndices();
  }
  _endSaving(dataChanges, changes, deferred) {
    const dataSource = this._dataController.dataSource();
    this._beforeEndSaving(changes);
    null === dataSource || void 0 === dataSource || dataSource.endLoading();
    this._refreshDataAfterSave(dataChanges, changes, deferred);
  }
  _cancelSaving(result2) {
    this.executeAction("onSaved", {
      changes: []
    });
    this._resolveAfterSave(result2);
  }
  _refreshDataAfterSave(dataChanges, changes, deferred) {
    const dataController2 = this._dataController;
    const refreshMode = this.option("editing.refreshMode");
    const isFullRefresh = "reshape" !== refreshMode && "repaint" !== refreshMode;
    if (!isFullRefresh) {
      dataController2.push(dataChanges);
    }
    when(dataController2.refresh({
      selection: isFullRefresh,
      reload: isFullRefresh,
      load: "reshape" === refreshMode,
      changesOnly: this.option("repaintChangesOnly")
    })).always(() => {
      this._fireSaveEditDataEvents(changes);
    }).done(() => {
      this._resolveAfterSave(deferred);
    }).fail((error2) => {
      this._resolveAfterSave(deferred, {
        error: error2
      });
    });
  }
  isSaving() {
    return this._saving;
  }
  _updateEditColumn() {
    const isEditColumnVisible = this._isEditColumnVisible();
    const useIcons = this.option("editing.useIcons");
    const cssClass = COMMAND_EDIT_CLASS2 + (useIcons ? ` ${COMMAND_EDIT_WITH_ICONS_CLASS}` : "");
    this._columnsController.addCommandColumn({
      type: "buttons",
      command: "edit",
      visible: isEditColumnVisible,
      cssClass,
      width: "auto",
      alignment: "center",
      cellTemplate: this._getEditCommandCellTemplate(),
      fixedPosition: "right"
    });
    this._columnsController.columnOption("command:edit", {
      visible: isEditColumnVisible,
      cssClass
    });
  }
  _isEditColumnVisible() {
    const editingOptions = this.option("editing");
    return editingOptions.allowDeleting;
  }
  _isEditButtonDisabled() {
    const hasChanges = this.hasChanges();
    const isEditRowDefined = isDefined(this.option("editing.editRowKey"));
    return !(isEditRowDefined || hasChanges);
  }
  _updateEditButtons() {
    const isButtonDisabled = this._isEditButtonDisabled();
    if (this._headerPanelView) {
      this._headerPanelView.setToolbarItemDisabled("saveButton", isButtonDisabled);
      this._headerPanelView.setToolbarItemDisabled("revertButton", isButtonDisabled);
    }
  }
  _applyModified($element, options2) {
    $element && $element.addClass(CELL_MODIFIED);
  }
  _beforeCloseEditCellInBatchMode(rowIndices) {
  }
  cancelEditData() {
    const changes = this.getChanges();
    const params = {
      cancel: false,
      changes
    };
    this.executeAction("onEditCanceling", params);
    if (!params.cancel) {
      this._cancelEditDataCore();
      this.executeAction("onEditCanceled", {
        changes
      });
    }
  }
  _cancelEditDataCore() {
    const rowIndex = this._getVisibleEditRowIndex();
    this._beforeCancelEditData();
    this.init();
    this.resetChanges();
    this._resetEditColumnName();
    this._resetEditRowKey();
    this._afterCancelEditData(rowIndex);
  }
  _afterCancelEditData(rowIndex) {
    const dataController2 = this._dataController;
    dataController2.updateItems({
      repaintChangesOnly: this.option("repaintChangesOnly")
    });
  }
  _hideEditPopup() {
  }
  hasEditData() {
    return this.hasChanges();
  }
  update(changeType) {
    const dataController2 = this._dataController;
    if (dataController2 && this._pageIndex !== dataController2.pageIndex()) {
      if ("refresh" === changeType) {
        this.refresh({
          isPageChanged: true
        });
      }
      this._pageIndex = dataController2.pageIndex();
    }
    this._updateEditButtons();
  }
  _getRowIndicesForCascadeUpdating(row, skipCurrentRow) {
    return skipCurrentRow ? [] : [row.rowIndex];
  }
  addDeferred(deferred) {
    if (!this._deferreds.includes(deferred)) {
      this._deferreds.push(deferred);
      deferred.always(() => {
        const index2 = this._deferreds.indexOf(deferred);
        if (index2 >= 0) {
          this._deferreds.splice(index2, 1);
        }
      });
    }
  }
  _prepareChange(options2, value2, text) {
    var _options$row;
    const newData = {};
    const oldData = null === (_options$row = options2.row) || void 0 === _options$row ? void 0 : _options$row.data;
    const rowKey = options2.key;
    const deferred = new Deferred();
    if (void 0 !== rowKey) {
      options2.value = value2;
      const setCellValueResult = fromPromise(options2.column.setCellValue(newData, value2, extend(true, {}, oldData), text));
      setCellValueResult.done(() => {
        deferred.resolve({
          data: newData,
          key: rowKey,
          oldData,
          type: DATA_EDIT_DATA_UPDATE_TYPE
        });
      }).fail(createFailureHandler(deferred)).fail((arg) => this._fireDataErrorOccurred(arg));
      if (isDefined(text) && options2.column.displayValueMap) {
        options2.column.displayValueMap[value2] = text;
      }
      this._updateRowValues(options2);
      this.addDeferred(deferred);
    }
    return deferred;
  }
  _updateRowValues(options2) {
    if (options2.values) {
      const dataController2 = this._dataController;
      const rowIndex = dataController2.getRowIndexByKey(options2.key);
      const row = dataController2.getVisibleRows()[rowIndex];
      if (row) {
        options2.row.values = row.values;
        options2.values = row.values;
      }
      options2.values[options2.columnIndex] = options2.value;
    }
  }
  updateFieldValue(options2, value2, text, forceUpdateRow) {
    const rowKey = options2.key;
    const deferred = new Deferred();
    if (void 0 === rowKey) {
      this._dataController.fireError("E1043");
    }
    if (options2.column.setCellValue) {
      this._prepareChange(options2, value2, text).done((params) => {
        when(this._applyChange(options2, params, forceUpdateRow)).always(() => {
          deferred.resolve();
        });
      });
    } else {
      deferred.resolve();
    }
    return deferred.promise();
  }
  _focusPreviousEditingCellIfNeed(options2) {
    if (this.hasEditData() && !this.isEditCell(options2.rowIndex, options2.columnIndex)) {
      this._focusEditingCell();
      this._updateEditRow(options2.row, true);
      return true;
    }
  }
  _needUpdateRow(column) {
    const visibleColumns = this._columnsController.getVisibleColumns();
    if (!column) {
      column = this._getEditColumn();
    }
    const isCustomSetCellValue = column && column.setCellValue !== column.defaultSetCellValue;
    const isCustomCalculateCellValue = visibleColumns.some((visibleColumn) => visibleColumn.calculateCellValue !== visibleColumn.defaultCalculateCellValue);
    return isCustomSetCellValue || isCustomCalculateCellValue;
  }
  _applyChange(options2, params, forceUpdateRow) {
    const changeOptions = _extends({}, options2, {
      forceUpdateRow
    });
    this._addChange(params, changeOptions);
    this._updateEditButtons();
    return this._applyChangeCore(options2, changeOptions.forceUpdateRow);
  }
  _applyChangeCore(options2, forceUpdateRow) {
    const isCustomSetCellValue = options2.column.setCellValue !== options2.column.defaultSetCellValue;
    const {
      row
    } = options2;
    if (row) {
      if (forceUpdateRow || isCustomSetCellValue) {
        this._updateEditRow(row, forceUpdateRow, isCustomSetCellValue);
      } else if (row.update) {
        row.update();
      }
    }
  }
  _updateEditRowCore(row, skipCurrentRow, isCustomSetCellValue) {
    this._dataController.updateItems({
      changeType: "update",
      rowIndices: this._getRowIndicesForCascadeUpdating(row, skipCurrentRow)
    });
  }
  _updateEditRow(row, forceUpdateRow, isCustomSetCellValue) {
    if (forceUpdateRow) {
      this._updateRowImmediately(row, forceUpdateRow, isCustomSetCellValue);
    } else {
      this._updateRowWithDelay(row, isCustomSetCellValue);
    }
  }
  _updateRowImmediately(row, forceUpdateRow, isCustomSetCellValue) {
    this._updateEditRowCore(row, !forceUpdateRow, isCustomSetCellValue);
    this._validateEditFormAfterUpdate(row, isCustomSetCellValue);
    if (!forceUpdateRow) {
      this._focusEditingCell();
    }
  }
  _updateRowWithDelay(row, isCustomSetCellValue) {
    const deferred = new Deferred();
    this.addDeferred(deferred);
    setTimeout(() => {
      var _this$_editForm;
      const elementContainer = (null === (_this$_editForm = this._editForm) || void 0 === _this$_editForm ? void 0 : _this$_editForm.element()) || this.component.$element().get(0);
      const $focusedElement = renderer_default(dom_adapter_default.getActiveElement(elementContainer));
      const columnIndex = this._rowsView.getCellIndex($focusedElement, row.rowIndex);
      let focusedElement = $focusedElement.get(0);
      const selectionRange = m_utils_default.getSelectionRange(focusedElement);
      this._updateEditRowCore(row, false, isCustomSetCellValue);
      this._validateEditFormAfterUpdate(row, isCustomSetCellValue);
      if (columnIndex >= 0) {
        const $focusedItem = this._rowsView._getCellElement(row.rowIndex, columnIndex);
        this._delayedInputFocus($focusedItem, () => {
          setTimeout(() => {
            var _this$component$$elem;
            focusedElement = dom_adapter_default.getActiveElement(null === (_this$component$$elem = this.component.$element()) || void 0 === _this$component$$elem ? void 0 : _this$component$$elem.get(0));
            if (selectionRange.selectionStart >= 0) {
              m_utils_default.setSelectionRange(focusedElement, selectionRange);
            }
          });
        });
      }
      deferred.resolve();
    });
  }
  _validateEditFormAfterUpdate() {
  }
  _addChange(changeParams, options2) {
    var _this$getChanges;
    const row = null === options2 || void 0 === options2 ? void 0 : options2.row;
    const changes = [...this.getChanges()];
    let index2 = m_utils_default.getIndexByKey(changeParams.key, changes);
    if (index2 < 0) {
      index2 = changes.length;
      this._addInternalData({
        key: changeParams.key,
        oldData: changeParams.oldData
      });
      delete changeParams.oldData;
      changes.push(changeParams);
    }
    const change = _extends({}, changes[index2]);
    if (change) {
      if (changeParams.data) {
        change.data = createObjectWithChanges(change.data, changeParams.data);
      }
      if ((!change.type || !changeParams.data) && changeParams.type) {
        change.type = changeParams.type;
      }
      if (row) {
        row.oldData = this._getOldData(row.key);
        row.data = createObjectWithChanges(row.data, changeParams.data);
      }
    }
    changes[index2] = change;
    this._silentOption(EDITING_CHANGES_OPTION_NAME, changes);
    if (options2 && change !== (null === (_this$getChanges = this.getChanges()) || void 0 === _this$getChanges ? void 0 : _this$getChanges[index2])) {
      options2.forceUpdateRow = true;
    }
    return change;
  }
  _getFormEditItemTemplate(cellOptions, column) {
    return column.editCellTemplate || this._getDefaultEditorTemplate();
  }
  getColumnTemplate(options2) {
    const {
      column
    } = options2;
    const rowIndex = options2.row && options2.row.rowIndex;
    let template;
    const isRowMode = this.isRowBasedEditMode();
    const isRowEditing = this.isEditRow(rowIndex);
    const isCellEditing = this.isEditCell(rowIndex, options2.columnIndex);
    let editingStartOptions;
    if ((column.showEditorAlways || column.setCellValue && (isRowEditing && column.allowEditing || isCellEditing)) && ("data" === options2.rowType || "detailAdaptive" === options2.rowType) && !column.command) {
      const allowUpdating = this.allowUpdating(options2);
      if (((allowUpdating || isRowEditing) && column.allowEditing || isCellEditing) && (isRowEditing || !isRowMode)) {
        if (column.showEditorAlways && !isRowMode) {
          editingStartOptions = {
            cancel: false,
            key: options2.row.isNewRow ? void 0 : options2.row.key,
            data: options2.row.data,
            column
          };
          this._isEditingStart(editingStartOptions);
        }
        if (!editingStartOptions || !editingStartOptions.cancel) {
          options2.setValue = (value2, text) => {
            this.updateFieldValue(options2, value2, text);
          };
        }
      }
      template = column.editCellTemplate || this._getDefaultEditorTemplate();
    } else if ("detail" === column.command && "detail" === options2.rowType && isRowEditing) {
      template = null === this || void 0 === this ? void 0 : this.getEditFormTemplate(options2);
    }
    return template;
  }
  _createButton($container, button, options2, change) {
    let icon = EDIT_ICON_CLASS[button.name];
    const useIcons = this.option("editing.useIcons");
    const useLegacyColumnButtonTemplate = this.option("useLegacyColumnButtonTemplate");
    let $button = renderer_default("<a>").attr("href", "#").addClass(LINK_CLASS).addClass(button.cssClass);
    if (button.template && useLegacyColumnButtonTemplate) {
      this._rowsView.renderTemplate($container, button.template, options2, true);
    } else {
      if (button.template) {
        $button = renderer_default("<span>").addClass(button.cssClass);
      } else if (useIcons && icon || button.icon) {
        icon = button.icon || icon;
        const iconType = getImageSourceType(icon);
        if ("image" === iconType || "svg" === iconType) {
          $button = getImageContainer(icon).addClass(button.cssClass);
        } else {
          $button.addClass(`dx-icon${"dxIcon" === iconType ? "-" : " "}${icon}`).attr("title", button.text);
        }
        $button.addClass(LINK_ICON_CLASS);
        $container.addClass(COMMAND_EDIT_WITH_ICONS_CLASS);
        const localizationName = this.getButtonLocalizationNames()[button.name];
        localizationName && $button.attr("aria-label", message_default.format(localizationName));
      } else {
        $button.text(button.text);
      }
      if (isDefined(button.hint)) {
        $button.attr("title", button.hint);
      }
      if (this._isButtonDisabled(button, options2)) {
        $button.addClass("dx-state-disabled");
      } else if (!button.template || button.onClick) {
        m_events_engine_default.on($button, addNamespace2("click", EDITING_NAMESPACE), this.createAction((e) => {
          var _button$onClick;
          null === (_button$onClick = button.onClick) || void 0 === _button$onClick || _button$onClick.call(button, extend({}, e, {
            row: options2.row,
            column: options2.column
          }));
          e.event.preventDefault();
          e.event.stopPropagation();
        }));
      }
      $container.append($button);
      if (button.template) {
        options2.renderAsync = false;
        this._rowsView.renderTemplate($button, button.template, options2, true, change);
      }
    }
  }
  getButtonLocalizationNames() {
    return {
      edit: "dxDataGrid-editingEditRow",
      save: "dxDataGrid-editingSaveRowChanges",
      delete: "dxDataGrid-editingDeleteRow",
      undelete: "dxDataGrid-editingUndeleteRow",
      cancel: "dxDataGrid-editingCancelRowChanges"
    };
  }
  prepareButtonItem(headerPanel8, name2, methodName, sortIndex) {
    const editingTexts = this.option("editing.texts") ?? {};
    const titleButtonTextByClassNames = {
      revert: editingTexts.cancelAllChanges,
      save: editingTexts.saveAllChanges,
      addRow: editingTexts.addRow
    };
    const className = {
      revert: "cancel",
      save: "save",
      addRow: "addrow"
    }[name2];
    const hintText = titleButtonTextByClassNames[name2];
    const isButtonDisabled = ("save" === className || "cancel" === className) && this._isEditButtonDisabled();
    return {
      widget: "dxButton",
      options: {
        onInitialized: (e) => {
          renderer_default(e.element).addClass(headerPanel8._getToolbarButtonClass(`${EDIT_BUTTON_CLASS} ${this.addWidgetPrefix(className)}-button`));
        },
        icon: `edit-button-${className}`,
        disabled: isButtonDisabled,
        onClick: () => {
          setTimeout(() => {
            this[methodName]();
          });
        },
        text: hintText,
        hint: hintText
      },
      showText: "inMenu",
      name: `${name2}Button`,
      location: "after",
      locateInMenu: "auto",
      sortIndex
    };
  }
  prepareEditButtons(headerPanel8) {
    const editingOptions = this.option("editing") ?? {};
    const buttonItems = [];
    if (editingOptions.allowAdding) {
      buttonItems.push(this.prepareButtonItem(headerPanel8, "addRow", "addRow", 20));
    }
    return buttonItems;
  }
  highlightDataCell($cell, params) {
    this.shouldHighlightCell(params) && $cell.addClass(CELL_MODIFIED);
  }
  _afterInsertRow(key) {
  }
  _beforeSaveEditData(change) {
    if (change && !isDefined(change.key) && isDefined(change.type)) {
      return true;
    }
  }
  _afterSaveEditData() {
  }
  _beforeCancelEditData() {
  }
  _allowEditAction(actionName, options2) {
    let allowEditAction = this.option(`editing.${actionName}`);
    if (isFunction(allowEditAction)) {
      allowEditAction = allowEditAction({
        component: this.component,
        row: options2.row
      });
    }
    return allowEditAction;
  }
  allowUpdating(options2, eventName) {
    const startEditAction = this.option("editing.startEditAction") ?? DEFAULT_START_EDIT_ACTION;
    const needCallback = arguments.length > 1 ? startEditAction === eventName || "down" === eventName : true;
    return needCallback && this._allowEditAction("allowUpdating", options2);
  }
  allowDeleting(options2) {
    return this._allowEditAction("allowDeleting", options2);
  }
  isCellModified(parameters) {
    var _parameters$row, _parameters$row2;
    const {
      columnIndex
    } = parameters;
    let modifiedValue = null === parameters || void 0 === parameters || null === (_parameters$row = parameters.row) || void 0 === _parameters$row || null === (_parameters$row = _parameters$row.modifiedValues) || void 0 === _parameters$row ? void 0 : _parameters$row[columnIndex];
    if (null !== parameters && void 0 !== parameters && null !== (_parameters$row2 = parameters.row) && void 0 !== _parameters$row2 && _parameters$row2.isNewRow) {
      modifiedValue = parameters.value;
    }
    return void 0 !== modifiedValue;
  }
  isNewRowInEditMode() {
    const visibleEditRowIndex = this._getVisibleEditRowIndex();
    const rows = this._dataController.items();
    return visibleEditRowIndex >= 0 ? rows[visibleEditRowIndex].isNewRow : false;
  }
  _isRowDeleteAllowed() {
  }
  shouldHighlightCell(parameters) {
    const cellModified = this.isCellModified(parameters);
    return cellModified && parameters.column.setCellValue && (this.getEditMode() !== EDIT_MODE_ROW || !parameters.row.isEditing);
  }
};
var dataControllerEditingExtenderMixin = (Base) => class extends Base {
  reload(full, repaintChangesOnly) {
    !repaintChangesOnly && this._editingController.refresh();
    return super.reload.apply(this, arguments);
  }
  repaintRows() {
    if (this._editingController.isSaving()) {
      return;
    }
    return super.repaintRows.apply(this, arguments);
  }
  _updateEditRow(items) {
    const editRowKey = this.option(EDITING_EDITROWKEY_OPTION_NAME);
    const editRowIndex = m_utils_default.getIndexByKey(editRowKey, items);
    const editItem = items[editRowIndex];
    if (editItem) {
      var _this$_updateEditItem;
      editItem.isEditing = true;
      null === (_this$_updateEditItem = this._updateEditItem) || void 0 === _this$_updateEditItem || _this$_updateEditItem.call(this, editItem);
    }
  }
  _updateItemsCore(change) {
    super._updateItemsCore(change);
    this._updateEditRow(this.items(true));
  }
  _applyChangeUpdate(change) {
    this._updateEditRow(change.items);
    super._applyChangeUpdate(change);
  }
  _applyChangesOnly(change) {
    this._updateEditRow(change.items);
    super._applyChangesOnly(change);
  }
  _processItems(items, change) {
    items = this._editingController.processItems(items, change);
    return super._processItems(items, change);
  }
  _processDataItem(dataItem, options2) {
    this._editingController.processDataItem(dataItem, options2, this.generateDataValues);
    return super._processDataItem(dataItem, options2);
  }
  _processItem(item, options2) {
    item = super._processItem(item, options2);
    if (item.isNewRow) {
      options2.dataIndex--;
      delete item.dataIndex;
    }
    return item;
  }
  _getChangedColumnIndices(oldItem, newItem, rowIndex, isLiveUpdate) {
    if (oldItem.isNewRow !== newItem.isNewRow || oldItem.removed !== newItem.removed) {
      return;
    }
    return super._getChangedColumnIndices.apply(this, arguments);
  }
  _isCellChanged(oldRow, newRow, visibleRowIndex, columnIndex, isLiveUpdate) {
    const cell = oldRow.cells && oldRow.cells[columnIndex];
    const isEditing = this._editingController && this._editingController.isEditCell(visibleRowIndex, columnIndex);
    if (isLiveUpdate && isEditing) {
      return false;
    }
    if (cell && cell.column && !cell.column.showEditorAlways && cell.isEditing !== isEditing) {
      return true;
    }
    return super._isCellChanged.apply(this, arguments);
  }
  needToRefreshOnDataSourceChange(args) {
    const isParasiteChange = Array.isArray(args.value) && args.value === args.previousValue && this._editingController.isSaving();
    return !isParasiteChange;
  }
  _handleDataSourceChange(args) {
    const result2 = super._handleDataSourceChange(args);
    const changes = this.option("editing.changes");
    const dataSource = args.value;
    if (Array.isArray(dataSource) && changes.length) {
      const dataSourceKeys = dataSource.map((item) => this.keyOf(item));
      const newChanges = changes.filter((change) => "insert" === change.type || dataSourceKeys.some((key) => equalByValue(change.key, key)));
      if (newChanges.length !== changes.length) {
        this.option("editing.changes", newChanges);
      }
      const editRowKey = this.option("editing.editRowKey");
      const isEditNewItem = newChanges.some((change) => "insert" === change.type && equalByValue(editRowKey, change.key));
      if (!isEditNewItem && dataSourceKeys.every((key) => !equalByValue(editRowKey, key))) {
        this.option("editing.editRowKey", null);
      }
    }
    return result2;
  }
};
var rowsView3 = (Base) => class extends Base {
  getCellIndex($cell, rowIndex) {
    if (!$cell.is("td") && rowIndex >= 0) {
      const $cellElements = this.getCellElements(rowIndex);
      let cellIndex = -1;
      each($cellElements, (index2, cellElement) => {
        if (renderer_default(cellElement).find($cell).length) {
          cellIndex = index2;
        }
      });
      return cellIndex;
    }
    return super.getCellIndex.apply(this, arguments);
  }
  publicMethods() {
    return super.publicMethods().concat(["cellValue"]);
  }
  _getCellTemplate(options2) {
    const template = this._editingController.getColumnTemplate(options2);
    return template || super._getCellTemplate(options2);
  }
  _createRow(row) {
    const $row = super._createRow.apply(this, arguments);
    if (row) {
      const isRowRemoved = !!row.removed;
      const isRowInserted = !!row.isNewRow;
      const isRowModified = !!row.modified;
      isRowInserted && $row.addClass(ROW_INSERTED);
      isRowModified && $row.addClass(ROW_MODIFIED);
      if (isRowInserted || isRowRemoved) {
        $row.removeClass(ROW_SELECTED);
      }
    }
    return $row;
  }
  _getColumnIndexByElement($element) {
    let $tableElement = $element.closest("table");
    const $tableElements = this.getTableElements();
    while ($tableElement.length && !$tableElements.filter($tableElement).length) {
      $element = $tableElement.closest("td");
      $tableElement = $element.closest("table");
    }
    return this._getColumnIndexByElementCore($element);
  }
  _getColumnIndexByElementCore($element) {
    const $targetElement = $element.closest(`.${ROW_CLASS}> td:not(.dx-master-detail-cell)`);
    return this.getCellIndex($targetElement);
  }
  _editCellByClick(e, eventName) {
    const editingController = this._editingController;
    const $targetElement = renderer_default(e.event.target);
    const columnIndex = this._getColumnIndexByElement($targetElement);
    const row = this._dataController.items()[e.rowIndex];
    const allowUpdating = editingController.allowUpdating({
      row
    }, eventName) || row && row.isNewRow;
    const column = this._columnsController.getVisibleColumns()[columnIndex];
    const isEditedCell = editingController.isEditCell(e.rowIndex, columnIndex);
    const allowEditing = allowUpdating && column && (column.allowEditing || isEditedCell);
    const startEditAction = this.option("editing.startEditAction") || "click";
    const isShowEditorAlways = column && column.showEditorAlways;
    if (isEditedCell) {
      return true;
    }
    if ("down" === eventName) {
      if (devices_default.real().ios || devices_default.real().android) {
        m_dom_default.resetActiveElement();
      }
      return isShowEditorAlways && allowEditing && editingController.editCell(e.rowIndex, columnIndex);
    }
    if ("click" === eventName && "dblClick" === startEditAction && this._pointerDownTarget === $targetElement.get(0)) {
      const isError = false;
      const withoutSaveEditData = null === row || void 0 === row ? void 0 : row.isNewRow;
      editingController.closeEditCell(isError, withoutSaveEditData);
    }
    if (allowEditing && eventName === startEditAction) {
      return editingController.editCell(e.rowIndex, columnIndex) || editingController.isEditRow(e.rowIndex);
    }
  }
  _rowPointerDown(e) {
    this._pointerDownTarget = e.event.target;
    this._pointerDownTimeout = setTimeout(() => {
      this._editCellByClick(e, "down");
    });
  }
  _rowClickTreeListHack(e) {
    super._rowClick.apply(this, arguments);
  }
  _rowClick(e) {
    const isEditForm2 = renderer_default(e.rowElement).hasClass(this.addWidgetPrefix(EDIT_FORM_CLASS2));
    e.event[TARGET_COMPONENT_NAME] = this.component;
    if (!this._editCellByClick(e, "click") && !isEditForm2) {
      super._rowClick.apply(this, arguments);
    }
  }
  _rowDblClickTreeListHack(e) {
    super._rowDblClick.apply(this, arguments);
  }
  _rowDblClick(e) {
    if (!this._editCellByClick(e, "dblClick")) {
      super._rowDblClick.apply(this, arguments);
    }
  }
  _cellPrepared($cell, parameters) {
    var _parameters$column;
    const editingController = this._editingController;
    const isCommandCell = !!parameters.column.command;
    const isEditableCell = parameters.setValue;
    const isEditRow = editingController.isEditRow(parameters.rowIndex);
    const isEditing = isEditingCell(isEditRow, parameters);
    if (isEditingOrShowEditorAlwaysDataCell(isEditRow, parameters)) {
      const {
        alignment
      } = parameters.column;
      $cell.toggleClass(this.addWidgetPrefix(READONLY_CLASS), !isEditableCell).toggleClass(CELL_FOCUS_DISABLED_CLASS2, !isEditableCell);
      if (alignment) {
        $cell.find(EDITORS_INPUT_SELECTOR).first().css("textAlign", alignment);
      }
    }
    if (isEditing) {
      this._editCellPrepared($cell);
    }
    const hasTemplate3 = !!(null !== (_parameters$column = parameters.column) && void 0 !== _parameters$column && _parameters$column.cellTemplate);
    if (parameters.column && !isCommandCell && (!hasTemplate3 || editingController.shouldHighlightCell(parameters))) {
      editingController.highlightDataCell($cell, parameters);
    }
    super._cellPrepared.apply(this, arguments);
  }
  _getCellOptions(options2) {
    const cellOptions = super._getCellOptions(options2);
    const {
      columnIndex,
      row
    } = options2;
    cellOptions.isEditing = this._editingController.isEditCell(cellOptions.rowIndex, cellOptions.columnIndex);
    cellOptions.removed = row.removed;
    if (row.modified) {
      cellOptions.modified = void 0 !== row.modifiedValues[columnIndex];
    }
    return cellOptions;
  }
  _setCellAriaAttributes($cell, cellOptions, options2) {
    super._setCellAriaAttributes($cell, cellOptions, options2);
    if (cellOptions.removed) {
      this.setAria("roledescription", message_default.format("dxDataGrid-ariaDeletedCell"), $cell);
    }
    if (cellOptions.modified) {
      this.setAria("roledescription", message_default.format("dxDataGrid-ariaModifiedCell"), $cell);
    }
    const isEditableCell = cellOptions.column.allowEditing && !cellOptions.removed && !cellOptions.modified && "data" === cellOptions.rowType && cellOptions.column.calculateCellValue === cellOptions.column.defaultCalculateCellValue && this._editingController.isCellBasedEditMode();
    if (isEditableCell) {
      this.setAria("roledescription", message_default.format("dxDataGrid-ariaEditableCell"), $cell);
    }
  }
  _createCell(options2) {
    const $cell = super._createCell(options2);
    const isEditRow = this._editingController.isEditRow(options2.rowIndex);
    isEditingOrShowEditorAlwaysDataCell(isEditRow, options2) && $cell.addClass(EDITOR_CELL_CLASS);
    return $cell;
  }
  cellValue(rowIndex, columnIdentifier, value2, text) {
    const cellOptions = this.getCellOptions(rowIndex, columnIdentifier);
    if (cellOptions) {
      if (void 0 === value2) {
        return cellOptions.value;
      }
      this._editingController.updateFieldValue(cellOptions, value2, text, true);
    }
  }
  dispose() {
    super.dispose.apply(this, arguments);
    clearTimeout(this._pointerDownTimeout);
  }
  _renderCore() {
    super._renderCore.apply(this, arguments);
    return this.waitAsyncTemplates(true).done(() => {
      this._editingController._focusEditorIfNeed();
    });
  }
  _editCellPrepared() {
  }
  _formItemPrepared() {
  }
};
var headerPanel3 = (Base) => class extends Base {
  optionChanged(args) {
    const {
      fullName
    } = args;
    switch (args.name) {
      case "editing": {
        const excludedOptions = [EDITING_POPUP_OPTION_NAME, EDITING_CHANGES_OPTION_NAME, EDITING_EDITCOLUMNNAME_OPTION_NAME, EDITING_EDITROWKEY_OPTION_NAME];
        const shouldInvalidate = fullName && !excludedOptions.some((optionName) => optionName === fullName);
        shouldInvalidate && this._invalidate();
        super.optionChanged(args);
        break;
      }
      case "useLegacyColumnButtonTemplate":
        args.handled = true;
        break;
      default:
        super.optionChanged(args);
    }
  }
  _getToolbarItems() {
    const items = super._getToolbarItems();
    const editButtonItems = this._editingController.prepareEditButtons(this);
    return editButtonItems.concat(items);
  }
};
var editingModule = {
  defaultOptions: () => ({
    editing: {
      mode: "row",
      refreshMode: "full",
      newRowPosition: VIEWPORT_TOP_NEW_ROW_POSITION,
      allowAdding: false,
      allowUpdating: false,
      allowDeleting: false,
      useIcons: false,
      selectTextOnEditStart: false,
      confirmDelete: true,
      texts: {
        editRow: message_default.format("dxDataGrid-editingEditRow"),
        saveAllChanges: message_default.format("dxDataGrid-editingSaveAllChanges"),
        saveRowChanges: message_default.format("dxDataGrid-editingSaveRowChanges"),
        cancelAllChanges: message_default.format("dxDataGrid-editingCancelAllChanges"),
        cancelRowChanges: message_default.format("dxDataGrid-editingCancelRowChanges"),
        addRow: message_default.format("dxDataGrid-editingAddRow"),
        deleteRow: message_default.format("dxDataGrid-editingDeleteRow"),
        undeleteRow: message_default.format("dxDataGrid-editingUndeleteRow"),
        confirmDeleteMessage: message_default.format("dxDataGrid-editingConfirmDeleteMessage"),
        confirmDeleteTitle: ""
      },
      form: {
        colCount: 2
      },
      popup: {},
      startEditAction: "click",
      editRowKey: null,
      editColumnName: null,
      changes: []
    },
    useLegacyColumnButtonTemplate: false
  }),
  controllers: {
    editing: EditingControllerImpl
  },
  extenders: {
    controllers: {
      data: dataControllerEditingExtenderMixin
    },
    views: {
      rowsView: rowsView3,
      headerPanel: headerPanel3
    }
  }
};

// node_modules/devextreme/esm/__internal/grids/data_grid/m_editing.js
var data4 = (Base) => class extends dataControllerEditingExtenderMixin(Base) {
  _changeRowExpandCore(key) {
    const editingController = this._editingController;
    if (Array.isArray(key)) {
      editingController && editingController.refresh();
    }
    return super._changeRowExpandCore.apply(this, arguments);
  }
};
m_core_default.registerModule("editing", _extends({}, editingModule, {
  extenders: _extends({}, editingModule.extenders, {
    controllers: _extends({}, editingModule.extenders.controllers, {
      data: data4
    })
  })
}));

// node_modules/devextreme/esm/__internal/grids/grid_core/editing/m_editing_row_based.js
var editingControllerExtender = (Base) => class extends Base {
  isRowEditMode() {
    return this.getEditMode() === EDIT_MODE_ROW;
  }
  _afterCancelEditData(rowIndex) {
    const dataController2 = this._dataController;
    if (this.isRowBasedEditMode() && rowIndex >= 0) {
      dataController2.updateItems({
        changeType: "update",
        rowIndices: [rowIndex, rowIndex + 1]
      });
    } else {
      super._afterCancelEditData(rowIndex);
    }
  }
  _isDefaultButtonVisible(button, options2) {
    const isRowMode = this.isRowBasedEditMode();
    const isPopupEditMode = this.isPopupEditMode();
    const isEditRow = !isPopupEditMode && options2.row && equalByValue(options2.row.key, this.option(EDITING_EDITROWKEY_OPTION_NAME));
    if (isRowMode) {
      switch (button.name) {
        case "edit":
          return !isEditRow && this.allowUpdating(options2);
        case "delete":
          return super._isDefaultButtonVisible(button, options2) && !isEditRow;
        case "save":
        case "cancel":
          return isEditRow;
        default:
          return super._isDefaultButtonVisible(button, options2);
      }
    }
    return super._isDefaultButtonVisible(button, options2);
  }
  isEditRow(rowIndex) {
    return this.isRowBasedEditMode() && this.isEditRowByIndex(rowIndex);
  }
  _cancelSaving(result2) {
    if (this.isRowBasedEditMode()) {
      if (!this.hasChanges()) {
        this._cancelEditDataCore();
      }
    }
    super._cancelSaving(result2);
  }
  _refreshCore(params) {
    const {
      allowCancelEditing
    } = params ?? {};
    if (this.isRowBasedEditMode()) {
      const hasUpdateChanges = this.getChanges().filter((it) => "update" === it.type).length > 0;
      this.init();
      allowCancelEditing && hasUpdateChanges && this._cancelEditDataCore();
    }
    super._refreshCore(params);
  }
  _isEditColumnVisible() {
    const result2 = super._isEditColumnVisible();
    const editingOptions = this.option("editing");
    const isRowEditMode = this.isRowEditMode();
    const isVisibleInRowEditMode = editingOptions.allowUpdating || editingOptions.allowAdding;
    return result2 || isRowEditMode && isVisibleInRowEditMode;
  }
  _focusEditorIfNeed() {
    const editMode = this.getEditMode();
    if (this._needFocusEditor) {
      if (MODES_WITH_DELAYED_FOCUS.includes(editMode)) {
        const $editingCell = this.getFocusedCellInRow(this._getVisibleEditRowIndex());
        this._delayedInputFocus($editingCell, () => {
          $editingCell && this.component.focus($editingCell);
        });
      }
      this._needFocusEditor = false;
    }
  }
};
var data5 = (Base) => class extends Base {
  _getChangedColumnIndices(oldItem, newItem, rowIndex, isLiveUpdate) {
    if (this._editingController.isRowBasedEditMode() && oldItem.isEditing !== newItem.isEditing) {
      return;
    }
    return super._getChangedColumnIndices.apply(this, arguments);
  }
};
var rowsView4 = (Base) => class extends Base {
  _createRow(row) {
    const $row = super._createRow.apply(this, arguments);
    if (row) {
      const editingController = this._editingController;
      const isEditRow = editingController.isEditRow(row.rowIndex);
      if (isEditRow) {
        $row.addClass(EDIT_ROW);
        $row.removeClass(ROW_SELECTED_CLASS);
        if ("detail" === row.rowType) {
          $row.addClass(this.addWidgetPrefix(EDIT_FORM_CLASS2));
        }
      }
    }
    return $row;
  }
  _update(change) {
    super._update(change);
    if ("updateSelection" === change.changeType) {
      this.getTableElements().children("tbody").children(`.${EDIT_ROW}`).removeClass(ROW_SELECTED_CLASS);
    }
  }
};
var editingRowBasedModule = {
  extenders: {
    controllers: {
      editing: editingControllerExtender,
      data: data5
    },
    views: {
      rowsView: rowsView4
    }
  }
};

// node_modules/devextreme/esm/__internal/grids/data_grid/module_not_extended/editing_row_based.js
m_core_default.registerModule("editingRowBased", editingRowBasedModule);

// node_modules/devextreme/esm/__internal/ui/m_validation_summary.js
var ITEM_CLASS4 = "dx-validationsummary-item";
var ITEM_DATA_KEY2 = "dx-validationsummary-item-data";
var ValidationSummary = class extends m_collection_widget_edit_default {
  _getDefaultOptions() {
    return _extends({}, super._getDefaultOptions(), {
      focusStateEnabled: false,
      noDataText: null
    });
  }
  _setOptionsByReference() {
    super._setOptionsByReference();
    extend(this._optionsByReference, {
      validationGroup: true
    });
  }
  _init() {
    super._init();
    this._initGroupRegistration();
  }
  _initGroupRegistration() {
    const $element = this.$element();
    const {
      validationGroup
    } = this.option();
    const group = validationGroup || m_validation_engine_default.findGroup($element, this._modelByElement($element));
    const groupConfig = m_validation_engine_default.addGroup(group, true);
    this._unsubscribeGroup();
    this._groupWasInit = true;
    this._validationGroup = group;
    this.groupSubscription = this._groupValidationHandler.bind(this);
    groupConfig.on("validated", this.groupSubscription);
  }
  _unsubscribeGroup() {
    const groupConfig = m_validation_engine_default.getGroupConfig(this._validationGroup);
    null === groupConfig || void 0 === groupConfig || groupConfig.off("validated", this.groupSubscription);
  }
  _getOrderedItems(validators, items) {
    let orderedItems = [];
    each(validators, (_, validator) => {
      const foundItems = grep(items, (item) => {
        if (item.validator === validator) {
          return true;
        }
      });
      if (foundItems.length) {
        orderedItems = orderedItems.concat(foundItems);
      }
    });
    return orderedItems;
  }
  _groupValidationHandler(params) {
    const items = this._getOrderedItems(params.validators, map(params.brokenRules, (rule) => ({
      text: rule.message,
      validator: rule.validator,
      index: rule.index
    })));
    this.validators = params.validators;
    each(this.validators, (_, validator) => {
      if (validator._validationSummary !== this) {
        let handler = this._itemValidationHandler.bind(this);
        const disposingHandler = function() {
          validator.off("validated", handler);
          validator._validationSummary = null;
          handler = null;
        };
        validator.on("validated", handler);
        validator.on("disposing", disposingHandler);
        validator._validationSummary = this;
      }
    });
    this.option("items", items);
  }
  _itemValidationHandler(_ref) {
    let {
      isValid,
      validator,
      brokenRules
    } = _ref;
    let {
      items
    } = this.option();
    let itemsChanged = false;
    let itemIndex = 0;
    while (itemIndex < items.length) {
      const item = items[itemIndex];
      if (item.validator === validator) {
        const foundRule = grep(brokenRules || [], (rule) => rule.index === item.index)[0];
        if (isValid || !foundRule) {
          items.splice(itemIndex, 1);
          itemsChanged = true;
          continue;
        }
        if (foundRule.message !== item.text) {
          item.text = foundRule.message;
          itemsChanged = true;
        }
      }
      itemIndex++;
    }
    each(brokenRules, (_, rule) => {
      const foundItem = grep(items, (item) => item.validator === validator && item.index === rule.index)[0];
      if (!foundItem) {
        items.push({
          text: rule.message,
          validator,
          index: rule.index
        });
        itemsChanged = true;
      }
    });
    if (itemsChanged) {
      items = this._getOrderedItems(this.validators, items);
      this.option("items", items);
    }
  }
  _initMarkup() {
    this.$element().addClass("dx-validationsummary");
    super._initMarkup();
  }
  _optionChanged(args) {
    if ("validationGroup" === args.name) {
      this._initGroupRegistration();
    } else {
      super._optionChanged(args);
    }
  }
  _itemClass() {
    return ITEM_CLASS4;
  }
  _itemDataKey() {
    return ITEM_DATA_KEY2;
  }
  _postprocessRenderItem(params) {
    m_events_engine_default.on(params.itemElement, "click", () => {
      var _params$itemData$vali, _params$itemData$vali2;
      null === (_params$itemData$vali = params.itemData.validator) || void 0 === _params$itemData$vali || null === (_params$itemData$vali2 = _params$itemData$vali.focus) || void 0 === _params$itemData$vali2 || _params$itemData$vali2.call(_params$itemData$vali);
    });
  }
  _dispose() {
    super._dispose();
    this._unsubscribeGroup();
  }
  refreshValidationGroup() {
    this._initGroupRegistration();
  }
};
component_registrator_default("dxValidationSummary", ValidationSummary);
var m_validation_summary_default = ValidationSummary;

// node_modules/devextreme/esm/__internal/ui/validation/m_default_adapter.js
var DefaultAdapter = class extends class_default.inherit({}) {
  ctor(editor, validator) {
    this.editor = editor;
    this.validator = validator;
    this.validationRequestsCallbacks = [];
    const handler = (args) => {
      this.validationRequestsCallbacks.forEach((item) => item(args));
    };
    editor.validationRequest.add(handler);
    editor.on("disposing", () => {
      editor.validationRequest.remove(handler);
    });
  }
  getValue() {
    return this.editor.option("value");
  }
  getCurrentValidationError() {
    return this.editor.option("validationError");
  }
  bypass() {
    return this.editor.option("disabled");
  }
  applyValidationResults(params) {
    this.editor.option({
      validationErrors: params.brokenRules,
      validationStatus: params.status
    });
  }
  reset() {
    this.editor.clear();
  }
  focus() {
    this.editor.focus();
  }
};
var m_default_adapter_default = DefaultAdapter;

// node_modules/devextreme/esm/__internal/ui/m_validator.js
var Validator = class extends dom_component_default {
  _initOptions(options2) {
    super._initOptions.apply(this, arguments);
    this.option(m_validation_engine_default.initValidationOptions(options2));
  }
  _getDefaultOptions() {
    return _extends({}, super._getDefaultOptions(), {
      validationRules: []
    });
  }
  _init() {
    super._init();
    this._initGroupRegistration();
    this.focused = callbacks_default();
    this._initAdapter();
    this._validationInfo = {
      result: null,
      deferred: null,
      skipValidation: false
    };
  }
  _initGroupRegistration() {
    const group = this._findGroup();
    if (!this._groupWasInit) {
      this.on("disposing", (args) => {
        m_validation_engine_default.removeRegisteredValidator(args.component._validationGroup, args.component);
      });
    }
    if (!this._groupWasInit || this._validationGroup !== group) {
      m_validation_engine_default.removeRegisteredValidator(this._validationGroup, this);
      this._groupWasInit = true;
      this._validationGroup = group;
      m_validation_engine_default.registerValidatorInGroup(group, this);
    }
  }
  _setOptionsByReference() {
    super._setOptionsByReference();
    extend(this._optionsByReference, {
      validationGroup: true
    });
  }
  _getEditor() {
    const element = this.$element()[0];
    return data(element, "dx-validation-target");
  }
  _initAdapter() {
    const dxStandardEditor = this._getEditor();
    let {
      adapter
    } = this.option();
    if (!adapter) {
      if (dxStandardEditor) {
        var _adapter;
        adapter = new m_default_adapter_default(dxStandardEditor, this);
        null === (_adapter = adapter) || void 0 === _adapter || null === (_adapter = _adapter.validationRequestsCallbacks) || void 0 === _adapter || _adapter.push((args) => {
          var _this$_validationInfo;
          if (null !== (_this$_validationInfo = this._validationInfo) && void 0 !== _this$_validationInfo && _this$_validationInfo.skipValidation) {
            return;
          }
          this.validate(args);
        });
        this.option("adapter", adapter);
        return;
      }
      throw ui_errors_default.Error("E0120");
    }
    const callbacks2 = adapter.validationRequestsCallbacks;
    if (callbacks2) {
      callbacks2.push((args) => {
        this.validate(args);
      });
    }
  }
  _toggleRTLDirection(isRtl) {
    var _adapter$editor;
    const {
      adapter
    } = this.option();
    const rtlEnabled = (null === adapter || void 0 === adapter || null === (_adapter$editor = adapter.editor) || void 0 === _adapter$editor ? void 0 : _adapter$editor.option("rtlEnabled")) ?? isRtl;
    super._toggleRTLDirection(rtlEnabled);
  }
  _initMarkup() {
    this.$element().addClass("dx-validator");
    super._initMarkup();
  }
  _render() {
    super._render();
    this._toggleAccessibilityAttributes();
  }
  _toggleAccessibilityAttributes() {
    const dxStandardEditor = this._getEditor();
    if (dxStandardEditor) {
      const rules = this.option("validationRules") || [];
      const isRequired = rules.some((_ref) => {
        let {
          type: type2
        } = _ref;
        return "required" === type2;
      }) || null;
      if (dxStandardEditor.isInitialized()) {
        dxStandardEditor.setAria("required", isRequired);
      }
      dxStandardEditor.option("_onMarkupRendered", () => {
        dxStandardEditor.setAria("required", isRequired);
      });
    }
  }
  _visibilityChanged(visible2) {
    if (visible2) {
      this._initGroupRegistration();
    }
  }
  _optionChanged(args) {
    switch (args.name) {
      case "validationGroup":
        this._initGroupRegistration();
        return;
      case "validationRules":
        this._resetValidationRules();
        this._toggleAccessibilityAttributes();
        void 0 !== this.option("isValid") && this.validate();
        return;
      case "adapter":
        this._initAdapter();
        break;
      case "isValid":
      case "validationStatus":
        this.option(m_validation_engine_default.synchronizeValidationOptions(args, this.option()));
        break;
      default:
        super._optionChanged(args);
    }
  }
  _getValidationRules() {
    if (!this._validationRules) {
      this._validationRules = map(this.option("validationRules"), (rule, index2) => extend({}, rule, {
        validator: this,
        index: index2
      }));
    }
    return this._validationRules;
  }
  _findGroup() {
    const $element = this.$element();
    const {
      validationGroup
    } = this.option();
    return validationGroup || m_validation_engine_default.findGroup($element, this._modelByElement($element));
  }
  _resetValidationRules() {
    delete this._validationRules;
  }
  validate(args) {
    var _adapter$bypass, _adapter$getValue, _adapter$getCurrentVa, _this$_validationInfo2, _result$complete;
    const {
      adapter,
      name: name2
    } = this.option();
    const bypass = null === adapter || void 0 === adapter || null === (_adapter$bypass = adapter.bypass) || void 0 === _adapter$bypass ? void 0 : _adapter$bypass.call(adapter);
    const value2 = args && void 0 !== args.value ? args.value : null === adapter || void 0 === adapter || null === (_adapter$getValue = adapter.getValue) || void 0 === _adapter$getValue ? void 0 : _adapter$getValue.call(adapter);
    const currentError = null === adapter || void 0 === adapter || null === (_adapter$getCurrentVa = adapter.getCurrentValidationError) || void 0 === _adapter$getCurrentVa ? void 0 : _adapter$getCurrentVa.call(adapter);
    const rules = this._getValidationRules();
    const currentResult = null === (_this$_validationInfo2 = this._validationInfo) || void 0 === _this$_validationInfo2 ? void 0 : _this$_validationInfo2.result;
    if (currentResult && "pending" === currentResult.status && currentResult.value === value2) {
      return extend({}, currentResult);
    }
    let result2;
    if (bypass) {
      result2 = {
        isValid: true,
        status: "valid"
      };
    } else if (null !== currentError && void 0 !== currentError && currentError.editorSpecific) {
      currentError.validator = this;
      result2 = {
        isValid: false,
        status: "invalid",
        brokenRule: currentError,
        brokenRules: [currentError]
      };
    } else {
      result2 = m_validation_engine_default.validate(value2, rules, name2);
    }
    result2.id = new guid_default2().toString();
    this._applyValidationResult(result2, adapter);
    null === (_result$complete = result2.complete) || void 0 === _result$complete || _result$complete.then((res) => {
      if (res.id === this._validationInfo.result.id) {
        this._applyValidationResult(res, adapter);
      }
    });
    return extend({}, this._validationInfo.result);
  }
  reset() {
    const {
      adapter
    } = this.option();
    const result2 = {
      id: null,
      isValid: true,
      brokenRule: null,
      brokenRules: null,
      pendingRules: null,
      status: "valid",
      complete: null
    };
    this._validationInfo.skipValidation = true;
    adapter.reset();
    this._validationInfo.skipValidation = false;
    this._resetValidationRules();
    this._applyValidationResult(result2, adapter);
  }
  _updateValidationResult(result2) {
    if (!this._validationInfo.result || this._validationInfo.result.id !== result2.id) {
      const complete = this._validationInfo.deferred && this._validationInfo.result.complete;
      this._validationInfo.result = extend({}, result2, {
        complete
      });
    } else {
      for (const prop in result2) {
        if ("id" !== prop && "complete" !== prop) {
          this._validationInfo.result[prop] = result2[prop];
        }
      }
    }
  }
  _applyValidationResult(result2, adapter) {
    const validatedAction = this._createActionByOption("onValidated", {
      excludeValidators: ["readOnly"]
    });
    result2.validator = this;
    this._updateValidationResult(result2);
    adapter.applyValidationResults && adapter.applyValidationResults(this._validationInfo.result);
    this.option({
      validationStatus: this._validationInfo.result.status
    });
    if ("pending" === this._validationInfo.result.status) {
      if (!this._validationInfo.deferred) {
        this._validationInfo.deferred = Deferred();
        this._validationInfo.result.complete = this._validationInfo.deferred.promise();
      }
      this._eventsStrategy.fireEvent("validating", [this._validationInfo.result]);
      return;
    }
    if ("pending" !== this._validationInfo.result.status) {
      validatedAction(result2);
      if (this._validationInfo.deferred) {
        this._validationInfo.deferred.resolve(result2);
        this._validationInfo.deferred = null;
      }
    }
  }
  focus() {
    const {
      adapter
    } = this.option();
    adapter && adapter.focus && adapter.focus();
  }
  _useTemplates() {
    return false;
  }
};
component_registrator_default("dxValidator", Validator);
var m_validator_default = Validator;

// node_modules/devextreme/esm/__internal/ui/m_validation_group.js
var ValidationGroup = class extends dom_component_default2 {
  _getDefaultOptions() {
    return super._getDefaultOptions();
  }
  _init() {
    super._init();
    m_validation_engine_default.addGroup(this, false);
  }
  _initMarkup() {
    const $element = this.$element();
    $element.addClass("dx-validationgroup");
    $element.find(".dx-validator").each((_, validatorContainer) => {
      m_validator_default.getInstance(renderer_default(validatorContainer))._initGroupRegistration();
    });
    $element.find(".dx-validationsummary").each((_, summaryContainer) => {
      m_validation_summary_default.getInstance(renderer_default(summaryContainer)).refreshValidationGroup();
    });
    super._initMarkup();
  }
  validate() {
    return m_validation_engine_default.validateGroup(this);
  }
  reset() {
    return m_validation_engine_default.resetGroup(this);
  }
  _dispose() {
    m_validation_engine_default.removeGroup(this);
    this.$element().removeClass("dx-validationgroup");
    super._dispose();
  }
  _useTemplates() {
    return false;
  }
};
component_registrator_default("dxValidationGroup", ValidationGroup);

// node_modules/devextreme/esm/ui/box.js
var box_default = m_box_default;

// node_modules/devextreme/esm/__internal/ui/m_responsive_box.js
var SCREEN_SIZE_CLASS_PREFIX = "dx-responsivebox-screen-";
var ResponsiveBox = class extends ui_collection_widget_edit_default {
  _getDefaultOptions() {
    return _extends({}, super._getDefaultOptions(), {
      rows: [],
      cols: [],
      screenByWidth: null,
      singleColumnScreen: "",
      height: "100%",
      width: "100%",
      activeStateEnabled: false,
      focusStateEnabled: false,
      onLayoutChanged: null
    });
  }
  _init() {
    if (!this.option("screenByWidth")) {
      this._options.silent("screenByWidth", defaultScreenFactorFunc);
    }
    super._init();
    this._initLayoutChangedAction();
  }
  _initLayoutChangedAction() {
    this._layoutChangedAction = this._createActionByOption("onLayoutChanged", {
      excludeValidators: ["disabled", "readOnly"]
    });
  }
  _itemClass() {
    return "dx-box-item";
  }
  _itemDataKey() {
    return "dxBoxItemData";
  }
  _initMarkup() {
    super._initMarkup();
    this.$element().addClass("dx-responsivebox");
  }
  _renderItems() {
    this._setScreenSize();
    this._screenItems = this._itemsByScreen();
    this._prepareGrid();
    this._spreadItems();
    this._layoutItems();
    this._linkNodeToItem();
  }
  _itemOptionChanged(item) {
    const $item = this._findItemElementByItem(item);
    if (!$item.length) {
      return;
    }
    this._refreshItem($item, item);
    this._clearItemNodeTemplates();
    this._update(true);
  }
  _setScreenSize() {
    const currentScreen = this._getCurrentScreen();
    this._removeScreenSizeClass();
    this.$element().addClass(SCREEN_SIZE_CLASS_PREFIX + currentScreen);
    this.option("currentScreenFactor", currentScreen);
  }
  _removeScreenSizeClass() {
    const {
      currentScreenFactor
    } = this.option();
    if (currentScreenFactor) {
      this.$element().removeClass(SCREEN_SIZE_CLASS_PREFIX + currentScreenFactor);
    }
  }
  _prepareGrid() {
    const grid = this._grid = [];
    this._prepareRowsAndCols();
    each(this._rows, () => {
      const row = [];
      grid.push(row);
      each(this._cols, () => {
        row.push(this._createEmptyCell());
      });
    });
  }
  getSingleColumnRows() {
    const {
      rows
    } = this.option();
    const screenItemsLength = this._screenItems.length;
    if (null !== rows && void 0 !== rows && rows.length) {
      const filteredRows = this._filterByScreen(rows);
      const result2 = [];
      for (let i = 0; i < screenItemsLength; i++) {
        const sizeConfig = this._defaultSizeConfig();
        if (i < filteredRows.length && isDefined(filteredRows[i].shrink)) {
          sizeConfig.shrink = filteredRows[i].shrink;
        }
        result2.push(sizeConfig);
      }
      return result2;
    }
    return this._defaultSizeConfig(screenItemsLength);
  }
  _prepareRowsAndCols() {
    if (this._isSingleColumnScreen()) {
      this._prepareSingleColumnScreenItems();
      this._rows = this.getSingleColumnRows();
      this._cols = this._defaultSizeConfig(1);
    } else {
      this._rows = this._sizesByScreen(this.option("rows"));
      this._cols = this._sizesByScreen(this.option("cols"));
    }
  }
  _isSingleColumnScreen() {
    const {
      singleColumnScreen,
      rows,
      cols
    } = this.option();
    return this._screenRegExp().test(singleColumnScreen) || !(null !== rows && void 0 !== rows && rows.length) || !(null !== cols && void 0 !== cols && cols.length);
  }
  _prepareSingleColumnScreenItems() {
    this._screenItems.sort((item1, item2) => item1.location.row - item2.location.row || item1.location.col - item2.location.col);
    each(this._screenItems, (index2, item) => {
      extend(item.location, {
        row: index2,
        col: 0,
        rowspan: 1,
        colspan: 1
      });
    });
  }
  _sizesByScreen(sizeConfigs) {
    return map(this._filterByScreen(sizeConfigs), (sizeConfig) => extend(this._defaultSizeConfig(), sizeConfig));
  }
  _createDefaultSizeConfig() {
    return {
      ratio: 1,
      baseSize: 0,
      minSize: 0,
      maxSize: 0
    };
  }
  _defaultSizeConfig(size) {
    const defaultSizeConfig = this._createDefaultSizeConfig();
    if (!arguments.length) {
      return defaultSizeConfig;
    }
    const result2 = [];
    for (let i = 0; i < size; i++) {
      result2.push(defaultSizeConfig);
    }
    return result2;
  }
  _filterByScreen(items) {
    const screenRegExp = this._screenRegExp();
    return grep(items, (item) => !item.screen || screenRegExp.test(item.screen));
  }
  _screenRegExp() {
    const screen = this._getCurrentScreen();
    return new RegExp(`(^|\\s)${screen}($|\\s)`, "i");
  }
  _getCurrentScreen() {
    const width = this._screenWidth();
    const {
      screenByWidth
    } = this.option();
    return null === screenByWidth || void 0 === screenByWidth ? void 0 : screenByWidth(width);
  }
  _screenWidth() {
    return hasWindow() ? getWidth(getWindow()) : 1920;
  }
  _createEmptyCell() {
    return {
      item: {},
      location: {
        colspan: 1,
        rowspan: 1
      }
    };
  }
  _spreadItems() {
    each(this._screenItems, (_, itemInfo) => {
      const location = itemInfo.location || {};
      const itemCol = location.col;
      const itemRow = location.row;
      const row = this._grid[itemRow];
      const itemCell = null === row || void 0 === row ? void 0 : row[itemCol];
      this._occupyCells(itemCell, itemInfo);
    });
  }
  _itemsByScreen() {
    const {
      items
    } = this.option();
    return null === items || void 0 === items ? void 0 : items.reduce((result2, item) => {
      let locations = item.location || {};
      locations = isPlainObject(locations) ? [locations] : locations;
      this._filterByScreen(locations).forEach((location) => {
        result2.push({
          item,
          location: extend({
            rowspan: 1,
            colspan: 1
          }, location)
        });
      });
      return result2;
    }, []);
  }
  _occupyCells(itemCell, itemInfo) {
    if (!itemCell || this._isItemCellOccupied(itemCell, itemInfo)) {
      return;
    }
    extend(itemCell, itemInfo);
    this._markSpanningCell(itemCell);
  }
  _isItemCellOccupied(itemCell, itemInfo) {
    if (!isEmptyObject(itemCell.item)) {
      return true;
    }
    let result2 = false;
    this._loopOverSpanning(itemInfo.location, (cell) => {
      result2 = result2 || !isEmptyObject(cell.item);
    });
    return result2;
  }
  _loopOverSpanning(location, callback) {
    const rowEnd = location.row + location.rowspan - 1;
    const colEnd = location.col + location.colspan - 1;
    const boundRowEnd = Math.min(rowEnd, this._rows.length - 1);
    const boundColEnd = Math.min(colEnd, this._cols.length - 1);
    location.rowspan -= rowEnd - boundRowEnd;
    location.colspan -= colEnd - boundColEnd;
    for (let rowIndex = location.row; rowIndex <= boundRowEnd; rowIndex++) {
      for (let colIndex = location.col; colIndex <= boundColEnd; colIndex++) {
        if (rowIndex !== location.row || colIndex !== location.col) {
          callback(this._grid[rowIndex][colIndex]);
        }
      }
    }
  }
  _markSpanningCell(itemCell) {
    this._loopOverSpanning(itemCell.location, (cell) => {
      extend(cell, {
        item: itemCell.item,
        spanningCell: itemCell
      });
    });
  }
  _linkNodeToItem() {
    each(this._itemElements(), (_, itemNode) => {
      const $item = renderer_default(itemNode);
      const item = $item.data("dxBoxItemData");
      if (!item.box) {
        item.node = $item.children();
      }
    });
  }
  _layoutItems() {
    const rowsCount = this._grid.length;
    const colsCount = rowsCount && this._grid[0].length;
    if (!rowsCount && !colsCount) {
      return;
    }
    const result2 = this._layoutBlock({
      direction: "col",
      row: {
        start: 0,
        end: rowsCount - 1
      },
      col: {
        start: 0,
        end: colsCount - 1
      }
    });
    const rootBox = this._prepareBoxConfig(result2.box || {
      direction: "row",
      items: [extend(result2, {
        ratio: 1
      })]
    });
    extend(rootBox, this._rootBoxConfig(rootBox.items));
    this._$root = renderer_default("<div>").appendTo(this._itemContainer());
    this._createComponent(this._$root, box_default, rootBox);
  }
  _rootBoxConfig(items) {
    const rootItems = each(items, (index2, item) => {
      this._needApplyAutoBaseSize(item) && extend(item, {
        baseSize: "auto"
      });
    });
    const {
      itemHoldTimeout
    } = this.option();
    return {
      width: "100%",
      height: "100%",
      items: rootItems,
      itemTemplate: this._getTemplateByOption("itemTemplate"),
      itemHoldTimeout,
      onItemHold: this._createActionByOption("onItemHold"),
      onItemClick: this._createActionByOption("onItemClick"),
      onItemContextMenu: this._createActionByOption("onItemContextMenu"),
      onItemRendered: this._createActionByOption("onItemRendered")
    };
  }
  _needApplyAutoBaseSize(item) {
    return !item.baseSize && (!item.minSize || "auto" === item.minSize) && (!item.maxSize || "auto" === item.maxSize);
  }
  _prepareBoxConfig(config3) {
    return extend(config3 || {}, {
      crossAlign: "stretch",
      onItemStateChanged: this.option("onItemStateChanged")
    });
  }
  _layoutBlock(options2) {
    if (this._isSingleItem(options2)) {
      return this._itemByCell(options2.row.start, options2.col.start);
    }
    return this._layoutDirection(options2);
  }
  _isSingleItem(options2) {
    const firstCellLocation = this._grid[options2.row.start][options2.col.start].location;
    const isItemRowSpanned = options2.row.end - options2.row.start === firstCellLocation.rowspan - 1;
    const isItemColSpanned = options2.col.end - options2.col.start === firstCellLocation.colspan - 1;
    return isItemRowSpanned && isItemColSpanned;
  }
  _itemByCell(rowIndex, colIndex) {
    const itemCell = this._grid[rowIndex][colIndex];
    return itemCell.spanningCell ? null : itemCell.item;
  }
  _layoutDirection(options2) {
    const items = [];
    const {
      direction
    } = options2;
    const crossDirection = this._crossDirection(direction);
    let block;
    while (block = this._nextBlock(options2)) {
      if (this._isBlockIndivisible(options2.prevBlockOptions, block)) {
        throw ui_errors_default.Error("E1025");
      }
      const item = this._layoutBlock({
        direction: crossDirection,
        row: block.row,
        col: block.col,
        prevBlockOptions: options2
      });
      if (item) {
        extend(item, this._blockSize(block, crossDirection));
        items.push(item);
      }
      options2[crossDirection].start = block[crossDirection].end + 1;
    }
    return {
      box: this._prepareBoxConfig({
        direction,
        items
      })
    };
  }
  _isBlockIndivisible(options2, block) {
    return options2 && options2.col.start === block.col.start && options2.col.end === block.col.end && options2.row.start === block.row.start && options2.row.end === block.row.end;
  }
  _crossDirection(direction) {
    return "col" === direction ? "row" : "col";
  }
  _nextBlock(options2) {
    const {
      direction
    } = options2;
    const crossDirection = this._crossDirection(direction);
    const startIndex = options2[direction].start;
    const endIndex = options2[direction].end;
    const crossStartIndex = options2[crossDirection].start;
    if (crossStartIndex > options2[crossDirection].end) {
      return null;
    }
    let crossSpan = 1;
    for (let crossIndex = crossStartIndex; crossIndex < crossStartIndex + crossSpan; crossIndex++) {
      let lineCrossSpan = 1;
      for (let index2 = startIndex; index2 <= endIndex; index2++) {
        const cell = this._cellByDirection(direction, index2, crossIndex);
        lineCrossSpan = Math.max(lineCrossSpan, cell.location[`${crossDirection}span`]);
      }
      const lineCrossEndIndex = crossIndex + lineCrossSpan;
      const crossEndIndex = crossStartIndex + crossSpan;
      if (lineCrossEndIndex > crossEndIndex) {
        crossSpan += lineCrossEndIndex - crossEndIndex;
      }
    }
    const result2 = {};
    result2[direction] = {
      start: startIndex,
      end: endIndex
    };
    result2[crossDirection] = {
      start: crossStartIndex,
      end: crossStartIndex + crossSpan - 1
    };
    return result2;
  }
  _cellByDirection(direction, index2, crossIndex) {
    return "col" === direction ? this._grid[crossIndex][index2] : this._grid[index2][crossIndex];
  }
  _blockSize(block, direction) {
    const defaultMinSize = "row" === direction ? "auto" : 0;
    const sizeConfigs = "row" === direction ? this._rows : this._cols;
    const result2 = extend(this._createDefaultSizeConfig(), {
      ratio: 0
    });
    for (let index2 = block[direction].start; index2 <= block[direction].end; index2++) {
      const sizeConfig = sizeConfigs[index2];
      result2.ratio += sizeConfig.ratio;
      result2.baseSize += sizeConfig.baseSize;
      result2.minSize += sizeConfig.minSize;
      result2.maxSize += sizeConfig.maxSize;
      if (isDefined(sizeConfig.shrink)) {
        result2.shrink = sizeConfig.shrink;
      }
    }
    result2.minSize = result2.minSize ? result2.minSize : defaultMinSize;
    result2.maxSize = result2.maxSize ? result2.maxSize : "auto";
    this._isSingleColumnScreen() && (result2.baseSize = "auto");
    return result2;
  }
  _update(forceRemoveRoot) {
    var _this$_layoutChangedA;
    const $existingRoot = this._$root;
    this._renderItems();
    if ($existingRoot) {
      if (forceRemoveRoot) {
        $existingRoot.remove();
      } else {
        $existingRoot.detach();
        this._saveAssistantRoot($existingRoot);
      }
    }
    null === (_this$_layoutChangedA = this._layoutChangedAction) || void 0 === _this$_layoutChangedA || _this$_layoutChangedA.call(this);
  }
  _saveAssistantRoot($root) {
    this._assistantRoots = this._assistantRoots || [];
    this._assistantRoots.push($root);
  }
  _dispose() {
    this._clearItemNodeTemplates();
    this._cleanUnusedRoots();
    super._dispose.apply(this, arguments);
  }
  _cleanUnusedRoots() {
    if (!this._assistantRoots) {
      return;
    }
    each(this._assistantRoots, (_, item) => {
      renderer_default(item).remove();
    });
  }
  _clearItemNodeTemplates() {
    each(this.option("items"), function() {
      delete this.node;
    });
  }
  _attachClickEvent() {
  }
  _optionChanged(args) {
    switch (args.name) {
      case "rows":
      case "cols":
      case "screenByWidth":
      case "singleColumnScreen":
        this._clearItemNodeTemplates();
        this._invalidate();
        break;
      case "width":
      case "height":
        super._optionChanged(args);
        this._update();
        break;
      case "onLayoutChanged":
        this._initLayoutChangedAction();
        break;
      case "itemTemplate":
        this._clearItemNodeTemplates();
        super._optionChanged(args);
        break;
      case "currentScreenFactor":
        break;
      default:
        super._optionChanged(args);
    }
  }
  _dimensionChanged() {
    if (this._getCurrentScreen() !== this.option("currentScreenFactor")) {
      this._update();
    }
  }
  repaint() {
    this._update();
  }
};
component_registrator_default("dxResponsiveBox", ResponsiveBox);
var m_responsive_box_default = ResponsiveBox;

// node_modules/devextreme/esm/__internal/ui/form/components/m_button_item.js
function renderButtonItem(_ref) {
  let {
    item,
    $parent,
    rootElementCssClassList,
    validationGroup,
    createComponentCallback
  } = _ref;
  const $rootElement = renderer_default("<div>").appendTo($parent).addClass(rootElementCssClassList.join(" ")).addClass("dx-field-button-item").css("textAlign", convertAlignmentToTextAlign(item.horizontalAlignment));
  $parent.css("justifyContent", convertAlignmentToJustifyContent(item.verticalAlignment));
  const $button = renderer_default("<div>").appendTo($rootElement);
  return {
    $rootElement,
    buttonInstance: createComponentCallback($button, "dxButton", extend({
      validationGroup
    }, item.buttonOptions))
  };
}
function convertAlignmentToTextAlign(horizontalAlignment) {
  return isDefined(horizontalAlignment) ? horizontalAlignment : "right";
}
function convertAlignmentToJustifyContent(verticalAlignment) {
  switch (verticalAlignment) {
    case "center":
      return "center";
    case "bottom":
      return "flex-end";
    default:
      return "flex-start";
  }
}

// node_modules/devextreme/esm/__internal/ui/form/components/m_empty_item.js
function renderEmptyItem(_ref) {
  let {
    $parent,
    rootElementCssClassList
  } = _ref;
  return renderer_default("<div>").addClass("dx-field-empty-item").html("&nbsp;").addClass(rootElementCssClassList.join(" ")).appendTo($parent);
}

// node_modules/devextreme/esm/ui/validator.js
var validator_default = m_validator_default;

// node_modules/devextreme/esm/__internal/ui/form/constants.js
var FORM_CLASS = "dx-form";
var FORM_GROUP_CLASS = "dx-form-group";
var FORM_GROUP_CAPTION_CLASS = "dx-form-group-caption";
var FORM_GROUP_CUSTOM_CAPTION_CLASS = "dx-form-group-custom-caption";
var FORM_FIELD_ITEM_COL_CLASS = "dx-col-";
var FIELD_ITEM_CLASS = "dx-field-item";
var LAYOUT_MANAGER_ONE_COLUMN = "dx-layout-manager-one-col";
var FIELD_ITEM_LABEL_CONTENT_CLASS = "dx-field-item-label-content";
var FORM_LAYOUT_MANAGER_CLASS = "dx-layout-manager";
var FIELD_ITEM_LABEL_CLASS = "dx-field-item-label";
var FIELD_ITEM_CONTENT_CLASS = "dx-field-item-content";
var SINGLE_COLUMN_ITEM_CONTENT = "dx-single-column-item-content";
var ROOT_SIMPLE_ITEM_CLASS = "dx-root-simple-item";
var FORM_GROUP_CONTENT_CLASS = "dx-form-group-content";
var FIELD_ITEM_CONTENT_HAS_GROUP_CLASS = "dx-field-item-has-group";
var FIELD_ITEM_CONTENT_HAS_TABS_CLASS = "dx-field-item-has-tabs";
var FORM_GROUP_WITH_CAPTION_CLASS = "dx-form-group-with-caption";
var FIELD_ITEM_TAB_CLASS = "dx-field-item-tab";
var GROUP_COL_COUNT_CLASS = "dx-group-colcount-";
var GROUP_COL_COUNT_ATTR = "group-col-count";
var FORM_VALIDATION_SUMMARY = "dx-form-validation-summary";
var FORM_UNDERLINED_CLASS = "dx-form-styling-mode-underlined";
var SIMPLE_ITEM_TYPE = "simple";

// node_modules/devextreme/esm/__internal/ui/form/m_form.layout_manager.utils.js
var EDITORS_WITH_ARRAY_VALUE = ["dxTagBox", "dxRangeSlider", "dxDateRangeBox"];
var EDITORS_WITH_MULTIPLE_INPUT_FIELDS = ["dxRangeSlider", "dxDateRangeBox"];
var EDITORS_WITH_SPECIFIC_LABELS = ["dxRangeSlider", "dxSlider"];
var EDITORS_WITHOUT_LABELS = ["dxCalendar", "dxCheckBox", "dxHtmlEditor", "dxRadioGroup", "dxRangeSlider", "dxSlider", "dxSwitch"];
var DROP_DOWN_EDITORS = ["dxSelectBox", "dxDropDownBox", "dxTagBox", "dxLookup", "dxAutocomplete", "dxColorBox", "dxDateBox", "dxDateRangeBox"];
function convertToRenderFieldItemOptions(_ref) {
  let {
    $parent,
    rootElementCssClassList,
    formOrLayoutManager,
    createComponentCallback,
    item,
    template,
    labelTemplate,
    name: name2,
    formLabelLocation,
    requiredMessageTemplate,
    validationGroup,
    editorValue,
    canAssignUndefinedValueToEditor,
    editorValidationBoundary,
    editorStylingMode,
    showColonAfterLabel,
    managerLabelLocation,
    itemId,
    managerMarkOptions,
    labelMode,
    onLabelTemplateRendered
  } = _ref;
  const isRequired = isDefined(item.isRequired) ? item.isRequired : !!_hasRequiredRuleInSet(item.validationRules);
  const isSimpleItem = item.itemType === SIMPLE_ITEM_TYPE;
  const helpID = item.helpText ? `dx-${new guid_default2()}` : null;
  const labelOptions = _convertToLabelOptions({
    item,
    id: itemId,
    isRequired,
    managerMarkOptions,
    showColonAfterLabel,
    labelLocation: managerLabelLocation,
    formLabelMode: labelMode,
    labelTemplate,
    onLabelTemplateRendered
  });
  const needRenderLabel = labelOptions.visible && (labelOptions.text || labelOptions.labelTemplate && isSimpleItem);
  const {
    location: labelLocation,
    labelID
  } = labelOptions;
  const labelNeedBaselineAlign = "top" !== labelLocation && ["dxTextArea", "dxRadioGroup", "dxCalendar", "dxHtmlEditor"].includes(item.editorType);
  const editorOptions = _convertToEditorOptions({
    $parent,
    editorType: item.editorType,
    editorValue,
    defaultEditorName: item.dataField,
    canAssignUndefinedValueToEditor,
    externalEditorOptions: item.editorOptions,
    editorInputId: itemId,
    editorValidationBoundary,
    editorStylingMode,
    formLabelMode: labelMode,
    labelText: labelOptions.textWithoutColon,
    labelMark: labelOptions.markOptions.showRequiredMark ? String.fromCharCode(160) + labelOptions.markOptions.requiredMark : ""
  });
  const needRenderOptionalMarkAsHelpText = labelOptions.markOptions.showOptionalMark && !labelOptions.visible && "hidden" !== editorOptions.labelMode && !isDefined(item.helpText);
  const helpText = needRenderOptionalMarkAsHelpText ? labelOptions.markOptions.optionalMark : item.helpText;
  return {
    $parent,
    rootElementCssClassList,
    formOrLayoutManager,
    createComponentCallback,
    labelOptions,
    labelNeedBaselineAlign,
    labelLocation,
    needRenderLabel,
    item,
    isSimpleItem,
    isRequired,
    template,
    helpID,
    labelID,
    name: name2,
    helpText,
    formLabelLocation,
    requiredMessageTemplate,
    validationGroup,
    editorOptions
  };
}
function getLabelMarkText(_ref2) {
  let {
    showRequiredMark,
    requiredMark,
    showOptionalMark,
    optionalMark
  } = _ref2;
  if (!showRequiredMark && !showOptionalMark) {
    return "";
  }
  return String.fromCharCode(160) + (showRequiredMark ? requiredMark : optionalMark);
}
function convertToLabelMarkOptions(_ref3, isRequired) {
  let {
    showRequiredMark,
    requiredMark,
    showOptionalMark,
    optionalMark
  } = _ref3;
  return {
    showRequiredMark: showRequiredMark && isRequired,
    requiredMark,
    showOptionalMark: showOptionalMark && !isRequired,
    optionalMark
  };
}
function getDropDownEditorOptions($parent, editorType, editorInputId) {
  const isDropDownEditor = DROP_DOWN_EDITORS.includes(editorType);
  if (!isDropDownEditor) {
    return {};
  }
  return {
    onPopupInitialized: (_ref4) => {
      let {
        component,
        popup
      } = _ref4;
      const openOnFieldClick = component.option("openOnFieldClick");
      const initialHideOnOutsideClick = popup.option("hideOnOutsideClick");
      if (openOnFieldClick && isFunction(initialHideOnOutsideClick)) {
        const hideOnOutsideClick = (e) => {
          const $target = renderer_default(e.target);
          const $label = $parent.find(`label[for="${editorInputId}"]`);
          const isLabelClicked = !!$target.closest($label).length;
          return !isLabelClicked && initialHideOnOutsideClick(e);
        };
        component.option("dropDownOptions", {
          hideOnOutsideClick
        });
        popup.option({
          hideOnOutsideClick
        });
      }
    }
  };
}
function _convertToEditorOptions(_ref5) {
  let {
    $parent,
    editorType,
    defaultEditorName,
    editorValue,
    canAssignUndefinedValueToEditor,
    externalEditorOptions,
    editorInputId,
    editorValidationBoundary,
    editorStylingMode,
    formLabelMode,
    labelText,
    labelMark
  } = _ref5;
  const editorOptionsWithValue = {};
  if (void 0 !== editorValue || canAssignUndefinedValueToEditor) {
    editorOptionsWithValue.value = editorValue;
  }
  if (EDITORS_WITH_ARRAY_VALUE.includes(editorType)) {
    editorOptionsWithValue.value = editorOptionsWithValue.value || [];
  }
  let labelMode = null === externalEditorOptions || void 0 === externalEditorOptions ? void 0 : externalEditorOptions.labelMode;
  if (!isDefined(labelMode)) {
    labelMode = "outside" === formLabelMode ? "hidden" : formLabelMode;
  }
  const stylingMode = (null === externalEditorOptions || void 0 === externalEditorOptions ? void 0 : externalEditorOptions.stylingMode) || editorStylingMode;
  const useSpecificLabelOptions = EDITORS_WITH_SPECIFIC_LABELS.includes(editorType);
  const dropDownEditorOptions = getDropDownEditorOptions($parent, editorType, editorInputId);
  const result2 = extend(true, editorOptionsWithValue, externalEditorOptions, dropDownEditorOptions, {
    inputAttr: {
      id: editorInputId
    },
    validationBoundary: editorValidationBoundary,
    stylingMode,
    label: useSpecificLabelOptions ? null === externalEditorOptions || void 0 === externalEditorOptions ? void 0 : externalEditorOptions.label : labelText,
    labelMode,
    labelMark
  });
  if (externalEditorOptions) {
    if (result2.dataSource) {
      result2.dataSource = externalEditorOptions.dataSource;
    }
    if (result2.items) {
      result2.items = externalEditorOptions.items;
    }
  }
  if (defaultEditorName) {
    if (EDITORS_WITH_MULTIPLE_INPUT_FIELDS.includes(editorType)) {
      if ("dxRangeSlider" === editorType) {
        if (!result2.startName) {
          result2.startName = `${defaultEditorName}Start`;
        }
        if (!result2.endName) {
          result2.endName = `${defaultEditorName}End`;
        }
      }
      if ("dxDateRangeBox" === editorType) {
        if (!result2.startDateName) {
          result2.startDateName = `${defaultEditorName}Start`;
        }
        if (!result2.endDateName) {
          result2.endDateName = `${defaultEditorName}End`;
        }
      }
      return result2;
    }
    if (!result2.name) {
      result2.name = defaultEditorName;
    }
  }
  return result2;
}
function _hasRequiredRuleInSet(rules) {
  let hasRequiredRule;
  if (null !== rules && void 0 !== rules && rules.length) {
    each(rules, (index2, rule) => {
      if ("required" === rule.type) {
        hasRequiredRule = true;
        return false;
      }
    });
  }
  return hasRequiredRule;
}
function _convertToLabelOptions(_ref6) {
  let {
    item,
    id,
    isRequired,
    managerMarkOptions,
    showColonAfterLabel,
    labelLocation,
    labelTemplate,
    formLabelMode,
    onLabelTemplateRendered
  } = _ref6;
  const isEditorWithoutLabels = EDITORS_WITHOUT_LABELS.includes(item.editorType);
  const labelOptions = extend({
    showColon: showColonAfterLabel,
    location: labelLocation,
    id,
    visible: "outside" === formLabelMode || isEditorWithoutLabels && "hidden" !== formLabelMode,
    isRequired
  }, item ? item.label : {}, {
    markOptions: convertToLabelMarkOptions(managerMarkOptions, isRequired),
    labelTemplate,
    onLabelTemplateRendered
  });
  if (["dxRadioGroup", "dxCheckBox", "dxLookup", "dxSlider", "dxRangeSlider", "dxSwitch", "dxHtmlEditor", "dxDateRangeBox"].includes(item.editorType)) {
    labelOptions.labelID = `dx-label-${new guid_default2()}`;
  }
  if (!labelOptions.text && item.dataField) {
    labelOptions.text = captionize(item.dataField);
  }
  if (labelOptions.text) {
    labelOptions.textWithoutColon = labelOptions.text;
    labelOptions.text += labelOptions.showColon ? ":" : "";
  }
  return labelOptions;
}

// node_modules/devextreme/esm/__internal/ui/form/components/m_label.js
function renderLabel(_ref) {
  let {
    text,
    id,
    location,
    alignment,
    labelID = null,
    markOptions = {},
    labelTemplate,
    labelTemplateData,
    onLabelTemplateRendered
  } = _ref;
  if ((!isDefined(text) || text.length <= 0) && !isDefined(labelTemplate)) {
    return null;
  }
  const $label = renderer_default("<label>").addClass(`${FIELD_ITEM_LABEL_CLASS} dx-field-item-label-location-${location}`).attr("for", id).attr("id", labelID).css("textAlign", alignment);
  const $labelContainer = renderer_default("<span>").addClass(FIELD_ITEM_LABEL_CONTENT_CLASS);
  let $labelContent = renderer_default("<span>").addClass("dx-field-item-label-text").text(text);
  if (labelTemplate) {
    $labelContent = renderer_default("<div>").addClass("dx-field-item-custom-label-content");
    labelTemplateData.text = text;
    labelTemplate.render({
      container: getPublicElement($labelContent),
      model: labelTemplateData,
      onRendered() {
        null === onLabelTemplateRendered || void 0 === onLabelTemplateRendered || onLabelTemplateRendered();
      }
    });
  }
  return $label.append($labelContainer.append($labelContent, _renderLabelMark(markOptions)));
}
function _renderLabelMark(markOptions) {
  const markText = getLabelMarkText(markOptions);
  if ("" === markText) {
    return null;
  }
  return renderer_default("<span>").addClass(markOptions.showRequiredMark ? "dx-field-item-required-mark" : "dx-field-item-optional-mark").text(markText);
}
function setLabelWidthByMaxLabelWidth($targetContainer, labelsSelector, labelMarkOptions) {
  const FIELD_ITEM_LABEL_CONTENT_CLASS_Selector = `${labelsSelector} > .${FIELD_ITEM_LABEL_CLASS}:not(.dx-field-item-label-location-top) > .${FIELD_ITEM_LABEL_CONTENT_CLASS}`;
  const $FIELD_ITEM_LABEL_CONTENT_CLASS_Items = $targetContainer.find(FIELD_ITEM_LABEL_CONTENT_CLASS_Selector);
  const FIELD_ITEM_LABEL_CONTENT_CLASS_Length = $FIELD_ITEM_LABEL_CONTENT_CLASS_Items.length;
  let labelWidth;
  let i;
  let maxWidth = 0;
  for (i = 0; i < FIELD_ITEM_LABEL_CONTENT_CLASS_Length; i++) {
    labelWidth = getLabelWidthByHTML($FIELD_ITEM_LABEL_CONTENT_CLASS_Items[i]);
    if (labelWidth > maxWidth) {
      maxWidth = labelWidth;
    }
  }
  for (i = 0; i < FIELD_ITEM_LABEL_CONTENT_CLASS_Length; i++) {
    $FIELD_ITEM_LABEL_CONTENT_CLASS_Items[i].style.width = `${maxWidth}px`;
  }
}
function getLabelWidthByHTML(labelContent) {
  let result2 = 0;
  const itemsCount = labelContent.children.length;
  for (let i = 0; i < itemsCount; i++) {
    const child = labelContent.children[i];
    result2 += child.offsetWidth;
  }
  return result2;
}

// node_modules/devextreme/esm/__internal/ui/form/components/m_field_item.js
function renderFieldItem(_ref) {
  let {
    $parent,
    rootElementCssClassList,
    formOrLayoutManager,
    createComponentCallback,
    labelOptions,
    labelNeedBaselineAlign,
    labelLocation,
    needRenderLabel,
    formLabelLocation,
    item,
    editorOptions,
    isSimpleItem,
    isRequired,
    template,
    helpID,
    labelID,
    name: name2,
    helpText,
    requiredMessageTemplate,
    validationGroup
  } = _ref;
  const $rootElement = renderer_default("<div>").addClass(rootElementCssClassList.join(" ")).appendTo($parent);
  $rootElement.addClass(isRequired ? "dx-field-item-required" : "dx-field-item-optional");
  if (isSimpleItem) {
    $rootElement.addClass("dx-flex-layout");
  }
  if (isSimpleItem && labelNeedBaselineAlign) {
    $rootElement.addClass("dx-field-item-label-align");
  }
  const $fieldEditorContainer = renderer_default("<div>");
  $fieldEditorContainer.data("dx-form-item", item);
  $fieldEditorContainer.addClass(FIELD_ITEM_CONTENT_CLASS).addClass("dx-field-item-content-location-" + {
    right: "left",
    left: "right",
    top: "bottom"
  }[formLabelLocation]);
  let $label = null;
  if (needRenderLabel) {
    if (labelOptions.labelTemplate) {
      labelOptions.labelTemplateData = getTemplateData(item, editorOptions, formOrLayoutManager);
    }
    $label = renderLabel(labelOptions);
  }
  if ($label) {
    const {
      editorType
    } = item;
    $rootElement.append($label);
    if ("top" === labelLocation || "left" === labelLocation) {
      $rootElement.append($fieldEditorContainer);
    }
    if ("right" === labelLocation) {
      $rootElement.prepend($fieldEditorContainer);
    }
    if ("top" === labelLocation) {
      $rootElement.addClass("dx-label-v-align");
    } else {
      $rootElement.addClass("dx-label-h-align");
    }
    if ("dxCheckBox" === editorType || "dxSwitch" === editorType) {
      m_events_engine_default.on($label, CLICK_EVENT_NAME, () => {
        m_events_engine_default.trigger($fieldEditorContainer.children(), CLICK_EVENT_NAME);
      });
    }
    const toggleControls = ["dxCheckBox", "dxSwitch", "dxRadioGroup"];
    const isToggleControls = toggleControls.includes(editorType);
    const labelAlignment = labelOptions.alignment;
    const isLabelAlignmentLeft = "left" === labelAlignment || !labelAlignment;
    const hasNotTemplate = !template;
    const isLabelOnTop = "top" === labelLocation;
    if (hasNotTemplate && isToggleControls && isLabelOnTop && isLabelAlignmentLeft) {
      $fieldEditorContainer.addClass("dx-toggle-controls-paddings");
    }
  } else {
    $rootElement.append($fieldEditorContainer);
  }
  let widgetInstance;
  if (template) {
    template.render({
      container: getPublicElement($fieldEditorContainer),
      model: getTemplateData(item, editorOptions, formOrLayoutManager),
      onRendered() {
        const $validationTarget2 = getValidationTarget($fieldEditorContainer);
        const validationTargetInstance2 = tryGetValidationTargetInstance($validationTarget2);
        subscribeWrapperInvalidClassToggle(validationTargetInstance2);
      }
    });
  } else {
    const $div = renderer_default("<div>").appendTo($fieldEditorContainer);
    try {
      widgetInstance = createComponentCallback($div, item.editorType, editorOptions);
      widgetInstance.setAria("describedby", helpID);
      if (labelID) {
        widgetInstance.setAria("labelledby", labelID);
      }
      widgetInstance.setAria("required", isRequired);
    } catch (e) {
      ui_errors_default.log("E1035", e.message);
    }
  }
  const $validationTarget = getValidationTarget($fieldEditorContainer);
  const validationTargetInstance = $validationTarget && $validationTarget.data("dx-validation-target");
  if (validationTargetInstance) {
    const isItemHaveCustomLabel = item.label && item.label.text;
    const itemName = isItemHaveCustomLabel ? null : name2;
    const fieldName = isItemHaveCustomLabel ? item.label.text : itemName && captionize(itemName);
    let validationRules;
    if (isSimpleItem) {
      if (item.validationRules) {
        validationRules = item.validationRules;
      } else {
        const requiredMessage = format(requiredMessageTemplate, fieldName || "");
        validationRules = item.isRequired ? [{
          type: "required",
          message: requiredMessage
        }] : null;
      }
    }
    if (Array.isArray(validationRules) && validationRules.length) {
      createComponentCallback($validationTarget, validator_default, {
        validationRules,
        validationGroup,
        dataGetter: () => ({
          formItem: item
        })
      });
    }
    subscribeWrapperInvalidClassToggle(validationTargetInstance);
  }
  if (helpText && isSimpleItem) {
    const $editorParent = $fieldEditorContainer.parent();
    $editorParent.append(renderer_default("<div>").addClass("dx-field-item-content-wrapper").append($fieldEditorContainer).append(renderer_default("<div>").addClass("dx-field-item-help-text").attr("id", helpID).text(helpText)));
  }
  return {
    $fieldEditorContainer,
    $rootElement,
    widgetInstance
  };
}
function getValidationTarget($fieldEditorContainer) {
  const $editor = $fieldEditorContainer.children().first();
  return $editor.hasClass("dx-template-wrapper") ? $editor.children().first() : $editor;
}
function tryGetValidationTargetInstance($validationTarget) {
  var _$validationTarget$pa;
  return (null === $validationTarget || void 0 === $validationTarget ? void 0 : $validationTarget.data("dx-validation-target")) || (null === $validationTarget || void 0 === $validationTarget || null === (_$validationTarget$pa = $validationTarget.parent) || void 0 === _$validationTarget$pa || null === (_$validationTarget$pa = _$validationTarget$pa.call($validationTarget)) || void 0 === _$validationTarget$pa ? void 0 : _$validationTarget$pa.data("dx-validation-target"));
}
function subscribeWrapperInvalidClassToggle(validationTargetInstance) {
  if (validationTargetInstance && isMaterialBased()) {
    const wrapperClass = ".dx-field-item-content-wrapper";
    const toggleInvalidClass = (_ref2) => {
      let {
        element,
        component
      } = _ref2;
      const {
        isValid,
        validationMessageMode
      } = component.option();
      renderer_default(element).parents(wrapperClass).toggleClass("dx-invalid", false === isValid && (component._isFocused() || "always" === validationMessageMode));
    };
    validationTargetInstance.on("optionChanged", (e) => {
      if ("isValid" !== e.name) {
        return;
      }
      toggleInvalidClass(e);
    });
    validationTargetInstance.on("focusIn", toggleInvalidClass).on("focusOut", toggleInvalidClass).on("enterKey", toggleInvalidClass);
  }
}
function getTemplateData(item, editorOptions, formOrLayoutManager) {
  return {
    dataField: item.dataField,
    editorType: item.editorType,
    editorOptions,
    component: formOrLayoutManager,
    name: item.name
  };
}

// node_modules/devextreme/esm/__internal/ui/form/m_form.items_runtime_info.js
var FormItemsRunTimeInfo = class {
  constructor() {
    this._map = {};
  }
  _findWidgetInstance(condition) {
    let result2;
    each(this._map, (guid2, _ref) => {
      let {
        widgetInstance,
        item
      } = _ref;
      if (condition(item)) {
        result2 = widgetInstance;
        return false;
      }
    });
    return result2;
  }
  _findFieldByCondition(callback, valueExpr) {
    let result2;
    each(this._map, (key, value2) => {
      if (callback(value2)) {
        result2 = "guid" === valueExpr ? key : value2[valueExpr];
        return false;
      }
    });
    return result2;
  }
  clear() {
    this._map = {};
  }
  removeItemsByItems(itemsRunTimeInfo) {
    each(itemsRunTimeInfo.getItems(), (guid2) => this.removeItemByKey(guid2));
  }
  removeItemByKey(key) {
    delete this._map[key];
  }
  add(options2) {
    const key = options2.guid || new guid_default2();
    this._map[key] = options2;
    return key;
  }
  addItemsOrExtendFrom(itemsRunTimeInfo) {
    itemsRunTimeInfo.each((key, itemRunTimeInfo) => {
      if (this._map[key]) {
        if (itemRunTimeInfo.widgetInstance) {
          this._map[key].widgetInstance = itemRunTimeInfo.widgetInstance;
        }
        this._map[key].$itemContainer = itemRunTimeInfo.$itemContainer;
      } else {
        this.add({
          item: itemRunTimeInfo.item,
          widgetInstance: itemRunTimeInfo.widgetInstance,
          guid: key,
          $itemContainer: itemRunTimeInfo.$itemContainer
        });
      }
    });
  }
  extendRunTimeItemInfoByKey(key, options2) {
    if (this._map[key]) {
      this._map[key] = extend(this._map[key], options2);
    }
  }
  findWidgetInstanceByItem(item) {
    return this._findWidgetInstance((storedItem) => storedItem === item);
  }
  findGroupOrTabLayoutManagerByPath(targetPath) {
    return this._findFieldByCondition((_ref2) => {
      let {
        path
      } = _ref2;
      return path === targetPath;
    }, "layoutManager");
  }
  findKeyByPath(targetPath) {
    return this._findFieldByCondition((_ref3) => {
      let {
        path
      } = _ref3;
      return path === targetPath;
    }, "guid");
  }
  findWidgetInstanceByName(name2) {
    return this._findWidgetInstance((item) => name2 === item.name);
  }
  findWidgetInstanceByDataField(dataField) {
    return this._findWidgetInstance((item) => dataField === (isString(item) ? item : item.dataField));
  }
  findItemContainerByItem(item) {
    for (const key in this._map) {
      if (this._map[key].item === item) {
        return this._map[key].$itemContainer;
      }
    }
    return null;
  }
  findItemIndexByItem(targetItem) {
    return this._findFieldByCondition((_ref4) => {
      let {
        item
      } = _ref4;
      return item === targetItem;
    }, "itemIndex");
  }
  findPreparedItemByItem(item) {
    return this._findFieldByCondition((_ref5) => {
      let {
        item: currentItem
      } = _ref5;
      return currentItem === item;
    }, "preparedItem");
  }
  getItems() {
    return this._map;
  }
  each(handler) {
    each(this._map, (key, itemRunTimeInfo) => {
      handler(key, itemRunTimeInfo);
    });
  }
  removeItemsByPathStartWith(path) {
    const keys = Object.keys(this._map);
    const filteredKeys = keys.filter((key) => {
      if (this._map[key].path) {
        return this._map[key].path.indexOf(path, 0) > -1;
      }
      return false;
    });
    filteredKeys.forEach((key) => this.removeItemByKey(key));
  }
};

// node_modules/devextreme/esm/__internal/ui/form/m_form.layout_manager.js
var LayoutManager = class extends widget_default {
  _getDefaultOptions() {
    return _extends({}, super._getDefaultOptions(), {
      layoutData: {},
      readOnly: false,
      colCount: 1,
      labelLocation: "left",
      onFieldDataChanged: null,
      onEditorEnterKey: null,
      customizeItem: null,
      alignItemLabels: true,
      minColWidth: 200,
      showRequiredMark: true,
      screenByWidth: null,
      showOptionalMark: false,
      requiredMark: "*",
      labelMode: "outside",
      optionalMark: message_default.format("dxForm-optionalMark"),
      requiredMessage: message_default.getFormatter("dxForm-requiredMessage")
    });
  }
  _setOptionsByReference() {
    super._setOptionsByReference();
    extend(this._optionsByReference, {
      layoutData: true,
      validationGroup: true
    });
  }
  _init() {
    const layoutData = this.option("layoutData");
    super._init();
    this._itemWatchers = [];
    this._itemsRunTimeInfo = new FormItemsRunTimeInfo();
    this._updateReferencedOptions(layoutData);
    this._initDataAndItems(layoutData);
  }
  _dispose() {
    super._dispose();
    this._cleanItemWatchers();
  }
  _initDataAndItems(initialData) {
    this._syncDataWithItems();
    this._updateItems(initialData);
  }
  _syncDataWithItems() {
    const layoutData = this.option("layoutData");
    const userItems = this.option("items");
    if (isDefined(userItems)) {
      userItems.forEach((item) => {
        if (item.dataField && void 0 === this._getDataByField(item.dataField)) {
          let value2;
          if (item.editorOptions) {
            value2 = item.editorOptions.value;
          }
          if (isDefined(value2) || item.dataField in layoutData) {
            this._updateFieldValue(item.dataField, value2);
          }
        }
      });
    }
  }
  _getDataByField(dataField) {
    return dataField ? this.option(`layoutData.${dataField}`) : null;
  }
  _isCheckboxUndefinedStateEnabled(_ref) {
    let {
      allowIndeterminateState,
      editorType,
      dataField
    } = _ref;
    if (true === allowIndeterminateState && "dxCheckBox" === editorType) {
      const nameParts = ["layoutData", ...dataField.split(".")];
      const propertyName = nameParts.pop();
      const layoutData = this.option(nameParts.join("."));
      return layoutData && propertyName in layoutData;
    }
    return false;
  }
  _updateFieldValue(dataField, value2) {
    const layoutData = this.option("layoutData");
    let newValue = value2;
    if (!variable_wrapper_default.isWrapped(layoutData[dataField]) && isDefined(dataField)) {
      this.option(`layoutData.${dataField}`, newValue);
    } else if (variable_wrapper_default.isWritableWrapped(layoutData[dataField])) {
      newValue = isFunction(newValue) ? newValue() : newValue;
      layoutData[dataField](newValue);
    }
    this._triggerOnFieldDataChanged({
      dataField,
      value: newValue
    });
  }
  _triggerOnFieldDataChanged(args) {
    this._createActionByOption("onFieldDataChanged")(args);
  }
  _updateItems(layoutData) {
    const that = this;
    const userItems = this.option("items");
    const isUserItemsExist = isDefined(userItems);
    const {
      customizeItem
    } = this.option();
    const items = isUserItemsExist ? userItems : this._generateItemsByData(layoutData);
    if (isDefined(items)) {
      const processedItems = [];
      each(items, (index2, item) => {
        if (that._isAcceptableItem(item)) {
          item = that._processItem(item);
          customizeItem && customizeItem(item);
          if (isObject(item) && false !== variable_wrapper_default.unwrap(item.visible)) {
            processedItems.push(item);
          }
        }
      });
      if (!that._itemWatchers.length || !isUserItemsExist) {
        that._updateItemWatchers(items);
      }
      this._setItems(processedItems);
      this._sortItems();
    }
  }
  _cleanItemWatchers() {
    this._itemWatchers.forEach((dispose2) => {
      dispose2();
    });
    this._itemWatchers = [];
  }
  _updateItemWatchers(items) {
    const that = this;
    const watch = that._getWatch();
    items.forEach((item) => {
      if (isObject(item) && isDefined(item.visible) && isFunction(watch)) {
        that._itemWatchers.push(watch(() => variable_wrapper_default.unwrap(item.visible), () => {
          that._updateItems(that.option("layoutData"));
          that.repaint();
        }, {
          skipImmediate: true
        }));
      }
    });
  }
  _generateItemsByData(layoutData) {
    const result2 = [];
    if (isDefined(layoutData)) {
      each(layoutData, (dataField) => {
        result2.push({
          dataField
        });
      });
    }
    return result2;
  }
  _isAcceptableItem(item) {
    const itemField = item.dataField || item;
    const itemData = this._getDataByField(itemField);
    return !(isFunction(itemData) && !variable_wrapper_default.isWrapped(itemData));
  }
  _processItem(item) {
    if ("string" === typeof item) {
      item = {
        dataField: item
      };
    }
    if ("object" === typeof item && !item.itemType) {
      item.itemType = SIMPLE_ITEM_TYPE;
    }
    if (!isDefined(item.editorType) && isDefined(item.dataField)) {
      const value2 = this._getDataByField(item.dataField);
      item.editorType = isDefined(value2) ? this._getEditorTypeByDataType(type(value2)) : "dxTextBox";
    }
    if ("dxCheckBox" === item.editorType) {
      item.allowIndeterminateState = item.allowIndeterminateState ?? true;
    }
    return item;
  }
  _getEditorTypeByDataType(dataType) {
    switch (dataType) {
      case "number":
        return "dxNumberBox";
      case "date":
        return "dxDateBox";
      case "boolean":
        return "dxCheckBox";
      default:
        return "dxTextBox";
    }
  }
  _sortItems() {
    normalizeIndexes(this._items, "visibleIndex");
    this._sortIndexes();
  }
  _sortIndexes() {
    this._items.sort((itemA, itemB) => {
      const indexA = itemA.visibleIndex;
      const indexB = itemB.visibleIndex;
      let result2;
      if (indexA > indexB) {
        result2 = 1;
      } else if (indexA < indexB) {
        result2 = -1;
      } else {
        result2 = 0;
      }
      return result2;
    });
  }
  _initMarkup() {
    this._itemsRunTimeInfo.clear();
    this.$element().addClass(FORM_LAYOUT_MANAGER_CLASS);
    super._initMarkup();
    this._renderResponsiveBox();
  }
  _renderResponsiveBox() {
    const that = this;
    const templatesInfo = [];
    if (that._items && that._items.length) {
      const colCount = that._getColCount();
      const $container = renderer_default("<div>").appendTo(that.$element());
      that._prepareItemsWithMerging(colCount);
      const layoutItems = that._generateLayoutItems();
      that._responsiveBox = that._createComponent($container, m_responsive_box_default, that._getResponsiveBoxConfig(layoutItems, colCount, templatesInfo));
      if (!hasWindow()) {
        that._renderTemplates(templatesInfo);
      }
    }
  }
  _itemStateChangedHandler(e) {
    this._refresh();
  }
  _renderTemplates(templatesInfo) {
    const that = this;
    let itemsWithLabelTemplateCount = 0;
    templatesInfo.forEach((_ref2) => {
      var _item$label;
      let {
        item
      } = _ref2;
      if (null !== item && void 0 !== item && null !== (_item$label = item.label) && void 0 !== _item$label && _item$label.template) {
        itemsWithLabelTemplateCount++;
      }
    });
    each(templatesInfo, (index2, info) => {
      switch (info.itemType) {
        case "empty":
          renderEmptyItem(info);
          break;
        case "button":
          that._renderButtonItem(info);
          break;
        default:
          that._renderFieldItem(info, itemsWithLabelTemplateCount);
      }
    });
  }
  _getResponsiveBoxConfig(layoutItems, colCount, templatesInfo) {
    const that = this;
    const colCountByScreen = that.option("colCountByScreen");
    const xsColCount = colCountByScreen && colCountByScreen.xs;
    return {
      onItemStateChanged: this._itemStateChangedHandler.bind(this),
      onLayoutChanged() {
        const {
          onLayoutChanged
        } = that.option();
        const isSingleColumnMode = that.isSingleColumnMode();
        if (onLayoutChanged) {
          that.$element().toggleClass(LAYOUT_MANAGER_ONE_COLUMN, isSingleColumnMode);
          onLayoutChanged(isSingleColumnMode);
        }
      },
      onContentReady(e) {
        if (hasWindow()) {
          that._renderTemplates(templatesInfo);
        }
        if (that.option("onLayoutChanged")) {
          that.$element().toggleClass(LAYOUT_MANAGER_ONE_COLUMN, that.isSingleColumnMode(e.component));
        }
      },
      itemTemplate(e, itemData, itemElement) {
        if (!e.location) {
          return;
        }
        const $itemElement = renderer_default(itemElement);
        const itemRenderedCountInPreviousRows = e.location.row * colCount;
        const item = that._items[e.location.col + itemRenderedCountInPreviousRows];
        if (!item) {
          return;
        }
        const itemCssClassList = [item.cssClass];
        $itemElement.toggleClass(SINGLE_COLUMN_ITEM_CONTENT, that.isSingleColumnMode(this));
        if (0 === e.location.row) {
          itemCssClassList.push("dx-first-row");
        }
        if (0 === e.location.col) {
          itemCssClassList.push("dx-first-col");
        }
        if (item.itemType === SIMPLE_ITEM_TYPE && that.option("isRoot")) {
          $itemElement.addClass(ROOT_SIMPLE_ITEM_CLASS);
        }
        const isLastColumn = e.location.col === colCount - 1 || e.location.col + e.location.colspan === colCount;
        const rowsCount = that._getRowsCount();
        const isLastRow = e.location.row === rowsCount - 1;
        if (isLastColumn) {
          itemCssClassList.push("dx-last-col");
        }
        if (isLastRow) {
          itemCssClassList.push("dx-last-row");
        }
        if ("empty" !== item.itemType) {
          itemCssClassList.push(FIELD_ITEM_CLASS);
          itemCssClassList.push(that.option("cssItemClass"));
          if (isDefined(item.col)) {
            itemCssClassList.push(`dx-col-${item.col}`);
          }
        }
        templatesInfo.push({
          itemType: item.itemType,
          item,
          $parent: $itemElement,
          rootElementCssClassList: itemCssClassList
        });
      },
      cols: that._generateRatio(colCount),
      rows: that._generateRatio(that._getRowsCount(), true),
      dataSource: layoutItems,
      screenByWidth: that.option("screenByWidth"),
      singleColumnScreen: xsColCount ? false : "xs"
    };
  }
  _getColCount() {
    let {
      colCount
    } = this.option();
    const colCountByScreen = this.option("colCountByScreen");
    if (colCountByScreen) {
      const {
        form
      } = this.option();
      let screenFactor = null === form || void 0 === form ? void 0 : form.getTargetScreenFactor();
      if (!screenFactor) {
        screenFactor = hasWindow() ? getCurrentScreenFactor(this.option("screenByWidth")) : "lg";
      }
      colCount = colCountByScreen[screenFactor] || colCount;
    }
    if ("auto" === colCount) {
      if (this._cashedColCount) {
        return this._cashedColCount;
      }
      this._cashedColCount = colCount = this._getMaxColCount();
    }
    return colCount < 1 ? 1 : colCount;
  }
  _getMaxColCount() {
    if (!hasWindow()) {
      return 1;
    }
    const minColWidth = this.option("minColWidth");
    const width = getWidth(this.$element());
    const itemsCount = this._items.length;
    const maxColCount = Math.floor(width / minColWidth) || 1;
    return itemsCount < maxColCount ? itemsCount : maxColCount;
  }
  isCachedColCountObsolete() {
    return this._cashedColCount && this._getMaxColCount() !== this._cashedColCount;
  }
  _prepareItemsWithMerging(colCount) {
    const items = this._items.slice(0);
    let item;
    let itemsMergedByCol;
    let result2 = [];
    let j;
    let i;
    for (i = 0; i < items.length; i++) {
      item = items[i];
      result2.push(item);
      if (this.option("alignItemLabels") || item.alignItemLabels || item.colSpan) {
        item.col = this._getColByIndex(result2.length - 1, colCount);
      }
      if (item.colSpan > 1 && item.col + item.colSpan <= colCount) {
        itemsMergedByCol = [];
        for (j = 0; j < item.colSpan - 1; j++) {
          itemsMergedByCol.push({
            merged: true
          });
        }
        result2 = result2.concat(itemsMergedByCol);
      } else {
        delete item.colSpan;
      }
    }
    this._setItems(result2);
  }
  _getColByIndex(index2, colCount) {
    return index2 % colCount;
  }
  _setItems(items) {
    this._items = items;
    this._cashedColCount = null;
  }
  _generateLayoutItems() {
    const items = this._items;
    const colCount = this._getColCount();
    const result2 = [];
    let item;
    let i;
    for (i = 0; i < items.length; i++) {
      item = items[i];
      if (!item.merged) {
        const generatedItem = {
          location: {
            row: parseInt(i / colCount),
            col: this._getColByIndex(i, colCount)
          }
        };
        if (isDefined(item.disabled)) {
          generatedItem.disabled = item.disabled;
        }
        if (isDefined(item.visible)) {
          generatedItem.visible = item.visible;
        }
        if (isDefined(item.colSpan)) {
          generatedItem.location.colspan = item.colSpan;
        }
        if (isDefined(item.rowSpan)) {
          generatedItem.location.rowspan = item.rowSpan;
        }
        result2.push(generatedItem);
      }
    }
    return result2;
  }
  _renderEmptyItem($container) {
    renderEmptyItem({
      $container
    });
  }
  _renderButtonItem(_ref3) {
    let {
      item,
      $parent,
      rootElementCssClassList
    } = _ref3;
    const {
      $rootElement,
      buttonInstance
    } = renderButtonItem({
      item,
      $parent,
      rootElementCssClassList,
      validationGroup: this.option("validationGroup"),
      createComponentCallback: this._createComponent.bind(this)
    });
    this._itemsRunTimeInfo.add({
      item,
      widgetInstance: buttonInstance,
      guid: item.guid,
      $itemContainer: $rootElement
    });
  }
  _renderFieldItem(_ref4, itemsWithLabelTemplateCount) {
    var _item$label2;
    let {
      item,
      $parent,
      rootElementCssClassList
    } = _ref4;
    const editorValue = this._getDataByField(item.dataField);
    let canAssignUndefinedValueToEditor = false;
    if (void 0 === editorValue) {
      const {
        allowIndeterminateState,
        editorType,
        dataField
      } = item;
      canAssignUndefinedValueToEditor = this._isCheckboxUndefinedStateEnabled({
        allowIndeterminateState,
        editorType,
        dataField
      });
    }
    const name2 = item.dataField || item.name;
    const formOrLayoutManager = this._getFormOrThis();
    const {
      form
    } = this.option();
    const {
      $fieldEditorContainer,
      widgetInstance,
      $rootElement
    } = renderFieldItem(convertToRenderFieldItemOptions({
      $parent,
      rootElementCssClassList,
      item,
      name: name2,
      editorValue,
      canAssignUndefinedValueToEditor,
      formOrLayoutManager: this._getFormOrThis(),
      createComponentCallback: this._createComponent.bind(this),
      formLabelLocation: this.option("labelLocation"),
      requiredMessageTemplate: this.option("requiredMessage"),
      validationGroup: this.option("validationGroup"),
      editorValidationBoundary: this.option("validationBoundary"),
      editorStylingMode: null === form || void 0 === form ? void 0 : form.option("stylingMode"),
      showColonAfterLabel: this.option("showColonAfterLabel"),
      managerLabelLocation: this.option("labelLocation"),
      template: item.template ? this._getTemplate(item.template) : null,
      labelTemplate: null !== (_item$label2 = item.label) && void 0 !== _item$label2 && _item$label2.template ? this._getTemplate(item.label.template) : null,
      itemId: null === form || void 0 === form ? void 0 : form.getItemID(name2),
      managerMarkOptions: this._getMarkOptions(),
      labelMode: this.option("labelMode"),
      onLabelTemplateRendered: () => {
        this._incTemplateRenderedCallCount();
        if (this._shouldAlignLabelsOnTemplateRendered(formOrLayoutManager, itemsWithLabelTemplateCount)) {
          formOrLayoutManager._alignLabels(this, this.isSingleColumnMode(formOrLayoutManager));
        }
      }
    }));
    const {
      onFieldItemRendered
    } = this.option();
    null === onFieldItemRendered || void 0 === onFieldItemRendered || onFieldItemRendered();
    if (widgetInstance && item.dataField) {
      this._bindDataField(widgetInstance, item.dataField, item.editorType, $fieldEditorContainer);
    }
    this._itemsRunTimeInfo.add({
      item,
      widgetInstance,
      guid: item.guid,
      $itemContainer: $rootElement
    });
  }
  _incTemplateRenderedCallCount() {
    this._labelTemplateRenderedCallCount = (this._labelTemplateRenderedCallCount ?? 0) + 1;
  }
  _shouldAlignLabelsOnTemplateRendered(formOrLayoutManager, totalItemsWithLabelTemplate) {
    return formOrLayoutManager.option("templatesRenderAsynchronously") && this._labelTemplateRenderedCallCount === totalItemsWithLabelTemplate;
  }
  _getMarkOptions() {
    return {
      showRequiredMark: this.option("showRequiredMark"),
      requiredMark: this.option("requiredMark"),
      showOptionalMark: this.option("showOptionalMark"),
      optionalMark: this.option("optionalMark")
    };
  }
  _getFormOrThis() {
    const {
      form
    } = this.option();
    return form || this;
  }
  _bindDataField(editorInstance, dataField, editorType, $container) {
    const formOrThis = this._getFormOrThis();
    editorInstance.on("enterKey", (args) => {
      formOrThis._createActionByOption("onEditorEnterKey")(extend(args, {
        dataField
      }));
    });
    this._createWatcher(editorInstance, $container, dataField);
    this.linkEditorToDataField(editorInstance, dataField);
  }
  _createWatcher(editorInstance, $container, dataField) {
    const that = this;
    const watch = that._getWatch();
    if (!isFunction(watch)) {
      return;
    }
    const dispose2 = watch(() => that._getDataByField(dataField), () => {
      const fieldValue = that._getDataByField(dataField);
      if ("dxTagBox" === editorInstance.NAME) {
        const editorValue = editorInstance.option("value");
        if (fieldValue !== editorValue && function(array1, array2) {
          if (!Array.isArray(array1) || !Array.isArray(array2) || array1.length !== array2.length) {
            return false;
          }
          for (let i = 0; i < array1.length; i++) {
            if (array1[i] !== array2[i]) {
              return false;
            }
          }
          return true;
        }(fieldValue, editorValue)) {
          return;
        }
      }
      editorInstance.option("value", fieldValue);
    }, {
      deep: true,
      skipImmediate: true
    }, {
      createWatcherDataField: dataField
    });
    m_events_engine_default.on($container, removeEvent, dispose2);
  }
  _getWatch() {
    if (!isDefined(this._watch)) {
      const {
        form: formInstance
      } = this.option();
      this._watch = formInstance && formInstance.option("integrationOptions.watchMethod");
    }
    return this._watch;
  }
  _createComponent($editor, type2, editorOptions) {
    const readOnlyState = this.option("readOnly");
    let hasEditorReadOnly = Object.hasOwn(editorOptions, "readOnly");
    const instance = super._createComponent($editor, type2, _extends({}, editorOptions, {
      readOnly: !hasEditorReadOnly ? readOnlyState : editorOptions.readOnly
    }));
    let isChangeByForm = false;
    instance.on("optionChanged", (args) => {
      if ("readOnly" === args.name && !isChangeByForm) {
        hasEditorReadOnly = true;
      }
    });
    this.on("optionChanged", (args) => {
      if ("readOnly" === args.name && !hasEditorReadOnly) {
        isChangeByForm = true;
        instance.option(args.name, args.value);
        isChangeByForm = false;
      }
    });
    return instance;
  }
  _generateRatio(count, isAutoSize) {
    const result2 = [];
    let ratio;
    let i;
    for (i = 0; i < count; i++) {
      ratio = {
        ratio: 1
      };
      if (isAutoSize) {
        ratio.baseSize = "auto";
      }
      result2.push(ratio);
    }
    return result2;
  }
  _getRowsCount() {
    return Math.ceil(this._items.length / this._getColCount());
  }
  _updateReferencedOptions(newLayoutData) {
    const layoutData = this.option("layoutData");
    if (isObject(layoutData)) {
      Object.getOwnPropertyNames(layoutData).forEach((property) => delete this._optionsByReference[`layoutData.${property}`]);
    }
    if (isObject(newLayoutData)) {
      Object.getOwnPropertyNames(newLayoutData).forEach((property) => this._optionsByReference[`layoutData.${property}`] = true);
    }
  }
  _clearWidget(instance) {
    this._disableEditorValueChangedHandler = true;
    instance.clear();
    this._disableEditorValueChangedHandler = false;
    instance.option("isValid", true);
  }
  _optionChanged(args) {
    if (0 === args.fullName.search("layoutData.")) {
      return;
    }
    switch (args.name) {
      case "showRequiredMark":
      case "showOptionalMark":
      case "requiredMark":
      case "optionalMark":
      case "alignItemLabels":
      case "labelLocation":
      case "labelMode":
      case "requiredMessage":
        this._invalidate();
        break;
      case "layoutData":
        this._updateReferencedOptions(args.value);
        if (this.option("items")) {
          if (!isEmptyObject(args.value)) {
            this._itemsRunTimeInfo.each((_, itemRunTimeInfo) => {
              if (isDefined(itemRunTimeInfo.item)) {
                const {
                  dataField
                } = itemRunTimeInfo.item;
                if (dataField && isDefined(itemRunTimeInfo.widgetInstance)) {
                  const valueGetter = compileGetter(dataField);
                  const dataValue = valueGetter(args.value);
                  const {
                    allowIndeterminateState,
                    editorType
                  } = itemRunTimeInfo.item;
                  if (void 0 !== dataValue || this._isCheckboxUndefinedStateEnabled({
                    allowIndeterminateState,
                    editorType,
                    dataField
                  })) {
                    itemRunTimeInfo.widgetInstance.option("value", dataValue);
                  } else {
                    this._clearWidget(itemRunTimeInfo.widgetInstance);
                  }
                }
              }
            });
          }
        } else {
          this._initDataAndItems(args.value);
          this._invalidate();
        }
        break;
      case "items":
        this._cleanItemWatchers();
        this._initDataAndItems(args.value);
        this._invalidate();
        break;
      case "customizeItem":
        this._updateItems(this.option("layoutData"));
        this._invalidate();
        break;
      case "colCount":
      case "colCountByScreen":
        this._resetColCount();
        break;
      case "minColWidth": {
        const {
          colCount
        } = this.option();
        if ("auto" === colCount) {
          this._resetColCount();
        }
        break;
      }
      case "readOnly":
      case "onFieldDataChanged":
        break;
      case "width": {
        super._optionChanged(args);
        const {
          colCount
        } = this.option();
        if ("auto" === colCount) {
          this._resetColCount();
        }
        break;
      }
      default:
        super._optionChanged(args);
    }
  }
  _resetColCount() {
    this._cashedColCount = null;
    this._invalidate();
  }
  linkEditorToDataField(editorInstance, dataField) {
    this.on("optionChanged", (args) => {
      if (args.fullName === `layoutData.${dataField}`) {
        editorInstance._setOptionWithoutOptionChange("value", args.value);
      }
    });
    editorInstance.on("valueChanged", (args) => {
      const isValueReferenceType = isObject(args.value) || Array.isArray(args.value);
      if (!this._disableEditorValueChangedHandler && !(isValueReferenceType && args.value === args.previousValue)) {
        this._updateFieldValue(dataField, args.value);
      }
    });
  }
  _dimensionChanged() {
    const {
      colCount
    } = this.option();
    if ("auto" === colCount && this.isCachedColCountObsolete()) {
      this._eventsStrategy.fireEvent("autoColCountChanged");
    }
  }
  updateData(data17, value2) {
    const that = this;
    if (isObject(data17)) {
      each(data17, (dataField, fieldValue) => {
        that._updateFieldValue(dataField, fieldValue);
      });
    } else if ("string" === typeof data17) {
      that._updateFieldValue(data17, value2);
    }
  }
  getEditor(field) {
    return this._itemsRunTimeInfo.findWidgetInstanceByDataField(field) || this._itemsRunTimeInfo.findWidgetInstanceByName(field);
  }
  isSingleColumnMode(component) {
    const responsiveBox = this._responsiveBox || component;
    if (responsiveBox) {
      return responsiveBox.option("currentScreenFactor") === responsiveBox.option("singleColumnScreen");
    }
  }
  getItemsRunTimeInfo() {
    return this._itemsRunTimeInfo;
  }
};
component_registrator_default("dxLayoutManager", LayoutManager);

// node_modules/devextreme/esm/ui/collection/ui.collection_widget.live_update.js
var ui_collection_widget_live_update_default = m_collection_widget_live_update_default;

// node_modules/devextreme/esm/__internal/ui/multi_view/m_multi_view.animation.js
var _translator = {
  move($element, position3) {
    move($element, {
      left: position3
    });
  }
};
var animation2 = {
  moveTo($element, position3, duration, completeAction) {
    fx_default.animate($element, {
      type: "slide",
      to: {
        left: position3
      },
      duration,
      complete: completeAction
    });
  },
  complete($element) {
    fx_default.stop($element, true);
  }
};

// node_modules/devextreme/esm/__internal/ui/m_multi_view.js
var toNumber2 = (value2) => +value2;
var position2 = ($element) => locate($element).left;
var MultiView = class extends ui_collection_widget_live_update_default {
  _supportedKeys() {
    return _extends({}, super._supportedKeys(), {
      pageUp: noop2,
      pageDown: noop2
    });
  }
  _getDefaultOptions() {
    return _extends({}, super._getDefaultOptions(), {
      selectedIndex: 0,
      swipeEnabled: true,
      animationEnabled: true,
      loop: false,
      deferRendering: true,
      loopItemFocus: false,
      selectOnFocus: true,
      selectionMode: "single",
      selectionRequired: true,
      selectByClick: false
    });
  }
  _defaultOptionsRules() {
    return super._defaultOptionsRules().concat([{
      device: () => "desktop" === devices_default.real().deviceType && !devices_default.isSimulator(),
      options: {
        focusStateEnabled: true
      }
    }]);
  }
  _itemClass() {
    return "dx-multiview-item";
  }
  _itemDataKey() {
    return "dxMultiViewItemData";
  }
  _itemContainer() {
    return this._$itemContainer;
  }
  _itemElements() {
    return this._itemContainer().children(this._itemSelector());
  }
  _itemWidth() {
    if (!this._itemWidthValue) {
      this._itemWidthValue = getWidth(this._$wrapper);
    }
    return this._itemWidthValue;
  }
  _clearItemWidthCache() {
    delete this._itemWidthValue;
  }
  _itemsCount() {
    return this.option("items").length;
  }
  _isAllItemsHidden() {
    const {
      items
    } = this.option();
    return items.every((_, index2) => !this._isItemVisible(index2));
  }
  _normalizeIndex(index2, direction) {
    let loop = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : true;
    const count = this._itemsCount();
    if (this._isAllItemsHidden()) {
      return;
    }
    if (index2 < 0) {
      index2 += count;
    }
    if (index2 >= count) {
      index2 -= count;
    }
    const step = direction > 0 ? -1 : 1;
    const lastNotLoopedIndex = -1 === step ? 0 : count - 1;
    while (!this._isItemVisible(index2) && (loop || index2 !== lastNotLoopedIndex)) {
      index2 = (index2 + step + count) % count;
    }
    return index2;
  }
  _getRTLSignCorrection() {
    return this.option("rtlEnabled") ? -1 : 1;
  }
  _init() {
    super._init.apply(this, arguments);
    this._activeStateUnit = ".dx-multiview-item";
    const $element = this.$element();
    $element.addClass("dx-multiview");
    this._$wrapper = renderer_default("<div>").addClass("dx-multiview-wrapper");
    this._$wrapper.appendTo($element);
    this._$itemContainer = renderer_default("<div>").addClass("dx-multiview-item-container");
    this._$itemContainer.appendTo(this._$wrapper);
    this.option("loopItemFocus", this.option("loop"));
    this._findBoundaryIndices();
    this._initSwipeable();
  }
  _ensureSelectedItemIsVisible() {
    const {
      loop,
      selectedIndex: currentSelectedIndex
    } = this.option();
    if (this._isItemVisible(currentSelectedIndex)) {
      return;
    }
    if (this._isAllItemsHidden()) {
      this.option("selectedIndex", 0);
      return;
    }
    const direction = -1 * this._getRTLSignCorrection();
    let newSelectedIndex = this._normalizeIndex(currentSelectedIndex, direction, loop);
    if (newSelectedIndex === currentSelectedIndex) {
      newSelectedIndex = this._normalizeIndex(currentSelectedIndex, -direction, loop);
    }
    this.option("selectedIndex", newSelectedIndex);
  }
  _initMarkup() {
    this._deferredItems = [];
    super._initMarkup();
    this._ensureSelectedItemIsVisible();
    const selectedItemIndices = this._getSelectedItemIndices();
    this._updateItemsVisibility(selectedItemIndices[0]);
    this._setElementAria();
    this._setItemsAria();
  }
  _afterItemElementDeleted($item, deletedActionArgs) {
    super._afterItemElementDeleted($item, deletedActionArgs);
    if (this._deferredItems) {
      this._deferredItems.splice(deletedActionArgs.itemIndex, 1);
    }
  }
  _beforeItemElementInserted(change) {
    super._beforeItemElementInserted.apply(this, arguments);
    if (this._deferredItems) {
      this._deferredItems.splice(change.index, 0, null);
    }
  }
  _executeItemRenderAction(index2, itemData, itemElement) {
    index2 = (this.option("items") || []).indexOf(itemData);
    super._executeItemRenderAction(index2, itemData, itemElement);
  }
  _renderItemContent(args) {
    const renderContentDeferred = Deferred();
    const that = this;
    const deferred = Deferred();
    deferred.done(() => {
      const $itemContent = super._renderItemContent.call(that, args);
      renderContentDeferred.resolve($itemContent);
    });
    this._deferredItems[args.index] = deferred;
    this.option("deferRendering") || deferred.resolve();
    return renderContentDeferred.promise();
  }
  _render() {
    super._render();
    deferRender(() => {
      const selectedItemIndices = this._getSelectedItemIndices();
      this._updateItems(selectedItemIndices[0]);
    });
  }
  _getElementAria() {
    return {
      role: "group",
      roledescription: message_default.format("dxMultiView-elementAriaRoleDescription"),
      label: message_default.format("dxMultiView-elementAriaLabel")
    };
  }
  _setElementAria() {
    const aria = this._getElementAria();
    this.setAria(aria, this.$element());
  }
  _setItemsAria() {
    const $itemElements = this._itemElements();
    const itemsCount = this._itemsCount();
    $itemElements.each((itemIndex, item) => {
      const aria = this._getItemAria({
        itemIndex,
        itemsCount
      });
      this.setAria(aria, renderer_default(item));
    });
  }
  _getItemAria(args) {
    const {
      itemIndex,
      itemsCount
    } = args;
    const aria = {
      role: "group",
      roledescription: message_default.format("dxMultiView-itemAriaRoleDescription"),
      label: message_default.format("dxMultiView-itemAriaLabel", itemIndex + 1, itemsCount)
    };
    return aria;
  }
  _updateItems(selectedIndex, newIndex) {
    this._updateItemsPosition(selectedIndex, newIndex);
    this._updateItemsVisibility(selectedIndex, newIndex);
  }
  _modifyByChanges() {
    super._modifyByChanges.apply(this, arguments);
    const selectedItemIndices = this._getSelectedItemIndices();
    this._updateItemsVisibility(selectedItemIndices[0]);
  }
  _updateItemsPosition(selectedIndex, newIndex) {
    const $itemElements = this._itemElements();
    const positionSign = isDefined(newIndex) ? -this._animationDirection(newIndex, selectedIndex) : void 0;
    const $selectedItem = $itemElements.eq(selectedIndex);
    _translator.move($selectedItem, 0);
    if (isDefined(newIndex)) {
      _translator.move($itemElements.eq(newIndex), 100 * positionSign + "%");
    }
  }
  _isItemVisible(index2) {
    var _this$option$index;
    return (null === (_this$option$index = this.option("items")[index2]) || void 0 === _this$option$index ? void 0 : _this$option$index.visible) ?? true;
  }
  _updateItemsVisibility(selectedIndex, newIndex) {
    const $itemElements = this._itemElements();
    $itemElements.each((itemIndex, item) => {
      const $item = renderer_default(item);
      const isHidden = itemIndex !== selectedIndex && itemIndex !== newIndex;
      if (!isHidden) {
        this._renderSpecificItem(itemIndex);
      }
      $item.toggleClass("dx-multiview-item-hidden", isHidden);
      this.setAria("hidden", isHidden || void 0, $item);
    });
  }
  _renderSpecificItem(index2) {
    const $item = this._itemElements().eq(index2);
    const hasItemContent = $item.find(this._itemContentClass()).length > 0;
    if (isDefined(index2) && !hasItemContent) {
      this._deferredItems[index2].resolve();
      triggerResizeEvent2($item);
    }
  }
  _refreshItem($item, item) {
    super._refreshItem($item, item);
    this._updateItemsVisibility(this.option("selectedIndex"));
  }
  _setAriaSelectionAttribute() {
  }
  _updateSelection(addedSelection, removedSelection) {
    const newIndex = addedSelection[0];
    const prevIndex = removedSelection[0];
    animation2.complete(this._$itemContainer);
    this._updateItems(prevIndex, newIndex);
    const animationDirection = this._animationDirection(newIndex, prevIndex);
    this._animateItemContainer(animationDirection * this._itemWidth(), () => {
      _translator.move(this._$itemContainer, 0);
      this._updateItems(newIndex);
      getWidth(this._$itemContainer);
    });
  }
  _animateItemContainer(position3, completeCallback) {
    const duration = this.option("animationEnabled") ? 200 : 0;
    animation2.moveTo(this._$itemContainer, position3, duration, completeCallback);
  }
  _animationDirection(newIndex, prevIndex) {
    const containerPosition = position2(this._$itemContainer);
    const indexDifference = (prevIndex - newIndex) * this._getRTLSignCorrection() * this._getItemFocusLoopSignCorrection();
    const isSwipePresent = 0 !== containerPosition;
    const directionSignVariable = isSwipePresent ? containerPosition : indexDifference;
    return sign(directionSignVariable);
  }
  _getSwipeDisabledState() {
    return !this.option("swipeEnabled") || this._itemsCount() <= 1;
  }
  _initSwipeable() {
    this._createComponent(this.$element(), m_swipeable_default, {
      disabled: this._getSwipeDisabledState(),
      elastic: false,
      itemSizeFunc: this._itemWidth.bind(this),
      onStart: (args) => this._swipeStartHandler(args.event),
      onUpdated: (args) => this._swipeUpdateHandler(args.event),
      onEnd: (args) => this._swipeEndHandler(args.event)
    });
  }
  _findBoundaryIndices() {
    const items = this.option("items");
    let firstIndex;
    let lastIndex;
    items.forEach((item, index2) => {
      const isDisabled = Boolean(null === item || void 0 === item ? void 0 : item.disabled);
      const isVisible2 = this._isItemVisible(index2);
      if (!isDisabled && isVisible2) {
        firstIndex ?? (firstIndex = index2);
        lastIndex = index2;
      }
    });
    this._boundaryIndices = {
      firstAvailableIndex: firstIndex ?? 0,
      lastAvailableIndex: lastIndex ?? items.length - 1,
      firstTrueIndex: 0,
      lastTrueIndex: items.length - 1
    };
  }
  _swipeStartHandler(e) {
    animation2.complete(this._$itemContainer);
    const selectedIndex = this.option("selectedIndex");
    const loop = this.option("loop");
    const {
      firstAvailableIndex,
      lastAvailableIndex
    } = this._boundaryIndices;
    const rtl = this.option("rtlEnabled");
    e.maxLeftOffset = toNumber2(loop || (rtl ? selectedIndex > firstAvailableIndex : selectedIndex < lastAvailableIndex));
    e.maxRightOffset = toNumber2(loop || (rtl ? selectedIndex < lastAvailableIndex : selectedIndex > firstAvailableIndex));
  }
  _swipeUpdateHandler(e) {
    const {
      offset: offset2
    } = e;
    const swipeDirection = sign(offset2) * this._getRTLSignCorrection();
    const selectedIndex = this.option("selectedIndex");
    const newIndex = this._normalizeIndex(selectedIndex - swipeDirection, swipeDirection);
    if (selectedIndex === newIndex) {
      return;
    }
    _translator.move(this._$itemContainer, offset2 * this._itemWidth());
    this._updateItems(selectedIndex, newIndex);
  }
  _findNextAvailableIndex(index2, offset2) {
    const {
      items,
      loop
    } = this.option();
    const {
      firstAvailableIndex,
      lastAvailableIndex,
      firstTrueIndex,
      lastTrueIndex
    } = this._boundaryIndices;
    const isFirstActive = [firstTrueIndex, firstAvailableIndex].includes(index2);
    const isLastActive = [lastTrueIndex, lastAvailableIndex].includes(index2);
    if (loop) {
      if (isFirstActive && offset2 < 0) {
        return lastAvailableIndex;
      }
      if (isLastActive && offset2 > 0) {
        return firstAvailableIndex;
      }
    }
    for (let i = index2 + offset2; i >= firstAvailableIndex && i <= lastAvailableIndex; i += offset2) {
      const isDisabled = Boolean(items[i].disabled);
      const isVisible2 = this._isItemVisible(i);
      if (!isDisabled && isVisible2) {
        return i;
      }
    }
    return index2;
  }
  _postprocessSwipe(args) {
  }
  _swipeEndHandler(e) {
    const targetOffset = e.targetOffset * this._getRTLSignCorrection();
    if (targetOffset) {
      const newSelectedIndex = this._findNextAvailableIndex(this.option("selectedIndex"), -targetOffset);
      this.selectItem(newSelectedIndex).fail(() => {
        this._animateItemContainer(0, noop2);
      }).done(() => {
        this._postprocessSwipe({
          swipedTabsIndex: newSelectedIndex
        });
      });
      const $selectedElement = this.itemElements().filter(".dx-item-selected");
      this.option("focusStateEnabled") && this.option("focusedElement", getPublicElement($selectedElement));
    } else {
      this._animateItemContainer(0, noop2);
    }
  }
  _getItemFocusLoopSignCorrection() {
    return this._itemFocusLooped ? -1 : 1;
  }
  _moveFocus() {
    super._moveFocus.apply(this, arguments);
    this._itemFocusLooped = false;
  }
  _prevItem($items) {
    const $result = super._prevItem.apply(this, arguments);
    this._itemFocusLooped = $result.is($items.last());
    return $result;
  }
  _nextItem($items) {
    const $result = super._nextItem.apply(this, arguments);
    this._itemFocusLooped = $result.is($items.first());
    return $result;
  }
  _dimensionChanged() {
    this._clearItemWidthCache();
  }
  _visibilityChanged(visible2) {
    if (visible2) {
      this._dimensionChanged();
    }
  }
  _updateSwipeDisabledState() {
    const disabled = this._getSwipeDisabledState();
    m_swipeable_default.getInstance(this.$element()).option("disabled", disabled);
  }
  _dispose() {
    delete this._boundaryIndices;
    super._dispose();
  }
  _itemOptionChanged(item, property) {
    super._itemOptionChanged(...arguments);
    const {
      selectedItem
    } = this.option();
    if ("visible" === property && item === selectedItem) {
      this._ensureSelectedItemIsVisible();
    }
  }
  _optionChanged(args) {
    const {
      value: value2
    } = args;
    switch (args.name) {
      case "loop":
        this.option("loopItemFocus", value2);
        break;
      case "animationEnabled":
        break;
      case "swipeEnabled":
        this._updateSwipeDisabledState();
        break;
      case "deferRendering":
        this._invalidate();
        break;
      case "items":
        this._updateSwipeDisabledState();
        this._findBoundaryIndices();
        super._optionChanged(args);
        break;
      case "selectedIndex":
        if (this._isItemVisible(value2)) {
          super._optionChanged(args);
        } else {
          this._ensureSelectedItemIsVisible();
        }
        break;
      default:
        super._optionChanged(args);
    }
  }
};
component_registrator_default("dxMultiView", MultiView);
var m_multi_view_default = MultiView;

// node_modules/devextreme/esm/__internal/ui/scroll_view/utils/get_scroll_left_max.js
function getScrollLeftMax(element) {
  return element.scrollWidth - element.clientWidth;
}

// node_modules/devextreme/esm/__internal/ui/scroll_view/utils/get_scroll_top_max.js
function getScrollTopMax(element) {
  return element.scrollHeight - element.clientHeight;
}

// node_modules/devextreme/esm/__internal/ui/scroll_view/utils/get_boundary_props.js
function isReachedLeft(scrollOffsetLeft, epsilon) {
  return Math.round(scrollOffsetLeft) <= epsilon;
}
function isReachedRight(element, scrollOffsetLeft, epsilon) {
  return Math.round(getScrollLeftMax(element) - scrollOffsetLeft) <= epsilon;
}
function isReachedTop(scrollOffsetTop, epsilon) {
  return Math.round(scrollOffsetTop) <= epsilon;
}
function isReachedBottom(element, scrollOffsetTop, pocketHeight, epsilon) {
  return Math.round(getScrollTopMax(element) - scrollOffsetTop - pocketHeight) <= epsilon;
}

// node_modules/devextreme/esm/__internal/ui/tabs/constants.js
var TABS_EXPANDED_CLASS = "dx-tabs-expanded";

// node_modules/devextreme/esm/__internal/ui/tabs/item.js
var TabsItem = class extends item_default {
  _renderWatchers() {
    super._renderWatchers();
    this._startWatcher("badge", this._renderBadge.bind(this));
  }
  _renderBadge(badge) {
    this._$element.children(".dx-badge").remove();
    if (!badge) {
      return;
    }
    const $badge = renderer_default("<div>").addClass("dx-tabs-item-badge").addClass("dx-badge").text(badge);
    this._$element.append($badge);
  }
};
var item_default2 = TabsItem;

// node_modules/devextreme/esm/__internal/ui/tabs/tabs.js
var TABS_ITEM_TEXT_CLASS = "dx-tab-text";
var TABS_ITEM_TEXT_SPAN_CLASS = "dx-tab-text-span";
var TABS_ITEM_TEXT_SPAN_PSEUDO_CLASS = "dx-tab-text-span-pseudo";
var TABS_ORIENTATION_CLASS = {
  vertical: "dx-tabs-vertical",
  horizontal: "dx-tabs-horizontal"
};
var TABS_INDICATOR_POSITION_CLASS = {
  top: "dx-tab-indicator-position-top",
  right: "dx-tab-indicator-position-right",
  bottom: "dx-tab-indicator-position-bottom",
  left: "dx-tab-indicator-position-left"
};
var TABS_ICON_POSITION_CLASS = {
  top: "dx-tabs-icon-position-top",
  end: "dx-tabs-icon-position-end",
  bottom: "dx-tabs-icon-position-bottom",
  start: "dx-tabs-icon-position-start"
};
var TABS_STYLING_MODE_CLASS = {
  primary: "dx-tabs-styling-mode-primary",
  secondary: "dx-tabs-styling-mode-secondary"
};
var ORIENTATION = {
  horizontal: "horizontal",
  vertical: "vertical"
};
var INDICATOR_POSITION = {
  top: "top",
  right: "right",
  bottom: "bottom",
  left: "left"
};
var SCROLLABLE_DIRECTION = {
  horizontal: "horizontal",
  vertical: "vertical"
};
var ICON_POSITION = {
  top: "top",
  end: "end",
  bottom: "bottom",
  start: "start"
};
var STYLING_MODE = {
  primary: "primary",
  secondary: "secondary"
};
var Tabs = class extends ui_collection_widget_live_update_default {
  _getDefaultOptions() {
    return _extends({}, super._getDefaultOptions(), {
      hoverStateEnabled: true,
      showNavButtons: true,
      scrollByContent: true,
      scrollingEnabled: true,
      selectionMode: "single",
      orientation: ORIENTATION.horizontal,
      iconPosition: ICON_POSITION.start,
      stylingMode: STYLING_MODE.primary,
      activeStateEnabled: true,
      selectionRequired: false,
      selectOnFocus: true,
      loopItemFocus: false,
      useInkRipple: false,
      badgeExpr: (data17) => null === data17 || void 0 === data17 ? void 0 : data17.badge,
      _itemAttributes: {
        role: "tab"
      },
      _indicatorPosition: null
    });
  }
  _defaultOptionsRules() {
    const themeName = current();
    return super._defaultOptionsRules().concat([{
      device: () => "desktop" !== devices_default.real().deviceType,
      options: {
        showNavButtons: false
      }
    }, {
      device: {
        deviceType: "desktop"
      },
      options: {
        scrollByContent: false
      }
    }, {
      device: () => "desktop" === devices_default.real().deviceType && !devices_default.isSimulator(),
      options: {
        focusStateEnabled: true
      }
    }, {
      device: () => isFluent(themeName),
      options: {
        iconPosition: ICON_POSITION.top,
        stylingMode: STYLING_MODE.secondary
      }
    }, {
      device: () => isMaterial(themeName),
      options: {
        useInkRipple: true,
        selectOnFocus: false,
        iconPosition: ICON_POSITION.top
      }
    }]);
  }
  _init() {
    const {
      orientation,
      stylingMode,
      scrollingEnabled
    } = this.option();
    const indicatorPosition = this._getIndicatorPosition();
    super._init();
    this._activeStateUnit = ".dx-tab";
    this.setAria("role", "tablist");
    this.$element().addClass("dx-tabs");
    this._toggleScrollingEnabledClass(scrollingEnabled);
    this._toggleOrientationClass(orientation);
    this._toggleIndicatorPositionClass(indicatorPosition);
    this._toggleIconPositionClass();
    this._toggleStylingModeClass(stylingMode);
    this._renderWrapper();
    this._renderMultiple();
    this._feedbackHideTimeout = 100;
  }
  _prepareDefaultItemTemplate(data17, $container) {
    const text = isPlainObject(data17) ? null === data17 || void 0 === data17 ? void 0 : data17.text : data17;
    if (isDefined(text)) {
      const $tabTextSpan = renderer_default("<span>").addClass("dx-tab-text-span");
      $tabTextSpan.text(text);
      const $tabTextSpanPseudo = renderer_default("<span>").addClass("dx-tab-text-span-pseudo");
      $tabTextSpanPseudo.text(text);
      $tabTextSpanPseudo.appendTo($tabTextSpan);
      $tabTextSpan.appendTo($container);
    }
    if (isDefined(data17.html)) {
      $container.html(data17.html);
    }
  }
  _initTemplates() {
    super._initTemplates();
    this._templateManager.addDefaultTemplates({
      item: new BindableTemplate(($container, data17) => {
        this._prepareDefaultItemTemplate(data17, $container);
        const $iconElement = getImageContainer(data17.icon);
        if ($iconElement) {
          $iconElement.prependTo($container);
        }
        const $tabItem = renderer_default("<div>").addClass("dx-tab-text");
        $container.wrapInner($tabItem);
      }, ["text", "html", "icon"], this.option("integrationOptions.watchMethod"))
    });
  }
  _itemClass() {
    return "dx-tab";
  }
  _selectedItemClass() {
    return "dx-tab-selected";
  }
  _itemDataKey() {
    return "dxTabData";
  }
  _initMarkup() {
    super._initMarkup();
    if (this.option("useInkRipple")) {
      this._renderInkRipple();
    }
    this.$element().addClass("dx-overflow-hidden");
    this._attachResizeObserverSubscription();
  }
  _postProcessRenderItems() {
    this._renderScrolling();
  }
  _renderScrolling() {
    const removeClasses = ["dx-tabs-stretched", TABS_EXPANDED_CLASS, "dx-overflow-hidden"];
    this.$element().removeClass(removeClasses.join(" "));
    if (this.option("scrollingEnabled") && this._isItemsSizeExceeded()) {
      if (!this._scrollable) {
        this._renderScrollable();
        this._renderNavButtons();
      }
      const scrollable = this.getScrollable();
      null === scrollable || void 0 === scrollable || scrollable.update();
      if (this.option("rtlEnabled")) {
        const maxLeftOffset = getScrollLeftMax(renderer_default(this.getScrollable().container()).get(0));
        null === scrollable || void 0 === scrollable || scrollable.scrollTo({
          left: maxLeftOffset
        });
      }
      this._updateNavButtonsState();
      const {
        selectedItem
      } = this.option();
      this._scrollToItem(selectedItem);
    }
    if (!(this.option("scrollingEnabled") && this._isItemsSizeExceeded())) {
      this._cleanScrolling();
      if (this._needStretchItems()) {
        this.$element().addClass("dx-tabs-stretched");
      }
      this.$element().removeClass("dx-tabs-nav-buttons").addClass(TABS_EXPANDED_CLASS);
    }
  }
  _isVertical() {
    const {
      orientation
    } = this.option();
    return orientation === ORIENTATION.vertical;
  }
  _isItemsSizeExceeded() {
    const isVertical = this._isVertical();
    return isVertical ? this._isItemsHeightExceeded() : this._isItemsWidthExceeded();
  }
  _isItemsWidthExceeded() {
    const $visibleItems = this._getVisibleItems();
    const tabItemTotalWidth = this._getSummaryItemsSize("width", $visibleItems, true);
    const elementWidth = getWidth(this.$element());
    if ([tabItemTotalWidth, elementWidth].includes(0)) {
      return false;
    }
    return tabItemTotalWidth > elementWidth - 1;
  }
  _isItemsHeightExceeded() {
    const $visibleItems = this._getVisibleItems();
    const itemsHeight = this._getSummaryItemsSize("height", $visibleItems, true);
    const elementHeight = getHeight(this.$element());
    return itemsHeight - 1 > elementHeight;
  }
  _needStretchItems() {
    const $visibleItems = this._getVisibleItems();
    const elementWidth = getWidth(this.$element());
    const itemsWidth = [];
    each($visibleItems, (_, item) => {
      itemsWidth.push(getOuterWidth(item, true));
    });
    const maxTabItemWidth = Math.max.apply(null, itemsWidth);
    const requireWidth = elementWidth / $visibleItems.length;
    return maxTabItemWidth > requireWidth + 1;
  }
  _cleanNavButtons() {
    if (!this._leftButton || !this._rightButton) {
      return;
    }
    this._leftButton.$element().remove();
    this._rightButton.$element().remove();
    this._leftButton = null;
    this._rightButton = null;
  }
  _cleanScrolling() {
    if (!this._scrollable) {
      return;
    }
    this._$wrapper.appendTo(this.$element());
    this._scrollable.$element().remove();
    this._scrollable = null;
    this._cleanNavButtons();
  }
  _renderInkRipple() {
    this._inkRipple = render();
  }
  _getPointerEvent() {
    return m_pointer_default.up;
  }
  _toggleActiveState($element, value2, e) {
    super._toggleActiveState($element, value2, e);
    if (!this._inkRipple) {
      return;
    }
    const config3 = {
      element: $element,
      event: e
    };
    if (value2) {
      this._inkRipple.showWave(config3);
    } else {
      this._inkRipple.hideWave(config3);
    }
  }
  _renderMultiple() {
    const {
      selectionMode
    } = this.option();
    if ("multiple" === selectionMode) {
      this.option("selectOnFocus", false);
    }
  }
  _renderWrapper() {
    this._$wrapper = renderer_default("<div>").addClass("dx-tabs-wrapper");
    this.$element().append(this._$wrapper);
  }
  _itemContainer() {
    return this._$wrapper;
  }
  _getScrollableDirection() {
    const isVertical = this._isVertical();
    return isVertical ? SCROLLABLE_DIRECTION.vertical : SCROLLABLE_DIRECTION.horizontal;
  }
  _updateScrollable() {
    if (this.getScrollable()) {
      this._cleanScrolling();
    }
    this._renderScrolling();
  }
  _renderScrollable() {
    const $itemContainer = this.$element().wrapInner(renderer_default("<div>").addClass("dx-tabs-scrollable")).children();
    this._scrollable = this._createComponent($itemContainer, m_scrollable_default, {
      direction: this._getScrollableDirection(),
      showScrollbar: "never",
      useKeyboard: false,
      useNative: false,
      scrollByContent: this.option("scrollByContent"),
      onScroll: () => {
        this._updateNavButtonsState();
      }
    });
    this.$element().append(this._scrollable.$element());
  }
  _scrollToItem(item) {
    if (!this._scrollable) {
      return;
    }
    const $item = this._editStrategy.getItemElement(item);
    this._scrollable.scrollToElement($item);
  }
  _renderNavButtons() {
    const {
      showNavButtons,
      rtlEnabled
    } = this.option();
    this.$element().toggleClass("dx-tabs-nav-buttons", showNavButtons);
    if (!showNavButtons) {
      return;
    }
    this._leftButton = this._createNavButton(-30, rtlEnabled ? "chevronnext" : "chevronprev");
    const $leftButton = this._leftButton.$element();
    $leftButton.addClass("dx-tabs-nav-button-left");
    this.$element().prepend($leftButton);
    this._rightButton = this._createNavButton(30, rtlEnabled ? "chevronprev" : "chevronnext");
    const $rightButton = this._rightButton.$element();
    $rightButton.addClass("dx-tabs-nav-button-right");
    this.$element().append($rightButton);
  }
  _updateNavButtonsAriaDisabled() {
    const buttons = [this._leftButton, this._rightButton];
    buttons.forEach((button) => {
      null === button || void 0 === button || button.$element().attr({
        "aria-disabled": null
      });
    });
  }
  _updateNavButtonsState() {
    const isVertical = this._isVertical();
    const scrollable = this.getScrollable();
    if (isVertical) {
      var _this$_leftButton, _this$_rightButton;
      null === (_this$_leftButton = this._leftButton) || void 0 === _this$_leftButton || _this$_leftButton.option("disabled", isReachedTop(scrollable.scrollTop(), 1));
      null === (_this$_rightButton = this._rightButton) || void 0 === _this$_rightButton || _this$_rightButton.option("disabled", isReachedBottom(renderer_default(scrollable.container()).get(0), scrollable.scrollTop(), 0, 1));
    } else {
      var _this$_leftButton2, _this$_rightButton2;
      null === (_this$_leftButton2 = this._leftButton) || void 0 === _this$_leftButton2 || _this$_leftButton2.option("disabled", isReachedLeft(scrollable.scrollLeft(), 1));
      null === (_this$_rightButton2 = this._rightButton) || void 0 === _this$_rightButton2 || _this$_rightButton2.option("disabled", isReachedRight(renderer_default(scrollable.container()).get(0), scrollable.scrollLeft(), 1));
    }
    this._updateNavButtonsAriaDisabled();
  }
  _updateScrollPosition(offset2, duration) {
    var _this$_scrollable, _this$_scrollable2;
    null === (_this$_scrollable = this._scrollable) || void 0 === _this$_scrollable || _this$_scrollable.update();
    null === (_this$_scrollable2 = this._scrollable) || void 0 === _this$_scrollable2 || _this$_scrollable2.scrollBy(offset2 / duration);
  }
  _createNavButton(offset2, icon) {
    const holdAction = this._createAction(() => {
      this._holdInterval = setInterval(() => {
        this._updateScrollPosition(offset2, 5);
      }, 5);
    });
    const holdEventName = addNamespace2(m_hold_default.name, "dxNavButton");
    const pointerUpEventName = addNamespace2(m_pointer_default.up, "dxNavButton");
    const pointerOutEventName = addNamespace2(m_pointer_default.out, "dxNavButton");
    const navButton = this._createComponent(renderer_default("<div>").addClass("dx-tabs-nav-button"), button_default2, {
      focusStateEnabled: false,
      icon,
      integrationOptions: {},
      elementAttr: {
        role: null,
        "aria-label": null,
        "aria-disabled": null
      },
      onClick: () => {
        this._updateScrollPosition(offset2, 1);
      }
    });
    const $navButton = navButton.$element();
    m_events_engine_default.on($navButton, holdEventName, {
      timeout: 300
    }, (e) => {
      holdAction({
        event: e
      });
    });
    m_events_engine_default.on($navButton, pointerUpEventName, () => {
      this._clearInterval();
    });
    m_events_engine_default.on($navButton, pointerOutEventName, () => {
      this._clearInterval();
    });
    return navButton;
  }
  _clearInterval() {
    if (this._holdInterval) {
      clearInterval(this._holdInterval);
    }
  }
  _updateSelection(addedSelection) {
    if (this._scrollable) {
      return this._scrollable.scrollToElement(this.itemElements().eq(addedSelection[0]));
    }
    return;
  }
  _visibilityChanged(visible2) {
    if (visible2) {
      this._dimensionChanged();
    }
  }
  _attachResizeObserverSubscription() {
    resize_observer_default.unobserve(this.$element().get(0));
    resize_observer_default.observe(this.$element().get(0), () => {
      this._dimensionChanged();
    });
  }
  _dimensionChanged() {
    this._renderScrolling();
  }
  _enterKeyHandler(e) {
    const {
      focusedElement
    } = this.option();
    super._enterKeyHandler(e);
    this.option("focusedElement", focusedElement);
  }
  _itemSelectHandler(e) {
    const {
      selectionMode
    } = this.option();
    if ("single" === selectionMode && this.isItemSelected(e.currentTarget)) {
      return;
    }
    super._itemSelectHandler(e);
  }
  _clean() {
    resize_observer_default.unobserve(this.$element().get(0));
    this._cleanScrolling();
    super._clean();
  }
  _toggleTabsVerticalClass(value2) {
    this.$element().toggleClass(TABS_ORIENTATION_CLASS.vertical, value2);
  }
  _toggleTabsHorizontalClass(value2) {
    this.$element().toggleClass(TABS_ORIENTATION_CLASS.horizontal, value2);
  }
  _getIndicatorPositionClass(indicatorPosition) {
    return TABS_INDICATOR_POSITION_CLASS[indicatorPosition];
  }
  _getIndicatorPosition() {
    const {
      _indicatorPosition,
      rtlEnabled
    } = this.option();
    if (_indicatorPosition) {
      return _indicatorPosition;
    }
    const isVertical = this._isVertical();
    if (rtlEnabled) {
      return isVertical ? INDICATOR_POSITION.left : INDICATOR_POSITION.bottom;
    }
    return isVertical ? INDICATOR_POSITION.right : INDICATOR_POSITION.bottom;
  }
  _toggleIndicatorPositionClass(indicatorPosition) {
    const newClass = this._getIndicatorPositionClass(indicatorPosition);
    this._toggleElementClasses(TABS_INDICATOR_POSITION_CLASS, newClass);
  }
  _toggleScrollingEnabledClass(scrollingEnabled) {
    this.$element().toggleClass("dx-tabs-scrolling-enabled", Boolean(scrollingEnabled));
  }
  _toggleOrientationClass(orientation) {
    const isVertical = orientation === ORIENTATION.vertical;
    this._toggleTabsVerticalClass(isVertical);
    this._toggleTabsHorizontalClass(!isVertical);
  }
  _getTabsIconPositionClass() {
    const {
      iconPosition
    } = this.option();
    switch (iconPosition) {
      case ICON_POSITION.top:
        return TABS_ICON_POSITION_CLASS.top;
      case ICON_POSITION.end:
        return TABS_ICON_POSITION_CLASS.end;
      case ICON_POSITION.bottom:
        return TABS_ICON_POSITION_CLASS.bottom;
      default:
        return TABS_ICON_POSITION_CLASS.start;
    }
  }
  _toggleIconPositionClass() {
    const newClass = this._getTabsIconPositionClass();
    this._toggleElementClasses(TABS_ICON_POSITION_CLASS, newClass);
  }
  _toggleStylingModeClass(value2) {
    const newClass = TABS_STYLING_MODE_CLASS[value2 ?? "primary"];
    this._toggleElementClasses(TABS_STYLING_MODE_CLASS, newClass);
  }
  _toggleElementClasses(classMap, newClass) {
    for (const key in classMap) {
      this.$element().removeClass(classMap[key]);
    }
    this.$element().addClass(newClass);
  }
  _toggleFocusedDisabledNextClass(currentIndex, isNextDisabled) {
    this._itemElements().eq(currentIndex).toggleClass("dx-focused-disabled-next-tab", isNextDisabled);
  }
  _toggleFocusedDisabledPrevClass(currentIndex, isPrevDisabled) {
    this._itemElements().eq(currentIndex).toggleClass("dx-focused-disabled-prev-tab", isPrevDisabled);
  }
  _toggleFocusedDisabledClasses(value2) {
    const {
      selectedIndex: currentIndex
    } = this.option();
    this._itemElements().removeClass("dx-focused-disabled-next-tab").removeClass("dx-focused-disabled-prev-tab");
    const prevItemIndex = currentIndex - 1;
    const nextItemIndex = currentIndex + 1;
    const nextFocusedIndex = renderer_default(value2).index();
    const isNextDisabled = this._itemElements().eq(nextItemIndex).hasClass("dx-state-disabled");
    const isPrevDisabled = this._itemElements().eq(prevItemIndex).hasClass("dx-state-disabled");
    const shouldNextClassBeSetted = isNextDisabled && nextFocusedIndex === nextItemIndex;
    const shouldPrevClassBeSetted = isPrevDisabled && nextFocusedIndex === prevItemIndex;
    this._toggleFocusedDisabledNextClass(currentIndex, shouldNextClassBeSetted);
    this._toggleFocusedDisabledPrevClass(currentIndex, shouldPrevClassBeSetted);
  }
  _updateFocusedElement() {
    const {
      focusStateEnabled,
      selectedIndex
    } = this.option();
    const itemElements = this._itemElements();
    if (focusStateEnabled && itemElements.length) {
      const selectedItem = itemElements.get(selectedIndex);
      this.option({
        focusedElement: selectedItem
      });
    }
  }
  _optionChanged(args) {
    var _this$_scrollable3;
    const {
      name: name2,
      value: value2
    } = args;
    switch (name2) {
      case "useInkRipple":
      case "scrollingEnabled":
        this._toggleScrollingEnabledClass(value2);
        this._invalidate();
        break;
      case "showNavButtons":
      case "badgeExpr":
        this._invalidate();
        break;
      case "scrollByContent":
        null === (_this$_scrollable3 = this._scrollable) || void 0 === _this$_scrollable3 || _this$_scrollable3.option(name2, value2);
        break;
      case "width":
      case "height":
        super._optionChanged(args);
        this._dimensionChanged();
        break;
      case "selectionMode":
        this._renderMultiple();
        super._optionChanged(args);
        break;
      case "focusedElement":
        this._toggleFocusedDisabledClasses(value2);
        super._optionChanged(args);
        this._scrollToItem(value2);
        break;
      case "rtlEnabled": {
        super._optionChanged(args);
        const indicatorPosition = this._getIndicatorPosition();
        this._toggleIndicatorPositionClass(indicatorPosition);
        break;
      }
      case "orientation": {
        this._toggleOrientationClass(value2);
        const indicatorPosition = this._getIndicatorPosition();
        this._toggleIndicatorPositionClass(indicatorPosition);
        if (hasWindow()) {
          this._updateScrollable();
        }
        break;
      }
      case "iconPosition":
        this._toggleIconPositionClass();
        if (hasWindow()) {
          this._dimensionChanged();
        }
        break;
      case "stylingMode":
        this._toggleStylingModeClass(value2);
        if (hasWindow()) {
          this._dimensionChanged();
        }
        break;
      case "_indicatorPosition": {
        const indicatorPosition = this._getIndicatorPosition();
        this._toggleIndicatorPositionClass(indicatorPosition);
        break;
      }
      case "selectedIndex":
      case "selectedItem":
      case "selectedItems":
        super._optionChanged(args);
        this._updateFocusedElement();
        break;
      default:
        super._optionChanged(args);
    }
  }
  _afterItemElementInserted() {
    super._afterItemElementInserted();
    this._planPostRenderActions();
  }
  _afterItemElementDeleted($item, deletedActionArgs) {
    super._afterItemElementDeleted($item, deletedActionArgs);
    this._renderScrolling();
  }
  getScrollable() {
    return this._scrollable;
  }
};
Tabs.ItemClass = item_default2;
component_registrator_default("dxTabs", Tabs);
var tabs_default = Tabs;

// node_modules/devextreme/esm/__internal/ui/tab_panel/item.js
var TabPanelItem = class extends item_default {
  _renderWatchers() {
    this._startWatcher("badge", noop2);
    super._renderWatchers();
  }
};

// node_modules/devextreme/esm/__internal/ui/tab_panel/tab_panel.js
var TABPANEL_TABS_POSITION_CLASS = {
  top: "dx-tabpanel-tabs-position-top",
  right: "dx-tabpanel-tabs-position-right",
  bottom: "dx-tabpanel-tabs-position-bottom",
  left: "dx-tabpanel-tabs-position-left"
};
var TABS_POSITION = {
  top: "top",
  right: "right",
  bottom: "bottom",
  left: "left"
};
var TABS_INDICATOR_POSITION_BY_TABS_POSITION = {
  top: "bottom",
  right: "left",
  bottom: "top",
  left: "right"
};
var TABS_ORIENTATION = {
  horizontal: "horizontal",
  vertical: "vertical"
};
var ICON_POSITION2 = {
  top: "top",
  end: "end",
  bottom: "bottom",
  start: "start"
};
var STYLING_MODE2 = {
  primary: "primary",
  secondary: "secondary"
};
var TabPanel = class extends m_multi_view_default {
  _getDefaultOptions() {
    return _extends({}, super._getDefaultOptions(), {
      itemTitleTemplate: "title",
      hoverStateEnabled: true,
      selectOnFocus: false,
      showNavButtons: false,
      scrollByContent: true,
      scrollingEnabled: true,
      tabsPosition: TABS_POSITION.top,
      iconPosition: ICON_POSITION2.start,
      stylingMode: STYLING_MODE2.primary,
      onTitleClick: null,
      onTitleHold: null,
      onTitleRendered: null,
      badgeExpr: (data17) => null === data17 || void 0 === data17 ? void 0 : data17.badge,
      _tabsIndicatorPosition: null
    });
  }
  _defaultOptionsRules() {
    const themeName = current();
    return super._defaultOptionsRules().concat([{
      device: () => "desktop" === devices_default.real().deviceType && !devices_default.isSimulator(),
      options: {
        focusStateEnabled: true
      }
    }, {
      device: () => !m_support_default.touch,
      options: {
        swipeEnabled: false
      }
    }, {
      device: {
        platform: "generic"
      },
      options: {
        animationEnabled: false
      }
    }, {
      device: () => isFluent(themeName),
      options: {
        stylingMode: STYLING_MODE2.secondary
      }
    }, {
      device: () => isMaterialBased(themeName),
      options: {
        iconPosition: ICON_POSITION2.top
      }
    }]);
  }
  _init() {
    super._init();
    this.$element().addClass("dx-tabpanel");
    this._toggleTabPanelTabsPositionClass();
  }
  _getElementAria() {
    return {
      role: "tabpanel"
    };
  }
  _getItemAria() {
    return {
      role: "tabpanel"
    };
  }
  _initMarkup() {
    super._initMarkup();
    this._createTitleActions();
    this._renderLayout();
  }
  _prepareTabsItemTemplate(data17, $container) {
    const $iconElement = getImageContainer(null === data17 || void 0 === data17 ? void 0 : data17.icon);
    if ($iconElement) {
      $container.append($iconElement);
    }
    const title = isPlainObject(data17) ? null === data17 || void 0 === data17 ? void 0 : data17.title : data17;
    if (isDefined(title) && !isPlainObject(title)) {
      const $tabTextSpan = renderer_default("<span>").addClass(TABS_ITEM_TEXT_SPAN_CLASS);
      $tabTextSpan.append(dom_adapter_default.createTextNode(title));
      const $tabTextSpanPseudo = renderer_default("<span>").addClass(TABS_ITEM_TEXT_SPAN_PSEUDO_CLASS);
      $tabTextSpanPseudo.append(dom_adapter_default.createTextNode(title));
      $tabTextSpanPseudo.appendTo($tabTextSpan);
      $tabTextSpan.appendTo($container);
    }
  }
  _initTemplates() {
    super._initTemplates();
    this._templateManager.addDefaultTemplates({
      title: new BindableTemplate(($container, data17) => {
        this._prepareTabsItemTemplate(data17, $container);
        const $tabItem = renderer_default("<div>").addClass(TABS_ITEM_TEXT_CLASS);
        $container.wrapInner($tabItem);
      }, ["title", "icon"], this.option("integrationOptions.watchMethod"))
    });
  }
  _createTitleActions() {
    this._createTitleClickAction();
    this._createTitleHoldAction();
    this._createTitleRenderedAction();
  }
  _createTitleClickAction() {
    this._titleClickAction = this._createActionByOption("onTitleClick");
  }
  _createTitleHoldAction() {
    this._titleHoldAction = this._createActionByOption("onTitleHold");
  }
  _createTitleRenderedAction() {
    this._titleRenderedAction = this._createActionByOption("onTitleRendered");
  }
  _renderLayout() {
    if (this._tabs) {
      return;
    }
    const $element = this.$element();
    this._$tabContainer = renderer_default("<div>").addClass("dx-tabpanel-tabs").appendTo($element);
    const $tabs = renderer_default("<div>").appendTo(this._$tabContainer);
    this._tabs = this._createComponent($tabs, tabs_default, this._tabConfig());
    this._$container = renderer_default("<div>").addClass("dx-tabpanel-container").appendTo($element);
    this._$container.append(this._$wrapper);
    const {
      focusStateEnabled,
      selectedIndex
    } = this.option();
    if (focusStateEnabled && isDefined(selectedIndex)) {
      const selectedItem = this._tabs.itemElements().get(selectedIndex);
      if (selectedItem) {
        this._tabs.option({
          focusedElement: selectedItem
        });
      }
    }
  }
  _refreshActiveDescendant() {
    if (!this._tabs) {
      return;
    }
    const tabs = this._tabs;
    const tabItems = tabs.itemElements();
    const $activeTab = renderer_default(tabItems[tabs.option("selectedIndex")]);
    const id = this.getFocusedItemId();
    this.setAria("controls", void 0, renderer_default(tabItems));
    this.setAria("controls", id, $activeTab);
  }
  _getTabsIndicatorPosition() {
    const {
      _tabsIndicatorPosition,
      tabsPosition
    } = this.option();
    return _tabsIndicatorPosition ?? TABS_INDICATOR_POSITION_BY_TABS_POSITION[tabsPosition ?? TABS_POSITION.top];
  }
  _tabConfig() {
    const tabsIndicatorPosition = this._getTabsIndicatorPosition();
    const {
      focusStateEnabled,
      hoverStateEnabled,
      repaintChangesOnly,
      tabIndex,
      selectedIndex,
      badgeExpr,
      itemHoldTimeout,
      items,
      scrollingEnabled,
      scrollByContent,
      showNavButtons,
      loop,
      iconPosition,
      stylingMode
    } = this.option();
    return {
      selectOnFocus: true,
      focusStateEnabled,
      hoverStateEnabled,
      repaintChangesOnly,
      tabIndex,
      selectedIndex,
      badgeExpr,
      onItemClick: this._titleClickAction.bind(this),
      onItemHold: this._titleHoldAction.bind(this),
      itemHoldTimeout,
      onSelectionChanging: (e) => {
        const newTabsSelectedItemData = e.addedItems[0];
        const newTabsSelectedIndex = this._getIndexByItemData(newTabsSelectedItemData);
        const selectingResult = this.selectItem(newTabsSelectedIndex);
        const promiseState = selectingResult.state();
        if ("pending" !== promiseState) {
          e.cancel = "rejected" === promiseState;
          return;
        }
        e.cancel = new Promise((resolve) => {
          selectingResult.done(() => {
            resolve(false);
          }).fail(() => {
            resolve(true);
          });
        });
      },
      onSelectionChanged: () => {
        this._refreshActiveDescendant();
      },
      onItemRendered: this._titleRenderedAction.bind(this),
      itemTemplate: this._getTemplateByOption("itemTitleTemplate"),
      items,
      noDataText: null,
      scrollingEnabled,
      scrollByContent,
      showNavButtons,
      itemTemplateProperty: "tabTemplate",
      loopItemFocus: loop,
      selectionRequired: true,
      onOptionChanged: (args) => {
        if ("focusedElement" === args.name) {
          if (args.value) {
            const $value = renderer_default(args.value);
            const $newItem = this._itemElements().eq($value.index());
            this.option("focusedElement", getPublicElement($newItem));
          } else {
            this.option("focusedElement", args.value);
          }
        }
      },
      onFocusIn: (args) => {
        this._focusInHandler(args.event);
      },
      onFocusOut: (args) => {
        if (!this._isFocusOutHandlerExecuting) {
          this._focusOutHandler(args.event);
        }
      },
      orientation: this._getTabsOrientation(),
      iconPosition,
      stylingMode,
      _itemAttributes: {
        class: "dx-tabpanel-tab"
      },
      _indicatorPosition: tabsIndicatorPosition
    };
  }
  _renderFocusTarget() {
    this._focusTarget().attr("tabIndex", -1);
  }
  _getTabsOrientation() {
    const {
      tabsPosition
    } = this.option();
    if ([TABS_POSITION.right, TABS_POSITION.left].includes(tabsPosition)) {
      return TABS_ORIENTATION.vertical;
    }
    return TABS_ORIENTATION.horizontal;
  }
  _getTabPanelTabsPositionClass() {
    const {
      tabsPosition
    } = this.option();
    switch (tabsPosition) {
      case TABS_POSITION.right:
        return TABPANEL_TABS_POSITION_CLASS.right;
      case TABS_POSITION.bottom:
        return TABPANEL_TABS_POSITION_CLASS.bottom;
      case TABS_POSITION.left:
        return TABPANEL_TABS_POSITION_CLASS.left;
      case TABS_POSITION.top:
      default:
        return TABPANEL_TABS_POSITION_CLASS.top;
    }
  }
  _toggleTabPanelTabsPositionClass() {
    for (const key in TABPANEL_TABS_POSITION_CLASS) {
      this.$element().removeClass(TABPANEL_TABS_POSITION_CLASS[key]);
    }
    const newClass = this._getTabPanelTabsPositionClass();
    this.$element().addClass(newClass);
  }
  _updateTabsOrientation() {
    const orientation = this._getTabsOrientation();
    this._setTabsOption("orientation", orientation);
  }
  _toggleWrapperFocusedClass(isFocused) {
    this._toggleFocusClass(isFocused, this._$wrapper);
  }
  _toggleDisabledFocusedClass(isFocused) {
    this._focusTarget().toggleClass("dx-disabled-focused-tab", isFocused);
  }
  _updateFocusState(e, isFocused) {
    super._updateFocusState(e, isFocused);
    const isTabsTarget = e.target === this._tabs._focusTarget().get(0);
    const isMultiViewTarget = e.target === this._focusTarget().get(0);
    if (isTabsTarget) {
      this._toggleFocusClass(isFocused, this._focusTarget());
    }
    if (isTabsTarget || isMultiViewTarget) {
      const isDisabled = this._isDisabled(this.option("focusedElement"));
      this._toggleWrapperFocusedClass(isFocused && !isDisabled);
      this._toggleDisabledFocusedClass(isFocused && isDisabled);
    }
    if (isMultiViewTarget) {
      this._toggleFocusClass(isFocused, this._tabs.$element());
      this._toggleFocusClass(isFocused, this._tabs.option("focusedElement"));
    }
  }
  _focusOutHandler(e) {
    this._isFocusOutHandlerExecuting = true;
    super._focusOutHandler(e);
    this._tabs._focusOutHandler(e);
    this._isFocusOutHandlerExecuting = false;
  }
  _setTabsOption(name2, value2) {
    if (this._tabs) {
      this._tabs.option(name2, value2);
    }
  }
  _postprocessSwipe(args) {
    this._setTabsOption("selectedIndex", args.swipedTabsIndex);
  }
  _visibilityChanged(visible2) {
    if (visible2) {
      this._tabs._dimensionChanged();
    }
  }
  registerKeyHandler(key, handler) {
    super.registerKeyHandler(key, handler);
    if (this._tabs) {
      this._tabs.registerKeyHandler(key, handler);
    }
  }
  repaint() {
    super.repaint();
    this._tabs.repaint();
  }
  _updateTabsIndicatorPosition() {
    const value2 = this._getTabsIndicatorPosition();
    this._setTabsOption("_indicatorPosition", value2);
  }
  _optionChanged(args) {
    const {
      name: name2,
      value: value2,
      fullName
    } = args;
    switch (name2) {
      case "dataSource":
      default:
        super._optionChanged(args);
        break;
      case "items":
        this._setTabsOption(name2, this.option(name2));
        if (!this.option("repaintChangesOnly")) {
          this._tabs.repaint();
        }
        super._optionChanged(args);
        break;
      case "width":
        super._optionChanged(args);
        this._tabs.repaint();
        break;
      case "selectedIndex":
      case "selectedItem": {
        this._setTabsOption(fullName, value2);
        super._optionChanged(args);
        const {
          focusStateEnabled
        } = this.option();
        if (true === focusStateEnabled) {
          const selectedIndex = this.option("selectedIndex");
          const selectedTabContent = this._itemElements().eq(selectedIndex);
          this.option("focusedElement", getPublicElement(selectedTabContent));
        }
        break;
      }
      case "itemHoldTimeout":
      case "focusStateEnabled":
      case "hoverStateEnabled":
        this._setTabsOption(fullName, value2);
        super._optionChanged(args);
        break;
      case "scrollingEnabled":
      case "scrollByContent":
      case "showNavButtons":
        this._setTabsOption(fullName, value2);
        break;
      case "focusedElement": {
        const id = value2 ? renderer_default(value2).index() : value2;
        const newItem = value2 && this._tabs ? this._tabs._itemElements().eq(id) : value2;
        this._setTabsOption("focusedElement", getPublicElement(newItem));
        if (value2) {
          const isDisabled = this._isDisabled(value2);
          this._toggleWrapperFocusedClass(!isDisabled);
          this._toggleDisabledFocusedClass(isDisabled);
        }
        super._optionChanged(args);
        break;
      }
      case "itemTitleTemplate":
        this._setTabsOption("itemTemplate", this._getTemplateByOption("itemTitleTemplate"));
        break;
      case "onTitleClick":
        this._createTitleClickAction();
        this._setTabsOption("onItemClick", this._titleClickAction.bind(this));
        break;
      case "onTitleHold":
        this._createTitleHoldAction();
        this._setTabsOption("onItemHold", this._titleHoldAction.bind(this));
        break;
      case "onTitleRendered":
        this._createTitleRenderedAction();
        this._setTabsOption("onItemRendered", this._titleRenderedAction.bind(this));
        break;
      case "loop":
        this._setTabsOption("loopItemFocus", value2);
        super._optionChanged(args);
        break;
      case "badgeExpr":
        this._invalidate();
        break;
      case "tabsPosition":
        this._toggleTabPanelTabsPositionClass();
        this._updateTabsIndicatorPosition();
        this._updateTabsOrientation();
        break;
      case "iconPosition":
        this._setTabsOption("iconPosition", value2);
        break;
      case "stylingMode":
        this._setTabsOption("stylingMode", value2);
        break;
      case "_tabsIndicatorPosition":
        this._setTabsOption("_indicatorPosition", value2);
    }
  }
};
TabPanel.ItemClass = TabPanelItem;
component_registrator_default("dxTabPanel", TabPanel);
var tab_panel_default = TabPanel;

// node_modules/devextreme/esm/ui/tab_panel.js
var tab_panel_default2 = tab_panel_default;

// node_modules/devextreme/esm/__internal/ui/form/m_form.item_option_action.js
var ItemOptionAction = class {
  constructor(options2) {
    this._options = options2;
    this._itemsRunTimeInfo = this._options.itemsRunTimeInfo;
  }
  findInstance() {
    return this._itemsRunTimeInfo.findWidgetInstanceByItem(this._options.item);
  }
  findItemContainer() {
    return this._itemsRunTimeInfo.findItemContainerByItem(this._options.item);
  }
  findPreparedItem() {
    return this._itemsRunTimeInfo.findPreparedItemByItem(this._options.item);
  }
  tryExecute() {
    class_default.abstract();
  }
};

// node_modules/devextreme/esm/__internal/ui/form/m_form.utils.js
var createItemPathByIndex = (index2, isTabs) => `${isTabs ? "tabs" : "items"}[${index2}]`;
var concatPaths = (path1, path2) => {
  if (isDefined(path1) && isDefined(path2)) {
    return `${path1}.${path2}`;
  }
  return path1 || path2;
};
var getTextWithoutSpaces = (text) => text ? text.replace(/\s/g, "") : void 0;
var isEqualToDataFieldOrNameOrTitleOrCaption = (item, fieldName) => {
  if (item) {
    return item.dataField === fieldName || item.name === fieldName || getTextWithoutSpaces(item.title) === fieldName || "group" === item.itemType && getTextWithoutSpaces(item.caption) === fieldName;
  }
  return false;
};
var getFullOptionName = (path, optionName) => `${path}.${optionName}`;
var getOptionNameFromFullName = (fullName) => {
  const parts = fullName.split(".");
  return parts[parts.length - 1].replace(/\[\d+]/, "");
};
var tryGetTabPath = (fullPath) => {
  const pathParts = fullPath.split(".");
  const resultPathParts = [...pathParts];
  for (let i = pathParts.length - 1; i >= 0; i--) {
    if (isFullPathContainsTabs(pathParts[i])) {
      return resultPathParts.join(".");
    }
    resultPathParts.splice(i, 1);
  }
  return "";
};
var isFullPathContainsTabs = (fullPath) => fullPath.indexOf("tabs") > -1;
var getItemPath = (items, item, isTabs) => {
  const index2 = items.indexOf(item);
  if (index2 > -1) {
    return createItemPathByIndex(index2, isTabs);
  }
  for (let i = 0; i < items.length; i++) {
    const targetItem = items[i];
    const tabOrGroupItems = targetItem.tabs || targetItem.items;
    if (tabOrGroupItems) {
      const itemPath = getItemPath(tabOrGroupItems, item, targetItem.tabs);
      if (itemPath) {
        return concatPaths(createItemPathByIndex(i, isTabs), itemPath);
      }
    }
  }
};
function convertToLayoutManagerOptions(_ref) {
  let {
    form,
    $formElement,
    formOptions,
    items,
    validationGroup,
    extendedLayoutManagerOptions,
    onFieldDataChanged,
    onContentReady,
    onDisposing,
    onFieldItemRendered
  } = _ref;
  const baseOptions = {
    form,
    items,
    $formElement,
    validationGroup,
    onFieldDataChanged,
    onContentReady,
    onDisposing,
    onFieldItemRendered,
    validationBoundary: formOptions.scrollingEnabled ? $formElement : void 0,
    scrollingEnabled: formOptions.scrollingEnabled,
    showRequiredMark: formOptions.showRequiredMark,
    showOptionalMark: formOptions.showOptionalMark,
    requiredMark: formOptions.requiredMark,
    optionalMark: formOptions.optionalMark,
    requiredMessage: formOptions.requiredMessage,
    screenByWidth: formOptions.screenByWidth,
    layoutData: formOptions.formData,
    labelLocation: formOptions.labelLocation,
    customizeItem: formOptions.customizeItem,
    minColWidth: formOptions.minColWidth,
    showColonAfterLabel: formOptions.showColonAfterLabel,
    onEditorEnterKey: formOptions.onEditorEnterKey,
    labelMode: formOptions.labelMode
  };
  const result2 = extend(baseOptions, {
    isRoot: extendedLayoutManagerOptions.isRoot,
    colCount: extendedLayoutManagerOptions.colCount,
    alignItemLabels: extendedLayoutManagerOptions.alignItemLabels,
    cssItemClass: extendedLayoutManagerOptions.cssItemClass,
    colCountByScreen: extendedLayoutManagerOptions.colCountByScreen,
    onLayoutChanged: extendedLayoutManagerOptions.onLayoutChanged,
    width: extendedLayoutManagerOptions.width
  });
  return result2;
}

// node_modules/devextreme/esm/__internal/ui/form/m_form.item_options_actions.js
var WidgetOptionItemOptionAction = class extends ItemOptionAction {
  tryExecute() {
    const {
      value: value2
    } = this._options;
    const instance = this.findInstance();
    if (instance) {
      instance.option(value2);
      return true;
    }
    return false;
  }
};
var TabOptionItemOptionAction = class extends ItemOptionAction {
  tryExecute() {
    const tabPanel = this.findInstance();
    if (tabPanel) {
      const {
        optionName,
        item,
        value: value2
      } = this._options;
      const itemIndex = this._itemsRunTimeInfo.findItemIndexByItem(item);
      if (itemIndex >= 0) {
        tabPanel.option(getFullOptionName(`items[${itemIndex}]`, optionName), value2);
        return true;
      }
    }
    return false;
  }
};
var SimpleItemTemplateChangedAction = class extends ItemOptionAction {
  tryExecute() {
    return false;
  }
};
var GroupItemTemplateChangedAction = class extends ItemOptionAction {
  tryExecute() {
    const preparedItem = this.findPreparedItem();
    if (null != preparedItem && preparedItem._prepareGroupItemTemplate && preparedItem._renderGroupContentTemplate) {
      preparedItem._prepareGroupItemTemplate(this._options.item.template);
      preparedItem._renderGroupContentTemplate();
      return true;
    }
    return false;
  }
};
var TabsOptionItemOptionAction = class extends ItemOptionAction {
  tryExecute() {
    const tabPanel = this.findInstance();
    if (tabPanel) {
      const {
        value: value2
      } = this._options;
      tabPanel.option("dataSource", value2);
      return true;
    }
    return false;
  }
};
var ValidationRulesItemOptionAction = class extends ItemOptionAction {
  tryExecute() {
    const {
      item
    } = this._options;
    const instance = this.findInstance();
    const validator = instance && data(instance.$element()[0], "dxValidator");
    if (validator && item) {
      const filterRequired = (item2) => "required" === item2.type;
      const oldContainsRequired = (validator.option("validationRules") || []).some(filterRequired);
      const newContainsRequired = (item.validationRules || []).some(filterRequired);
      if (!oldContainsRequired && !newContainsRequired || oldContainsRequired && newContainsRequired) {
        validator.option("validationRules", item.validationRules);
        return true;
      }
    }
    return false;
  }
};
var CssClassItemOptionAction = class extends ItemOptionAction {
  tryExecute() {
    const $itemContainer = this.findItemContainer();
    const {
      previousValue,
      value: value2
    } = this._options;
    if ($itemContainer) {
      $itemContainer.removeClass(previousValue).addClass(value2);
      return true;
    }
    return false;
  }
};
var tryCreateItemOptionAction = (optionName, itemActionOptions) => {
  switch (optionName) {
    case "editorOptions":
    case "buttonOptions":
      return new WidgetOptionItemOptionAction(itemActionOptions);
    case "validationRules":
      return new ValidationRulesItemOptionAction(itemActionOptions);
    case "cssClass":
      return new CssClassItemOptionAction(itemActionOptions);
    case "badge":
    case "disabled":
    case "icon":
    case "tabTemplate":
    case "title":
      return new TabOptionItemOptionAction(extend(itemActionOptions, {
        optionName
      }));
    case "tabs":
      return new TabsOptionItemOptionAction(itemActionOptions);
    case "template": {
      var _itemActionOptions$it, _itemActionOptions$it2;
      const itemType = (null === itemActionOptions || void 0 === itemActionOptions || null === (_itemActionOptions$it = itemActionOptions.item) || void 0 === _itemActionOptions$it ? void 0 : _itemActionOptions$it.itemType) ?? (null === (_itemActionOptions$it2 = itemActionOptions.itemsRunTimeInfo.findPreparedItemByItem(null === itemActionOptions || void 0 === itemActionOptions ? void 0 : itemActionOptions.item)) || void 0 === _itemActionOptions$it2 ? void 0 : _itemActionOptions$it2.itemType);
      if ("simple" === itemType) {
        return new SimpleItemTemplateChangedAction(itemActionOptions);
      }
      if ("group" === itemType) {
        return new GroupItemTemplateChangedAction(itemActionOptions);
      }
      return new TabOptionItemOptionAction(extend(itemActionOptions, {
        optionName
      }));
    }
    default:
      return null;
  }
};
var m_form_item_options_actions_default = tryCreateItemOptionAction;

// node_modules/devextreme/esm/__internal/ui/form/m_form.js
var ITEM_OPTIONS_FOR_VALIDATION_UPDATING = ["items", "isRequired", "validationRules", "visible"];
var Form = class extends widget_default {
  _init() {
    super._init();
    this._dirtyFields = /* @__PURE__ */ new Set();
    this._cachedColCountOptions = [];
    this._itemsRunTimeInfo = new FormItemsRunTimeInfo();
    this._groupsColCount = [];
    this._attachSyncSubscriptions();
  }
  _getDefaultOptions() {
    return _extends({}, super._getDefaultOptions(), {
      formID: `dx-${new guid_default2()}`,
      formData: {},
      colCount: 1,
      screenByWidth: defaultScreenFactorFunc,
      labelLocation: "left",
      readOnly: false,
      onFieldDataChanged: null,
      customizeItem: null,
      onEditorEnterKey: null,
      minColWidth: 200,
      alignItemLabels: true,
      alignItemLabelsInAllGroups: true,
      alignRootItemLabels: true,
      showColonAfterLabel: true,
      showRequiredMark: true,
      showOptionalMark: false,
      requiredMark: "*",
      optionalMark: message_default.format("dxForm-optionalMark"),
      requiredMessage: message_default.getFormatter("dxForm-requiredMessage"),
      showValidationSummary: false,
      scrollingEnabled: false,
      stylingMode: config_default2().editorStylingMode,
      labelMode: "outside",
      isDirty: false
    });
  }
  _defaultOptionsRules() {
    return super._defaultOptionsRules().concat([{
      device: () => isMaterialBased(),
      options: {
        labelLocation: "top"
      }
    }, {
      device: () => isMaterial(),
      options: {
        showColonAfterLabel: false
      }
    }]);
  }
  _setOptionsByReference() {
    super._setOptionsByReference();
    extend(this._optionsByReference, {
      formData: true,
      validationGroup: true
    });
  }
  _getGroupColCount($element) {
    return parseInt($element.attr(GROUP_COL_COUNT_ATTR));
  }
  _applyLabelsWidthByCol($container, index2) {
    let options2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
    let labelMarkOptions = arguments.length > 3 ? arguments[3] : void 0;
    const fieldItemClass = options2.inOneColumn ? FIELD_ITEM_CLASS : FORM_FIELD_ITEM_COL_CLASS + index2;
    const cssExcludeTabbedSelector = options2.excludeTabbed ? `:not(.${FIELD_ITEM_TAB_CLASS})` : "";
    setLabelWidthByMaxLabelWidth($container, `.${fieldItemClass}${cssExcludeTabbedSelector}`, labelMarkOptions);
  }
  _applyLabelsWidth($container, excludeTabbed, inOneColumn, colCount, labelMarkOptions) {
    colCount = inOneColumn ? 1 : colCount || this._getGroupColCount($container);
    const applyLabelsOptions = {
      excludeTabbed,
      inOneColumn
    };
    let i;
    for (i = 0; i < colCount; i++) {
      this._applyLabelsWidthByCol($container, i, applyLabelsOptions, labelMarkOptions);
    }
  }
  _getGroupElementsInColumn($container, columnIndex, colCount) {
    const cssColCountSelector = isDefined(colCount) ? `.${GROUP_COL_COUNT_CLASS}${colCount}` : "";
    const groupSelector = `.${FORM_FIELD_ITEM_COL_CLASS}${columnIndex} > .${FIELD_ITEM_CONTENT_CLASS} > .${FORM_GROUP_CLASS}${cssColCountSelector}`;
    return $container.find(groupSelector);
  }
  _applyLabelsWidthWithGroups($container, colCount, excludeTabbed, labelMarkOptions) {
    const {
      alignRootItemLabels
    } = this.option();
    if (true === alignRootItemLabels) {
      const $rootSimpleItems = $container.find(`.${ROOT_SIMPLE_ITEM_CLASS}`);
      for (let colIndex = 0; colIndex < colCount; colIndex++) {
        this._applyLabelsWidthByCol($rootSimpleItems, colIndex, excludeTabbed, labelMarkOptions);
      }
    }
    const alignItemLabelsInAllGroups = this.option("alignItemLabelsInAllGroups");
    if (alignItemLabelsInAllGroups) {
      this._applyLabelsWidthWithNestedGroups($container, colCount, excludeTabbed, labelMarkOptions);
    } else {
      const $groups = this.$element().find(`.${FORM_GROUP_CLASS}`);
      let i;
      for (i = 0; i < $groups.length; i++) {
        this._applyLabelsWidth($groups.eq(i), excludeTabbed, void 0, void 0, labelMarkOptions);
      }
    }
  }
  _applyLabelsWidthWithNestedGroups($container, colCount, excludeTabbed, labelMarkOptions) {
    const applyLabelsOptions = {
      excludeTabbed
    };
    let colIndex;
    let groupsColIndex;
    let groupColIndex;
    let $groupsByCol;
    for (colIndex = 0; colIndex < colCount; colIndex++) {
      $groupsByCol = this._getGroupElementsInColumn($container, colIndex);
      this._applyLabelsWidthByCol($groupsByCol, 0, applyLabelsOptions, labelMarkOptions);
      for (groupsColIndex = 0; groupsColIndex < this._groupsColCount.length; groupsColIndex++) {
        $groupsByCol = this._getGroupElementsInColumn($container, colIndex, this._groupsColCount[groupsColIndex]);
        const groupColCount = this._getGroupColCount($groupsByCol);
        for (groupColIndex = 1; groupColIndex < groupColCount; groupColIndex++) {
          this._applyLabelsWidthByCol($groupsByCol, groupColIndex, applyLabelsOptions, labelMarkOptions);
        }
      }
    }
  }
  _labelLocation() {
    const {
      labelLocation
    } = this.option();
    return labelLocation;
  }
  _alignLabelsInColumn(_ref) {
    let {
      layoutManager,
      inOneColumn,
      $container,
      excludeTabbed,
      items
    } = _ref;
    if (!hasWindow() || "top" === this._labelLocation()) {
      return;
    }
    const labelMarkOptions = convertToLabelMarkOptions(layoutManager._getMarkOptions());
    if (inOneColumn) {
      this._applyLabelsWidth($container, excludeTabbed, true, void 0, labelMarkOptions);
    } else if (this._checkGrouping(items)) {
      this._applyLabelsWidthWithGroups($container, layoutManager._getColCount(), excludeTabbed, labelMarkOptions);
    } else {
      this._applyLabelsWidth($container, excludeTabbed, false, layoutManager._getColCount(), labelMarkOptions);
    }
  }
  _prepareFormData() {
    if (!isDefined(this.option("formData"))) {
      this.option("formData", {});
    }
  }
  _setStylingModeClass() {
    const {
      stylingMode
    } = this.option();
    if ("underlined" === stylingMode) {
      this.$element().addClass(FORM_UNDERLINED_CLASS);
    }
  }
  _initMarkup() {
    validation_engine_default.addGroup(this._getValidationGroup(), false);
    this._clearCachedInstances();
    this._prepareFormData();
    this.$element().addClass(FORM_CLASS);
    this._setStylingModeClass();
    super._initMarkup();
    this.setAria("role", "form", this.$element());
    if (this.option("scrollingEnabled")) {
      this._renderScrollable();
    }
    this._renderLayout();
    this._renderValidationSummary();
    this._lastMarkupScreenFactor = this._targetScreenFactor || this._getCurrentScreenFactor();
    this._attachResizeObserverSubscription();
  }
  _attachResizeObserverSubscription() {
    if (hasWindow()) {
      const formRootElement = this.$element().get(0);
      resize_observer_default.unobserve(formRootElement);
      resize_observer_default.observe(formRootElement, () => {
        this._resizeHandler();
      });
    }
  }
  _resizeHandler() {
    if (this._cachedLayoutManagers.length) {
      each(this._cachedLayoutManagers, (_, layoutManager) => {
        var _layoutManager$option;
        null === (_layoutManager$option = layoutManager.option("onLayoutChanged")) || void 0 === _layoutManager$option || _layoutManager$option(layoutManager.isSingleColumnMode());
      });
    }
  }
  _getCurrentScreenFactor() {
    return hasWindow() ? getCurrentScreenFactor(this.option("screenByWidth")) : "lg";
  }
  _clearCachedInstances() {
    this._itemsRunTimeInfo.clear();
    this._cachedLayoutManagers = [];
  }
  _alignLabels(layoutManager, inOneColumn) {
    this._alignLabelsInColumn({
      $container: this.$element(),
      layoutManager,
      excludeTabbed: true,
      items: this.option("items"),
      inOneColumn
    });
    triggerResizeEvent2(this.$element().find(`.${TOOLBAR_CLASS}`));
  }
  _clean() {
    this._clearValidationSummary();
    super._clean();
    this._groupsColCount = [];
    this._cachedColCountOptions = [];
    this._lastMarkupScreenFactor = void 0;
    resize_observer_default.unobserve(this.$element().get(0));
  }
  _renderScrollable() {
    const useNativeScrolling = this.option("useNativeScrolling");
    this._scrollable = new m_scrollable_default(this.$element(), {
      useNative: !!useNativeScrolling,
      useSimulatedScrollbar: !useNativeScrolling,
      useKeyboard: false,
      direction: "both",
      bounceEnabled: false
    });
  }
  _getContent() {
    var _this$_scrollable;
    return this.option("scrollingEnabled") ? renderer_default(null === (_this$_scrollable = this._scrollable) || void 0 === _this$_scrollable ? void 0 : _this$_scrollable.content()) : this.$element();
  }
  _clearValidationSummary() {
    var _this$_$validationSum;
    null === (_this$_$validationSum = this._$validationSummary) || void 0 === _this$_$validationSum || _this$_$validationSum.remove();
    this._$validationSummary = void 0;
    this._validationSummary = void 0;
  }
  _renderValidationSummary() {
    this._clearValidationSummary();
    if (this.option("showValidationSummary")) {
      this._$validationSummary = renderer_default("<div>").addClass(FORM_VALIDATION_SUMMARY).appendTo(this._getContent());
      this._validationSummary = this._$validationSummary.dxValidationSummary({
        validationGroup: this._getValidationGroup()
      }).dxValidationSummary("instance");
    }
  }
  _prepareItems(items, parentIsTabbedItem, currentPath, isTabs) {
    if (items) {
      const result2 = [];
      for (let i = 0; i < items.length; i++) {
        let item = items[i];
        const path = concatPaths(currentPath, createItemPathByIndex(i, isTabs));
        const itemRunTimeInfo = {
          item,
          itemIndex: i,
          path
        };
        const guid2 = this._itemsRunTimeInfo.add(itemRunTimeInfo);
        if (isString(item)) {
          item = {
            dataField: item
          };
        }
        if (isObject(item)) {
          const preparedItem = _extends({}, item);
          itemRunTimeInfo.preparedItem = preparedItem;
          preparedItem.guid = guid2;
          this._tryPrepareGroupItemCaption(preparedItem);
          this._tryPrepareGroupItem(preparedItem);
          this._tryPrepareTabbedItem(preparedItem, path);
          this._tryPrepareItemTemplate(preparedItem);
          if (parentIsTabbedItem) {
            preparedItem.cssItemClass = FIELD_ITEM_TAB_CLASS;
          }
          if (preparedItem.items) {
            preparedItem.items = this._prepareItems(preparedItem.items, parentIsTabbedItem, path);
          }
          result2.push(preparedItem);
        } else {
          result2.push(item);
        }
      }
      return result2;
    }
  }
  _tryPrepareGroupItemCaption(item) {
    if ("group" === item.itemType) {
      item._prepareGroupCaptionTemplate = (captionTemplate) => {
        if (item.captionTemplate) {
          item.groupCaptionTemplate = this._getTemplate(captionTemplate);
        }
        item.captionTemplate = this._itemGroupTemplate.bind(this, item);
      };
      item._prepareGroupCaptionTemplate(item.captionTemplate);
    }
  }
  _tryPrepareGroupItem(item) {
    if ("group" === item.itemType) {
      item.alignItemLabels = ensureDefined(item.alignItemLabels, true);
      item._prepareGroupItemTemplate = (itemTemplate) => {
        if (item.template) {
          item.groupContentTemplate = this._getTemplate(itemTemplate);
        }
        item.template = this._itemGroupTemplate.bind(this, item);
      };
      item._prepareGroupItemTemplate(item.template);
    }
  }
  _tryPrepareTabbedItem(item, path) {
    if ("tabbed" === item.itemType) {
      item.template = this._itemTabbedTemplate.bind(this, item);
      item.tabs = this._prepareItems(item.tabs, true, path, true);
    }
  }
  _tryPrepareItemTemplate(item) {
    if (item.template) {
      item.template = this._getTemplate(item.template);
    }
  }
  _checkGrouping(items) {
    if (items) {
      for (let i = 0; i < items.length; i++) {
        const item = items[i];
        if ("group" === item.itemType) {
          return true;
        }
      }
    }
  }
  _renderLayout() {
    const that = this;
    let items = that.option("items");
    const $content = that._getContent();
    items = that._prepareItems(items);
    that._rootLayoutManager = that._renderLayoutManager($content, this._createLayoutManagerOptions(items, {
      isRoot: true,
      colCount: that.option("colCount"),
      alignItemLabels: that.option("alignItemLabels"),
      screenByWidth: this.option("screenByWidth"),
      colCountByScreen: this.option("colCountByScreen"),
      onLayoutChanged(inOneColumn) {
        that._alignLabels.bind(that)(that._rootLayoutManager, inOneColumn);
      },
      onContentReady(e) {
        that._alignLabels(e.component, e.component.isSingleColumnMode());
      }
    }));
  }
  _tryGetItemsForTemplate(item) {
    return item.items || [];
  }
  _itemTabbedTemplate(item, e, $container) {
    const $tabPanel = renderer_default("<div>").appendTo($container);
    const tabPanelOptions = extend({}, item.tabPanelOptions, {
      dataSource: item.tabs,
      onItemRendered: (args) => {
        var _item$tabPanelOptions, _item$tabPanelOptions2;
        null === (_item$tabPanelOptions = item.tabPanelOptions) || void 0 === _item$tabPanelOptions || null === (_item$tabPanelOptions2 = _item$tabPanelOptions.onItemRendered) || void 0 === _item$tabPanelOptions2 || _item$tabPanelOptions2.call(_item$tabPanelOptions, args);
        triggerShownEvent2(args.itemElement);
      },
      itemTemplate: (itemData, e2, container) => {
        const $container2 = renderer_default(container);
        const alignItemLabels = ensureDefined(itemData.alignItemLabels, true);
        const layoutManager = this._renderLayoutManager($container2, this._createLayoutManagerOptions(this._tryGetItemsForTemplate(itemData), {
          colCount: itemData.colCount,
          alignItemLabels,
          screenByWidth: this.option("screenByWidth"),
          colCountByScreen: itemData.colCountByScreen,
          cssItemClass: itemData.cssItemClass,
          onLayoutChanged: (inOneColumn) => {
            this._alignLabelsInColumn({
              $container: $container2,
              layoutManager,
              items: itemData.items,
              inOneColumn
            });
          }
        }));
        if (this._itemsRunTimeInfo) {
          this._itemsRunTimeInfo.extendRunTimeItemInfoByKey(itemData.guid, {
            layoutManager
          });
        }
        if (alignItemLabels) {
          this._alignLabelsInColumn({
            $container: $container2,
            layoutManager,
            items: itemData.items,
            inOneColumn: layoutManager.isSingleColumnMode()
          });
        }
      }
    });
    const tryUpdateTabPanelInstance = (items, instance) => {
      if (Array.isArray(items)) {
        items.forEach((item2) => this._itemsRunTimeInfo.extendRunTimeItemInfoByKey(item2.guid, {
          widgetInstance: instance
        }));
      }
    };
    const tabPanel = this._createComponent($tabPanel, tab_panel_default2, tabPanelOptions);
    renderer_default($container).parent().addClass(FIELD_ITEM_CONTENT_HAS_TABS_CLASS);
    tabPanel.on("optionChanged", (e2) => {
      if ("dataSource" === e2.fullName) {
        tryUpdateTabPanelInstance(e2.value, e2.component);
      }
    });
    tryUpdateTabPanelInstance([{
      guid: item.guid
    }, ...item.tabs ?? []], tabPanel);
  }
  _itemGroupCaptionTemplate(item, $group, id) {
    if (item.groupCaptionTemplate) {
      const $captionTemplate = renderer_default("<div>").addClass(FORM_GROUP_CUSTOM_CAPTION_CLASS).attr("id", id).appendTo($group);
      item._renderGroupCaptionTemplate = () => {
        const data17 = {
          component: this,
          caption: item.caption,
          name: item.name
        };
        item.groupCaptionTemplate.render({
          model: data17,
          container: getPublicElement($captionTemplate)
        });
      };
      item._renderGroupCaptionTemplate();
      return;
    }
    if (item.caption) {
      renderer_default("<span>").addClass(FORM_GROUP_CAPTION_CLASS).text(item.caption).attr("id", id).appendTo($group);
    }
  }
  _itemGroupContentTemplate(item, $group) {
    const $groupContent = renderer_default("<div>").addClass(FORM_GROUP_CONTENT_CLASS).appendTo($group);
    if (item.groupContentTemplate) {
      item._renderGroupContentTemplate = () => {
        $groupContent.empty();
        const data17 = {
          formData: this.option("formData"),
          component: this
        };
        item.groupContentTemplate.render({
          model: data17,
          container: getPublicElement($groupContent)
        });
      };
      item._renderGroupContentTemplate();
    } else {
      var _this$_itemsRunTimeIn;
      const layoutManager = this._renderLayoutManager($groupContent, this._createLayoutManagerOptions(this._tryGetItemsForTemplate(item), {
        colCount: item.colCount,
        colCountByScreen: item.colCountByScreen,
        alignItemLabels: item.alignItemLabels,
        cssItemClass: item.cssItemClass
      }));
      null === (_this$_itemsRunTimeIn = this._itemsRunTimeInfo) || void 0 === _this$_itemsRunTimeIn || _this$_itemsRunTimeIn.extendRunTimeItemInfoByKey(item.guid, {
        layoutManager
      });
      const colCount = layoutManager._getColCount();
      if (!this._groupsColCount.includes(colCount)) {
        this._groupsColCount.push(colCount);
      }
      $group.addClass(GROUP_COL_COUNT_CLASS + colCount);
      $group.attr(GROUP_COL_COUNT_ATTR, colCount);
    }
  }
  _itemGroupTemplate(item, options2, $container) {
    const {
      id
    } = options2.editorOptions.inputAttr;
    const $group = renderer_default("<div>").toggleClass(FORM_GROUP_WITH_CAPTION_CLASS, isDefined(item.caption) && item.caption.length).addClass(FORM_GROUP_CLASS).appendTo($container);
    const groupAria = {
      role: "group",
      labelledby: id
    };
    this.setAria(groupAria, $group);
    renderer_default($container).parent().addClass(FIELD_ITEM_CONTENT_HAS_GROUP_CLASS);
    this._itemGroupCaptionTemplate(item, $group, id);
    this._itemGroupContentTemplate(item, $group);
  }
  _createLayoutManagerOptions(items, extendedLayoutManagerOptions) {
    return convertToLayoutManagerOptions({
      form: this,
      formOptions: this.option(),
      $formElement: this.$element(),
      items,
      validationGroup: this._getValidationGroup(),
      extendedLayoutManagerOptions,
      onFieldDataChanged: (args) => {
        if (!this._isDataUpdating) {
          this._triggerOnFieldDataChanged(args);
        }
      },
      onContentReady: (args) => {
        var _extendedLayoutManage;
        this._itemsRunTimeInfo.addItemsOrExtendFrom(args.component._itemsRunTimeInfo);
        null === (_extendedLayoutManage = extendedLayoutManagerOptions.onContentReady) || void 0 === _extendedLayoutManage || _extendedLayoutManage.call(extendedLayoutManagerOptions, args);
      },
      onDisposing: (_ref2) => {
        let {
          component
        } = _ref2;
        const nestedItemsRunTimeInfo = component.getItemsRunTimeInfo();
        this._itemsRunTimeInfo.removeItemsByItems(nestedItemsRunTimeInfo);
      },
      onFieldItemRendered: () => {
        var _this$_validationSumm;
        null === (_this$_validationSumm = this._validationSummary) || void 0 === _this$_validationSumm || _this$_validationSumm.refreshValidationGroup();
      }
    });
  }
  _renderLayoutManager($parent, layoutManagerOptions) {
    const baseColCountByScreen = {
      lg: layoutManagerOptions.colCount,
      md: layoutManagerOptions.colCount,
      sm: layoutManagerOptions.colCount,
      xs: 1
    };
    this._cachedColCountOptions.push({
      colCountByScreen: extend(baseColCountByScreen, layoutManagerOptions.colCountByScreen)
    });
    const $element = renderer_default("<div>");
    $element.appendTo($parent);
    const instance = this._createComponent($element, "dxLayoutManager", layoutManagerOptions);
    instance.on("autoColCountChanged", () => {
      this._clearAutoColCountChangedTimeout();
      this.autoColCountChangedTimeoutId = setTimeout(() => !this._disposed && this._refresh(), 0);
    });
    this._cachedLayoutManagers.push(instance);
    return instance;
  }
  _getValidationGroup() {
    return this.option("validationGroup") || this;
  }
  _createComponent($element, type2, config3) {
    config3 = config3 || {};
    this._extendConfig(config3, {
      readOnly: this.option("readOnly")
    });
    return super._createComponent($element, type2, config3);
  }
  _attachSyncSubscriptions() {
    const that = this;
    that.on("optionChanged", (args) => {
      const optionFullName = args.fullName;
      if ("formData" === optionFullName) {
        if (!isDefined(args.value)) {
          that._options.silent("formData", args.value = {});
        }
        that._triggerOnFieldDataChangedByDataSet(args.value);
      }
      if (that._cachedLayoutManagers.length) {
        each(that._cachedLayoutManagers, (index2, layoutManager) => {
          if ("formData" === optionFullName) {
            that._isDataUpdating = true;
            layoutManager.option("layoutData", args.value);
            that._isDataUpdating = false;
          }
          if ("readOnly" === args.name || "disabled" === args.name) {
            layoutManager.option(optionFullName, args.value);
          }
        });
      }
    });
  }
  _optionChanged(args) {
    const splitFullName = args.fullName.split(".");
    if (splitFullName.length > 1 && -1 !== splitFullName[0].search("items") && this._itemsOptionChangedHandler(args)) {
      return;
    }
    if (splitFullName.length > 1 && -1 !== splitFullName[0].search("formData") && this._formDataOptionChangedHandler(args)) {
      return;
    }
    this._defaultOptionChangedHandler(args);
  }
  _defaultOptionChangedHandler(args) {
    switch (args.name) {
      case "formData":
        if (!this.option("items")) {
          this._invalidate();
        } else if (isEmptyObject(args.value)) {
          this._clear();
        }
        break;
      case "onFieldDataChanged":
      case "alignRootItemLabels":
      case "readOnly":
      case "isDirty":
        break;
      case "items":
      case "colCount":
      case "onEditorEnterKey":
      case "labelLocation":
      case "labelMode":
      case "alignItemLabels":
      case "showColonAfterLabel":
      case "customizeItem":
      case "alignItemLabelsInAllGroups":
      case "showRequiredMark":
      case "showOptionalMark":
      case "requiredMark":
      case "optionalMark":
      case "requiredMessage":
      case "scrollingEnabled":
      case "formID":
      case "colCountByScreen":
      case "screenByWidth":
      case "stylingMode":
        this._invalidate();
        break;
      case "showValidationSummary":
        this._renderValidationSummary();
        break;
      case "minColWidth": {
        const {
          colCount
        } = this.option();
        if ("auto" === colCount) {
          this._invalidate();
        }
        break;
      }
      case "width":
        super._optionChanged(args);
        this._rootLayoutManager.option(args.name, args.value);
        this._alignLabels(this._rootLayoutManager, this._rootLayoutManager.isSingleColumnMode());
        break;
      case "validationGroup":
        validation_engine_default.removeGroup(args.previousValue || this);
        this._invalidate();
        break;
      default:
        super._optionChanged(args);
    }
  }
  _itemsOptionChangedHandler(args) {
    const nameParts = args.fullName.split(".");
    const {
      value: value2
    } = args;
    const itemPath = this._getItemPath(nameParts);
    const item = this.option(itemPath);
    const optionNameWithoutPath = args.fullName.replace(`${itemPath}.`, "");
    const simpleOptionName = optionNameWithoutPath.split(".")[0].replace(/\[\d+]/, "");
    const itemAction = this._tryCreateItemOptionAction(simpleOptionName, item, item[simpleOptionName], args.previousValue, itemPath);
    let result2 = this._tryExecuteItemOptionAction(itemAction) || this._tryChangeLayoutManagerItemOption(args.fullName, value2);
    if (!result2 && item) {
      this._changeItemOption(item, optionNameWithoutPath, value2);
      const items = this._generateItemsFromData(this.option("items"));
      this.option("items", items);
      result2 = true;
    }
    return result2;
  }
  _formDataOptionChangedHandler(args) {
    const nameParts = args.fullName.split(".");
    const {
      value: value2
    } = args;
    const dataField = nameParts.slice(1).join(".");
    const editor = this.getEditor(dataField);
    if (editor) {
      editor.option("value", value2);
    } else {
      this._triggerOnFieldDataChanged({
        dataField,
        value: value2
      });
    }
    return true;
  }
  _tryCreateItemOptionAction(optionName, item, value2, previousValue, itemPath) {
    if ("tabs" === optionName) {
      this._itemsRunTimeInfo.removeItemsByPathStartWith(`${itemPath}.tabs`);
      value2 = this._prepareItems(value2, true, itemPath, true);
    }
    return m_form_item_options_actions_default(optionName, {
      item,
      value: value2,
      previousValue,
      itemsRunTimeInfo: this._itemsRunTimeInfo
    });
  }
  _tryExecuteItemOptionAction(action) {
    return null === action || void 0 === action ? void 0 : action.tryExecute();
  }
  _updateValidationGroupAndSummaryIfNeeded(fullName) {
    const optionName = getOptionNameFromFullName(fullName);
    if (ITEM_OPTIONS_FOR_VALIDATION_UPDATING.includes(optionName)) {
      validation_engine_default.addGroup(this._getValidationGroup(), false);
      if (this.option("showValidationSummary")) {
        var _this$_validationSumm2;
        null === (_this$_validationSumm2 = this._validationSummary) || void 0 === _this$_validationSumm2 || _this$_validationSumm2.refreshValidationGroup();
      }
    }
  }
  _setLayoutManagerItemOption(layoutManager, optionName, value2, path) {
    if (this._updateLockCount > 0) {
      !layoutManager._updateLockCount && layoutManager.beginUpdate();
      const key = this._itemsRunTimeInfo.findKeyByPath(path);
      this.postponedOperations.add(key, () => {
        !layoutManager._disposed && layoutManager.endUpdate();
        return Deferred().resolve();
      });
    }
    const contentReadyHandler = (e) => {
      e.component.off("contentReady", contentReadyHandler);
      if (isFullPathContainsTabs(path)) {
        const tabPath = tryGetTabPath(path);
        const tabLayoutManager = this._itemsRunTimeInfo.findGroupOrTabLayoutManagerByPath(tabPath);
        if (tabLayoutManager) {
          this._alignLabelsInColumn({
            items: tabLayoutManager.option("items"),
            layoutManager: tabLayoutManager,
            $container: tabLayoutManager.$element(),
            inOneColumn: tabLayoutManager.isSingleColumnMode()
          });
        }
      } else {
        this._alignLabels(this._rootLayoutManager, this._rootLayoutManager.isSingleColumnMode());
      }
    };
    layoutManager.on("contentReady", contentReadyHandler);
    layoutManager.option(optionName, value2);
    this._updateValidationGroupAndSummaryIfNeeded(optionName);
  }
  _tryChangeLayoutManagerItemOption(fullName, value2) {
    const nameParts = fullName.split(".");
    const optionName = getOptionNameFromFullName(fullName);
    if ("items" === optionName && nameParts.length > 1) {
      const itemPath = this._getItemPath(nameParts);
      const layoutManager = this._itemsRunTimeInfo.findGroupOrTabLayoutManagerByPath(itemPath);
      if (layoutManager) {
        this._itemsRunTimeInfo.removeItemsByItems(layoutManager.getItemsRunTimeInfo());
        const items = this._prepareItems(value2, false, itemPath);
        this._setLayoutManagerItemOption(layoutManager, optionName, items, itemPath);
        return true;
      }
    } else if (nameParts.length > 2) {
      const endPartIndex = nameParts.length - 2;
      const itemPath = this._getItemPath(nameParts.slice(0, endPartIndex));
      const layoutManager = this._itemsRunTimeInfo.findGroupOrTabLayoutManagerByPath(itemPath);
      if (layoutManager) {
        const fullOptionName = getFullOptionName(nameParts[endPartIndex], optionName);
        if ("editorType" === optionName) {
          if (layoutManager.option(fullOptionName) !== value2) {
            return false;
          }
        }
        if ("visible" === optionName) {
          const formItems = this.option(getFullOptionName(itemPath, "items"));
          if (null !== formItems && void 0 !== formItems && formItems.length) {
            const layoutManagerItems = layoutManager.option("items");
            formItems.forEach((item, index2) => {
              const layoutItem = layoutManagerItems[index2];
              layoutItem.visibleIndex = item.visibleIndex;
            });
          }
        }
        this._setLayoutManagerItemOption(layoutManager, fullOptionName, value2, itemPath);
        return true;
      }
    }
    return false;
  }
  _tryChangeLayoutManagerItemOptions(itemPath, options2) {
    let result2;
    this.beginUpdate();
    each(options2, (optionName, optionValue) => {
      result2 = this._tryChangeLayoutManagerItemOption(getFullOptionName(itemPath, optionName), optionValue);
      if (!result2) {
        return false;
      }
    });
    this.endUpdate();
    return result2;
  }
  _getItemPath(nameParts) {
    let itemPath = nameParts[0];
    let i;
    for (i = 1; i < nameParts.length; i++) {
      if (-1 !== nameParts[i].search(/items\[\d+]|tabs\[\d+]/)) {
        itemPath += `.${nameParts[i]}`;
      } else {
        break;
      }
    }
    return itemPath;
  }
  _triggerOnFieldDataChanged(args) {
    this._updateIsDirty(args.dataField);
    this._createActionByOption("onFieldDataChanged")(args);
  }
  _triggerOnFieldDataChangedByDataSet(data17) {
    if (data17 && isObject(data17)) {
      Object.keys(data17).forEach((key) => {
        this._triggerOnFieldDataChanged({
          dataField: key,
          value: data17[key]
        });
      });
    }
  }
  _updateFieldValue(dataField, value2) {
    if (isDefined(this.option("formData"))) {
      const editor = this.getEditor(dataField);
      this.option(`formData.${dataField}`, value2);
      if (editor) {
        const editorValue = editor.option("value");
        if (editorValue !== value2) {
          editor.option("value", value2);
        }
      }
    }
  }
  _generateItemsFromData(items) {
    const formData = this.option("formData");
    const result2 = [];
    if (!items && isDefined(formData)) {
      each(formData, (dataField) => {
        result2.push({
          dataField
        });
      });
    }
    if (items) {
      each(items, (index2, item) => {
        if (isObject(item)) {
          result2.push(item);
        } else {
          result2.push({
            dataField: item
          });
        }
      });
    }
    return result2;
  }
  _getItemByField(field, items) {
    const that = this;
    const fieldParts = isObject(field) ? field : that._getFieldParts(field);
    const {
      fieldName
    } = fieldParts;
    const {
      fieldPath
    } = fieldParts;
    let resultItem;
    if (items.length) {
      each(items, (index2, item) => {
        const {
          itemType
        } = item;
        if (fieldPath.length) {
          const path = fieldPath.slice();
          item = that._getItemByFieldPath(path, fieldName, item);
        } else if ("group" === itemType && !(item.caption || item.name) || "tabbed" === itemType && !item.name) {
          const subItemsField = that._getSubItemField(itemType);
          item.items = that._generateItemsFromData(item.items);
          item = that._getItemByField({
            fieldName,
            fieldPath
          }, item[subItemsField]);
        }
        if (isEqualToDataFieldOrNameOrTitleOrCaption(item, fieldName)) {
          resultItem = item;
          return false;
        }
      });
    }
    return resultItem;
  }
  _getFieldParts(field) {
    let fieldName = field;
    let separatorIndex = fieldName.indexOf(".");
    const resultPath = [];
    while (-1 !== separatorIndex) {
      resultPath.push(fieldName.substr(0, separatorIndex));
      fieldName = fieldName.substr(separatorIndex + 1);
      separatorIndex = fieldName.indexOf(".");
    }
    return {
      fieldName,
      fieldPath: resultPath.reverse()
    };
  }
  _getItemByFieldPath(path, fieldName, item) {
    const that = this;
    const {
      itemType
    } = item;
    const subItemsField = that._getSubItemField(itemType);
    const isItemWithSubItems = "group" === itemType || "tabbed" === itemType || item.title;
    let result2;
    do {
      if (isItemWithSubItems) {
        const name2 = item.name || item.caption || item.title;
        const isGroupWithName = isDefined(name2);
        const nameWithoutSpaces = getTextWithoutSpaces(name2);
        let pathNode;
        item[subItemsField] = that._generateItemsFromData(item[subItemsField]);
        if (isGroupWithName) {
          pathNode = path.pop();
        }
        if (!path.length) {
          result2 = that._getItemByField(fieldName, item[subItemsField]);
          if (result2) {
            break;
          }
        }
        if (!isGroupWithName || isGroupWithName && nameWithoutSpaces === pathNode) {
          if (path.length) {
            result2 = that._searchItemInEverySubItem(path, fieldName, item[subItemsField]);
          }
        }
      } else {
        break;
      }
    } while (path.length && !isDefined(result2));
    return result2;
  }
  _getSubItemField(itemType) {
    return "tabbed" === itemType ? "tabs" : "items";
  }
  _searchItemInEverySubItem(path, fieldName, items) {
    const that = this;
    let result2;
    each(items, (index2, groupItem) => {
      result2 = that._getItemByFieldPath(path.slice(), fieldName, groupItem);
      if (result2) {
        return false;
      }
    });
    if (!result2) {
      result2 = false;
    }
    return result2;
  }
  _changeItemOption(item, option, value2) {
    if (isObject(item)) {
      item[option] = value2;
    }
  }
  _dimensionChanged() {
    const currentScreenFactor = this._getCurrentScreenFactor();
    if (this._lastMarkupScreenFactor !== currentScreenFactor) {
      if (this._isColCountChanged(this._lastMarkupScreenFactor, currentScreenFactor)) {
        this._targetScreenFactor = currentScreenFactor;
        this._refresh();
        this._targetScreenFactor = void 0;
      }
      this._lastMarkupScreenFactor = currentScreenFactor;
    }
  }
  _isColCountChanged(oldScreenSize, newScreenSize) {
    let isChanged = false;
    each(this._cachedColCountOptions, (index2, item) => {
      if (item.colCountByScreen[oldScreenSize] !== item.colCountByScreen[newScreenSize]) {
        isChanged = true;
        return false;
      }
    });
    return isChanged;
  }
  _refresh() {
    const editorSelector = `.${TEXTEDITOR_CLASS}.${FOCUSED_STATE_CLASS}:not(.${DROP_DOWN_EDITOR_CLASS}) .${TEXTEDITOR_INPUT_CLASS}`;
    m_events_engine_default.trigger(this.$element().find(editorSelector), "change");
    super._refresh();
  }
  _updateIsDirty(dataField) {
    const editor = this.getEditor(dataField);
    if (!editor) {
      return;
    }
    if (editor.option("isDirty")) {
      this._dirtyFields.add(dataField);
    } else {
      this._dirtyFields.delete(dataField);
    }
    this.option("isDirty", !!this._dirtyFields.size);
  }
  updateRunTimeInfoForEachEditor(editorAction) {
    this._itemsRunTimeInfo.each((_, itemRunTimeInfo) => {
      const {
        widgetInstance
      } = itemRunTimeInfo;
      if (isDefined(widgetInstance) && editor_default2.isEditor(widgetInstance)) {
        editorAction(widgetInstance);
      }
    });
  }
  _clear() {
    this.updateRunTimeInfoForEachEditor((editor) => {
      editor.clear();
      editor.option("isValid", true);
    });
    validation_engine_default.resetGroup(this._getValidationGroup());
  }
  _updateData(data17, value2, isComplexData) {
    const that = this;
    const _data = isComplexData ? value2 : data17;
    if (isObject(_data)) {
      each(_data, (dataField, fieldValue) => {
        that._updateData(isComplexData ? `${data17}.${dataField}` : dataField, fieldValue, isObject(fieldValue));
      });
    } else if (isString(data17)) {
      that._updateFieldValue(data17, value2);
    }
  }
  registerKeyHandler(key, handler) {
    super.registerKeyHandler(key, handler);
    this._itemsRunTimeInfo.each((_, itemRunTimeInfo) => {
      if (isDefined(itemRunTimeInfo.widgetInstance)) {
        itemRunTimeInfo.widgetInstance.registerKeyHandler(key, handler);
      }
    });
  }
  _focusTarget() {
    return this.$element().find(`.${FIELD_ITEM_CONTENT_CLASS} [tabindex]`).first();
  }
  _visibilityChanged() {
    this._alignLabels(this._rootLayoutManager, this._rootLayoutManager.isSingleColumnMode());
  }
  _clearAutoColCountChangedTimeout() {
    if (this.autoColCountChangedTimeoutId) {
      clearTimeout(this.autoColCountChangedTimeoutId);
      this.autoColCountChangedTimeoutId = void 0;
    }
  }
  _dispose() {
    this._clearAutoColCountChangedTimeout();
    validation_engine_default.removeGroup(this._getValidationGroup());
    super._dispose();
  }
  clear() {
    this._clear();
  }
  resetValues() {
    this._clear();
  }
  reset(editorsData) {
    this.updateRunTimeInfoForEachEditor((editor) => {
      const editorName = editor.option("name");
      if (editorsData && editorName in editorsData) {
        editor.reset(editorsData[editorName]);
        this._updateIsDirty(editorName);
      } else {
        editor.reset();
      }
    });
    this._renderValidationSummary();
  }
  updateData(data17, value2) {
    this._updateData(data17, value2);
  }
  getEditor(dataField) {
    return this._itemsRunTimeInfo.findWidgetInstanceByDataField(dataField) || this._itemsRunTimeInfo.findWidgetInstanceByName(dataField);
  }
  getButton(name2) {
    return this._itemsRunTimeInfo.findWidgetInstanceByName(name2);
  }
  updateDimensions() {
    const that = this;
    const deferred = Deferred();
    if (that._scrollable) {
      that._scrollable.update().done(() => {
        deferred.resolveWith(that);
      });
    } else {
      deferred.resolveWith(that);
    }
    return deferred.promise();
  }
  itemOption(id, option, value2) {
    const items = this._generateItemsFromData(this.option("items"));
    const item = this._getItemByField(id, items);
    const path = getItemPath(items, item);
    if (!item) {
      return;
    }
    switch (arguments.length) {
      case 1:
        return item;
      case 3: {
        const itemAction = this._tryCreateItemOptionAction(option, item, value2, item[option], path);
        this._changeItemOption(item, option, value2);
        const fullName = getFullOptionName(path, option);
        if (!this._tryExecuteItemOptionAction(itemAction) && !this._tryChangeLayoutManagerItemOption(fullName, value2)) {
          this.option("items", items);
        }
        break;
      }
      default:
        if (isObject(option)) {
          if (!this._tryChangeLayoutManagerItemOptions(path, option)) {
            let allowUpdateItems;
            each(option, (optionName, optionValue) => {
              const itemAction = this._tryCreateItemOptionAction(optionName, item, optionValue, item[optionName], path);
              this._changeItemOption(item, optionName, optionValue);
              if (!allowUpdateItems && !this._tryExecuteItemOptionAction(itemAction)) {
                allowUpdateItems = true;
              }
            });
            allowUpdateItems && this.option("items", items);
          }
        }
    }
  }
  validate() {
    return validation_engine_default.validateGroup(this._getValidationGroup());
  }
  getItemID(name2) {
    const {
      formID
    } = this.option();
    return `dx_${formID}_${name2 || new guid_default2()}`;
  }
  getTargetScreenFactor() {
    return this._targetScreenFactor;
  }
};
component_registrator_default("dxForm", Form);
var m_form_default = Form;

// node_modules/devextreme/esm/ui/form/ui.form.js
var ui_form_default = m_form_default;

// node_modules/devextreme/esm/ui/form.js
var form_default = ui_form_default;

// node_modules/devextreme/esm/__internal/grids/grid_core/editing/m_editing_form_based.js
var editingControllerExtender2 = (Base) => class extends Base {
  init() {
    this._editForm = null;
    this._updateEditFormDeferred = null;
    super.init();
  }
  isEditRow(rowIndex) {
    return !this.isPopupEditMode() && super.isEditRow(rowIndex);
  }
  isFormOrPopupEditMode() {
    return this.isPopupEditMode() || this.isFormEditMode();
  }
  isFormEditMode() {
    const editMode = this.option("editing.mode");
    return editMode === EDIT_MODE_FORM;
  }
  getFirstEditableColumnIndex() {
    const firstFormItem = this._firstFormItem;
    if (this.isFormEditMode() && firstFormItem) {
      const editRowKey = this.option(EDITING_EDITROWKEY_OPTION_NAME);
      const editRowIndex = this._dataController.getRowIndexByKey(editRowKey);
      const $editFormElements = this._rowsView.getCellElements(editRowIndex);
      return this._rowsView._getEditFormEditorVisibleIndex($editFormElements, firstFormItem.column);
    }
    return super.getFirstEditableColumnIndex();
  }
  getEditFormRowIndex() {
    return this.isFormOrPopupEditMode() ? this._getVisibleEditRowIndex() : super.getEditFormRowIndex();
  }
  _isEditColumnVisible() {
    const result2 = super._isEditColumnVisible();
    const editingOptions = this.option("editing");
    return this.isFormOrPopupEditMode() ? editingOptions.allowUpdating || result2 : result2;
  }
  _handleDataChanged(args) {
    if (this.isPopupEditMode()) {
      var _args$items, _args$changeTypes;
      const editRowKey = this.option("editing.editRowKey");
      const hasEditRow = null === args || void 0 === args || null === (_args$items = args.items) || void 0 === _args$items ? void 0 : _args$items.some((item) => equalByValue(item.key, editRowKey));
      const onlyInsertChanges = (null === (_args$changeTypes = args.changeTypes) || void 0 === _args$changeTypes ? void 0 : _args$changeTypes.length) && args.changeTypes.every((item) => "insert" === item);
      if (("refresh" === args.changeType || hasEditRow && args.isOptionChanged) && !onlyInsertChanges) {
        this._repaintEditPopup();
      }
    }
    super._handleDataChanged(args);
  }
  getPopupContent() {
    var _this$_editPopup;
    const popupVisible = null === (_this$_editPopup = this._editPopup) || void 0 === _this$_editPopup ? void 0 : _this$_editPopup.option("visible");
    if (this.isPopupEditMode() && popupVisible) {
      return this._$popupContent;
    }
  }
  _showAddedRow(rowIndex) {
    if (this.isPopupEditMode()) {
      this._showEditPopup(rowIndex);
    } else {
      super._showAddedRow(rowIndex);
    }
  }
  _cancelEditDataCore() {
    super._cancelEditDataCore();
    if (this.isPopupEditMode()) {
      this._hideEditPopup();
    }
  }
  _updateEditRowCore(row, skipCurrentRow, isCustomSetCellValue) {
    const editForm = this._editForm;
    if (this.isPopupEditMode()) {
      if (this.option("repaintChangesOnly")) {
        var _row$update;
        null === (_row$update = row.update) || void 0 === _row$update || _row$update.call(row, row);
        this._rowsView.renderDelayedTemplates();
      } else if (editForm) {
        this._updateEditFormDeferred = new Deferred().done(() => editForm.repaint());
        if (!this._updateLockCount) {
          this._updateEditFormDeferred.resolve();
        }
      }
    } else {
      super._updateEditRowCore(row, skipCurrentRow, isCustomSetCellValue);
    }
  }
  _showEditPopup(rowIndex, repaintForm) {
    const isMobileDevice = "desktop" !== devices_default.current().deviceType;
    const editPopupClass = this.addWidgetPrefix(EDIT_POPUP_CLASS);
    const popupOptions = extend({
      showTitle: false,
      fullScreen: isMobileDevice,
      wrapperAttr: {
        class: editPopupClass
      },
      toolbarItems: [{
        toolbar: "bottom",
        location: "after",
        widget: "dxButton",
        options: this._getSaveButtonConfig()
      }, {
        toolbar: "bottom",
        location: "after",
        widget: "dxButton",
        options: this._getCancelButtonConfig()
      }],
      contentTemplate: this._getPopupEditFormTemplate(rowIndex)
    }, this.option(EDITING_POPUP_OPTION_NAME));
    if (!this._editPopup) {
      const $popupContainer = renderer_default("<div>").appendTo(this.component.$element()).addClass(editPopupClass);
      this._editPopup = this._createComponent($popupContainer, ui_popup_default);
      this._editPopup.on("hiding", this._getEditPopupHiddenHandler());
      this._editPopup.on("shown", (e) => {
        m_events_engine_default.trigger(e.component.$content().find(FOCUSABLE_ELEMENT_SELECTOR).not(`.${FOCUSABLE_ELEMENT_CLASS}`).first(), "focus");
        if (repaintForm) {
          var _this$_editForm;
          null === (_this$_editForm = this._editForm) || void 0 === _this$_editForm || _this$_editForm.repaint();
        }
      });
    }
    this._editPopup.option(popupOptions);
    this._editPopup.show();
    super._showEditPopup(rowIndex, repaintForm);
  }
  _getPopupEditFormTemplate(rowIndex) {
    const row = this.component.getVisibleRows()[rowIndex];
    const templateOptions = {
      row,
      values: row.values,
      rowType: row.rowType,
      key: row.key,
      rowIndex
    };
    this._rowsView._addWatchMethod(templateOptions, row);
    return (container) => {
      const formTemplate = this.getEditFormTemplate();
      const scrollable = this._createComponent(renderer_default("<div>").appendTo(container), ui_scrollable_default);
      this._$popupContent = renderer_default(scrollable.content());
      formTemplate(this._$popupContent, templateOptions, {
        isPopupForm: true
      });
      this._rowsView.renderDelayedTemplates();
      renderer_default(container).parent().attr("aria-label", this.localize("dxDataGrid-ariaEditForm"));
    };
  }
  _repaintEditPopup() {
    const rowIndex = this._getVisibleEditRowIndex();
    if (rowIndex >= 0) {
      var _this$_editPopup2, _this$_editPopup3;
      const defaultAnimation = null === (_this$_editPopup2 = this._editPopup) || void 0 === _this$_editPopup2 ? void 0 : _this$_editPopup2.option("animation");
      null === (_this$_editPopup3 = this._editPopup) || void 0 === _this$_editPopup3 || _this$_editPopup3.option("animation", null);
      this._showEditPopup(rowIndex, true);
      if (void 0 !== defaultAnimation) {
        this._editPopup.option("animation", defaultAnimation);
      }
    }
  }
  _hideEditPopup() {
    var _this$_editPopup4;
    null === (_this$_editPopup4 = this._editPopup) || void 0 === _this$_editPopup4 || _this$_editPopup4.option("visible", false);
  }
  optionChanged(args) {
    if ("editing" === args.name && this.isFormOrPopupEditMode()) {
      const {
        fullName
      } = args;
      if (0 === fullName.indexOf(EDITING_FORM_OPTION_NAME)) {
        this._handleFormOptionChange(args);
        args.handled = true;
      } else if (0 === fullName.indexOf(EDITING_POPUP_OPTION_NAME)) {
        this._handlePopupOptionChange(args);
        args.handled = true;
      }
    }
    super.optionChanged(args);
  }
  _handleFormOptionChange(args) {
    var _this$_editPopup5;
    if (this.isFormEditMode()) {
      const editRowIndex = this._getVisibleEditRowIndex();
      if (editRowIndex >= 0) {
        this._dataController.updateItems({
          changeType: "update",
          rowIndices: [editRowIndex]
        });
      }
    } else if (null !== (_this$_editPopup5 = this._editPopup) && void 0 !== _this$_editPopup5 && _this$_editPopup5.option("visible") && 0 === args.fullName.indexOf(EDITING_FORM_OPTION_NAME)) {
      this._repaintEditPopup();
    }
  }
  _handlePopupOptionChange(args) {
    const editPopup = this._editPopup;
    if (editPopup) {
      const popupOptionName = args.fullName.slice(EDITING_POPUP_OPTION_NAME.length + 1);
      if (popupOptionName) {
        editPopup.option(popupOptionName, args.value);
      } else {
        editPopup.option(args.value);
      }
    }
  }
  renderFormEditorTemplate(detailCellOptions, item, formTemplateOptions, container, isReadOnly) {
    const that = this;
    const $container = renderer_default(container);
    const {
      column
    } = item;
    const editorType = getEditorType(item);
    const row = null === detailCellOptions || void 0 === detailCellOptions ? void 0 : detailCellOptions.row;
    const rowData = null === row || void 0 === row ? void 0 : row.data;
    const form = formTemplateOptions.component;
    const value2 = column.calculateCellValue(rowData);
    const displayValue = m_utils_default.getDisplayValue(column, value2, rowData, null === row || void 0 === row ? void 0 : row.rowType);
    const {
      label,
      labelMark,
      labelMode
    } = formTemplateOptions.editorOptions || {};
    const cellOptions = extend({}, detailCellOptions, {
      data: rowData,
      cellElement: null,
      isOnForm: true,
      item,
      id: form.getItemID(item.name || item.dataField),
      column: extend({}, column, {
        editorType,
        editorOptions: extend({
          label,
          labelMark,
          labelMode
        }, column.editorOptions, item.editorOptions)
      }),
      columnIndex: column.index,
      setValue: !isReadOnly && column.allowEditing && function(value3, text) {
        that.updateFieldValue(cellOptions, value3, text);
      }
    });
    cellOptions.value = value2;
    cellOptions.displayValue = displayValue;
    cellOptions.text = !column.command ? m_utils_default.formatValue(displayValue, column) : "";
    const template = this._getFormEditItemTemplate.bind(this)(cellOptions, column);
    this._rowsView.renderTemplate($container, template, cellOptions, !!isElementInDom($container)).done(() => {
      this._rowsView._updateCell($container, cellOptions);
    });
    return cellOptions;
  }
  getFormEditorTemplate(cellOptions, item) {
    const column = this.component.columnOption(item.name || item.dataField);
    return (options2, container) => {
      const $container = renderer_default(container);
      const {
        row
      } = cellOptions;
      if (null !== row && void 0 !== row && row.watch) {
        const dispose2 = row.watch(() => column.selector(row.data), () => {
          var _validator;
          let $editorElement = $container.find(".dx-widget").first();
          let validator = $editorElement.data("dxValidator");
          const validatorOptions = null === (_validator = validator) || void 0 === _validator ? void 0 : _validator.option();
          $container.contents().remove();
          cellOptions = this.renderFormEditorTemplate.bind(this)(cellOptions, item, options2, $container);
          $editorElement = $container.find(".dx-widget").first();
          validator = $editorElement.data("dxValidator");
          if (validatorOptions && !validator) {
            $editorElement.dxValidator({
              validationRules: validatorOptions.validationRules,
              validationGroup: validatorOptions.validationGroup,
              dataGetter: validatorOptions.dataGetter
            });
          }
        });
        m_events_engine_default.on($container, removeEvent, dispose2);
      }
      cellOptions = this.renderFormEditorTemplate.bind(this)(cellOptions, item, options2, $container);
    };
  }
  getEditFormOptions(detailOptions) {
    var _this$_getValidationG;
    const editFormOptions = null === (_this$_getValidationG = this._getValidationGroupsInForm) || void 0 === _this$_getValidationG ? void 0 : _this$_getValidationG.call(this, detailOptions);
    const userCustomizeItem = this.option("editing.form.customizeItem");
    const editFormItemClass = this.addWidgetPrefix(EDIT_FORM_ITEM_CLASS2);
    let items = this.option("editing.form.items");
    const isCustomEditorType = {};
    if (!items) {
      const columns7 = this._columnsController.getColumns();
      items = [];
      each(columns7, (_, column) => {
        if (!column.isBand && !column.type) {
          items.push({
            column,
            name: column.name,
            dataField: column.dataField
          });
        }
      });
    } else {
      forEachFormItems(items, (item) => {
        const itemId = (null === item || void 0 === item ? void 0 : item.name) || (null === item || void 0 === item ? void 0 : item.dataField);
        if (itemId) {
          isCustomEditorType[itemId] = !!item.editorType;
        }
      });
    }
    return extend({}, editFormOptions, {
      items,
      formID: `dx-${new guid_default2()}`,
      customizeItem: (item) => {
        let column;
        const itemId = item.name || item.dataField;
        if (item.column || itemId) {
          column = item.column || this._columnsController.columnOption(item.name ? `name:${item.name}` : `dataField:${item.dataField}`);
        }
        if (column) {
          item.label = item.label || {};
          item.label.text = item.label.text || column.caption;
          if ("boolean" === column.dataType && void 0 === item.label.visible) {
            const labelMode = this.option("editing.form.labelMode");
            if ("floating" === labelMode || "static" === labelMode) {
              item.label.visible = true;
            }
          }
          item.template = item.template || this.getFormEditorTemplate(detailOptions, item);
          item.column = column;
          item.isCustomEditorType = isCustomEditorType[itemId];
          if (column.formItem) {
            extend(item, column.formItem);
          }
          if (void 0 === item.isRequired && column.validationRules) {
            item.isRequired = column.validationRules.some((rule) => "required" === rule.type);
            item.validationRules = [];
          }
          const itemVisible = isDefined(item.visible) ? item.visible : true;
          if (!this._firstFormItem && itemVisible) {
            this._firstFormItem = item;
          }
        }
        null === userCustomizeItem || void 0 === userCustomizeItem || userCustomizeItem.call(this, item);
        item.cssClass = isString(item.cssClass) ? `${item.cssClass} ${editFormItemClass}` : editFormItemClass;
      }
    });
  }
  getEditFormTemplate() {
    return ($container, detailOptions, options2) => {
      const editFormOptions = this.option(EDITING_FORM_OPTION_NAME);
      const baseEditFormOptions = this.getEditFormOptions(detailOptions);
      const $formContainer = renderer_default("<div>").appendTo($container);
      const isPopupForm = null === options2 || void 0 === options2 ? void 0 : options2.isPopupForm;
      this._firstFormItem = void 0;
      if (isPopupForm) {
        $formContainer.addClass(this.addWidgetPrefix(EDIT_POPUP_FORM_CLASS));
      }
      this._editForm = this._createComponent($formContainer, form_default, extend({}, editFormOptions, baseEditFormOptions));
      if (!isPopupForm) {
        const $buttonsContainer = renderer_default("<div>").addClass(this.addWidgetPrefix(FORM_BUTTONS_CONTAINER_CLASS)).appendTo($container);
        this._createComponent(renderer_default("<div>").appendTo($buttonsContainer), button_default2, this._getSaveButtonConfig());
        this._createComponent(renderer_default("<div>").appendTo($buttonsContainer), button_default2, this._getCancelButtonConfig());
      }
      this._editForm.on("contentReady", () => {
        var _this$_editPopup6;
        this._rowsView.renderDelayedTemplates();
        null === (_this$_editPopup6 = this._editPopup) || void 0 === _this$_editPopup6 || _this$_editPopup6.repaint();
      });
    };
  }
  getEditForm() {
    return this._editForm;
  }
  _endUpdateCore() {
    var _this$_updateEditForm;
    null === (_this$_updateEditForm = this._updateEditFormDeferred) || void 0 === _this$_updateEditForm || _this$_updateEditForm.resolve();
  }
  _beforeEndSaving(changes) {
    super._beforeEndSaving(changes);
    if (this.isPopupEditMode()) {
      var _this$_editPopup7;
      null === (_this$_editPopup7 = this._editPopup) || void 0 === _this$_editPopup7 || _this$_editPopup7.hide();
    }
  }
  _processDataItemCore(item, change, key, columns7, generateDataValues) {
    const {
      type: type2
    } = change;
    if (this.isPopupEditMode() && type2 === DATA_EDIT_DATA_INSERT_TYPE) {
      item.visible = false;
    }
    super._processDataItemCore(item, change, key, columns7, generateDataValues);
  }
  _editRowFromOptionChangedCore(rowIndices, rowIndex) {
    const isPopupEditMode = this.isPopupEditMode();
    super._editRowFromOptionChangedCore(rowIndices, rowIndex, isPopupEditMode);
    if (isPopupEditMode) {
      this._showEditPopup(rowIndex);
    }
  }
};
var data6 = (Base) => class extends Base {
  _updateEditItem(item) {
    if (this._editingController.isFormEditMode()) {
      item.rowType = "detail";
    }
  }
  _getChangedColumnIndices(oldItem, newItem, visibleRowIndex, isLiveUpdate) {
    if (false === isLiveUpdate && newItem.isEditing && this._editingController.isFormEditMode()) {
      return;
    }
    return super._getChangedColumnIndices.apply(this, arguments);
  }
};
var rowsView5 = (Base) => class extends Base {
  _renderCellContent($cell, options2) {
    if ("data" === options2.rowType && this._editingController.isPopupEditMode() && false === options2.row.visible) {
      return;
    }
    super._renderCellContent.apply(this, arguments);
  }
  getCellElements(rowIndex) {
    const $cellElements = super.getCellElements(rowIndex);
    const editingController = this._editingController;
    const editForm = editingController.getEditForm();
    const editFormRowIndex = editingController.getEditFormRowIndex();
    if (editFormRowIndex === rowIndex && $cellElements && editForm) {
      return editForm.$element().find(`.${this.addWidgetPrefix(EDIT_FORM_ITEM_CLASS2)}, .${BUTTON_CLASS2}`);
    }
    return $cellElements;
  }
  _getVisibleColumnIndex($cells, rowIndex, columnIdentifier) {
    const editFormRowIndex = this._editingController.getEditFormRowIndex();
    if (editFormRowIndex === rowIndex && isString(columnIdentifier)) {
      const column = this._columnsController.columnOption(columnIdentifier);
      return this._getEditFormEditorVisibleIndex($cells, column);
    }
    return super._getVisibleColumnIndex.apply(this, arguments);
  }
  _getEditFormEditorVisibleIndex($cells, column) {
    let visibleIndex = -1;
    each($cells, (index2, cellElement) => {
      const item = renderer_default(cellElement).find(".dx-field-item-content").data("dx-form-item");
      if (null !== item && void 0 !== item && item.column && column && item.column.index === column.index) {
        visibleIndex = index2;
        return false;
      }
    });
    return visibleIndex;
  }
  _isFormItem(parameters) {
    const isDetailRow2 = "detail" === parameters.rowType || "detailAdaptive" === parameters.rowType;
    const isPopupEditing = "data" === parameters.rowType && this._editingController.isPopupEditMode();
    return (isDetailRow2 || isPopupEditing) && parameters.item;
  }
  _updateCell($cell, parameters) {
    if (this._isFormItem(parameters)) {
      this._formItemPrepared(parameters, $cell);
    } else {
      super._updateCell($cell, parameters);
    }
  }
  _updateContent() {
    const editingController = this._editingController;
    const oldEditForm = editingController.getEditForm();
    const validationGroup = null === oldEditForm || void 0 === oldEditForm ? void 0 : oldEditForm.option("validationGroup");
    const deferred = super._updateContent.apply(this, arguments);
    return deferred.done(() => {
      const newEditForm = editingController.getEditForm();
      if (validationGroup && newEditForm && newEditForm !== oldEditForm) {
        newEditForm.option("validationGroup", validationGroup);
      }
    });
  }
};
var editingFormBasedModule = {
  extenders: {
    controllers: {
      editing: editingControllerExtender2,
      data: data6
    },
    views: {
      rowsView: rowsView5
    }
  }
};

// node_modules/devextreme/esm/__internal/grids/data_grid/module_not_extended/editing_form_based.js
m_core_default.registerModule("editingFormBased", editingFormBasedModule);

// node_modules/devextreme/esm/__internal/grids/grid_core/editing/m_editing_cell_based.js
var editingControllerExtender3 = (Base) => class extends Base {
  init() {
    const needCreateHandlers = !this._saveEditorHandler;
    super.init();
    if (needCreateHandlers) {
      let $pointerDownTarget;
      let isResizing;
      this._pointerUpEditorHandler = () => {
        var _this$_columnsResizer;
        isResizing = null === (_this$_columnsResizer = this._columnsResizerController) || void 0 === _this$_columnsResizer ? void 0 : _this$_columnsResizer.isResizing();
      };
      this._pointerDownEditorHandler = (e) => $pointerDownTarget = renderer_default(e.target);
      this._saveEditorHandler = this.createAction(function(e) {
        const {
          event
        } = e;
        const $target = renderer_default(event.target);
        const targetComponent = event[TARGET_COMPONENT_NAME];
        const {
          component
        } = this;
        if (isEditable($pointerDownTarget) && !$pointerDownTarget.is($target)) {
          return;
        }
        function checkEditorPopup($element) {
          if (!$element) {
            return false;
          }
          const $dropDownEditorOverlay = $element.closest(`.${DROPDOWN_EDITOR_OVERLAY_CLASS2}`);
          const $componentElement = component.$element();
          return $dropDownEditorOverlay.length > 0 && 0 === $componentElement.closest($dropDownEditorOverlay).length;
        }
        if (this.isCellOrBatchEditMode() && !this._editCellInProgress) {
          const isEditorPopup = checkEditorPopup($target) || checkEditorPopup(null === targetComponent || void 0 === targetComponent ? void 0 : targetComponent.$element());
          const isAnotherComponent = targetComponent && !targetComponent._disposed && targetComponent !== this.component;
          const isAddRowButton = !!$target.closest(`.${this.addWidgetPrefix(ADD_ROW_BUTTON_CLASS)}`).length;
          const isFocusOverlay = $target.hasClass(this.addWidgetPrefix(FOCUS_OVERLAY_CLASS));
          const isCellEditMode = this.isCellEditMode();
          if (!isResizing && !isEditorPopup && !isFocusOverlay && !(isAddRowButton && isCellEditMode && this.isEditing()) && (isElementInDom($target) || isAnotherComponent)) {
            this._closeEditItem.bind(this)($target);
          }
        }
      });
      m_events_engine_default.on(dom_adapter_default.getDocument(), m_pointer_default.up, this._pointerUpEditorHandler);
      m_events_engine_default.on(dom_adapter_default.getDocument(), m_pointer_default.down, this._pointerDownEditorHandler);
      m_events_engine_default.on(dom_adapter_default.getDocument(), CLICK_EVENT_NAME, this._saveEditorHandler);
    }
  }
  isCellEditMode() {
    return this.option("editing.mode") === EDIT_MODE_CELL;
  }
  isBatchEditMode() {
    return this.option("editing.mode") === EDIT_MODE_BATCH;
  }
  isCellOrBatchEditMode() {
    return this.isCellEditMode() || this.isBatchEditMode();
  }
  _needToCloseEditableCell($targetElement) {
    const $element = this.component.$element();
    let result2 = this.isEditing();
    const isCurrentComponentElement = !$element || !!$targetElement.closest($element).length;
    if (isCurrentComponentElement) {
      const isDataRow2 = $targetElement.closest(`.${DATA_ROW_CLASS2}`).length;
      if (isDataRow2) {
        const $targetCell = $targetElement.closest(`.${ROW_CLASS}> td`);
        const rowIndex = this._rowsView.getRowIndex($targetCell.parent());
        const cellElements = this._rowsView.getCellElements(rowIndex);
        if (null !== cellElements && void 0 !== cellElements && cellElements.length) {
          var _visibleColumns$colum;
          const columnIndex = cellElements.index($targetCell);
          const visibleColumns = this._columnsController.getVisibleColumns();
          const allowEditing = null === (_visibleColumns$colum = visibleColumns[columnIndex]) || void 0 === _visibleColumns$colum ? void 0 : _visibleColumns$colum.allowEditing;
          const isEditingCell2 = this.isEditCell(rowIndex, columnIndex);
          result2 = result2 && !allowEditing && !isEditingCell2;
        }
      }
    }
    return result2 || super._needToCloseEditableCell($targetElement);
  }
  _closeEditItem($targetElement) {
    if (this._needToCloseEditableCell($targetElement)) {
      this.closeEditCell();
    }
  }
  _focusEditorIfNeed() {
    if (this._needFocusEditor && this.isCellOrBatchEditMode()) {
      var _this$_rowsView;
      const editColumnIndex = this._getVisibleEditColumnIndex();
      const $cell = null === (_this$_rowsView = this._rowsView) || void 0 === _this$_rowsView ? void 0 : _this$_rowsView._getCellElement(this._getVisibleEditRowIndex(), editColumnIndex);
      this._refocusEditCell = false;
      clearTimeout(this._inputFocusTimeoutID);
      if ($cell && !$cell.find(":focus").length) {
        this._focusEditingCell(() => {
          this._editCellInProgress = false;
        }, $cell, true);
      } else {
        this._editCellInProgress = false;
      }
      this._needFocusEditor = false;
    } else {
      super._focusEditorIfNeed();
    }
  }
  isEditing() {
    if (this.isCellOrBatchEditMode()) {
      const isEditRowKeyDefined = isDefined(this.option(EDITING_EDITROWKEY_OPTION_NAME));
      const isEditColumnNameDefined = isDefined(this.option(EDITING_EDITCOLUMNNAME_OPTION_NAME));
      return isEditRowKeyDefined && isEditColumnNameDefined;
    }
    return super.isEditing();
  }
  _handleEditColumnNameChange(args) {
    const oldRowIndex = this._getVisibleEditRowIndex(args.previousValue);
    if (this.isCellOrBatchEditMode() && -1 !== oldRowIndex && isDefined(args.value) && args.value !== args.previousValue) {
      const columnIndex = this._columnsController.getVisibleColumnIndex(args.value);
      const oldColumnIndex = this._columnsController.getVisibleColumnIndex(args.previousValue);
      this._editCellFromOptionChanged(columnIndex, oldColumnIndex, oldRowIndex);
    }
  }
  _addRow(parentKey) {
    if (this.isCellEditMode() && this.hasChanges()) {
      const deferred = new Deferred();
      this.saveEditData().done(() => {
        if (!this.hasChanges()) {
          this.addRow(parentKey).done(deferred.resolve).fail(deferred.reject);
        } else {
          deferred.reject("cancel");
        }
      });
      return deferred.promise();
    }
    return super._addRow(parentKey);
  }
  editCell(rowIndex, columnIndex) {
    return this._editCell({
      rowIndex,
      columnIndex
    });
  }
  _editCell(options2) {
    const d = new Deferred();
    let coreResult;
    this.executeOperation(d, () => {
      coreResult = this._editCellCore(options2);
      when(coreResult).done(d.resolve).fail(d.reject);
    });
    return void 0 !== coreResult ? coreResult : d.promise();
  }
  _editCellCore(options2) {
    const dataController2 = this._dataController;
    const isEditByOptionChanged = isDefined(options2.oldColumnIndex) || isDefined(options2.oldRowIndex);
    const {
      columnIndex,
      rowIndex,
      column,
      item
    } = this._getNormalizedEditCellOptions(options2);
    const params = {
      data: null === item || void 0 === item ? void 0 : item.data,
      cancel: false,
      column
    };
    if (void 0 === item.key) {
      this._dataController.fireError("E1043");
      return;
    }
    if (column && ("data" === item.rowType || "detailAdaptive" === item.rowType) && !item.removed && this.isCellOrBatchEditMode()) {
      if (!isEditByOptionChanged && this.isEditCell(rowIndex, columnIndex)) {
        return true;
      }
      const editRowIndex = rowIndex + dataController2.getRowIndexOffset();
      return when(this._beforeEditCell(rowIndex, columnIndex, item)).done((cancel2) => {
        if (cancel2) {
          return;
        }
        if (!this._prepareEditCell(params, item, columnIndex, editRowIndex)) {
          this._processCanceledEditingCell();
        }
      });
    }
    return false;
  }
  _beforeEditCell(rowIndex, columnIndex, item) {
    if (this.isCellEditMode() && !item.isNewRow && this.hasChanges()) {
      const isSaving = new Deferred();
      this.saveEditData().always(() => {
        isSaving.resolve(this.hasChanges());
      });
      this.addDeferred(isSaving);
      return isSaving;
    }
    return false;
  }
  publicMethods() {
    const publicMethods = super.publicMethods();
    return publicMethods.concat(["editCell", "closeEditCell"]);
  }
  _getNormalizedEditCellOptions(_ref) {
    let {
      oldColumnIndex,
      oldRowIndex,
      columnIndex,
      rowIndex
    } = _ref;
    const columnsController = this._columnsController;
    const visibleColumns = columnsController.getVisibleColumns();
    const items = this._dataController.items();
    const item = items[rowIndex];
    let oldColumn;
    if (isDefined(oldColumnIndex)) {
      oldColumn = visibleColumns[oldColumnIndex];
    } else {
      oldColumn = this._getEditColumn();
    }
    if (!isDefined(oldRowIndex)) {
      oldRowIndex = this._getVisibleEditRowIndex();
    }
    if (isString(columnIndex)) {
      columnIndex = columnsController.columnOption(columnIndex, "index");
      columnIndex = columnsController.getVisibleIndex(columnIndex);
    }
    const column = visibleColumns[columnIndex];
    return {
      oldColumn,
      columnIndex,
      oldRowIndex,
      rowIndex,
      column,
      item
    };
  }
  _prepareEditCell(params, item, editColumnIndex, editRowIndex) {
    if (!item.isNewRow) {
      params.key = item.key;
    }
    if (this._isEditingStart(params)) {
      return false;
    }
    this._pageIndex = this._dataController.pageIndex();
    this._setEditRowKey(item.key);
    this._setEditColumnNameByIndex(editColumnIndex);
    if (!params.column.showEditorAlways) {
      this._addInternalData({
        key: item.key,
        oldData: item.oldData ?? item.data
      });
    }
    return true;
  }
  closeEditCell(isError, withoutSaveEditData) {
    let result2 = when();
    const oldEditRowIndex = this._getVisibleEditRowIndex();
    if (this.isCellOrBatchEditMode()) {
      const deferred = new Deferred();
      result2 = new Deferred();
      this.executeOperation(deferred, () => {
        this._closeEditCellCore(isError, oldEditRowIndex, withoutSaveEditData).always(result2.resolve);
      });
    }
    return result2.promise();
  }
  _closeEditCellCore(isError, oldEditRowIndex, withoutSaveEditData) {
    const dataController2 = this._dataController;
    const deferred = new Deferred();
    const promise = deferred.promise();
    if (this.isCellEditMode() && this.hasChanges()) {
      if (!withoutSaveEditData) {
        this.saveEditData().done((error2) => {
          if (!this.hasChanges()) {
            this.closeEditCell(!!error2).always(deferred.resolve);
            return;
          }
          deferred.resolve();
        });
        return promise;
      }
    } else {
      this._resetEditRowKey();
      this._resetEditColumnName();
      if (oldEditRowIndex >= 0) {
        const rowIndices = [oldEditRowIndex];
        this._beforeCloseEditCellInBatchMode(rowIndices);
        if (!isError) {
          dataController2.updateItems({
            changeType: "update",
            rowIndices
          });
        }
      }
    }
    deferred.resolve();
    return promise;
  }
  _resetModifiedClassCells(changes) {
    if (this.isBatchEditMode()) {
      const columnsCount = this._columnsController.getVisibleColumns().length;
      changes.forEach((_ref2) => {
        let {
          key
        } = _ref2;
        const rowIndex = this._dataController.getRowIndexByKey(key);
        for (let columnIndex = 0; columnIndex < columnsCount; columnIndex++) {
          const cellElement = this._rowsView._getCellElement(rowIndex, columnIndex);
          null === cellElement || void 0 === cellElement || cellElement.removeClass(CELL_MODIFIED_CLASS);
        }
      });
    }
  }
  _prepareChange(options2, value2, text) {
    const $cellElement = renderer_default(options2.cellElement);
    if (this.isBatchEditMode() && void 0 !== options2.key) {
      this._applyModified($cellElement, options2);
    }
    return super._prepareChange(options2, value2, text);
  }
  _cancelSaving(result2) {
    const dataController2 = this._dataController;
    if (this.isCellOrBatchEditMode()) {
      if (this.isBatchEditMode()) {
        this._resetEditIndices();
      }
      dataController2.updateItems();
    }
    super._cancelSaving(result2);
  }
  optionChanged(args) {
    const {
      fullName
    } = args;
    if ("editing" === args.name && fullName === EDITING_EDITCOLUMNNAME_OPTION_NAME) {
      this._handleEditColumnNameChange(args);
      args.handled = true;
    } else {
      super.optionChanged(args);
    }
  }
  _editCellFromOptionChanged(columnIndex, oldColumnIndex, oldRowIndex) {
    const columns7 = this._columnsController.getVisibleColumns();
    if (columnIndex > -1) {
      deferRender(() => {
        this._repaintEditCell(columns7[columnIndex], columns7[oldColumnIndex], oldRowIndex);
      });
    }
  }
  _handleEditRowKeyChange(args) {
    if (this.isCellOrBatchEditMode()) {
      const columnIndex = this._getVisibleEditColumnIndex();
      const oldRowIndexCorrection = this._getEditRowIndexCorrection();
      const oldRowIndex = this._dataController.getRowIndexByKey(args.previousValue) + oldRowIndexCorrection;
      if (isDefined(args.value) && args.value !== args.previousValue) {
        var _this$_editCellFromOp;
        null === (_this$_editCellFromOp = this._editCellFromOptionChanged) || void 0 === _this$_editCellFromOp || _this$_editCellFromOp.call(this, columnIndex, columnIndex, oldRowIndex);
      }
    } else {
      super._handleEditRowKeyChange(args);
    }
  }
  deleteRow(rowIndex) {
    if (this.isCellEditMode() && this.isEditing()) {
      const {
        isNewRow
      } = this._dataController.items()[rowIndex];
      const rowKey = this._dataController.getKeyByRowIndex(rowIndex);
      this.closeEditCell(null, isNewRow).always(() => {
        rowIndex = this._dataController.getRowIndexByKey(rowKey);
        this._checkAndDeleteRow(rowIndex);
      });
    } else {
      super.deleteRow(rowIndex);
    }
  }
  _checkAndDeleteRow(rowIndex) {
    if (this.isBatchEditMode()) {
      this._deleteRowCore(rowIndex);
    } else {
      super._checkAndDeleteRow(rowIndex);
    }
  }
  _refreshCore(params) {
    const {
      isPageChanged
    } = params ?? {};
    const needResetIndexes = this.isBatchEditMode() || isPageChanged && "virtual" !== this.option("scrolling.mode");
    if (this.isCellOrBatchEditMode()) {
      if (needResetIndexes) {
        this._resetEditColumnName();
        this._resetEditRowKey();
      }
    } else {
      super._refreshCore(params);
    }
  }
  _allowRowAdding(params) {
    if (this.isBatchEditMode()) {
      return true;
    }
    return super._allowRowAdding(params);
  }
  _afterDeleteRow(rowIndex, oldEditRowIndex) {
    const dataController2 = this._dataController;
    if (this.isBatchEditMode()) {
      dataController2.updateItems({
        changeType: "update",
        rowIndices: [oldEditRowIndex, rowIndex]
      });
      return new Deferred().resolve();
    }
    return super._afterDeleteRow(rowIndex, oldEditRowIndex);
  }
  _updateEditRow(row, forceUpdateRow, isCustomSetCellValue) {
    if (this.isCellOrBatchEditMode()) {
      this._updateRowImmediately(row, forceUpdateRow, isCustomSetCellValue);
    } else {
      super._updateEditRow(row, forceUpdateRow, isCustomSetCellValue);
    }
  }
  _isDefaultButtonVisible(button, options2) {
    if (this.isCellOrBatchEditMode()) {
      const isBatchMode = this.isBatchEditMode();
      switch (button.name) {
        case "save":
        case "cancel":
        case "edit":
          return false;
        case "delete":
          return super._isDefaultButtonVisible(button, options2) && (!isBatchMode || !options2.row.removed);
        case "undelete":
          return isBatchMode && this.allowDeleting(options2) && options2.row.removed;
        default:
          return super._isDefaultButtonVisible(button, options2);
      }
    }
    return super._isDefaultButtonVisible(button, options2);
  }
  _isRowDeleteAllowed() {
    const callBaseResult = super._isRowDeleteAllowed();
    return callBaseResult || this.isBatchEditMode();
  }
  _beforeEndSaving(changes) {
    if (this.isCellEditMode()) {
      var _changes$;
      if ("update" !== (null === (_changes$ = changes[0]) || void 0 === _changes$ ? void 0 : _changes$.type)) {
        super._beforeEndSaving(changes);
      }
    } else {
      if (this.isBatchEditMode()) {
        this._resetModifiedClassCells(changes);
      }
      super._beforeEndSaving(changes);
    }
  }
  prepareEditButtons(headerPanel8) {
    const editingOptions = this.option("editing") ?? {};
    const buttonItems = super.prepareEditButtons(headerPanel8);
    const needEditingButtons = editingOptions.allowUpdating || editingOptions.allowAdding || editingOptions.allowDeleting;
    if (needEditingButtons && this.isBatchEditMode()) {
      buttonItems.push(this.prepareButtonItem(headerPanel8, "save", "saveEditData", 21));
      buttonItems.push(this.prepareButtonItem(headerPanel8, "revert", "cancelEditData", 22));
    }
    return buttonItems;
  }
  _saveEditDataInner() {
    var _deferred;
    const editRow = this._dataController.getVisibleRows()[this.getEditRowIndex()];
    const editColumn = this._getEditColumn();
    const showEditorAlways = null === editColumn || void 0 === editColumn ? void 0 : editColumn.showEditorAlways;
    const isUpdateInCellMode = this.isCellEditMode() && !(null !== editRow && void 0 !== editRow && editRow.isNewRow);
    let deferred;
    if (isUpdateInCellMode && showEditorAlways) {
      deferred = new Deferred();
      this.addDeferred(deferred);
    }
    return super._saveEditDataInner().always(null === (_deferred = deferred) || void 0 === _deferred ? void 0 : _deferred.resolve);
  }
  _applyChange(options2, params, forceUpdateRow) {
    const isUpdateInCellMode = this.isCellEditMode() && options2.row && !options2.row.isNewRow;
    const {
      showEditorAlways
    } = options2.column;
    const isCustomSetCellValue = options2.column.setCellValue !== options2.column.defaultSetCellValue;
    const focusPreviousEditingCell = showEditorAlways && !forceUpdateRow && isUpdateInCellMode && this.hasEditData() && !this.isEditCell(options2.rowIndex, options2.columnIndex);
    if (focusPreviousEditingCell) {
      this._focusEditingCell();
      this._updateEditRow(options2.row, true, isCustomSetCellValue);
      return;
    }
    return super._applyChange(options2, params, forceUpdateRow);
  }
  _applyChangeCore(options2, forceUpdateRow) {
    const {
      showEditorAlways
    } = options2.column;
    const isUpdateInCellMode = this.isCellEditMode() && options2.row && !options2.row.isNewRow;
    if (showEditorAlways && !forceUpdateRow) {
      if (isUpdateInCellMode) {
        this._setEditRowKey(options2.row.key, true);
        this._setEditColumnNameByIndex(options2.columnIndex, true);
        return this.saveEditData();
      }
      if (this.isBatchEditMode()) {
        forceUpdateRow = this._needUpdateRow(options2.column);
        return super._applyChangeCore(options2, forceUpdateRow);
      }
    }
    return super._applyChangeCore(options2, forceUpdateRow);
  }
  _processDataItemCore(item, change, key, columns7, generateDataValues) {
    const {
      data: data17,
      type: type2
    } = change;
    if (this.isBatchEditMode() && type2 === DATA_EDIT_DATA_REMOVE_TYPE) {
      item.data = createObjectWithChanges(item.data, data17);
    }
    super._processDataItemCore(item, change, key, columns7, generateDataValues);
  }
  _processRemoveCore(changes, editIndex, processIfBatch) {
    if (this.isBatchEditMode() && !processIfBatch) {
      return;
    }
    return super._processRemoveCore(changes, editIndex, processIfBatch);
  }
  _processRemoveIfError(changes, editIndex) {
    if (this.isBatchEditMode()) {
      return;
    }
    return super._processRemoveIfError(changes, editIndex);
  }
  _beforeFocusElementInRow(rowIndex) {
    super._beforeFocusElementInRow(rowIndex);
    const editRowIndex = rowIndex >= 0 ? rowIndex : 0;
    const columnIndex = this.getFirstEditableColumnIndex();
    columnIndex >= 0 && this.editCell(editRowIndex, columnIndex);
  }
};
var rowsView6 = (Base) => class extends Base {
  _createTable() {
    const $table = super._createTable.apply(this, arguments);
    const editingController = this._editingController;
    if (editingController.isCellOrBatchEditMode() && this.option("editing.allowUpdating")) {
      m_events_engine_default.on($table, addNamespace2(m_hold_default.name, "dxDataGridRowsView"), `td:not(.${EDITOR_CELL_CLASS})`, this.createAction(() => {
        if (editingController.isEditing()) {
          editingController.closeEditCell();
        }
      }));
    }
    return $table;
  }
  _createRow(row) {
    const $row = super._createRow.apply(this, arguments);
    if (row) {
      const editingController = this._editingController;
      const isRowRemoved = !!row.removed;
      if (editingController.isBatchEditMode()) {
        isRowRemoved && $row.addClass(ROW_REMOVED);
      }
    }
    return $row;
  }
};
var editingCellBasedModule = {
  extenders: {
    controllers: {
      editing: editingControllerExtender3
    },
    views: {
      rowsView: rowsView6
    }
  }
};

// node_modules/devextreme/esm/__internal/grids/data_grid/module_not_extended/editing_cell_based.js
m_core_default.registerModule("editingCellBased", editingCellBasedModule);

// node_modules/devextreme/esm/__internal/grids/grid_core/validating/m_validating.js
var INSERT_INDEX2 = "__DX_INSERT_INDEX__";
var EDIT_MODE_ROW2 = "row";
var EDIT_MODE_BATCH2 = "batch";
var EDIT_MODE_CELL2 = "cell";
var FORM_BASED_MODES = ["popup", "form"];
var VALIDATION_STATUS = {
  valid: "valid",
  invalid: "invalid",
  pending: "pending"
};
var validationResultIsValid = function(result2) {
  return isDefined(result2) && "cancel" !== result2;
};
var cellValueShouldBeValidated = function(value2, rowOptions) {
  return void 0 !== value2 || void 0 === value2 && rowOptions && !rowOptions.isNewRow;
};
var ValidatingController = class extends m_modules_default.Controller {
  constructor() {
    super(...arguments);
    this._isValidationInProgress = false;
    this._disableApplyValidationResults = false;
  }
  init() {
    this._editingController = this.getController("editing");
    this._editorFactoryController = this.getController("editorFactory");
    this._columnsController = this.getController("columns");
    this.createAction("onRowValidating");
    if (!this._validationState) {
      this.initValidationState();
    }
  }
  initValidationState() {
    this._validationState = [];
    this._validationStateCache = {};
  }
  _rowIsValidated(change) {
    const validationData = this._getValidationData(null === change || void 0 === change ? void 0 : change.key);
    return !!validationData && !!validationData.validated;
  }
  _getValidationData(key, create2) {
    const keyHash = getKeyHash(key);
    const isObjectKeyHash = isObject(keyHash);
    let validationData;
    if (isObjectKeyHash) {
      validationData = this._validationState.filter((data17) => equalByValue(data17.key, key))[0];
    } else {
      validationData = this._validationStateCache[keyHash];
    }
    if (!validationData && create2) {
      validationData = {
        key,
        isValid: true
      };
      this._validationState.push(validationData);
      if (!isObjectKeyHash) {
        this._validationStateCache[keyHash] = validationData;
      }
    }
    return validationData;
  }
  _getBrokenRules(validationData, validationResults) {
    let brokenRules;
    if (validationResults) {
      brokenRules = validationResults.brokenRules || validationResults.brokenRule && [validationResults.brokenRule];
    } else {
      brokenRules = validationData.brokenRules || [];
    }
    return brokenRules;
  }
  _rowValidating(validationData, validationResults) {
    const deferred = new Deferred();
    const change = this._editingController.getChangeByKey(null === validationData || void 0 === validationData ? void 0 : validationData.key);
    const brokenRules = this._getBrokenRules(validationData, validationResults);
    const isValid = validationResults ? validationResults.isValid : validationData.isValid;
    const parameters = {
      brokenRules,
      isValid,
      key: change.key,
      newData: change.data,
      oldData: this._editingController._getOldData(change.key),
      promise: null,
      errorText: this.getHiddenValidatorsErrorText(brokenRules)
    };
    this.executeAction("onRowValidating", parameters);
    when(fromPromise(parameters.promise)).always(() => {
      validationData.isValid = parameters.isValid;
      validationData.errorText = parameters.errorText;
      deferred.resolve(parameters);
    });
    return deferred.promise();
  }
  getHiddenValidatorsErrorText(brokenRules) {
    const brokenRulesMessages = [];
    each(brokenRules, (_, brokenRule) => {
      const {
        column
      } = brokenRule;
      const isGroupExpandColumn = column && void 0 !== column.groupIndex && !column.showWhenGrouped;
      const isVisibleColumn2 = column && column.visible;
      if (!brokenRule.validator.$element().parent().length && (!isVisibleColumn2 || isGroupExpandColumn)) {
        brokenRulesMessages.push(brokenRule.message);
      }
    });
    return brokenRulesMessages.join(", ");
  }
  validate(isFull) {
    let isValid = true;
    const editingController = this._editingController;
    const deferred = new Deferred();
    const completeList = [];
    const editMode = editingController.getEditMode();
    isFull = isFull || editMode === EDIT_MODE_ROW2;
    if (this._isValidationInProgress) {
      return deferred.resolve(false).promise();
    }
    this._isValidationInProgress = true;
    if (isFull) {
      editingController.addDeferred(deferred);
      const changes = editingController.getChanges();
      each(changes, (index2, _ref) => {
        let {
          type: type2,
          key
        } = _ref;
        if ("remove" !== type2) {
          const validationData = this._getValidationData(key, true);
          const validationResult = this.validateGroup(validationData);
          completeList.push(validationResult);
          validationResult.done((validationResult2) => {
            validationData.validated = true;
            isValid = isValid && validationResult2.isValid;
          });
        }
      });
    } else if (this._currentCellValidator) {
      const validationResult = this.validateGroup(this._currentCellValidator._findGroup());
      completeList.push(validationResult);
      validationResult.done((validationResult2) => {
        isValid = validationResult2.isValid;
      });
    }
    when(...completeList).done(() => {
      this._isValidationInProgress = false;
      deferred.resolve(isValid);
    });
    return deferred.promise();
  }
  validateGroup(validationData) {
    var _validationResult;
    const result2 = new Deferred();
    const validateGroup = validationData && validation_engine_default.getGroupConfig(validationData);
    let validationResult;
    if (null !== validateGroup && void 0 !== validateGroup && validateGroup.validators.length) {
      this.resetRowValidationResults(validationData);
      validationResult = validation_engine_default.validateGroup(validationData);
    }
    when((null === (_validationResult = validationResult) || void 0 === _validationResult ? void 0 : _validationResult.complete) || validationResult).done((validationResult2) => {
      when(this._rowValidating(validationData, validationResult2)).done(result2.resolve);
    });
    return result2.promise();
  }
  isRowDataModified(change) {
    return !isEmptyObject(change.data);
  }
  updateValidationState(change) {
    const editMode = this._editingController.getEditMode();
    const {
      key
    } = change;
    const validationData = this._getValidationData(key, true);
    if (!FORM_BASED_MODES.includes(editMode)) {
      if ("insert" === change.type && !this.isRowDataModified(change)) {
        validationData.isValid = true;
        return;
      }
      this.setDisableApplyValidationResults(true);
      const groupConfig = validation_engine_default.getGroupConfig(validationData);
      if (groupConfig) {
        const validationResult = validation_engine_default.validateGroup(validationData);
        when(validationResult.complete || validationResult).done((validationResult2) => {
          validationData.isValid = validationResult2.isValid;
          validationData.brokenRules = validationResult2.brokenRules;
        });
      } else if (!validationData.brokenRules || !validationData.brokenRules.length) {
        validationData.isValid = true;
      }
      this.setDisableApplyValidationResults(false);
    } else {
      validationData.isValid = true;
    }
  }
  setValidator(validator) {
    this._currentCellValidator = validator;
  }
  renderCellPendingIndicator($container) {
    let $indicator = $container.find(".dx-pending-indicator");
    if (!$indicator.length) {
      const $indicatorContainer = $container;
      $indicator = renderer_default("<div>").appendTo($indicatorContainer).addClass("dx-pending-indicator");
      this._createComponent($indicator, load_indicator_default);
      $container.addClass("dx-validation-pending");
    }
  }
  disposeCellPendingIndicator($container) {
    const $indicator = $container.find(".dx-pending-indicator");
    if ($indicator.length) {
      const indicator = load_indicator_default.getInstance($indicator);
      if (indicator) {
        indicator.dispose();
        indicator.$element().remove();
      }
      $container.removeClass("dx-validation-pending");
    }
  }
  validationStatusChanged(result2) {
    const {
      validator
    } = result2;
    const validationGroup = validator.option("validationGroup");
    const {
      column
    } = validator.option("dataGetter")();
    this.updateCellValidationResult({
      rowKey: validationGroup.key,
      columnIndex: column.index,
      validationResult: result2
    });
  }
  validatorInitialized(arg) {
    arg.component.on("validating", this.validationStatusChanged.bind(this));
    arg.component.on("validated", this.validationStatusChanged.bind(this));
  }
  validatorDisposing(arg) {
    const validator = arg.component;
    const validationGroup = validator.option("validationGroup");
    const {
      column
    } = validator.option("dataGetter")();
    const result2 = this.getCellValidationResult({
      rowKey: null === validationGroup || void 0 === validationGroup ? void 0 : validationGroup.key,
      columnIndex: column.index
    });
    if (validationResultIsValid(result2) && result2.status === VALIDATION_STATUS.pending) {
      this.cancelCellValidationResult({
        change: validationGroup,
        columnIndex: column.index
      });
    }
  }
  applyValidationResult($container, result2) {
    const {
      validator
    } = result2;
    const validationGroup = validator.option("validationGroup");
    const {
      column
    } = validator.option("dataGetter")();
    result2.brokenRules && result2.brokenRules.forEach((rule) => {
      rule.columnIndex = column.index;
      rule.column = column;
    });
    if ($container) {
      const validationResult = this.getCellValidationResult({
        rowKey: validationGroup.key,
        columnIndex: column.index
      });
      const requestIsDisabled = validationResultIsValid(validationResult) && validationResult.disabledPendingId === result2.id;
      if (this._disableApplyValidationResults || requestIsDisabled) {
        return;
      }
      if (result2.status === VALIDATION_STATUS.invalid) {
        const $focus = $container.find(":focus");
        if (!focused($focus)) {
          m_events_engine_default.trigger($focus, "focus");
          m_events_engine_default.trigger($focus, m_pointer_default.down);
        }
      }
      const editor = !column.editCellTemplate && this._editorFactoryController.getEditorInstance($container);
      if (result2.status === VALIDATION_STATUS.pending) {
        if (editor) {
          editor.option("validationStatus", VALIDATION_STATUS.pending);
        } else {
          this.renderCellPendingIndicator($container);
        }
      } else if (editor) {
        editor.option("validationStatus", VALIDATION_STATUS.valid);
      } else {
        this.disposeCellPendingIndicator($container);
      }
      $container.toggleClass(this.addWidgetPrefix("invalid"), result2.status === VALIDATION_STATUS.invalid);
    }
  }
  _syncInternalEditingData(parameters) {
    var _parameters$row;
    const editingController = this._editingController;
    const change = editingController.getChangeByKey(parameters.key);
    const oldDataFromState = editingController._getOldData(parameters.key);
    const oldData = null === (_parameters$row = parameters.row) || void 0 === _parameters$row ? void 0 : _parameters$row.oldData;
    if (change && oldData && !oldDataFromState) {
      editingController._addInternalData({
        key: parameters.key,
        oldData
      });
    }
  }
  createValidator(parameters, $container) {
    const editingController = this._editingController;
    const {
      column
    } = parameters;
    let {
      showEditorAlways
    } = column;
    if (isDefined(column.command) || !column.validationRules || !Array.isArray(column.validationRules) || !column.validationRules.length) {
      return;
    }
    const editIndex = editingController.getIndexByKey(parameters.key, editingController.getChanges());
    let needCreateValidator = editIndex > -1;
    if (!needCreateValidator) {
      if (!showEditorAlways) {
        var _this$_columnsControl;
        const visibleColumns = (null === (_this$_columnsControl = this._columnsController) || void 0 === _this$_columnsControl ? void 0 : _this$_columnsControl.getVisibleColumns()) || [];
        showEditorAlways = visibleColumns.some((column2) => column2.showEditorAlways);
      }
      const isEditRow = equalByValue(this.option("editing.editRowKey"), parameters.key);
      const isCellOrBatchEditingAllowed = editingController.isCellOrBatchEditMode() && editingController.allowUpdating({
        row: parameters.row
      });
      needCreateValidator = isEditRow || isCellOrBatchEditingAllowed && showEditorAlways;
      if (isCellOrBatchEditingAllowed && showEditorAlways) {
        var _parameters$row2;
        editingController._addInternalData({
          key: parameters.key,
          oldData: (null === (_parameters$row2 = parameters.row) || void 0 === _parameters$row2 ? void 0 : _parameters$row2.oldData) ?? parameters.data
        });
      }
    }
    if (needCreateValidator) {
      if ($container && !$container.length) {
        ui_errors_default.log("E1050");
        return;
      }
      this._syncInternalEditingData(parameters);
      const validationData = this._getValidationData(parameters.key, true);
      const getValue = () => {
        const change = editingController.getChangeByKey(null === validationData || void 0 === validationData ? void 0 : validationData.key);
        const value2 = column.calculateCellValue((null === change || void 0 === change ? void 0 : change.data) || {});
        return void 0 !== value2 ? value2 : parameters.value;
      };
      const useDefaultValidator = $container && $container.hasClass("dx-widget");
      $container && $container.addClass(this.addWidgetPrefix("validator"));
      const validator = new validator_default($container || renderer_default("<div>"), {
        name: column.caption,
        validationRules: extend(true, [], column.validationRules),
        validationGroup: validationData,
        adapter: useDefaultValidator ? null : {
          getValue,
          applyValidationResults: (result2) => {
            this.applyValidationResult($container, result2);
          }
        },
        dataGetter() {
          const key = null === validationData || void 0 === validationData ? void 0 : validationData.key;
          const change = editingController.getChangeByKey(key);
          const oldData = editingController._getOldData(key);
          return {
            data: createObjectWithChanges(oldData, null === change || void 0 === change ? void 0 : change.data),
            column
          };
        },
        onInitialized: this.validatorInitialized.bind(this),
        onDisposing: this.validatorDisposing.bind(this)
      });
      if (useDefaultValidator) {
        const adapter = validator.option("adapter");
        if (adapter) {
          const originBypass = adapter.bypass;
          const defaultAdapterBypass = () => parameters.row.isNewRow && !this._isValidationInProgress && !editingController.isCellModified(parameters);
          adapter.getValue = getValue;
          adapter.validationRequestsCallbacks = [];
          adapter.bypass = () => originBypass.call(adapter) || defaultAdapterBypass();
        }
      }
      return validator;
    }
    return;
  }
  setDisableApplyValidationResults(flag) {
    this._disableApplyValidationResults = flag;
  }
  getDisableApplyValidationResults() {
    return this._disableApplyValidationResults;
  }
  isCurrentValidatorProcessing(_ref2) {
    let {
      rowKey,
      columnIndex
    } = _ref2;
    return this._currentCellValidator && equalByValue(this._currentCellValidator.option("validationGroup").key, rowKey) && this._currentCellValidator.option("dataGetter")().column.index === columnIndex;
  }
  validateCell(validator) {
    const cellParams = {
      rowKey: validator.option("validationGroup").key,
      columnIndex: validator.option("dataGetter")().column.index,
      validationResult: null
    };
    let validationResult = this.getCellValidationResult(cellParams);
    const stateRestored = validationResultIsValid(validationResult);
    const adapter = validator.option("adapter");
    if (!stateRestored) {
      validationResult = validator.validate();
    } else {
      const currentCellValue = adapter.getValue();
      if (!equalByValue(currentCellValue, validationResult.value)) {
        validationResult = validator.validate();
      }
    }
    const deferred = new Deferred();
    if (stateRestored && validationResult.status === VALIDATION_STATUS.pending) {
      this.updateCellValidationResult(cellParams);
      adapter.applyValidationResults(validationResult);
    }
    when(validationResult.complete || validationResult).done((validationResult2) => {
      stateRestored && adapter.applyValidationResults(validationResult2);
      deferred.resolve(validationResult2);
    });
    return deferred.promise();
  }
  updateCellValidationResult(_ref3) {
    let {
      rowKey,
      columnIndex,
      validationResult
    } = _ref3;
    const validationData = this._getValidationData(rowKey);
    if (!validationData) {
      return;
    }
    if (!validationData.validationResults) {
      validationData.validationResults = {};
    }
    let result2;
    if (validationResult) {
      result2 = extend({}, validationResult);
      validationData.validationResults[columnIndex] = result2;
      if (validationResult.status === VALIDATION_STATUS.pending) {
        if (this._editingController.getEditMode() === EDIT_MODE_CELL2) {
          result2.deferred = new Deferred();
          result2.complete.always(() => {
            result2.deferred.resolve();
          });
          this._editingController.addDeferred(result2.deferred);
        }
        if (this._disableApplyValidationResults) {
          result2.disabledPendingId = validationResult.id;
          return;
        }
      }
    } else {
      result2 = validationData.validationResults[columnIndex];
    }
    if (result2 && result2.disabledPendingId) {
      delete result2.disabledPendingId;
    }
  }
  getCellValidationResult(_ref4) {
    var _validationData$valid;
    let {
      rowKey,
      columnIndex
    } = _ref4;
    const validationData = this._getValidationData(rowKey, true);
    return null === validationData || void 0 === validationData || null === (_validationData$valid = validationData.validationResults) || void 0 === _validationData$valid ? void 0 : _validationData$valid[columnIndex];
  }
  removeCellValidationResult(_ref5) {
    let {
      change,
      columnIndex
    } = _ref5;
    const validationData = this._getValidationData(null === change || void 0 === change ? void 0 : change.key);
    if (validationData && validationData.validationResults) {
      this.cancelCellValidationResult({
        change,
        columnIndex
      });
      delete validationData.validationResults[columnIndex];
    }
  }
  cancelCellValidationResult(_ref6) {
    let {
      change,
      columnIndex
    } = _ref6;
    const validationData = this._getValidationData(change.key);
    if (change && validationData.validationResults) {
      const result2 = validationData.validationResults[columnIndex];
      if (result2) {
        result2.deferred && result2.deferred.reject("cancel");
        validationData.validationResults[columnIndex] = "cancel";
      }
    }
  }
  resetRowValidationResults(validationData) {
    if (validationData) {
      validationData.validationResults && delete validationData.validationResults;
      delete validationData.validated;
    }
  }
  isInvalidCell(_ref7) {
    let {
      rowKey,
      columnIndex
    } = _ref7;
    const result2 = this.getCellValidationResult({
      rowKey,
      columnIndex
    });
    return validationResultIsValid(result2) && result2.status === VALIDATION_STATUS.invalid;
  }
  getCellValidator(_ref8) {
    let {
      rowKey,
      columnIndex
    } = _ref8;
    const validationData = this._getValidationData(rowKey);
    const groupConfig = validationData && validation_engine_default.getGroupConfig(validationData);
    const validators = groupConfig && groupConfig.validators;
    return validators && validators.filter((v) => {
      const {
        column
      } = v.option("dataGetter")();
      return column ? column.index === columnIndex : false;
    })[0];
  }
  setCellValidationStatus(cellOptions) {
    const validationResult = this.getCellValidationResult({
      rowKey: cellOptions.key,
      columnIndex: cellOptions.column.index
    });
    if (isDefined(validationResult)) {
      cellOptions.validationStatus = "cancel" !== validationResult ? validationResult.status : "cancel";
    } else {
      delete cellOptions.validationStatus;
    }
  }
};
var validatingEditingExtender = (Base) => class extends Base {
  processDataItemTreeListHack(item) {
    super.processDataItem.apply(this, arguments);
  }
  processItemsTreeListHack(items, e) {
    return super.processItems.apply(this, arguments);
  }
  _addChange(changeParams) {
    const change = super._addChange.apply(this, arguments);
    if (change && "remove" !== changeParams.type) {
      this._validatingController.updateValidationState(change);
    }
    return change;
  }
  _handleChangesChange(args) {
    super._handleChangesChange.apply(this, arguments);
    args.value.forEach((change) => {
      if (void 0 === this._validatingController._getValidationData(change.key)) {
        this._validatingController.updateValidationState(change);
      }
    });
  }
  _updateRowAndPageIndices() {
    const that = this;
    const startInsertIndex = that.getView("rowsView").getTopVisibleItemIndex();
    let rowIndex = startInsertIndex;
    each(that.getChanges(), (_, _ref9) => {
      let {
        key,
        type: type2
      } = _ref9;
      const validationData = this._validatingController._getValidationData(key);
      if (validationData && !validationData.isValid && validationData.pageIndex !== that._pageIndex) {
        validationData.pageIndex = that._pageIndex;
        if ("insert" === type2) {
          validationData.rowIndex = startInsertIndex;
        } else {
          validationData.rowIndex = rowIndex;
        }
        rowIndex++;
      }
    });
  }
  _getValidationGroupsInForm(detailOptions) {
    const validationData = this._validatingController._getValidationData(detailOptions.key, true);
    return {
      validationGroup: validationData
    };
  }
  _validateEditFormAfterUpdate(row, isCustomSetCellValue) {
    if (isCustomSetCellValue && this._editForm) {
      this._editForm.validate();
    }
    super._validateEditFormAfterUpdate.apply(this, arguments);
  }
  _prepareEditCell(params) {
    const isNotCanceled = super._prepareEditCell.apply(this, arguments);
    if (isNotCanceled && params.column.showEditorAlways) {
      this._validatingController.updateValidationState({
        key: params.key
      });
    }
    return isNotCanceled;
  }
  processItems(items, changeType) {
    const changes = this.getChanges();
    const getIndexByChange = (change, items2) => {
      let index2 = -1;
      const isInsert = "insert" === change.type;
      const {
        key
      } = change;
      each(items2, (i, item) => {
        if (equalByValue(key, isInsert ? item.key : this._dataController.keyOf(item))) {
          index2 = i;
          return false;
        }
        return;
      });
      return index2;
    };
    items = super.processItems(items, changeType);
    const itemsCount = items.length;
    if (this.getEditMode() === EDIT_MODE_BATCH2 && "prepend" !== changeType && "append" !== changeType) {
      changes.forEach((change) => {
        const {
          key
        } = change;
        const validationData = this._validatingController._getValidationData(key);
        if (validationData && change.type && validationData.pageIndex === this._pageIndex && (null === change || void 0 === change ? void 0 : change.pageIndex) !== this._pageIndex) {
          !function(change2, validationData2) {
            const data17 = {
              key: change2.key
            };
            const index2 = getIndexByChange(change2, items);
            if (index2 >= 0) {
              return;
            }
            validationData2.rowIndex = validationData2.rowIndex > itemsCount ? validationData2.rowIndex % itemsCount : validationData2.rowIndex;
            const {
              rowIndex
            } = validationData2;
            data17[INSERT_INDEX2] = 1;
            items.splice(rowIndex, 0, data17);
          }(change, validationData);
        }
      });
    }
    return items;
  }
  processDataItem(item) {
    const isInserted = item.data[INSERT_INDEX2];
    const key = isInserted ? item.data.key : item.key;
    const editMode = this.getEditMode();
    if (editMode === EDIT_MODE_BATCH2 && isInserted && key) {
      const changes = this.getChanges();
      const editIndex = m_utils_default.getIndexByKey(key, changes);
      if (editIndex >= 0) {
        const change = changes[editIndex];
        if ("insert" !== change.type) {
          const oldData = this._getOldData(change.key);
          item.data = extend(true, {}, oldData, change.data);
          item.key = key;
        }
      }
    }
    super.processDataItem.apply(this, arguments);
  }
  _createInvisibleColumnValidators(changes) {
    const that = this;
    const columns7 = this._columnsController.getColumns();
    const invisibleColumns = this._columnsController.getInvisibleColumns().filter((column) => !column.isBand);
    const groupColumns = this._columnsController.getGroupColumns().filter((column) => !column.showWhenGrouped && -1 === invisibleColumns.indexOf(column));
    const invisibleColumnValidators = [];
    const isCellVisible = (column, rowKey) => this._dataController.getRowIndexByKey(rowKey) >= 0 && invisibleColumns.indexOf(column) < 0;
    invisibleColumns.push(...groupColumns);
    if (!FORM_BASED_MODES.includes(this.getEditMode())) {
      each(columns7, (_, column) => {
        changes.forEach((change) => {
          let data17;
          if (isCellVisible(column, change.key)) {
            return;
          }
          if ("insert" === change.type) {
            data17 = change.data;
          } else if ("update" === change.type) {
            const oldData = that._getOldData(change.key);
            if (!isDefined(oldData)) {
              return;
            }
            data17 = createObjectWithChanges(oldData, change.data);
          }
          if (data17) {
            const validator = this._validatingController.createValidator({
              column,
              key: change.key,
              value: column.calculateCellValue(data17)
            });
            if (validator) {
              invisibleColumnValidators.push(validator);
            }
          }
        });
      });
    }
    return function() {
      invisibleColumnValidators.forEach((validator) => {
        validator.dispose();
      });
    };
  }
  _beforeSaveEditData(change, editIndex) {
    let result2 = super._beforeSaveEditData.apply(this, arguments);
    const validationData = this._validatingController._getValidationData(null === change || void 0 === change ? void 0 : change.key, true);
    if (change) {
      const isValid = "remove" === change.type || validationData.isValid;
      result2 = result2 || !isValid;
    } else {
      const disposeValidators = this._createInvisibleColumnValidators(this.getChanges());
      result2 = new Deferred();
      this.executeOperation(result2, () => {
        this._validatingController.validate(true).done((isFullValid) => {
          disposeValidators();
          this._updateRowAndPageIndices();
          switch (this.getEditMode()) {
            case EDIT_MODE_CELL2:
              if (!isFullValid) {
                this._focusEditingCell();
              }
              break;
            case EDIT_MODE_BATCH2:
              if (!isFullValid) {
                this._resetEditRowKey();
                this._resetEditColumnName();
                this._dataController.updateItems();
              }
          }
          result2.resolve(!isFullValid);
        });
      });
    }
    return result2.promise ? result2.promise() : result2;
  }
  _beforeEditCell(rowIndex, columnIndex, item) {
    const result2 = super._beforeEditCell(rowIndex, columnIndex, item);
    if (this.getEditMode() === EDIT_MODE_CELL2) {
      const $cell = this._rowsView._getCellElement(rowIndex, columnIndex);
      const validator = $cell && $cell.data("dxValidator");
      const rowOptions = $cell && $cell.closest(".dx-row").data("options");
      const value2 = validator && validator.option("adapter").getValue();
      if (validator && cellValueShouldBeValidated(value2, rowOptions)) {
        const deferred = new Deferred();
        when(this._validatingController.validateCell(validator), result2).done((validationResult, result3) => {
          deferred.resolve(validationResult.status === VALIDATION_STATUS.valid && result3);
        });
        return deferred.promise();
      }
      if (!validator) {
        return result2;
      }
    }
    return false;
  }
  _afterSaveEditData(cancel2) {
    let $firstErrorRow;
    const isCellEditMode = this.getEditMode() === EDIT_MODE_CELL2;
    each(this.getChanges(), (_, change) => {
      const $errorRow = this._showErrorRow(change);
      $firstErrorRow = $firstErrorRow || $errorRow;
    });
    if ($firstErrorRow) {
      const scrollable = this._rowsView.getScrollable();
      if (scrollable) {
        scrollable.update();
        scrollable.scrollToElement($firstErrorRow);
      }
    }
    if (cancel2 && isCellEditMode && this._needUpdateRow()) {
      const editRowIndex = this.getEditRowIndex();
      this._dataController.updateItems({
        changeType: "update",
        rowIndices: [editRowIndex]
      });
      this._focusEditingCell();
    } else if (!cancel2) {
      let shouldResetValidationState = true;
      if (isCellEditMode) {
        const columns7 = this._columnsController.getColumns();
        const columnsWithValidatingEditors = columns7.filter((col) => {
          var _col$validationRules;
          return col.showEditorAlways && (null === (_col$validationRules = col.validationRules) || void 0 === _col$validationRules ? void 0 : _col$validationRules.length) > 0;
        }).length > 0;
        shouldResetValidationState = !columnsWithValidatingEditors;
      }
      if (shouldResetValidationState) {
        this._validatingController.initValidationState();
      }
    }
  }
  _handleDataChanged(args) {
    const validationState = this._validatingController._validationState;
    if ("standard" === this.option("scrolling.mode")) {
      this.resetRowAndPageIndices();
    }
    if ("prepend" === args.changeType) {
      each(validationState, (_, validationData) => {
        validationData.rowIndex += args.items.length;
      });
    }
    super._handleDataChanged(args);
  }
  resetRowAndPageIndices() {
    const validationState = this._validatingController._validationState;
    each(validationState, (_, validationData) => {
      if (validationData.pageIndex !== this._pageIndex) {
        delete validationData.pageIndex;
        delete validationData.rowIndex;
      }
    });
  }
  _beforeCancelEditData() {
    this._validatingController.initValidationState();
    super._beforeCancelEditData();
  }
  _showErrorRow(change) {
    let $popupContent;
    const items = this._dataController.items();
    const rowIndex = this.getIndexByKey(change.key, items);
    const validationData = this._validatingController._getValidationData(change.key);
    if (!(null !== validationData && void 0 !== validationData && validationData.isValid) && null !== validationData && void 0 !== validationData && validationData.errorText && rowIndex >= 0) {
      $popupContent = this.getPopupContent();
      return this._errorHandlingController && this._errorHandlingController.renderErrorRow(null === validationData || void 0 === validationData ? void 0 : validationData.errorText, rowIndex, $popupContent);
    }
  }
  updateFieldValue(e) {
    const deferred = new Deferred();
    this._validatingController.removeCellValidationResult({
      change: this.getChangeByKey(e.key),
      columnIndex: e.column.index
    });
    super.updateFieldValue.apply(this, arguments).done(() => {
      const currentValidator = this._validatingController.getCellValidator({
        rowKey: e.key,
        columnIndex: e.column.index
      });
      when(currentValidator && this._validatingController.validateCell(currentValidator)).done((validationResult) => {
        this._editorFactoryController.refocus();
        deferred.resolve(validationResult);
      });
    });
    return deferred.promise();
  }
  highlightDataCell($cell, parameters) {
    super.highlightDataCell.apply(this, arguments);
    this._validatingController.setCellValidationStatus(parameters);
    const isEditableCell = !!parameters.setValue;
    const cellModified = this.isCellModified(parameters);
    const isValidated = isDefined(parameters.validationStatus);
    const needValidation = cellModified && parameters.column.setCellValue || isEditableCell && !cellModified && !(parameters.row.isNewRow || !isValidated);
    if (needValidation) {
      const validator = $cell.data("dxValidator");
      if (validator) {
        when(this._validatingController.validateCell(validator)).done(() => {
          this._validatingController.setCellValidationStatus(parameters);
        });
      }
    }
  }
  getChangeByKey(key) {
    const changes = this.getChanges();
    return changes[m_utils_default.getIndexByKey(key, changes)];
  }
  isCellModified(parameters) {
    const cellModified = super.isCellModified(parameters);
    const change = this.getChangeByKey(parameters.key);
    const isCellInvalid = !!parameters.row && this._validatingController.isInvalidCell({
      rowKey: parameters.key,
      columnIndex: parameters.column.index
    });
    return cellModified || this._validatingController._rowIsValidated(change) && isCellInvalid;
  }
};
var getWidthOfVisibleCells = function(that, element) {
  const rowIndex = renderer_default(element).closest("tr").index();
  const $cellElements = renderer_default(that._rowsView.getRowElement(rowIndex)).first().children().filter(":not(.dx-hidden-cell)");
  return that._rowsView._getWidths($cellElements).reduce((w1, w2) => w1 + w2, 0);
};
var getBoundaryNonFixedColumnsInfo = function(fixedColumns) {
  let firstNonFixedColumnIndex;
  let lastNonFixedColumnIndex;
  fixedColumns.some((column, index2) => {
    if ("transparent" === column.command) {
      firstNonFixedColumnIndex = 0 === index2 ? -1 : index2;
      lastNonFixedColumnIndex = index2 === fixedColumns.length - 1 ? -1 : index2 + column.colspan - 1;
      return true;
    }
    return;
  });
  return {
    startColumnIndex: firstNonFixedColumnIndex,
    endColumnIndex: lastNonFixedColumnIndex
  };
};
var validatingEditorFactoryExtender = (Base) => class extends Base {
  _showRevertButton($container) {
    var _this$_revertTooltip, _$tooltipElement2;
    let $tooltipElement = null === (_this$_revertTooltip = this._revertTooltip) || void 0 === _this$_revertTooltip ? void 0 : _this$_revertTooltip.$element();
    if (!$container || !$container.length) {
      var _$tooltipElement;
      null === (_$tooltipElement = $tooltipElement) || void 0 === _$tooltipElement || _$tooltipElement.remove();
      this._revertTooltip = void 0;
      return;
    }
    if ($container.find($tooltipElement).length) {
      var _this$_revertTooltip2;
      null === (_this$_revertTooltip2 = this._revertTooltip) || void 0 === _this$_revertTooltip2 || _this$_revertTooltip2.repaint();
      return;
    }
    const $overlayContainer = this.getRevertButtonContainer($container);
    const revertTooltipClass = this.addWidgetPrefix("revert-tooltip");
    null === (_$tooltipElement2 = $tooltipElement) || void 0 === _$tooltipElement2 || _$tooltipElement2.remove();
    $tooltipElement = renderer_default("<div>").addClass(revertTooltipClass).appendTo($container);
    const tooltipOptions = {
      animation: null,
      visible: true,
      width: "auto",
      height: "auto",
      shading: false,
      container: $overlayContainer,
      propagateOutsideClick: true,
      hideOnOutsideClick: false,
      wrapperAttr: {
        class: revertTooltipClass
      },
      contentTemplate: () => {
        const $buttonElement = renderer_default("<div>").addClass("dx-revert-button");
        const buttonOptions = {
          icon: "revert",
          hint: this.option("editing.texts.validationCancelChanges"),
          elementAttr: {
            id: "dxRevertButton",
            "aria-label": message_default.format("dxDataGrid-ariaRevertButton")
          },
          onClick: () => {
            this._editingController.cancelEditData();
          }
        };
        return new button_default2($buttonElement, buttonOptions).$element();
      },
      position: {
        my: "left top",
        at: "right top",
        offset: "1 0",
        collision: "flip",
        boundaryOffset: "0 0",
        boundary: this._rowsView.element(),
        of: $container
      },
      onPositioned: this.overlayPositionedHandler.bind(this)
    };
    this._revertTooltip = new ui_overlay_default($tooltipElement, tooltipOptions);
  }
  _hideFixedGroupCell($cell, overlayOptions) {
    var _this$_rowsView, _this$_rowsView$isFix;
    let $nextFixedRowElement;
    let $groupCellElement;
    const isFixedColumns = null === (_this$_rowsView = this._rowsView) || void 0 === _this$_rowsView || null === (_this$_rowsView$isFix = _this$_rowsView.isFixedColumns) || void 0 === _this$_rowsView$isFix ? void 0 : _this$_rowsView$isFix.call(_this$_rowsView);
    const isFormOrPopupEditMode = this._editingController.isFormOrPopupEditMode();
    if (isFixedColumns && !isFormOrPopupEditMode) {
      const nextRowOptions = $cell.closest(".dx-row").next().data("options");
      if (nextRowOptions && "group" === nextRowOptions.rowType) {
        $nextFixedRowElement = renderer_default(this._rowsView.getRowElement(nextRowOptions.rowIndex)).last();
        $groupCellElement = $nextFixedRowElement.find(".dx-group-cell");
        if ($groupCellElement.length && "hidden" !== $groupCellElement.get(0).style.visibility) {
          $groupCellElement.css("visibility", "hidden");
          overlayOptions.onDisposing = function() {
            $groupCellElement.css("visibility", "");
          };
        }
      }
    }
  }
  _showValidationMessage($cell, messages, alignment) {
    const editorPopup = $cell.find(".dx-dropdowneditor-overlay").data("dxPopup");
    const isOverlayVisible = editorPopup && editorPopup.option("visible");
    const myPosition = isOverlayVisible ? "top right" : `top ${alignment}`;
    const atPosition = isOverlayVisible ? "top left" : `bottom ${alignment}`;
    const $overlayContainer = this.getValidationMessageContainer($cell);
    let errorMessageText = "";
    messages && messages.forEach((message) => {
      errorMessageText += (errorMessageText.length ? "<br/>" : "") + encodeHtml(message);
    });
    const invalidMessageClass = this.addWidgetPrefix("invalid-message");
    this._rowsView.element().find(`.${invalidMessageClass}`).remove();
    const $overlayElement = renderer_default("<div>").addClass("dx-invalid-message").addClass("dx-invalid-message-always").addClass(invalidMessageClass).html(errorMessageText).appendTo($cell);
    const overlayOptions = {
      container: $overlayContainer,
      shading: false,
      width: "auto",
      height: "auto",
      visible: true,
      animation: false,
      propagateOutsideClick: true,
      hideOnOutsideClick: false,
      wrapperAttr: {
        id: "dxInvalidMessage",
        class: `dx-invalid-message dx-invalid-message-always ${invalidMessageClass}`
      },
      position: {
        collision: "flip",
        boundary: this._rowsView.element(),
        boundaryOffset: "0 0",
        offset: {
          x: 0,
          y: !isOverlayVisible && browser_default.mozilla ? -1 : 0
        },
        my: myPosition,
        at: atPosition,
        of: $cell
      },
      onPositioned: (e) => {
        this.overlayPositionedHandler(e, isOverlayVisible);
        this._shiftValidationMessageIfNeed(e.component.$content(), $cell);
      }
    };
    this._hideFixedGroupCell($cell, overlayOptions);
    new ui_overlay_default($overlayElement, overlayOptions);
  }
  getValidationMessages() {
    var _this$_rowsView$eleme;
    return null === (_this$_rowsView$eleme = this._rowsView.element()) || void 0 === _this$_rowsView$eleme ? void 0 : _this$_rowsView$eleme.find(this._getValidationMessagesSelector());
  }
  getRevertButton() {
    var _this$_revertTooltip3;
    return renderer_default(null === (_this$_revertTooltip3 = this._revertTooltip) || void 0 === _this$_revertTooltip3 ? void 0 : _this$_revertTooltip3.element());
  }
  _hideValidationMessage() {
    var _this$_rowsView$eleme2;
    const validationMessages = null === (_this$_rowsView$eleme2 = this._rowsView.element()) || void 0 === _this$_rowsView$eleme2 ? void 0 : _this$_rowsView$eleme2.find(this._getValidationMessagesSelector());
    null === validationMessages || void 0 === validationMessages || validationMessages.remove();
  }
  _normalizeValidationMessagePositionAndMaxWidth(options2, isRevertButton, isOverlayVisible) {
    const fixedColumns = this._columnsController.getFixedColumns();
    if (!fixedColumns || !fixedColumns.length) {
      return;
    }
    let position3;
    const visibleTableWidth = !isRevertButton && getWidthOfVisibleCells(this, options2.element);
    const $overlayContentElement = options2.component.$content();
    const validationMessageWidth = getOuterWidth($overlayContentElement, true);
    const needMaxWidth = !isRevertButton && validationMessageWidth > visibleTableWidth;
    const columnIndex = this._rowsView.getCellIndex(renderer_default(options2.element).closest("td"));
    const boundaryNonFixedColumnsInfo = getBoundaryNonFixedColumnsInfo(fixedColumns);
    if (!isRevertButton && (columnIndex === boundaryNonFixedColumnsInfo.startColumnIndex || needMaxWidth)) {
      position3 = {
        collision: "none flip",
        my: "top left",
        at: isOverlayVisible ? "top right" : "bottom left"
      };
    } else if (columnIndex === boundaryNonFixedColumnsInfo.endColumnIndex) {
      position3 = {
        collision: "none flip",
        my: "top right",
        at: isRevertButton || isOverlayVisible ? "top left" : "bottom right"
      };
      if (isRevertButton) {
        position3.offset = "-1 0";
      }
    }
    return position3 && {
      position: position3,
      maxWidth: needMaxWidth ? visibleTableWidth - 2 : void 0
    };
  }
  _shiftValidationMessageIfNeed($content, $cell) {
    const $revertContent = this._revertTooltip && this._revertTooltip.$content();
    if (!$revertContent) {
      return;
    }
    const contentOffset = $content.offset();
    const revertContentOffset = $revertContent.offset();
    if (contentOffset.top === revertContentOffset.top && contentOffset.left + getWidth($content) > revertContentOffset.left) {
      const left = getWidth($revertContent) + 2;
      $content.css("left", revertContentOffset.left < $cell.offset().left ? -left : left);
    }
  }
  getOverlayBaseZIndex() {
    return ui_overlay_default.baseZIndex();
  }
  overlayPositionedHandler(e, isOverlayVisible) {
    if (!e.component.__skipPositionProcessing) {
      const isRevertButton = renderer_default(e.element).hasClass(this.addWidgetPrefix("revert-tooltip"));
      const needRepaint = !isRevertButton && this._rowsView.updateFreeSpaceRowHeight();
      const normalizedPosition = this._normalizeValidationMessagePositionAndMaxWidth(e, isRevertButton, isOverlayVisible);
      e.component.__skipPositionProcessing = !!(needRepaint || normalizedPosition);
      if (normalizedPosition) {
        e.component.option(normalizedPosition);
      } else if (needRepaint) {
        e.component.repaint();
      }
    }
  }
  _getRevertTooltipsSelector() {
    const revertTooltipClass = this.addWidgetPrefix("revert-tooltip");
    return `.dx-editor-cell .${revertTooltipClass}`;
  }
  _getValidationMessagesSelector() {
    const invalidMessageClass = this.addWidgetPrefix("invalid-message");
    return `.dx-editor-cell .${invalidMessageClass}, .dx-cell-modified .${invalidMessageClass}`;
  }
  loseFocus(skipValidator) {
    if (!skipValidator) {
      this._validatingController.setValidator(null);
    }
    super.loseFocus();
  }
  updateCellState($element, validationResult, isHideBorder) {
    var _change$data;
    const $focus = null === $element || void 0 === $element ? void 0 : $element.closest(this._getFocusCellSelector());
    const $cell = null !== $focus && void 0 !== $focus && $focus.is("td") ? $focus : null;
    const rowOptions = null === $focus || void 0 === $focus ? void 0 : $focus.closest(".dx-row").data("options");
    const change = rowOptions ? this._editingController.getChangeByKey(rowOptions.key) : null;
    const column = $cell && this._columnsController.getVisibleColumns()[$cell.index()];
    const isCellModified = void 0 !== (null === change || void 0 === change || null === (_change$data = change.data) || void 0 === _change$data ? void 0 : _change$data[null === column || void 0 === column ? void 0 : column.name]) && !this._editingController.isSaving();
    const validationDescriptionValues = [];
    if (this._editingController.getEditMode() === EDIT_MODE_CELL2) {
      if ((null === validationResult || void 0 === validationResult ? void 0 : validationResult.status) === VALIDATION_STATUS.invalid || isCellModified) {
        this._showRevertButton($focus);
        validationDescriptionValues.push("dxRevertButton");
      } else {
        this._revertTooltip && this._revertTooltip.$element().remove();
      }
    }
    const showValidationMessage = validationResult && validationResult.status === VALIDATION_STATUS.invalid;
    if (showValidationMessage && $cell && column && validationResult && validationResult.brokenRules) {
      const errorMessages = [];
      validationResult.brokenRules.forEach((rule) => {
        if (rule.message) {
          errorMessages.push(rule.message);
        }
      });
      if (errorMessages.length) {
        this._showValidationMessage($focus, errorMessages, column.alignment || "left");
        validationDescriptionValues.push("dxInvalidMessage");
      }
    }
    this._updateAriaValidationAttributes($focus, validationDescriptionValues);
    !isHideBorder && this._rowsView.element() && this._rowsView.updateFreeSpaceRowHeight();
  }
  _updateAriaValidationAttributes($focus, inputDescriptionValues) {
    if (0 === inputDescriptionValues.length) {
      return;
    }
    const editMode = this._editingController.getEditMode();
    const shouldSetValidationAriaAttributes = [EDIT_MODE_CELL2, EDIT_MODE_BATCH2, EDIT_MODE_ROW2].includes(editMode);
    if (shouldSetValidationAriaAttributes) {
      const $focusElement = this._getCurrentFocusElement($focus);
      $focusElement.attr("aria-labelledby", inputDescriptionValues.join(" "));
      $focusElement.attr("aria-invalid", true);
    }
  }
  _getCurrentFocusElement($focus) {
    if (this._editingController.isEditing()) {
      return $focus.find(EDITORS_INPUT_SELECTOR).first();
    }
    return $focus;
  }
  focus($element, isHideBorder) {
    if (!arguments.length) {
      return super.focus();
    }
    this._hideValidationMessage();
    if (null !== $element && void 0 !== $element && $element.hasClass("dx-row") || null !== $element && void 0 !== $element && $element.hasClass("dx-master-detail-cell")) {
      return super.focus($element, isHideBorder);
    }
    const $focus = null === $element || void 0 === $element ? void 0 : $element.closest(this._getFocusCellSelector());
    const validator = $focus && ($focus.data("dxValidator") || $element.find(`.${this.addWidgetPrefix("validator")}`).eq(0).data("dxValidator"));
    const rowOptions = $focus && $focus.closest(".dx-row").data("options");
    const change = rowOptions ? this._editingController.getChangeByKey(rowOptions.key) : null;
    let validationResult;
    if (validator) {
      this._validatingController.setValidator(validator);
      const value2 = validator.option("adapter").getValue();
      if (cellValueShouldBeValidated(value2, rowOptions) || this._validatingController._rowIsValidated(change)) {
        this._editingController.waitForDeferredOperations().done(() => {
          const isDetached = !this._rowsView.isElementInside($element);
          if (isDetached) {
            return;
          }
          when(this._validatingController.validateCell(validator)).done((result2) => {
            validationResult = result2;
            const {
              column
            } = validationResult.validator.option("dataGetter")();
            if (change && column && !this._validatingController.isCurrentValidatorProcessing({
              rowKey: change.key,
              columnIndex: column.index
            })) {
              return;
            }
            if (!isFluent(current()) && validationResult.status === VALIDATION_STATUS.invalid) {
              isHideBorder = true;
            }
            this.updateCellState($element, validationResult, isHideBorder);
            super.focus.call(this, $element, isHideBorder);
          });
        });
        return super.focus($element, isHideBorder);
      }
    }
    this.updateCellState($element, validationResult, isHideBorder);
    return super.focus($element, isHideBorder);
  }
  getEditorInstance($container) {
    const $editor = $container.find(".dx-texteditor").eq(0);
    return m_utils_default.getWidgetInstance($editor);
  }
  getValidationMessageContainer($cell) {
    return $cell.closest(`.${this.addWidgetPrefix("content")}`);
  }
  getRevertButtonContainer($cell) {
    return $cell.closest(`.${this.addWidgetPrefix("content")}`).parent();
  }
  hasOverlayElements() {
    const $validationMessageElements = this.getValidationMessages();
    const $revertButtonElement = this.getRevertButton();
    return super.hasOverlayElements() || !!(null !== $validationMessageElements && void 0 !== $validationMessageElements && $validationMessageElements.length) || !!(null !== $revertButtonElement && void 0 !== $revertButtonElement && $revertButtonElement.length);
  }
};
var validatingDataControllerExtender = (Base) => class extends Base {
  _getValidationStatus(validationResult) {
    const validationStatus = validationResultIsValid(validationResult) ? validationResult.status : validationResult;
    return validationStatus || VALIDATION_STATUS.valid;
  }
  _isCellChanged(oldRow, newRow, visibleRowIndex, columnIndex, isLiveUpdate) {
    var _oldRow$cells, _cell$column$validati;
    const cell = null === (_oldRow$cells = oldRow.cells) || void 0 === _oldRow$cells ? void 0 : _oldRow$cells[columnIndex];
    const oldValidationStatus = this._getValidationStatus({
      status: null === cell || void 0 === cell ? void 0 : cell.validationStatus
    });
    const validationResult = this._validatingController.getCellValidationResult({
      rowKey: oldRow.key,
      columnIndex
    });
    const validationData = this._validatingController._getValidationData(oldRow.key);
    const newValidationStatus = this._getValidationStatus(validationResult);
    const rowIsModified = JSON.stringify(newRow.modifiedValues) !== JSON.stringify(oldRow.modifiedValues);
    const validationStatusChanged = oldValidationStatus !== newValidationStatus && rowIsModified;
    const cellIsMarkedAsInvalid = renderer_default(null === cell || void 0 === cell ? void 0 : cell.cellElement).hasClass(this.addWidgetPrefix("invalid"));
    const hasValidationRules = null === cell || void 0 === cell || null === (_cell$column$validati = cell.column.validationRules) || void 0 === _cell$column$validati ? void 0 : _cell$column$validati.length;
    const rowEditStateChanged = oldRow.isEditing !== newRow.isEditing && hasValidationRules;
    const cellValidationStateChanged = validationStatusChanged || validationData.isValid && cellIsMarkedAsInvalid;
    if (rowEditStateChanged || cellValidationStateChanged) {
      return true;
    }
    return super._isCellChanged.apply(this, arguments);
  }
};
var validatingRowsViewExtender = (Base) => class extends Base {
  updateFreeSpaceRowHeight($table) {
    const that = this;
    let $rowElements;
    let $freeSpaceRowElement;
    let $freeSpaceRowElements;
    const $element = that.element();
    const $tooltipContent = $element && $element.find(`.${that.addWidgetPrefix("invalid-message")} .dx-overlay-content`);
    super.updateFreeSpaceRowHeight($table);
    if ($tooltipContent && $tooltipContent.length) {
      $rowElements = that._getRowElements().filter(":visible");
      $freeSpaceRowElements = that._getFreeSpaceRowElements($table);
      $freeSpaceRowElement = $freeSpaceRowElements.first();
      const rowElementsHasFocusInside = $rowElements.find(":focus").length > 0;
      if ($freeSpaceRowElement && 1 === $rowElements.length && (!$freeSpaceRowElement.is(":visible") || getOuterHeight($tooltipContent) > getOuterHeight($freeSpaceRowElement)) && rowElementsHasFocusInside) {
        $freeSpaceRowElements.show();
        setHeight($freeSpaceRowElements, getOuterHeight($tooltipContent));
        return true;
      }
    }
    return;
  }
  _formItemPrepared(cellOptions, $container) {
    super._formItemPrepared.apply(this, arguments);
    deferUpdate(() => {
      const $editor = $container.find(".dx-widget").first();
      const isEditorDisposed = $editor.length && !$editor.children().length;
      if (!isEditorDisposed) {
        this._validatingController.createValidator(cellOptions, $editor);
      }
    });
  }
  _cellPrepared($cell, parameters) {
    if (!this._editingController.isFormOrPopupEditMode()) {
      this._validatingController.createValidator(parameters, $cell);
    }
    super._cellPrepared.apply(this, arguments);
  }
  _restoreErrorRow(contentTable) {
    this._editingController && this._editingController.hasChanges() && this._getRowElements(contentTable).each((_, item) => {
      const rowOptions = renderer_default(item).data("options");
      if (rowOptions) {
        const change = this._editingController.getChangeByKey(rowOptions.key);
        change && this._editingController._showErrorRow(change);
      }
    });
  }
};
var validatingModule = {
  defaultOptions: () => ({
    editing: {
      texts: {
        validationCancelChanges: message_default.format("dxDataGrid-validationCancelChanges")
      }
    }
  }),
  controllers: {
    validating: ValidatingController
  },
  extenders: {
    controllers: {
      editing: validatingEditingExtender,
      editorFactory: validatingEditorFactoryExtender,
      data: validatingDataControllerExtender
    },
    views: {
      rowsView: validatingRowsViewExtender
    }
  }
};

// node_modules/devextreme/esm/__internal/grids/data_grid/module_not_extended/validating.js
m_core_default.registerModule("validating", validatingModule);

// node_modules/devextreme/esm/__internal/grids/grid_core/virtual_data_loader/m_virtual_data_loader.js
var LEGACY_SCROLLING_MODE2 = "scrolling.legacyMode";
var needTwoPagesLoading = (that) => that.option("scrolling.loadTwoPagesOnStart") || that._controller.isVirtual() || that._controller.getViewportItemIndex() > 0;
var getBeginPageIndex = (that) => that._cache.length ? that._cache[0].pageIndex : -1;
var getEndPageIndex = (that) => that._cache.length ? that._cache[that._cache.length - 1].pageIndex : -1;
var fireChanged = (that, changed, args) => {
  that._isChangedFiring = true;
  changed(args);
  that._isChangedFiring = false;
};
var processDelayChanged = (that, changed, args) => {
  if (that._isDelayChanged) {
    that._isDelayChanged = false;
    fireChanged(that, changed, args);
    return true;
  }
};
var getViewportPageCount = (that) => {
  const pageSize = that._dataOptions.pageSize();
  const preventPreload = that.option("scrolling.preventPreload");
  if (preventPreload) {
    return 0;
  }
  let realViewportSize = that._controller.viewportSize();
  if (that._controller.isVirtualMode() && that.option("scrolling.removeInvisiblePages")) {
    realViewportSize = 0;
    const viewportSize = that._controller.viewportSize() * that._controller.viewportItemSize();
    let offset2 = that._controller.getContentOffset();
    const position3 = that._controller.getViewportPosition();
    const virtualItemsCount = that._controller.virtualItemsCount();
    const totalItemsCount = that._dataOptions.totalItemsCount();
    for (let itemIndex = virtualItemsCount.begin; itemIndex < totalItemsCount; itemIndex++) {
      if (offset2 >= position3 + viewportSize) {
        break;
      }
      const itemSize = that._controller.getItemSizes()[itemIndex] || that._controller.viewportItemSize();
      offset2 += itemSize;
      if (offset2 >= position3) {
        realViewportSize++;
      }
    }
  }
  return pageSize && realViewportSize > 0 ? Math.ceil(realViewportSize / pageSize) : 1;
};
var getPreloadPageCount = (that, previous) => {
  const preloadEnabled = that.option("scrolling.preloadEnabled");
  let pageCount = getViewportPageCount(that);
  const isAppendMode3 = that._controller.isAppendMode();
  if (pageCount) {
    if (previous) {
      pageCount = preloadEnabled ? 1 : 0;
    } else {
      if (preloadEnabled) {
        pageCount++;
      }
      if (isAppendMode3 || !needTwoPagesLoading(that)) {
        pageCount--;
      }
    }
  }
  return pageCount;
};
var getPageIndexForLoad = (that) => {
  let result2 = -1;
  const beginPageIndex = getBeginPageIndex(that);
  const dataOptions = that._dataOptions;
  if (beginPageIndex < 0) {
    result2 = that._pageIndex;
  } else if (!that._cache[that._pageIndex - beginPageIndex]) {
    result2 = that._pageIndex;
  } else if (beginPageIndex >= 0 && that._controller.viewportSize() >= 0) {
    if (beginPageIndex > 0) {
      const needToLoadPageBeforeLast = getEndPageIndex(that) + 1 === dataOptions.pageCount() && that._cache.length < getPreloadPageCount(that) + 1;
      const needToLoadPrevPage = needToLoadPageBeforeLast || that._pageIndex === beginPageIndex && getPreloadPageCount(that, true);
      if (needToLoadPrevPage) {
        result2 = beginPageIndex - 1;
      }
    }
    if (result2 < 0) {
      const needToLoadNextPage = beginPageIndex + that._cache.length <= that._pageIndex + getPreloadPageCount(that);
      if (needToLoadNextPage) {
        result2 = beginPageIndex + that._cache.length;
      }
    }
  }
  if (that._loadingPageIndexes[result2]) {
    result2 = -1;
  }
  return result2;
};
var loadCore = (that, pageIndex) => {
  const dataOptions = that._dataOptions;
  if (pageIndex === that.pageIndex() || !dataOptions.isLoading() && pageIndex < dataOptions.pageCount() || !dataOptions.hasKnownLastPage() && pageIndex === dataOptions.pageCount()) {
    dataOptions.pageIndex(pageIndex);
    that._loadingPageIndexes[pageIndex] = true;
    return when(dataOptions.load()).always(() => {
      that._loadingPageIndexes[pageIndex] = false;
    });
  }
};
var processChanged = (that, changed, changeType, isDelayChanged, removeCacheItem) => {
  const dataOptions = that._dataOptions;
  const items = dataOptions.items().slice();
  let change = isObject(changeType) ? changeType : void 0;
  const isPrepend = "prepend" === changeType;
  const viewportItems = dataOptions.viewportItems();
  if (changeType && isString(changeType) && !that._isDelayChanged) {
    change = {
      changeType,
      items
    };
    if (removeCacheItem) {
      change.removeCount = removeCacheItem.itemsCount;
      if (change.removeCount && dataOptions.correctCount) {
        change.removeCount = dataOptions.correctCount(viewportItems, change.removeCount, isPrepend);
      }
    }
  }
  let removeItemCount = removeCacheItem ? removeCacheItem.itemsLength : 0;
  if (removeItemCount && dataOptions.correctCount) {
    removeItemCount = dataOptions.correctCount(viewportItems, removeItemCount, isPrepend);
  }
  if ("append" === changeType) {
    viewportItems.push.apply(viewportItems, items);
    if (removeCacheItem) {
      viewportItems.splice(0, removeItemCount);
    }
  } else if (isPrepend) {
    viewportItems.unshift.apply(viewportItems, items);
    if (removeCacheItem) {
      viewportItems.splice(-removeItemCount);
    }
  } else {
    that._dataOptions.viewportItems(items);
  }
  dataOptions.updateLoading();
  that._lastPageIndex = that.pageIndex();
  that._isDelayChanged = isDelayChanged;
  if (!isDelayChanged) {
    fireChanged(that, changed, change);
  }
};
var VirtualDataLoader = class {
  constructor(controller, dataOptions) {
    this._dataOptions = dataOptions;
    this._controller = controller;
    this._pageIndex = this._lastPageIndex = dataOptions.pageIndex();
    this._cache = [];
    this._loadingPageIndexes = {};
  }
  option() {
    return this._controller.option.apply(this._controller, arguments);
  }
  viewportItemIndexChanged(itemIndex) {
    const pageSize = this._dataOptions.pageSize();
    const pageCount = this._dataOptions.pageCount();
    const virtualMode = this._controller.isVirtualMode();
    const appendMode = this._controller.isAppendMode();
    const totalItemsCount = this._dataOptions.totalItemsCount();
    let newPageIndex;
    if (pageSize && (virtualMode || appendMode) && totalItemsCount >= 0) {
      const viewportSize = this._controller.viewportSize();
      if (viewportSize && itemIndex + viewportSize >= totalItemsCount && !this._controller.isVirtual()) {
        if (this._dataOptions.hasKnownLastPage()) {
          newPageIndex = pageCount - 1;
          const lastPageSize = totalItemsCount % pageSize;
          if (newPageIndex > 0 && lastPageSize > 0 && lastPageSize < viewportSize) {
            newPageIndex--;
          }
        } else {
          newPageIndex = pageCount;
        }
      } else {
        newPageIndex = Math.floor(itemIndex / pageSize);
        const maxPageIndex = pageCount - 1;
        newPageIndex = Math.max(newPageIndex, 0);
        newPageIndex = Math.min(newPageIndex, maxPageIndex);
      }
      this.pageIndex(newPageIndex);
      return this.load();
    }
  }
  pageIndex(pageIndex) {
    const isVirtualMode3 = this._controller.isVirtualMode();
    const isAppendMode3 = this._controller.isAppendMode();
    if (false !== this.option(LEGACY_SCROLLING_MODE2) && (isVirtualMode3 || isAppendMode3)) {
      if (void 0 !== pageIndex) {
        this._pageIndex = pageIndex;
      }
      return this._pageIndex;
    }
    return this._dataOptions.pageIndex(pageIndex);
  }
  beginPageIndex(defaultPageIndex) {
    let index2 = getBeginPageIndex(this);
    if (index2 < 0) {
      index2 = void 0 !== defaultPageIndex ? defaultPageIndex : this.pageIndex();
    }
    return index2;
  }
  endPageIndex() {
    const endPageIndex = getEndPageIndex(this);
    return endPageIndex > 0 ? endPageIndex : this._lastPageIndex;
  }
  pageSize() {
    return this._dataOptions.pageSize();
  }
  load() {
    const dataOptions = this._dataOptions;
    let result2;
    const isVirtualMode3 = this._controller.isVirtualMode();
    const isAppendMode3 = this._controller.isAppendMode();
    if (false !== this.option(LEGACY_SCROLLING_MODE2) && (isVirtualMode3 || isAppendMode3)) {
      const pageIndexForLoad = getPageIndexForLoad(this);
      if (pageIndexForLoad >= 0) {
        const loadResult = loadCore(this, pageIndexForLoad);
        if (loadResult) {
          result2 = new Deferred();
          loadResult.done(() => {
            const delayDeferred = this._delayDeferred;
            if (delayDeferred) {
              delayDeferred.done(result2.resolve).fail(result2.reject);
            } else {
              result2.resolve();
            }
          }).fail(result2.reject);
          dataOptions.updateLoading();
        }
      }
    } else {
      result2 = dataOptions.load();
    }
    if (!result2 && this._lastPageIndex !== this.pageIndex()) {
      this._dataOptions.onChanged({
        changeType: "pageIndex"
      });
    }
    return result2 || new Deferred().resolve();
  }
  loadIfNeed() {
    const isVirtualMode3 = this._controller.isVirtualMode();
    const isAppendMode3 = this._controller.isAppendMode();
    if ((isVirtualMode3 || isAppendMode3) && !this._dataOptions.isLoading() && (!this._isChangedFiring || this._controller.isVirtual())) {
      const position3 = this._controller.getViewportPosition();
      if (position3 > 0) {
        this._controller._setViewportPositionCore(position3);
      } else {
        this.load();
      }
    }
  }
  handleDataChanged(callBase, e) {
    const dataOptions = this._dataOptions;
    let lastCacheLength = this._cache.length;
    let changeType;
    let removeInvisiblePages;
    const isVirtualMode3 = this._controller.isVirtualMode();
    const isAppendMode3 = this._controller.isAppendMode();
    if (e && e.changes) {
      fireChanged(this, callBase, e);
    } else if (false !== this.option(LEGACY_SCROLLING_MODE2) && (isVirtualMode3 || isAppendMode3)) {
      const beginPageIndex = getBeginPageIndex(this);
      if (beginPageIndex >= 0) {
        if (isVirtualMode3 && beginPageIndex + this._cache.length !== dataOptions.pageIndex() && beginPageIndex - 1 !== dataOptions.pageIndex()) {
          lastCacheLength = 0;
          this._cache = [];
        }
        if (isAppendMode3) {
          if (0 === dataOptions.pageIndex()) {
            this._cache = [];
          } else if (dataOptions.pageIndex() < getEndPageIndex(this)) {
            fireChanged(this, callBase, {
              changeType: "append",
              items: []
            });
            return;
          }
        }
      }
      const cacheItem = {
        pageIndex: dataOptions.pageIndex(),
        itemsLength: dataOptions.items(true).length,
        itemsCount: this.itemsCount(true)
      };
      if (this.option("scrolling.removeInvisiblePages") && isVirtualMode3) {
        removeInvisiblePages = this._cache.length > Math.max(getPreloadPageCount(this) + (this.option("scrolling.preloadEnabled") ? 1 : 0), 2);
      } else {
        processDelayChanged(this, callBase, {
          isDelayed: true
        });
      }
      let removeCacheItem;
      if (beginPageIndex === dataOptions.pageIndex() + 1) {
        if (removeInvisiblePages) {
          removeCacheItem = this._cache.pop();
        }
        changeType = "prepend";
        this._cache.unshift(cacheItem);
      } else {
        if (removeInvisiblePages) {
          removeCacheItem = this._cache.shift();
        }
        changeType = "append";
        this._cache.push(cacheItem);
      }
      const isDelayChanged = isVirtualMode3 && 0 === lastCacheLength && needTwoPagesLoading(this);
      processChanged(this, callBase, this._cache.length > 1 ? changeType : void 0, isDelayChanged, removeCacheItem);
      this._delayDeferred = this.load().done(() => {
        if (processDelayChanged(this, callBase)) {
          this.load();
        }
      });
    } else {
      processChanged(this, callBase, e);
    }
  }
  getDelayDeferred() {
    return this._delayDeferred;
  }
  itemsCount(isBase) {
    let count = 0;
    const isVirtualMode3 = this._controller.isVirtualMode();
    if (!isBase && isVirtualMode3) {
      this._cache.forEach((cacheItem) => {
        count += cacheItem.itemsCount;
      });
    } else {
      count = this._dataOptions.itemsCount();
    }
    return count;
  }
  virtualItemsCount() {
    let pageIndex = getBeginPageIndex(this);
    if (pageIndex < 0) {
      pageIndex = this._dataOptions.pageIndex();
    }
    const beginItemsCount = pageIndex * this._dataOptions.pageSize();
    const itemsCount = this._cache.length * this._dataOptions.pageSize();
    const endItemsCount = Math.max(0, this._dataOptions.totalItemsCount() - itemsCount - beginItemsCount);
    return {
      begin: beginItemsCount,
      end: endItemsCount
    };
  }
  reset() {
    this._loadingPageIndexes = {};
    this._cache = [];
  }
};

// node_modules/devextreme/esm/__internal/grids/grid_core/virtual_scrolling/m_virtual_scrolling_core.js
var LEGACY_SCROLLING_MODE3 = "scrolling.legacyMode";
var isVirtualMode = (that) => "virtual" === that.option("scrolling.mode") || that._isVirtual;
var isAppendMode = (that) => "infinite" === that.option("scrolling.mode") && !that._isVirtual;
function subscribeToExternalScrollers($element, scrollChangedHandler, $targetElement) {
  let $scrollElement;
  const scrollableArray = [];
  const scrollToArray = [];
  const disposeArray = [];
  $targetElement = $targetElement || $element;
  function getElementOffset(scrollable) {
    const $scrollableElement = scrollable.element ? scrollable.$element() : scrollable;
    const scrollableOffset = position_default.offset($scrollableElement);
    if (!scrollableOffset) {
      return $element.offset().top;
    }
    return scrollable.scrollTop() - (scrollableOffset.top - $element.offset().top);
  }
  const widgetScrollStrategy = {
    on(scrollable, eventName, handler) {
      scrollable.on("scroll", handler);
    },
    off(scrollable, eventName, handler) {
      scrollable.off("scroll", handler);
    }
  };
  function subscribeToScrollEvents($scrollElement2) {
    const isDocument = "#document" === $scrollElement2.get(0).nodeName;
    const isElement = $scrollElement2.get(0).nodeType === getWindow().Node.ELEMENT_NODE;
    let scrollable = $scrollElement2.data("dxScrollable");
    let eventsStrategy = widgetScrollStrategy;
    if (!scrollable) {
      scrollable = isDocument && renderer_default(getWindow()) || isElement && "auto" === $scrollElement2.css("overflowY") && $scrollElement2;
      eventsStrategy = m_events_engine_default;
      if (!scrollable) {
        return;
      }
    }
    const handler = /* @__PURE__ */ function(scrollable2) {
      return function() {
        let scrollTop = scrollable2.scrollTop() - getElementOffset(scrollable2);
        scrollTop = scrollTop > 0 ? scrollTop : 0;
        scrollChangedHandler(scrollTop);
      };
    }(scrollable);
    eventsStrategy.on(scrollable, "scroll", handler);
    scrollToArray.push((pos) => {
      const topOffset = getElementOffset(scrollable);
      const scrollMethod = scrollable.scrollTo ? "scrollTo" : "scrollTop";
      if (pos - topOffset >= 0) {
        scrollable[scrollMethod](pos + topOffset);
      }
    });
    scrollableArray.push(scrollable);
    disposeArray.push(() => {
      eventsStrategy.off(scrollable, "scroll", handler);
    });
  }
  const getScrollElementParent = ($element2) => renderer_default($element2.get(0).parentNode ?? $element2.get(0).host);
  for ($scrollElement = $targetElement.parent(); $scrollElement.length; $scrollElement = getScrollElementParent($scrollElement)) {
    subscribeToScrollEvents($scrollElement);
  }
  return {
    scrollTo(pos) {
      each(scrollToArray, (_, scrollTo) => {
        scrollTo(pos);
      });
    },
    dispose() {
      each(disposeArray, (_, dispose2) => {
        dispose2();
      });
    }
  };
}
var VirtualScrollController = class {
  constructor(component, dataOptions, isVirtual) {
    this._dataOptions = dataOptions;
    this.component = component;
    this._viewportSize = false === component.option(LEGACY_SCROLLING_MODE3) ? 15 : 0;
    this._viewportItemSize = 20;
    this._viewportItemIndex = 0;
    this._position = 0;
    this._isScrollingBack = false;
    this._contentSize = 0;
    this._itemSizes = {};
    this._sizeRatio = 1;
    this._isVirtual = isVirtual;
    this.positionChanged = callbacks_default();
    this._dataLoader = new VirtualDataLoader(this, this._dataOptions);
  }
  getItemSizes() {
    return this._itemSizes;
  }
  option(name2, value2) {
    return this.component.option.apply(this.component, arguments);
  }
  isVirtual() {
    return this._isVirtual;
  }
  virtualItemsCount() {
    if (isVirtualMode(this)) {
      const dataOptions = this._dataOptions;
      const totalItemsCount = dataOptions.totalItemsCount();
      if (false === this.option(LEGACY_SCROLLING_MODE3) && -1 !== totalItemsCount) {
        const viewportParams = this.getViewportParams();
        const loadedOffset = dataOptions.loadedOffset();
        const loadedItemCount = dataOptions.loadedItemCount();
        const skip = Math.max(viewportParams.skip, loadedOffset);
        const take = Math.min(viewportParams.take, loadedItemCount);
        const endItemsCount = Math.max(totalItemsCount - (skip + take), 0);
        return {
          begin: skip,
          end: endItemsCount
        };
      }
      return this._dataLoader.virtualItemsCount.apply(this._dataLoader, arguments);
    }
    return;
  }
  getScrollingTimeout() {
    const renderAsync = this.option("scrolling.renderAsync");
    let scrollingTimeout = 0;
    if (!isDefined(renderAsync)) {
      scrollingTimeout = Math.min(this.option("scrolling.timeout") || 0, this._dataOptions.changingDuration());
      if (scrollingTimeout < this.option("scrolling.renderingThreshold")) {
        scrollingTimeout = this.option("scrolling.minTimeout") || 0;
      }
    } else if (renderAsync) {
      scrollingTimeout = this.option("scrolling.timeout") ?? 0;
    }
    return scrollingTimeout;
  }
  setViewportPosition(position3) {
    const result2 = new Deferred();
    const scrollingTimeout = this.getScrollingTimeout();
    clearTimeout(this._scrollTimeoutID);
    if (scrollingTimeout > 0) {
      this._scrollTimeoutID = setTimeout(() => {
        this._setViewportPositionCore(position3);
        result2.resolve();
      }, scrollingTimeout);
    } else {
      this._setViewportPositionCore(position3);
      result2.resolve();
    }
    return result2.promise();
  }
  getViewportPosition() {
    return this._position;
  }
  getItemIndexByPosition(position3, viewportItemIndex, height) {
    position3 = position3 ?? this._position;
    const defaultItemSize = this.getItemSize();
    let offset2 = 0;
    let itemOffset = 0;
    const itemOffsetsWithSize = Object.keys(this._itemSizes).concat(-1);
    for (let i = 0; i < itemOffsetsWithSize.length && offset2 < position3; i++) {
      const itemOffsetWithSize = parseInt(itemOffsetsWithSize[i]);
      let itemOffsetDiff = (position3 - offset2) / defaultItemSize;
      if (itemOffsetWithSize < 0 || itemOffset + itemOffsetDiff < itemOffsetWithSize) {
        itemOffset += itemOffsetDiff;
        if (this._sizeRatio < 1 && isDefined(viewportItemIndex)) {
          itemOffset = viewportItemIndex + height / this._viewportItemSize;
        }
        break;
      } else {
        itemOffsetDiff = itemOffsetWithSize - itemOffset;
        offset2 += itemOffsetDiff * defaultItemSize;
        itemOffset += itemOffsetDiff;
      }
      const itemSize = this._itemSizes[itemOffsetWithSize];
      offset2 += itemSize;
      itemOffset += offset2 < position3 ? 1 : (position3 - offset2 + itemSize) / itemSize;
    }
    return Math.round(50 * itemOffset) / 50;
  }
  isScrollingBack() {
    return this._isScrollingBack;
  }
  _setViewportPositionCore(position3) {
    const prevPosition = this._position || 0;
    this._position = position3;
    if (prevPosition !== this._position) {
      this._isScrollingBack = this._position < prevPosition;
    }
    const itemIndex = this.getItemIndexByPosition();
    const result2 = this.setViewportItemIndex(itemIndex);
    this.positionChanged.fire();
    return result2;
  }
  setContentItemSizes(sizes) {
    const virtualItemsCount = this.virtualItemsCount();
    this._contentSize = sizes.reduce((a, b) => a + b, 0);
    if (virtualItemsCount) {
      sizes.forEach((size, index2) => {
        this._itemSizes[virtualItemsCount.begin + index2] = size;
      });
      const virtualContentSize = (virtualItemsCount.begin + virtualItemsCount.end + this.itemsCount()) * this._viewportItemSize;
      const contentHeightLimit = m_utils_default.getContentHeightLimit(browser_default);
      if (virtualContentSize > contentHeightLimit) {
        this._sizeRatio = contentHeightLimit / virtualContentSize;
      } else {
        this._sizeRatio = 1;
      }
    }
  }
  getItemSize() {
    return this._viewportItemSize * this._sizeRatio;
  }
  getItemOffset(itemIndex, isEnd) {
    const virtualItemsCount = this.virtualItemsCount();
    let itemCount = itemIndex;
    if (!virtualItemsCount) {
      return 0;
    }
    let offset2 = 0;
    const totalItemsCount = this._dataOptions.totalItemsCount();
    Object.keys(this._itemSizes).forEach((currentItemIndex) => {
      if (!itemCount) {
        return;
      }
      if (isEnd ? currentItemIndex >= totalItemsCount - itemIndex : currentItemIndex < itemIndex) {
        offset2 += this._itemSizes[currentItemIndex];
        itemCount--;
      }
    });
    return Math.floor(offset2 + itemCount * this._viewportItemSize * this._sizeRatio);
  }
  getContentOffset(type2) {
    const isEnd = "end" === type2;
    const virtualItemsCount = this.virtualItemsCount();
    if (!virtualItemsCount) {
      return 0;
    }
    return this.getItemOffset(isEnd ? virtualItemsCount.end : virtualItemsCount.begin, isEnd);
  }
  getVirtualContentSize() {
    const virtualItemsCount = this.virtualItemsCount();
    return virtualItemsCount ? this.getContentOffset("begin") + this.getContentOffset("end") + this._contentSize : 0;
  }
  getViewportItemIndex() {
    return this._viewportItemIndex;
  }
  setViewportItemIndex(itemIndex) {
    this._viewportItemIndex = itemIndex;
    if (false === this.option(LEGACY_SCROLLING_MODE3)) {
      return;
    }
    return this._dataLoader.viewportItemIndexChanged.apply(this._dataLoader, arguments);
  }
  viewportItemSize(size) {
    if (void 0 !== size) {
      this._viewportItemSize = size;
    }
    return this._viewportItemSize;
  }
  viewportSize(size) {
    if (void 0 !== size) {
      this._viewportSize = size;
    }
    return this._viewportSize;
  }
  viewportHeight(height, scrollTop) {
    const position3 = scrollTop ?? this._position;
    const begin = this.getItemIndexByPosition(position3);
    const end = this.getItemIndexByPosition(position3 + height, begin, height);
    this.viewportSize(Math.ceil(end - begin));
    if (!isDefined(scrollTop) && this._viewportItemIndex !== begin) {
      this._setViewportPositionCore(position3);
    }
  }
  reset(isRefresh) {
    this._dataLoader.reset();
    if (!isRefresh) {
      this._itemSizes = {};
    }
  }
  subscribeToWindowScrollEvents($element) {
    this._windowScroll = this._windowScroll || subscribeToExternalScrollers($element, (scrollTop) => {
      if (this.viewportItemSize()) {
        this.setViewportPosition(scrollTop);
      }
    });
  }
  dispose() {
    clearTimeout(this._scrollTimeoutID);
    this._windowScroll && this._windowScroll.dispose();
    this._windowScroll = null;
  }
  scrollTo(pos) {
    this._windowScroll && this._windowScroll.scrollTo(pos);
  }
  isVirtualMode() {
    return isVirtualMode(this);
  }
  isAppendMode() {
    return isAppendMode(this);
  }
  getViewportParams() {
    const virtualMode = "virtual" === this.option("scrolling.mode");
    const totalItemsCount = this._dataOptions.totalItemsCount();
    const hasKnownLastPage = this._dataOptions.hasKnownLastPage();
    const topIndex = hasKnownLastPage && this._viewportItemIndex > totalItemsCount ? totalItemsCount : this._viewportItemIndex;
    const bottomIndex = this._viewportSize + topIndex;
    const maxGap = this.option("scrolling.prerenderedRowChunkSize") || 1;
    const isScrollingBack = this.isScrollingBack();
    const minGap = this.option("scrolling.prerenderedRowCount") ?? 1;
    const topMinGap = isScrollingBack ? minGap : 0;
    const bottomMinGap = isScrollingBack ? 0 : minGap;
    const skip = Math.floor(Math.max(0, topIndex - topMinGap) / maxGap) * maxGap;
    let take = Math.ceil((bottomIndex + bottomMinGap - skip) / maxGap) * maxGap;
    if (virtualMode) {
      const remainedItems = Math.max(0, totalItemsCount - skip);
      take = Math.min(take, remainedItems);
    }
    return {
      skip,
      take
    };
  }
  itemsCount() {
    let result2 = 0;
    if (this.option(LEGACY_SCROLLING_MODE3)) {
      result2 = this._dataLoader.itemsCount.apply(this._dataLoader, arguments);
    } else {
      result2 = this._dataOptions.itemsCount();
    }
    return result2;
  }
  pageIndex() {
    return this._dataLoader.pageIndex(...arguments);
  }
  beginPageIndex() {
    return this._dataLoader.beginPageIndex(...arguments);
  }
  endPageIndex() {
    return this._dataLoader.endPageIndex(...arguments);
  }
  pageSize() {
    return this._dataLoader.pageSize(...arguments);
  }
  load() {
    return this._dataLoader.load(...arguments);
  }
  loadIfNeed() {
    return this._dataLoader.loadIfNeed(...arguments);
  }
  handleDataChanged() {
    return this._dataLoader.handleDataChanged(...arguments);
  }
  getDelayDeferred() {
    return this._dataLoader.getDelayDeferred();
  }
};

// node_modules/devextreme/esm/__internal/grids/grid_core/virtual_scrolling/m_virtual_scrolling.js
var FREESPACE_CLASS = "dx-freespace-row";
var ROW_INSERTED2 = "dx-row-inserted";
var LEGACY_SCROLLING_MODE4 = "scrolling.legacyMode";
var PAGING_METHOD_NAMES = ["beginPageIndex", "endPageIndex", "pageIndex"];
var isVirtualMode2 = function(that) {
  return "virtual" === that.option("scrolling.mode");
};
var isAppendMode2 = function(that) {
  return "infinite" === that.option("scrolling.mode");
};
var isVirtualPaging = function(that) {
  return isVirtualMode2(that) || isAppendMode2(that);
};
var correctCount = function(items, count, fromEnd, isItemCountableFunc) {
  for (let i = 0; i < count + 1; i++) {
    const item = items[fromEnd ? items.length - 1 - i : i];
    if (item && !isItemCountableFunc(item, i === count, fromEnd)) {
      count++;
    }
  }
  return count;
};
var isItemCountableByDataSource = function(item, dataSource) {
  return "data" === item.rowType && !item.isNewRow || "group" === item.rowType && dataSource.isGroupItemCountable(item.data);
};
var updateItemIndices = function(items) {
  items.forEach((item, index2) => {
    item.rowIndex = index2;
  });
  return items;
};
var updateLoading = function(that) {
  const beginPageIndex = that._virtualScrollController.beginPageIndex(-1);
  if (isVirtualMode2(that)) {
    if (beginPageIndex < 0 || that.viewportSize() >= 0 && that.getViewportItemIndex() >= 0 && (beginPageIndex * that.pageSize() > that.getViewportItemIndex() || beginPageIndex * that.pageSize() + that.itemsCount() < that.getViewportItemIndex() + that.viewportSize()) && that._dataSource.isLoading()) {
      if (!that._isLoading) {
        that._isLoading = true;
        that.loadingChanged.fire(true);
      }
    } else if (that._isLoading) {
      that._isLoading = false;
      that.loadingChanged.fire(false);
    }
  }
};
var proxyDataSourceAdapterMethod = function(that, methodName, args) {
  if (false === that.option(LEGACY_SCROLLING_MODE4) && PAGING_METHOD_NAMES.includes(methodName)) {
    const dataSource = that._dataSource;
    return dataSource.pageIndex.apply(dataSource, args);
  }
  const virtualScrollController = that._virtualScrollController;
  return virtualScrollController[methodName].apply(virtualScrollController, args);
};
var removeEmptyRows = function($emptyRows, className) {
  const tBodies = $emptyRows.toArray().map((row) => renderer_default(row).parent(`.${className}`).get(0)).filter((row) => row);
  if (tBodies.length) {
    $emptyRows = renderer_default(tBodies);
  }
  const rowCount = className === FREESPACE_CLASS ? $emptyRows.length - 1 : $emptyRows.length;
  for (let i = 0; i < rowCount; i++) {
    $emptyRows.eq(i).remove();
  }
};
var dataSourceAdapterExtender2 = (Base) => class extends Base {
  init() {
    super.init.apply(this, arguments);
    this._items = [];
    this._totalCount = -1;
    this._isLoaded = true;
    this._loadPageCount = 1;
    this._virtualScrollController = new VirtualScrollController(this.component, this._getVirtualScrollDataOptions());
  }
  dispose() {
    this._virtualScrollController.dispose();
    super.dispose.apply(this, arguments);
  }
  _getVirtualScrollDataOptions() {
    const that = this;
    return {
      pageSize: () => that.pageSize(),
      totalItemsCount: () => that.totalItemsCount(),
      hasKnownLastPage: () => that.hasKnownLastPage(),
      pageIndex: (index2) => that._dataSource.pageIndex(index2),
      isLoading: () => that._dataSource.isLoading() && !that.isCustomLoading(),
      pageCount: () => that.pageCount(),
      load: () => that._dataSource.load(),
      updateLoading() {
        updateLoading(that);
      },
      itemsCount: () => that.itemsCount(true),
      items: () => that._dataSource.items(),
      viewportItems(items) {
        if (items) {
          that._items = items;
        }
        return that._items;
      },
      onChanged(e) {
        that.changed.fire(e);
      },
      changingDuration() {
        if (that.isLoading()) {
          return 300;
        }
        return that._renderTime || 0;
      }
    };
  }
  _handleLoadingChanged(isLoading) {
    if (false === this.option(LEGACY_SCROLLING_MODE4)) {
      super._handleLoadingChanged.apply(this, arguments);
      return;
    }
    if (!isVirtualMode2(this) || this._isLoadingAll) {
      this._isLoading = isLoading;
      super._handleLoadingChanged.apply(this, arguments);
    }
    if (isLoading) {
      this._startLoadTime = /* @__PURE__ */ new Date();
    } else {
      this._startLoadTime = void 0;
    }
  }
  _handleLoadError() {
    if (false !== this.option(LEGACY_SCROLLING_MODE4)) {
      this._isLoading = false;
      this.loadingChanged.fire(false);
    }
    super._handleLoadError.apply(this, arguments);
  }
  _handleDataChanged(e) {
    if (false === this.option(LEGACY_SCROLLING_MODE4)) {
      this._items = this._dataSource.items().slice();
      this._totalCount = this._dataSourceTotalCount(true);
      super._handleDataChanged.apply(this, arguments);
      return;
    }
    const callBase = super._handleDataChanged.bind(this);
    this._virtualScrollController.handleDataChanged(callBase, e);
  }
  _customizeRemoteOperations(options2, operationTypes) {
    const newMode = false === this.option(LEGACY_SCROLLING_MODE4);
    let renderAsync = this.option("scrolling.renderAsync");
    if (!isDefined(renderAsync)) {
      renderAsync = this._renderTime >= this.option("scrolling.renderingThreshold");
    }
    if ((isVirtualMode2(this) || isAppendMode2(this) && newMode) && !operationTypes.reload && (operationTypes.skip || newMode) && !renderAsync) {
      options2.delay = void 0;
    }
    super._customizeRemoteOperations.apply(this, arguments);
  }
  items() {
    return this._items;
  }
  _dataSourceTotalCount(isBase) {
    return false === this.option(LEGACY_SCROLLING_MODE4) && isVirtualMode2(this) && !isBase ? this._totalCount : super._dataSourceTotalCount();
  }
  itemsCount(isBase) {
    if (isBase || false === this.option(LEGACY_SCROLLING_MODE4)) {
      return super.itemsCount();
    }
    return this._virtualScrollController.itemsCount();
  }
  load(loadOptions) {
    if (false === this.option(LEGACY_SCROLLING_MODE4) || loadOptions) {
      return super.load(loadOptions);
    }
    return this._virtualScrollController.load();
  }
  isLoading() {
    return false === this.option(LEGACY_SCROLLING_MODE4) ? this._dataSource.isLoading() : this._isLoading;
  }
  isLoaded() {
    return this._dataSource.isLoaded() && this._isLoaded;
  }
  resetPagesCache(isLiveUpdate) {
    if (!isLiveUpdate) {
      this._virtualScrollController.reset(true);
    }
    super.resetPagesCache.apply(this, arguments);
  }
  _changeRowExpandCore() {
    const result2 = super._changeRowExpandCore.apply(this, arguments);
    if (false === this.option(LEGACY_SCROLLING_MODE4)) {
      return result2;
    }
    this.resetPagesCache();
    updateLoading(this);
    return result2;
  }
  reload() {
    this._dataSource.pageIndex(this.pageIndex());
    const virtualScrollController = this._virtualScrollController;
    if (false !== this.option(LEGACY_SCROLLING_MODE4) && virtualScrollController) {
      const d = new Deferred();
      super.reload.apply(this, arguments).done((r) => {
        const delayDeferred = virtualScrollController.getDelayDeferred();
        if (delayDeferred) {
          delayDeferred.done(d.resolve).fail(d.reject);
        } else {
          d.resolve(r);
        }
      }).fail(d.reject);
      return d;
    }
    return super.reload.apply(this, arguments);
  }
  refresh(options2, operationTypes) {
    if (false !== this.option(LEGACY_SCROLLING_MODE4)) {
      const {
        storeLoadOptions
      } = options2;
      const dataSource = this._dataSource;
      if (operationTypes.reload) {
        this._virtualScrollController.reset();
        dataSource.items().length = 0;
        this._isLoaded = false;
        updateLoading(this);
        this._isLoaded = true;
        if (isAppendMode2(this)) {
          this.pageIndex(0);
          dataSource.pageIndex(0);
          storeLoadOptions.pageIndex = 0;
          options2.pageIndex = 0;
          storeLoadOptions.skip = 0;
        } else {
          dataSource.pageIndex(this.pageIndex());
          if (dataSource.paginate()) {
            options2.pageIndex = this.pageIndex();
            storeLoadOptions.skip = this.pageIndex() * this.pageSize();
          }
        }
      } else if (isAppendMode2(this) && storeLoadOptions.skip && this._totalCountCorrection < 0) {
        storeLoadOptions.skip += this._totalCountCorrection;
      }
    }
    return super.refresh.apply(this, arguments);
  }
  loadPageCount(count) {
    if (!isDefined(count)) {
      return this._loadPageCount;
    }
    this._loadPageCount = count;
  }
  _handleDataLoading(options2) {
    const loadPageCount = this.loadPageCount();
    const pageSize = this.pageSize();
    const newMode = false === this.option(LEGACY_SCROLLING_MODE4);
    const {
      storeLoadOptions
    } = options2;
    const takeIsDefined = isDefined(storeLoadOptions.take);
    options2.loadPageCount = loadPageCount;
    if (!options2.isCustomLoading && newMode && takeIsDefined && loadPageCount > 1 && pageSize > 0) {
      storeLoadOptions.take = loadPageCount * pageSize;
    }
    super._handleDataLoading.apply(this, arguments);
  }
  _loadPageSize() {
    return super._loadPageSize.apply(this, arguments) * this.loadPageCount();
  }
  beginPageIndex() {
    return proxyDataSourceAdapterMethod(this, "beginPageIndex", [...arguments]);
  }
  endPageIndex() {
    return proxyDataSourceAdapterMethod(this, "endPageIndex", [...arguments]);
  }
  pageIndex(pageIndex) {
    return proxyDataSourceAdapterMethod(this, "pageIndex", [...arguments]);
  }
  virtualItemsCount() {
    return proxyDataSourceAdapterMethod(this, "virtualItemsCount", [...arguments]);
  }
  getContentOffset() {
    return proxyDataSourceAdapterMethod(this, "getContentOffset", [...arguments]);
  }
  getVirtualContentSize() {
    return proxyDataSourceAdapterMethod(this, "getVirtualContentSize", [...arguments]);
  }
  setContentItemSizes() {
    return proxyDataSourceAdapterMethod(this, "setContentItemSizes", [...arguments]);
  }
  setViewportPosition() {
    return proxyDataSourceAdapterMethod(this, "setViewportPosition", [...arguments]);
  }
  getViewportItemIndex() {
    return proxyDataSourceAdapterMethod(this, "getViewportItemIndex", [...arguments]);
  }
  setViewportItemIndex(viewportItemIndex) {
    return proxyDataSourceAdapterMethod(this, "setViewportItemIndex", [...arguments]);
  }
  getItemIndexByPosition() {
    return proxyDataSourceAdapterMethod(this, "getItemIndexByPosition", [...arguments]);
  }
  viewportSize() {
    return proxyDataSourceAdapterMethod(this, "viewportSize", [...arguments]);
  }
  viewportItemSize() {
    return proxyDataSourceAdapterMethod(this, "viewportItemSize", [...arguments]);
  }
  getItemSize() {
    return proxyDataSourceAdapterMethod(this, "getItemSize", [...arguments]);
  }
  getItemSizes() {
    return proxyDataSourceAdapterMethod(this, "getItemSizes", [...arguments]);
  }
  loadIfNeed() {
    return proxyDataSourceAdapterMethod(this, "loadIfNeed", [...arguments]);
  }
};
var data7 = (Base) => class extends Base {
  dispose() {
    const rowsScrollController = this._rowsScrollController;
    rowsScrollController && rowsScrollController.dispose();
    super.dispose.apply(this, arguments);
  }
  _refreshDataSource() {
    const baseResult = super._refreshDataSource.apply(this, arguments) || new Deferred().resolve().promise();
    baseResult.done(this.initVirtualRows.bind(this));
    return baseResult;
  }
  _loadDataSource() {
    if (this._rowsScrollController && isVirtualPaging(this)) {
      var _this$_dataSource;
      const {
        loadPageCount
      } = isDefined(this._loadViewportParams) ? this.getLoadPageParams() : {
        loadPageCount: 0
      };
      loadPageCount >= 1 && (null === (_this$_dataSource = this._dataSource) || void 0 === _this$_dataSource ? void 0 : _this$_dataSource.loadPageCount(loadPageCount));
    }
    return super._loadDataSource.apply(this, arguments);
  }
  getRowPageSize() {
    const rowPageSize = this.option("scrolling.rowPageSize");
    const pageSize = this.pageSize();
    return pageSize && pageSize < rowPageSize ? pageSize : rowPageSize;
  }
  reload() {
    const rowsScrollController = this._rowsScrollController || this._dataSource;
    const itemIndex = null === rowsScrollController || void 0 === rowsScrollController ? void 0 : rowsScrollController.getItemIndexByPosition();
    const result2 = super.reload.apply(this, arguments);
    return null === result2 || void 0 === result2 ? void 0 : result2.done(() => {
      if (isVirtualMode2(this) || m_utils_default.isVirtualRowRendering(this)) {
        const rowIndexOffset = this.getRowIndexOffset();
        const rowIndex = Math.floor(itemIndex) - rowIndexOffset;
        const {
          component
        } = this;
        const scrollable = component.getScrollable && component.getScrollable();
        const isSortingOperation = this.dataSource().operationTypes().sorting;
        if (scrollable && !isSortingOperation && rowIndex >= 0) {
          var _$rowElement$position;
          const rowElement = component.getRowElement(rowIndex);
          const $rowElement = (null === rowElement || void 0 === rowElement ? void 0 : rowElement[0]) && renderer_default(rowElement[0]);
          let top = null === $rowElement || void 0 === $rowElement || null === (_$rowElement$position = $rowElement.position()) || void 0 === _$rowElement$position ? void 0 : _$rowElement$position.top;
          const isChromeLatest = browser_default.chrome && Number(browser_default.version ?? 0) >= 91;
          const allowedTopOffset = browser_default.mozilla || isChromeLatest ? 1 : 0;
          if (top && top > allowedTopOffset) {
            top = Math.round(top + getOuterHeight($rowElement) * (itemIndex % 1));
            scrollable.scrollTo({
              y: top
            });
          }
        }
      }
    });
  }
  initVirtualRows() {
    const virtualRowsRendering = m_utils_default.isVirtualRowRendering(this);
    this._allItems = null;
    this._loadViewportParams = null;
    if ("virtual" !== this.option("scrolling.mode") && !virtualRowsRendering || !virtualRowsRendering || false !== this.option(LEGACY_SCROLLING_MODE4) && !this.option("scrolling.rowPageSize")) {
      this._visibleItems = null;
      this._rowsScrollController = null;
      return;
    }
    const pageIndex = !isVirtualMode2(this) && this.pageIndex() >= this.pageCount() ? this.pageCount() - 1 : this.pageIndex();
    this._rowPageIndex = Math.ceil(pageIndex * this.pageSize() / this.getRowPageSize());
    this._visibleItems = false === this.option(LEGACY_SCROLLING_MODE4) ? null : [];
    this._viewportChanging = false;
    this._needUpdateViewportAfterLoading = false;
    if (!this._rowsScrollController) {
      this._rowsScrollController = new VirtualScrollController(this.component, this._getRowsScrollDataOptions(), true);
      this._rowsScrollController.positionChanged.add(() => {
        var _this$_dataSource2;
        if (false === this.option(LEGACY_SCROLLING_MODE4)) {
          this._viewportChanging = true;
          this.loadViewport();
          this._viewportChanging = false;
          return;
        }
        null === (_this$_dataSource2 = this._dataSource) || void 0 === _this$_dataSource2 || _this$_dataSource2.setViewportItemIndex(this._rowsScrollController.getViewportItemIndex());
      });
    }
    if (false === this.option(LEGACY_SCROLLING_MODE4)) {
      this._updateLoadViewportParams();
    }
    if (this.isLoaded() && false !== this.option(LEGACY_SCROLLING_MODE4)) {
      this._rowsScrollController.load();
    }
  }
  isViewportChanging() {
    return this._viewportChanging;
  }
  _getRowsScrollDataOptions() {
    const that = this;
    const isItemCountable = function(item) {
      return isItemCountableByDataSource(item, that._dataSource);
    };
    return {
      pageSize: () => that.getRowPageSize(),
      loadedOffset() {
        var _that$_dataSource;
        return isVirtualMode2(that) && (null === (_that$_dataSource = that._dataSource) || void 0 === _that$_dataSource ? void 0 : _that$_dataSource.lastLoadOptions().skip) || 0;
      },
      loadedItemCount: () => that._itemCount,
      totalItemsCount() {
        if (isVirtualPaging(that)) {
          return that.totalItemsCount();
        }
        return false === that.option(LEGACY_SCROLLING_MODE4) ? that._itemCount : that._items.filter(isItemCountable).length;
      },
      hasKnownLastPage: () => false === that.option(LEGACY_SCROLLING_MODE4) ? that.hasKnownLastPage() : true,
      pageIndex(index2) {
        if (void 0 !== index2) {
          that._rowPageIndex = index2;
        }
        return that._rowPageIndex;
      },
      isLoading: () => that.isLoading(),
      pageCount() {
        const pageCount = Math.ceil(this.totalItemsCount() / this.pageSize());
        return pageCount || 1;
      },
      load() {
        if (that._rowsScrollController.pageIndex() >= this.pageCount()) {
          that._rowPageIndex = this.pageCount() - 1;
          that._rowsScrollController.pageIndex(that._rowPageIndex);
        }
        if (!this.items().length && this.totalItemsCount()) {
          return;
        }
        that._rowsScrollController.handleDataChanged((change) => {
          change = change || {};
          change.changeType = change.changeType || "refresh";
          change.items = change.items || that._visibleItems;
          that._visibleItems.forEach((item, index2) => {
            item.rowIndex = index2;
          });
          that._fireChanged(change);
        });
      },
      updateLoading() {
      },
      itemsCount() {
        return this.items(true).length;
      },
      correctCount: (items, count, fromEnd) => correctCount(items, count, fromEnd, (item, isNextAfterLast, fromEnd2) => {
        if (item.isNewRow) {
          return isNextAfterLast && !fromEnd2;
        }
        if (isNextAfterLast && fromEnd2) {
          return !item.isNewRow;
        }
        return isItemCountable(item);
      }),
      items(countableOnly) {
        let result2 = that._items;
        if (that.option(LEGACY_SCROLLING_MODE4)) {
          const dataSource = that.dataSource();
          const virtualItemsCount = null === dataSource || void 0 === dataSource ? void 0 : dataSource.virtualItemsCount();
          const begin = virtualItemsCount ? virtualItemsCount.begin : 0;
          const rowPageSize = that.getRowPageSize();
          let skip = that._rowPageIndex * rowPageSize - begin;
          let take = rowPageSize;
          if (skip < 0) {
            return [];
          }
          if (skip) {
            skip = this.correctCount(result2, skip);
            result2 = result2.slice(skip);
          }
          if (take) {
            take = this.correctCount(result2, take);
            result2 = result2.slice(0, take);
          }
        }
        return countableOnly ? result2.filter(isItemCountable) : result2;
      },
      viewportItems(items) {
        if (items && false !== that.option(LEGACY_SCROLLING_MODE4)) {
          that._visibleItems = items;
        }
        return that._visibleItems;
      },
      onChanged() {
      },
      changingDuration() {
        const dataSource = that.dataSource();
        if (null !== dataSource && void 0 !== dataSource && dataSource.isLoading() && false !== that.option(LEGACY_SCROLLING_MODE4)) {
          return 300;
        }
        return (null === dataSource || void 0 === dataSource ? void 0 : dataSource._renderTime) || 0;
      }
    };
  }
  _updateItemsCore(change) {
    const delta = this.getRowIndexDelta();
    super._updateItemsCore.apply(this, arguments);
    if (false === this.option(LEGACY_SCROLLING_MODE4) && m_utils_default.isVirtualRowRendering(this)) {
      if ("update" === change.changeType && 0 === change.rowIndices.length && change.cancelEmptyChanges) {
        change.cancel = true;
      }
      return;
    }
    const rowsScrollController = this._rowsScrollController;
    if (rowsScrollController) {
      const visibleItems = this._visibleItems;
      const isRefresh = "refresh" === change.changeType || change.isLiveUpdate;
      if ("append" === change.changeType && change.items && !change.items.length) {
        return;
      }
      if (isRefresh || "append" === change.changeType || "prepend" === change.changeType) {
        change.cancel = true;
        isRefresh && rowsScrollController.reset(true);
        rowsScrollController.load();
      } else {
        if ("update" === change.changeType) {
          change.rowIndices.forEach((rowIndex, index2) => {
            const changeType = change.changeTypes[index2];
            const newItem = change.items[index2];
            if ("update" === changeType) {
              visibleItems[rowIndex] = newItem;
            } else if ("insert" === changeType) {
              visibleItems.splice(rowIndex, 0, newItem);
            } else if ("remove" === changeType) {
              visibleItems.splice(rowIndex, 1);
            }
          });
        } else {
          visibleItems.forEach((item, index2) => {
            visibleItems[index2] = this._items[index2 + delta] || visibleItems[index2];
          });
          change.items = visibleItems;
        }
        updateItemIndices(visibleItems);
      }
    }
  }
  _updateLoadViewportParams() {
    const viewportParams = this._rowsScrollController.getViewportParams();
    const pageSize = this.pageSize();
    if (viewportParams && !isVirtualPaging(this) && pageSize > 0) {
      const pageOffset = this.pageIndex() * pageSize;
      viewportParams.skip += pageOffset;
    }
    this._loadViewportParams = viewportParams;
  }
  _processItems() {
    const resultItems = super._processItems.apply(this, arguments);
    if (false === this.option(LEGACY_SCROLLING_MODE4)) {
      const dataSource = this._dataSource;
      let currentIndex = (null === dataSource || void 0 === dataSource ? void 0 : dataSource.lastLoadOptions().skip) ?? 0;
      let prevCountable;
      let prevRowType;
      let isPrevRowNew;
      let wasCountableItem = false;
      let newRows = [];
      resultItems.forEach((item) => {
        const {
          rowType
        } = item;
        const itemCountable = isItemCountableByDataSource(item, dataSource);
        const isNextGroupItem = "group" === rowType && (prevCountable || itemCountable || "group" !== prevRowType && currentIndex > 0);
        const isNextDataItem = "data" === rowType && itemCountable && (prevCountable || "group" !== prevRowType);
        if (!item.isNewRow && isDefined(prevCountable)) {
          const isPrevNewRowFirst = isPrevRowNew && !wasCountableItem;
          if ((isNextGroupItem || isNextDataItem) && !isPrevNewRowFirst) {
            currentIndex++;
          }
        }
        if (isNextGroupItem || isNextDataItem) {
          wasCountableItem = true;
        }
        if (item.isNewRow) {
          newRows.push(item);
        } else {
          newRows.forEach((it) => {
            it.loadIndex = currentIndex;
          });
          newRows = [];
        }
        item.loadIndex = currentIndex;
        prevCountable = itemCountable;
        prevRowType = rowType;
        isPrevRowNew = item.isNewRow;
      });
      newRows.forEach((it) => {
        it.loadIndex = currentIndex;
      });
    }
    return resultItems;
  }
  _afterProcessItems(items) {
    this._itemCount = items.filter((item) => isItemCountableByDataSource(item, this._dataSource)).length;
    if (isDefined(this._loadViewportParams)) {
      this._updateLoadViewportParams();
      let result2 = items;
      this._allItems = items;
      if (items.length) {
        const {
          skipForCurrentPage
        } = this.getLoadPageParams(true);
        const skip = items[0].loadIndex + skipForCurrentPage;
        const {
          take
        } = this._loadViewportParams;
        result2 = items.filter((it) => {
          const isNewRowInEmptyData = it.isNewRow && it.loadIndex === skip && 0 === take;
          const isLoadIndexGreaterStart = it.loadIndex >= skip;
          const isLoadIndexLessEnd = it.loadIndex < skip + take || isNewRowInEmptyData;
          return isLoadIndexGreaterStart && isLoadIndexLessEnd;
        });
      }
      return result2;
    }
    return super._afterProcessItems.apply(this, arguments);
  }
  _applyChange(change) {
    const that = this;
    const {
      items
    } = change;
    const {
      changeType
    } = change;
    let {
      removeCount
    } = change;
    if (removeCount) {
      const fromEnd = "prepend" === changeType;
      removeCount = correctCount(that._items, removeCount, fromEnd, (item, isNextAfterLast) => "data" === item.rowType && !item.isNewRow || "group" === item.rowType && (that._dataSource.isGroupItemCountable(item.data) || isNextAfterLast));
      change.removeCount = removeCount;
    }
    switch (changeType) {
      case "prepend":
        that._items.unshift.apply(that._items, items);
        if (removeCount) {
          that._items.splice(-removeCount);
        }
        break;
      case "append":
        that._items.push.apply(that._items, items);
        if (removeCount) {
          that._items.splice(0, removeCount);
        }
        break;
      default:
        super._applyChange(change);
    }
  }
  items(allItems) {
    return allItems ? this._allItems || this._items : this._visibleItems || this._items;
  }
  getRowIndexDelta() {
    let delta = 0;
    if (this.option(LEGACY_SCROLLING_MODE4)) {
      const visibleItems = this._visibleItems;
      if (null !== visibleItems && void 0 !== visibleItems && visibleItems[0]) {
        delta = this._items.indexOf(visibleItems[0]);
      }
    }
    return delta < 0 ? 0 : delta;
  }
  getRowIndexOffset(byLoadedRows, needGroupOffset) {
    let offset2 = 0;
    const dataSource = this.dataSource();
    const rowsScrollController = this._rowsScrollController;
    const newMode = false === this.option(LEGACY_SCROLLING_MODE4);
    const virtualPaging = isVirtualPaging(this);
    if (rowsScrollController && !byLoadedRows) {
      if (newMode && isDefined(this._loadViewportParams)) {
        const {
          skipForCurrentPage,
          pageIndex
        } = this.getLoadPageParams(true);
        const items = this.items(true);
        offset2 = virtualPaging ? pageIndex * this.pageSize() : 0;
        if (items.length) {
          const firstLoadIndex = items[0].loadIndex;
          offset2 += items.filter((item) => item.loadIndex < firstLoadIndex + skipForCurrentPage).length;
        }
      } else {
        offset2 = rowsScrollController.beginPageIndex() * rowsScrollController.pageSize();
      }
    } else if (virtualPaging && newMode && dataSource) {
      var _lastLoadOptions$skip;
      const lastLoadOptions = dataSource.lastLoadOptions();
      if (needGroupOffset && null !== (_lastLoadOptions$skip = lastLoadOptions.skips) && void 0 !== _lastLoadOptions$skip && _lastLoadOptions$skip.length) {
        offset2 = lastLoadOptions.skips.reduce((res, skip) => res + skip, 0);
      } else {
        offset2 = lastLoadOptions.skip ?? 0;
      }
    } else if (isVirtualMode2(this) && dataSource) {
      offset2 = dataSource.beginPageIndex() * dataSource.pageSize();
    }
    return offset2;
  }
  getDataIndex() {
    if (false === this.option(LEGACY_SCROLLING_MODE4)) {
      return this.getRowIndexOffset(true, true);
    }
    return super.getDataIndex.apply(this, arguments);
  }
  viewportSize() {
    const rowsScrollController = this._rowsScrollController;
    const dataSource = this._dataSource;
    const result2 = null === rowsScrollController || void 0 === rowsScrollController ? void 0 : rowsScrollController.viewportSize.apply(rowsScrollController, arguments);
    if (false === this.option(LEGACY_SCROLLING_MODE4)) {
      return result2;
    }
    return null === dataSource || void 0 === dataSource ? void 0 : dataSource.viewportSize.apply(dataSource, arguments);
  }
  viewportHeight(height, scrollTop) {
    var _this$_rowsScrollCont;
    null === (_this$_rowsScrollCont = this._rowsScrollController) || void 0 === _this$_rowsScrollCont || _this$_rowsScrollCont.viewportHeight(height, scrollTop);
  }
  viewportItemSize() {
    const rowsScrollController = this._rowsScrollController;
    const dataSource = this._dataSource;
    const result2 = null === rowsScrollController || void 0 === rowsScrollController ? void 0 : rowsScrollController.viewportItemSize.apply(rowsScrollController, arguments);
    if (false === this.option(LEGACY_SCROLLING_MODE4)) {
      return result2;
    }
    return null === dataSource || void 0 === dataSource ? void 0 : dataSource.viewportItemSize.apply(dataSource, arguments);
  }
  setViewportPosition() {
    const rowsScrollController = this._rowsScrollController;
    const dataSource = this._dataSource;
    this._isPaging = false;
    if (rowsScrollController) {
      rowsScrollController.setViewportPosition.apply(rowsScrollController, arguments);
    } else {
      null === dataSource || void 0 === dataSource || dataSource.setViewportPosition.apply(dataSource, arguments);
    }
  }
  setContentItemSizes(sizes) {
    const rowsScrollController = this._rowsScrollController;
    const dataSource = this._dataSource;
    const result2 = null === rowsScrollController || void 0 === rowsScrollController ? void 0 : rowsScrollController.setContentItemSizes(sizes);
    if (false === this.option(LEGACY_SCROLLING_MODE4)) {
      return result2;
    }
    return null === dataSource || void 0 === dataSource ? void 0 : dataSource.setContentItemSizes(sizes);
  }
  getPreloadedRowCount() {
    const preloadCount = this.option("scrolling.preloadedRowCount");
    const preloadEnabled = this.option("scrolling.preloadEnabled");
    if (isDefined(preloadCount)) {
      return preloadCount;
    }
    const viewportSize = this.viewportSize();
    return preloadEnabled ? 2 * viewportSize : viewportSize;
  }
  getLoadPageParams(byLoadedPage) {
    var _this$_dataSource3, _this$_dataSource4;
    const pageSize = this.pageSize();
    const viewportParams = this._loadViewportParams;
    const lastLoadOptions = null === (_this$_dataSource3 = this._dataSource) || void 0 === _this$_dataSource3 ? void 0 : _this$_dataSource3.lastLoadOptions();
    const loadedPageIndex = (null === lastLoadOptions || void 0 === lastLoadOptions ? void 0 : lastLoadOptions.pageIndex) || 0;
    const loadedTake = (null === lastLoadOptions || void 0 === lastLoadOptions ? void 0 : lastLoadOptions.take) || 0;
    const isScrollingBack = this._rowsScrollController.isScrollingBack();
    const topPreloadCount = isScrollingBack ? this.getPreloadedRowCount() : 0;
    const bottomPreloadCount = isScrollingBack ? 0 : this.getPreloadedRowCount();
    const totalCountCorrection = (null === (_this$_dataSource4 = this._dataSource) || void 0 === _this$_dataSource4 ? void 0 : _this$_dataSource4.totalCountCorrection()) || 0;
    const skipWithPreload = Math.max(0, viewportParams.skip - topPreloadCount);
    const pageIndex = byLoadedPage ? loadedPageIndex : Math.floor(pageSize ? skipWithPreload / pageSize : 0);
    const pageOffset = pageIndex * pageSize;
    const skipForCurrentPage = viewportParams.skip - pageOffset;
    const loadingTake = viewportParams.take + skipForCurrentPage + bottomPreloadCount - totalCountCorrection;
    const take = byLoadedPage ? loadedTake : loadingTake;
    const loadPageCount = Math.ceil(pageSize ? take / pageSize : 0);
    return {
      pageIndex,
      loadPageCount: Math.max(1, loadPageCount),
      skipForCurrentPage: Math.max(0, skipForCurrentPage)
    };
  }
  _updateVisiblePageIndex(currentPageIndex) {
    if (!this._rowsScrollController) {
      return;
    }
    if (isDefined(currentPageIndex)) {
      this._silentOption("paging.pageIndex", currentPageIndex);
      this.pageChanged.fire();
      return;
    }
    const viewPortItemIndex = this._rowsScrollController.getViewportItemIndex();
    const newPageIndex = Math.floor(viewPortItemIndex / this.pageSize());
    if (this.pageIndex() !== newPageIndex) {
      this._silentOption("paging.pageIndex", newPageIndex);
      this.updateItems({
        changeType: "pageIndex"
      });
    }
  }
  _getChangedLoadParams() {
    const loadedPageParams = this.getLoadPageParams(true);
    const {
      pageIndex,
      loadPageCount
    } = this.getLoadPageParams();
    const pageIndexIsValid = this._pageIndexIsValid(pageIndex);
    let result2 = null;
    if (!this._isLoading && pageIndexIsValid && (pageIndex !== loadedPageParams.pageIndex || loadPageCount !== loadedPageParams.loadPageCount)) {
      result2 = {
        pageIndex,
        loadPageCount
      };
    }
    return result2;
  }
  _pageIndexIsValid(pageIndex) {
    let result2 = true;
    if (isAppendMode2(this) && this.hasKnownLastPage() || isVirtualMode2(this)) {
      result2 = pageIndex * this.pageSize() < this.totalItemsCount();
    }
    return result2;
  }
  _loadItems(checkLoading, viewportIsFilled) {
    const virtualPaging = isVirtualPaging(this);
    const dataSourceAdapter = this._dataSource;
    const changedParams = this._getChangedLoadParams();
    const currentLoadPageCount = (null === dataSourceAdapter || void 0 === dataSourceAdapter ? void 0 : dataSourceAdapter.loadPageCount()) ?? 0;
    const lastRequiredItemCount = this.pageSize() * currentLoadPageCount;
    const currentPageIndex = (null === dataSourceAdapter || void 0 === dataSourceAdapter ? void 0 : dataSourceAdapter.pageIndex()) ?? 0;
    const pageIndexNotChanged = (null === changedParams || void 0 === changedParams ? void 0 : changedParams.pageIndex) === currentPageIndex;
    const allLoadedInAppendMode = isAppendMode2(this) && this.totalItemsCount() < lastRequiredItemCount;
    const isRepaintMode = "repaint" === this.option("editing.refreshMode");
    const pageIndexIncreased = (null === changedParams || void 0 === changedParams ? void 0 : changedParams.pageIndex) > currentPageIndex;
    let result2 = false;
    if (!dataSourceAdapter || virtualPaging && checkLoading && (isRepaintMode && viewportIsFilled || pageIndexIncreased || pageIndexNotChanged && allLoadedInAppendMode)) {
      return result2;
    }
    if (virtualPaging && this._isLoading) {
      this._needUpdateViewportAfterLoading = true;
    }
    if (virtualPaging && changedParams) {
      result2 = true;
      dataSourceAdapter.pageIndex(changedParams.pageIndex);
      dataSourceAdapter.loadPageCount(changedParams.loadPageCount);
      this._repaintChangesOnly = true;
      this._needUpdateDimensions = true;
      const viewportChanging = this._viewportChanging;
      this.load().always(() => {
        this._repaintChangesOnly = void 0;
        this._needUpdateDimensions = void 0;
      }).done(() => {
        const isLastPage = this.pageCount() > 0 && this.pageIndex() === this.pageCount() - 1;
        (viewportChanging || isLastPage) && this._updateVisiblePageIndex();
        if (this._needUpdateViewportAfterLoading) {
          this._needUpdateViewportAfterLoading = false;
          this.loadViewport({
            checkLoadedParamsOnly: true
          });
        }
      });
    }
    return result2;
  }
  loadViewport(params) {
    const {
      checkLoadedParamsOnly,
      checkLoading,
      viewportIsNotFilled
    } = params ?? {};
    const virtualPaging = isVirtualPaging(this);
    if (virtualPaging || m_utils_default.isVirtualRowRendering(this)) {
      var _this$_dataSource5;
      this._updateLoadViewportParams();
      const loadingItemsStarted = this._loadItems(checkLoading, !viewportIsNotFilled);
      const isCustomLoading = null === (_this$_dataSource5 = this._dataSource) || void 0 === _this$_dataSource5 ? void 0 : _this$_dataSource5.isCustomLoading();
      const isLoading = checkLoading && !isCustomLoading && this._isLoading;
      const needToUpdateItems = !(loadingItemsStarted || isLoading || checkLoadedParamsOnly);
      if (needToUpdateItems) {
        var _this$_editingControl;
        const noPendingChangesInEditing = !(null !== (_this$_editingControl = this._editingController) && void 0 !== _this$_editingControl && null !== (_this$_editingControl = _this$_editingControl.getChanges()) && void 0 !== _this$_editingControl && _this$_editingControl.length);
        this.updateItems({
          repaintChangesOnly: true,
          needUpdateDimensions: true,
          useProcessedItemsCache: noPendingChangesInEditing,
          cancelEmptyChanges: true
        });
      }
    }
  }
  updateViewport() {
    var _this$_loadViewportPa;
    const viewportSize = this.viewportSize();
    const itemCount = this.items().length;
    const viewportIsNotFilled = viewportSize > itemCount;
    const currentTake = (null === (_this$_loadViewportPa = this._loadViewportParams) || void 0 === _this$_loadViewportPa ? void 0 : _this$_loadViewportPa.take) ?? 0;
    const rowsScrollController = this._rowsScrollController;
    const newTake = null === rowsScrollController || void 0 === rowsScrollController ? void 0 : rowsScrollController.getViewportParams().take;
    (viewportIsNotFilled || currentTake < newTake) && !this._isPaging && itemCount && this.loadViewport({
      checkLoading: true,
      viewportIsNotFilled
    });
  }
  loadIfNeed() {
    if (false === this.option(LEGACY_SCROLLING_MODE4)) {
      return;
    }
    const rowsScrollController = this._rowsScrollController;
    rowsScrollController && rowsScrollController.loadIfNeed();
    const dataSource = this._dataSource;
    return null === dataSource || void 0 === dataSource ? void 0 : dataSource.loadIfNeed();
  }
  getItemSize() {
    const rowsScrollController = this._rowsScrollController;
    if (rowsScrollController) {
      return rowsScrollController.getItemSize.apply(rowsScrollController, arguments);
    }
    const dataSource = this._dataSource;
    return null === dataSource || void 0 === dataSource ? void 0 : dataSource.getItemSize.apply(dataSource, arguments);
  }
  getItemSizes() {
    const rowsScrollController = this._rowsScrollController;
    if (rowsScrollController) {
      return rowsScrollController.getItemSizes.apply(rowsScrollController, arguments);
    }
    const dataSource = this._dataSource;
    return null === dataSource || void 0 === dataSource ? void 0 : dataSource.getItemSizes.apply(dataSource, arguments);
  }
  getContentOffset() {
    const rowsScrollController = this._rowsScrollController;
    if (rowsScrollController) {
      return rowsScrollController.getContentOffset.apply(rowsScrollController, arguments);
    }
    const dataSource = this._dataSource;
    return null === dataSource || void 0 === dataSource ? void 0 : dataSource.getContentOffset.apply(dataSource, arguments);
  }
  refresh(options2) {
    const dataSource = this._dataSource;
    if (dataSource && null !== options2 && void 0 !== options2 && options2.load && isAppendMode2(this)) {
      dataSource.resetCurrentTotalCount();
    }
    return super.refresh.apply(this, arguments);
  }
  topItemIndex() {
    var _this$_loadViewportPa2;
    return null === (_this$_loadViewportPa2 = this._loadViewportParams) || void 0 === _this$_loadViewportPa2 ? void 0 : _this$_loadViewportPa2.skip;
  }
  bottomItemIndex() {
    const viewportParams = this._loadViewportParams;
    return viewportParams && viewportParams.skip + viewportParams.take;
  }
  virtualItemsCount() {
    const rowsScrollController = this._rowsScrollController;
    if (rowsScrollController) {
      return rowsScrollController.virtualItemsCount.apply(rowsScrollController, arguments);
    }
    const dataSource = this._dataSource;
    return null === dataSource || void 0 === dataSource ? void 0 : dataSource.virtualItemsCount.apply(dataSource, arguments);
  }
  pageIndex(pageIndex) {
    const virtualPaging = isVirtualPaging(this);
    const rowsScrollController = this._rowsScrollController;
    if (false === this.option(LEGACY_SCROLLING_MODE4) && virtualPaging && rowsScrollController) {
      if (void 0 === pageIndex) {
        return this.option("paging.pageIndex") ?? 0;
      }
    }
    return super.pageIndex.apply(this, arguments);
  }
  _fireChanged(e) {
    super._fireChanged.apply(this, arguments);
    const {
      operationTypes
    } = e;
    if (false === this.option(LEGACY_SCROLLING_MODE4) && isVirtualPaging(this) && operationTypes) {
      const {
        fullReload,
        pageIndex
      } = operationTypes;
      if (e.isDataChanged && !fullReload && pageIndex) {
        this._updateVisiblePageIndex(this._dataSource.pageIndex());
      }
    }
  }
  _getPagingOptionValue(optionName) {
    let result2 = super._getPagingOptionValue.apply(this, arguments);
    if (false === this.option(LEGACY_SCROLLING_MODE4) && isVirtualPaging(this)) {
      result2 = this[optionName]();
    }
    return result2;
  }
  isEmpty() {
    return false === this.option(LEGACY_SCROLLING_MODE4) ? !this.items(true).length : super.isEmpty.apply(this, arguments);
  }
  isLastPageLoaded() {
    let result2 = false;
    if (false === this.option(LEGACY_SCROLLING_MODE4) && isVirtualPaging(this)) {
      const {
        pageIndex,
        loadPageCount
      } = this.getLoadPageParams(true);
      const pageCount = this.pageCount();
      result2 = pageIndex + loadPageCount >= pageCount;
    } else {
      result2 = super.isLastPageLoaded.apply(this, arguments);
    }
    return result2;
  }
  reset() {
    this._itemCount = 0;
    this._allItems = null;
    super.reset.apply(this, arguments);
  }
  _applyFilter() {
    var _this$_dataSource6;
    null === (_this$_dataSource6 = this._dataSource) || void 0 === _this$_dataSource6 || _this$_dataSource6.loadPageCount(1);
    return super._applyFilter.apply(this, arguments);
  }
  getVirtualContentSize() {
    var _this$_dataSource7;
    return null === (_this$_dataSource7 = this._dataSource) || void 0 === _this$_dataSource7 ? void 0 : _this$_dataSource7.getVirtualContentSize.apply(this._dataSource, arguments);
  }
  setViewportItemIndex() {
    var _this$_dataSource8;
    return null === (_this$_dataSource8 = this._dataSource) || void 0 === _this$_dataSource8 ? void 0 : _this$_dataSource8.setViewportItemIndex.apply(this._dataSource, arguments);
  }
};
var resizing3 = (Base) => class extends Base {
  dispose() {
    super.dispose.apply(this, arguments);
    clearTimeout(this._resizeTimeout);
  }
  _updateMasterDataGridCore(masterDataGrid) {
    return when(super._updateMasterDataGridCore.apply(this, arguments)).done((masterDataGridUpdated) => {
      const isNewVirtualMode = isVirtualMode2(masterDataGrid) && false === masterDataGrid.option(LEGACY_SCROLLING_MODE4);
      if (!masterDataGridUpdated && isNewVirtualMode) {
        const scrollable = masterDataGrid.getScrollable();
        if (scrollable) {
          masterDataGrid.updateDimensions();
        }
      }
    });
  }
  hasResizeTimeout() {
    return isDefined(this._resizeTimeout);
  }
  resetLastResizeTime() {
    this._lastTime = void 0;
  }
  resize() {
    let result2;
    if (isVirtualMode2(this) || m_utils_default.isVirtualRowRendering(this)) {
      clearTimeout(this._resizeTimeout);
      this._resizeTimeout = null;
      const diff = /* @__PURE__ */ new Date() - this._lastTime;
      const updateTimeout = this.option("scrolling.updateTimeout");
      if (this._lastTime && diff < updateTimeout) {
        result2 = new Deferred();
        this._resizeTimeout = setTimeout(() => {
          this._resizeTimeout = null;
          super.resize.apply(this).done(result2.resolve).fail(result2.reject);
          this._lastTime = /* @__PURE__ */ new Date();
        }, updateTimeout);
        this._lastTime = /* @__PURE__ */ new Date();
      } else {
        result2 = super.resize.apply(this);
        if (this._dataController.isLoaded()) {
          this._lastTime = /* @__PURE__ */ new Date();
        }
      }
    } else {
      result2 = super.resize.apply(this);
    }
    return result2;
  }
};
var rowsView7 = (Base) => class extends Base {
  init() {
    var _this$_dataController;
    super.init();
    this._dataController.pageChanged.add((pageIndex) => {
      const scrollTop = this._scrollTop;
      this.scrollToPage(pageIndex ?? this._dataController.pageIndex());
      if (false === this.option(LEGACY_SCROLLING_MODE4) && this._scrollTop === scrollTop) {
        this._dataController.updateViewport();
      }
    });
    this._dataController.dataSourceChanged.add(() => {
      !this._scrollTop && this._scrollToCurrentPageOnResize();
    });
    null === (_this$_dataController = this._dataController.stateLoaded) || void 0 === _this$_dataController || _this$_dataController.add(() => {
      this._scrollToCurrentPageOnResize();
    });
    this._scrollToCurrentPageOnResize();
  }
  dispose() {
    clearTimeout(this._scrollTimeoutID);
    super.dispose();
  }
  _scrollToCurrentPageOnResize() {
    if (this._dataController.pageIndex() > 0) {
      const resizeHandler = () => {
        this.resizeCompleted.remove(resizeHandler);
        this.scrollToPage(this._dataController.pageIndex());
      };
      this.resizeCompleted.add(resizeHandler);
    }
  }
  scrollToPage(pageIndex) {
    const pageSize = this._dataController ? this._dataController.pageSize() : 0;
    let scrollPosition;
    if (isVirtualMode2(this) || isAppendMode2(this)) {
      const itemSize = this._dataController.getItemSize();
      const itemSizes = this._dataController.getItemSizes();
      const itemIndex = pageIndex * pageSize;
      scrollPosition = itemIndex * itemSize;
      for (const index2 in itemSizes) {
        if (parseInt(index2) < itemIndex) {
          scrollPosition += itemSizes[index2] - itemSize;
        }
      }
    } else {
      scrollPosition = 0;
    }
    this.scrollTo({
      y: scrollPosition,
      x: this._scrollLeft
    });
  }
  renderDelayedTemplates() {
    this.waitAsyncTemplates().done(() => {
      this._updateContentPosition(true);
    });
    super.renderDelayedTemplates.apply(this, arguments);
  }
  _renderCore(e) {
    const startRenderTime = /* @__PURE__ */ new Date();
    const deferred = super._renderCore.apply(this, arguments);
    const dataSource = this._dataController._dataSource;
    if (dataSource && e) {
      const itemCount = e.items ? e.items.length : 20;
      const viewportSize = this._dataController.viewportSize() || 20;
      if (m_utils_default.isVirtualRowRendering(this) && itemCount > 0 && false !== this.option(LEGACY_SCROLLING_MODE4)) {
        dataSource._renderTime = (/* @__PURE__ */ new Date() - startRenderTime) * viewportSize / itemCount;
      } else {
        dataSource._renderTime = /* @__PURE__ */ new Date() - startRenderTime;
      }
    }
    return deferred;
  }
  _getRowElements(tableElement) {
    const $rows = super._getRowElements(tableElement);
    return null === $rows || void 0 === $rows ? void 0 : $rows.not(".dx-virtual-row");
  }
  _removeRowsElements(contentTable, removeCount, changeType) {
    let rowElements = this._getRowElements(contentTable).toArray();
    if ("append" === changeType) {
      rowElements = rowElements.slice(0, removeCount);
    } else {
      rowElements = rowElements.slice(-removeCount);
    }
    rowElements.map((rowElement) => {
      const $rowElement = renderer_default(rowElement);
      this._errorHandlingController && this._errorHandlingController.removeErrorRow($rowElement.next());
      $rowElement.remove();
    });
  }
  _updateContent(tableElement, change) {
    let $freeSpaceRowElements;
    const contentElement = this._findContentElement();
    const changeType = null === change || void 0 === change ? void 0 : change.changeType;
    const d = Deferred();
    const contentTable = contentElement.children().first();
    if ("append" === changeType || "prepend" === changeType) {
      this.waitAsyncTemplates().done(() => {
        const $tBodies = this._getBodies(tableElement);
        if (1 === $tBodies.length) {
          this._getBodies(contentTable)["append" === changeType ? "append" : "prepend"]($tBodies.children());
        } else {
          $tBodies["append" === changeType ? "appendTo" : "prependTo"](contentTable);
        }
        tableElement.remove();
        $freeSpaceRowElements = this._getFreeSpaceRowElements(contentTable);
        removeEmptyRows($freeSpaceRowElements, FREESPACE_CLASS);
        if (change.removeCount) {
          this._removeRowsElements(contentTable, change.removeCount, changeType);
        }
        this._restoreErrorRow(contentTable);
        d.resolve();
      }).fail(d.reject);
    } else {
      super._updateContent.apply(this, arguments).done(() => {
        if ("update" === changeType) {
          this._restoreErrorRow(contentTable);
        }
        d.resolve();
      }).fail(d.reject);
    }
    return d.promise().done(() => {
      this._updateBottomLoading();
    });
  }
  _addVirtualRow($table, isFixed, location, position3) {
    if (!position3) {
      return;
    }
    let $virtualRow = this._createEmptyRow("dx-virtual-row", isFixed, position3);
    $virtualRow = this._wrapRowIfNeed($table, $virtualRow);
    this._appendEmptyRow($table, $virtualRow, location);
  }
  _updateContentItemSizes() {
    const rowHeights = this._getRowHeights();
    const correctedRowHeights = this._correctRowHeights(rowHeights);
    this._dataController.setContentItemSizes(correctedRowHeights);
  }
  _updateViewportSize(viewportHeight, scrollTop) {
    if (!isDefined(viewportHeight)) {
      viewportHeight = this._hasHeight ? getOuterHeight(this.element()) : getOuterHeight(getWindow());
    }
    this._dataController.viewportHeight(viewportHeight, scrollTop);
  }
  _getRowHeights() {
    var _this$_editingControl2, _this$_editingControl3;
    const isPopupEditMode = null === (_this$_editingControl2 = this._editingController) || void 0 === _this$_editingControl2 || null === (_this$_editingControl3 = _this$_editingControl2.isPopupEditMode) || void 0 === _this$_editingControl3 ? void 0 : _this$_editingControl3.call(_this$_editingControl2);
    let rowElements = this._getRowElements(this._tableElement).toArray();
    if (isPopupEditMode) {
      rowElements = rowElements.filter((row) => !renderer_default(row).hasClass(ROW_INSERTED2));
    }
    return rowElements.map((row) => getBoundingRect(row).height);
  }
  _correctRowHeights(rowHeights) {
    const dataController2 = this._dataController;
    const dataSource = dataController2._dataSource;
    const correctedRowHeights = [];
    const visibleRows = dataController2.getVisibleRows();
    let itemSize = 0;
    let firstCountableItem = true;
    let lastLoadIndex = -1;
    for (let i = 0; i < rowHeights.length; i++) {
      const currentItem = visibleRows[i];
      if (!isDefined(currentItem)) {
        continue;
      }
      if (false === this.option(LEGACY_SCROLLING_MODE4)) {
        if (lastLoadIndex >= 0 && lastLoadIndex !== currentItem.loadIndex) {
          correctedRowHeights.push(itemSize);
          itemSize = 0;
        }
        lastLoadIndex = currentItem.loadIndex;
      } else if (isItemCountableByDataSource(currentItem, dataSource)) {
        if (firstCountableItem) {
          firstCountableItem = false;
        } else {
          correctedRowHeights.push(itemSize);
          itemSize = 0;
        }
      }
      itemSize += rowHeights[i];
    }
    itemSize > 0 && correctedRowHeights.push(itemSize);
    return correctedRowHeights;
  }
  _updateContentPosition(isRender) {
    const rowHeight = this._rowHeight || 20;
    this._dataController.viewportItemSize(rowHeight);
    if (isVirtualMode2(this) || m_utils_default.isVirtualRowRendering(this)) {
      const isEmptyRows = this._dataController.isEmpty();
      if (isEmptyRows) {
        return;
      }
      if (!isRender) {
        this._updateContentItemSizes();
      }
      const top = this._dataController.getContentOffset("begin");
      const bottom = this._dataController.getContentOffset("end");
      const $tables = this.getTableElements();
      const $virtualRows = $tables.children("tbody").children(".dx-virtual-row");
      removeEmptyRows($virtualRows, "dx-virtual-row");
      $tables.each((index2, element) => {
        const isFixed = index2 > 0;
        const prevFixed = this._isFixedTableRendering;
        this._isFixedTableRendering = isFixed;
        this._addVirtualRow(renderer_default(element), isFixed, "top", top);
        this._addVirtualRow(renderer_default(element), isFixed, "bottom", bottom);
        this._isFixedTableRendering = prevFixed;
      });
    }
  }
  _isTableLinesDisplaysCorrect(table) {
    const hasColumnLines = table.find(".dx-column-lines").length > 0;
    return hasColumnLines === this.option("showColumnLines");
  }
  _isColumnElementsEqual($columns, $virtualColumns) {
    let result2 = $columns.length === $virtualColumns.length;
    if (result2) {
      each($columns, (index2, element) => {
        if (element.style.width !== $virtualColumns[index2].style.width) {
          result2 = false;
          return result2;
        }
        return;
      });
    }
    return result2;
  }
  _getCellClasses(column) {
    const classes = [];
    const {
      cssClass
    } = column;
    const isExpandColumn = "expand" === column.command;
    cssClass && classes.push(cssClass);
    isExpandColumn && classes.push(this.addWidgetPrefix("group-space"));
    return classes;
  }
  _findBottomLoadPanel($contentElement) {
    const $element = $contentElement || this.element();
    const $bottomLoadPanel = null === $element || void 0 === $element ? void 0 : $element.find(`.${this.addWidgetPrefix("bottom-load-panel")}`);
    if (null !== $bottomLoadPanel && void 0 !== $bottomLoadPanel && $bottomLoadPanel.length) {
      return $bottomLoadPanel;
    }
  }
  _updateBottomLoading() {
    const that = this;
    const virtualMode = isVirtualMode2(this);
    const appendMode = isAppendMode2(this);
    const showBottomLoading = !that._dataController.hasKnownLastPage() && that._dataController.isLoaded() && (virtualMode || appendMode);
    const $contentElement = that._findContentElement();
    const bottomLoadPanelElement = that._findBottomLoadPanel($contentElement);
    if (showBottomLoading) {
      if (!bottomLoadPanelElement) {
        renderer_default("<div>").addClass(that.addWidgetPrefix("bottom-load-panel")).append(that._createComponent(renderer_default("<div>"), load_indicator_default, {
          elementAttr: {
            role: null,
            "aria-label": null
          }
        }).$element()).appendTo($contentElement);
      }
    } else if (bottomLoadPanelElement) {
      bottomLoadPanelElement.remove();
    }
  }
  _handleScroll(e) {
    const legacyScrollingMode = true === this.option(LEGACY_SCROLLING_MODE4);
    const zeroTopPosition = 0 === e.scrollOffset.top;
    const isScrollTopChanged = this._scrollTop !== e.scrollOffset.top;
    const hasScrolled = isScrollTopChanged || e.forceUpdateScrollPosition;
    const isValidScrollTarget = this._hasHeight || !legacyScrollingMode && zeroTopPosition;
    if (hasScrolled && isValidScrollTarget && this._rowHeight) {
      this._scrollTop = e.scrollOffset.top;
      const isVirtualRowRendering = isVirtualMode2(this) || "standard" !== this.option("scrolling.rowRenderingMode");
      if (isVirtualRowRendering && false === this.option(LEGACY_SCROLLING_MODE4)) {
        this._updateContentItemSizes();
        this._updateViewportSize(null, this._scrollTop);
      }
      this._dataController.setViewportPosition(e.scrollOffset.top);
    }
    super._handleScroll.apply(this, arguments);
  }
  _needUpdateRowHeight(itemsCount) {
    return super._needUpdateRowHeight.apply(this, arguments) || itemsCount > 0 && isAppendMode2(this) && !m_utils_default.isVirtualRowRendering(this);
  }
  _updateRowHeight() {
    super._updateRowHeight.apply(this, arguments);
    if (this._rowHeight) {
      this._updateContentPosition();
      const viewportHeight = this._hasHeight ? getOuterHeight(this.element()) : getOuterHeight(getWindow());
      if (false === this.option(LEGACY_SCROLLING_MODE4)) {
        this._updateViewportSize(viewportHeight);
        this._dataController.updateViewport();
      } else {
        this._dataController.viewportSize(Math.ceil(viewportHeight / this._rowHeight));
      }
    }
  }
  updateFreeSpaceRowHeight() {
    const result2 = super.updateFreeSpaceRowHeight.apply(this, arguments);
    if (result2) {
      this._updateContentPosition();
    }
    return result2;
  }
  setLoading(isLoading, messageText) {
    const dataController2 = this._dataController;
    const hasBottomLoadPanel = dataController2.pageIndex() > 0 && dataController2.isLoaded() && !!this._findBottomLoadPanel();
    if (false === this.option(LEGACY_SCROLLING_MODE4) && isLoading && dataController2.isViewportChanging()) {
      return;
    }
    if (hasBottomLoadPanel) {
      isLoading = false;
    }
    super.setLoading.call(this, isLoading, messageText);
  }
  isGridDragging() {
    return this.component.option("isDragging");
  }
  throwHeightWarningIfNeed() {
    const isGridDragging = this.isGridDragging();
    if (void 0 === this._hasHeight || isGridDragging) {
      return;
    }
    const needToThrow = !this._hasHeight && isVirtualPaging(this);
    if (needToThrow && !this._heightWarningIsThrown) {
      this._heightWarningIsThrown = true;
      ui_errors_default.log("W1025");
    }
  }
  _resizeCore() {
    const that = this;
    const $element = that.element();
    super._resizeCore();
    this.throwHeightWarningIfNeed();
    if (that.component.$element() && !that._windowScroll && isElementInDom($element)) {
      that._windowScroll = subscribeToExternalScrollers($element, (scrollPos) => {
        if (!that._hasHeight && that._rowHeight) {
          that._dataController.setViewportPosition(scrollPos);
        }
      }, that.component.$element());
      that.on("disposing", () => {
        that._windowScroll.dispose();
      });
    }
    if (false !== this.option(LEGACY_SCROLLING_MODE4)) {
      that.loadIfNeed();
    }
  }
  loadIfNeed() {
    var _this$_dataController2, _this$_dataController3;
    null === (_this$_dataController2 = this._dataController) || void 0 === _this$_dataController2 || null === (_this$_dataController3 = _this$_dataController2.loadIfNeed) || void 0 === _this$_dataController3 || _this$_dataController3.call(_this$_dataController2);
  }
  _restoreErrorRow(contentTable) {
    if (false === this.option(LEGACY_SCROLLING_MODE4)) {
      var _this$_errorHandlingC;
      null === (_this$_errorHandlingC = this._errorHandlingController) || void 0 === _this$_errorHandlingC || _this$_errorHandlingC.removeErrorRow();
    }
    super._restoreErrorRow.apply(this, arguments);
  }
};
var virtualScrollingModule = {
  defaultOptions: () => ({
    scrolling: {
      timeout: 300,
      updateTimeout: 300,
      minTimeout: 0,
      renderingThreshold: 100,
      removeInvisiblePages: true,
      rowPageSize: 5,
      prerenderedRowChunkSize: 1,
      mode: "standard",
      preloadEnabled: false,
      rowRenderingMode: "standard",
      loadTwoPagesOnStart: false,
      legacyMode: false,
      prerenderedRowCount: 1
    }
  }),
  extenders: {
    controllers: {
      data: data7,
      resizing: resizing3
    },
    views: {
      rowsView: rowsView7
    }
  }
};

// node_modules/devextreme/esm/__internal/grids/data_grid/module_not_extended/virtual_scrolling.js
m_core_default.registerModule("virtualScrolling", virtualScrollingModule);
m_data_source_adapter_default.extend(dataSourceAdapterExtender2);

// node_modules/devextreme/esm/__internal/ui/overlay/m_utils.js
var getElementMaxHeightByWindow = ($element, startLocation) => {
  const $window = renderer_default(m_window_default.getWindow());
  const {
    top: elementOffset
  } = $element.offset();
  let actualOffset;
  if (isNumeric(startLocation)) {
    if (startLocation < elementOffset) {
      return elementOffset - startLocation;
    }
    actualOffset = getInnerHeight($window) - startLocation + $window.scrollTop();
  } else {
    const offsetTop = elementOffset - $window.scrollTop();
    const offsetBottom = getInnerHeight($window) - offsetTop - getOuterHeight($element);
    actualOffset = Math.max(offsetTop, offsetBottom);
  }
  return 0.9 * actualOffset;
};

// node_modules/devextreme/esm/__internal/ui/menu/m_submenu.js
var Submenu = class extends m_context_menu_default {
  _getDefaultOptions() {
    return extend(super._getDefaultOptions(), {
      orientation: "horizontal",
      tabIndex: null,
      onHoverStart: noop2
    });
  }
  _initDataAdapter() {
    this._dataAdapter = this.option("_dataAdapter");
    if (!this._dataAdapter) {
      super._initDataAdapter();
    }
  }
  _renderContentImpl() {
    this._renderContextMenuOverlay();
    super._renderContentImpl();
    const node = this._dataAdapter.getNodeByKey(this.option("_parentKey"));
    node && this._renderItems(this._getChildNodes(node));
    this._renderDelimiter();
  }
  _renderDelimiter() {
    this.$contentDelimiter = renderer_default("<div>").appendTo(this._itemContainer()).addClass("dx-context-menu-content-delimiter");
  }
  _getOverlayOptions() {
    return extend(true, super._getOverlayOptions(), {
      onPositioned: this._overlayPositionedActionHandler.bind(this),
      position: {
        precise: true
      }
    });
  }
  _overlayPositionedActionHandler(arg) {
    this._showDelimiter(arg);
  }
  _hoverEndHandler(e) {
    super._hoverEndHandler(e);
    this._toggleFocusClass(false, e.currentTarget);
  }
  _isMenuHorizontal() {
    return "horizontal" === this.option("orientation");
  }
  _hoverStartHandler(e) {
    const hoverStartAction = this.option("onHoverStart");
    hoverStartAction(e);
    super._hoverStartHandler(e);
    this._toggleFocusClass(true, e.currentTarget);
  }
  _drawSubmenu($rootItem) {
    this._actions.onShowing({
      rootItem: getPublicElement($rootItem),
      submenu: this
    });
    super._drawSubmenu($rootItem);
    this._actions.onShown({
      rootItem: getPublicElement($rootItem),
      submenu: this
    });
  }
  _hideSubmenu($rootItem) {
    this._actions.onHiding({
      cancel: true,
      rootItem: getPublicElement($rootItem),
      submenu: this
    });
    super._hideSubmenu($rootItem);
    this._actions.onHidden({
      rootItem: getPublicElement($rootItem),
      submenu: this
    });
  }
  _showDelimiter(arg) {
    if (!this.$contentDelimiter) {
      return;
    }
    const $submenu = this._itemContainer().children(".dx-submenu").eq(0);
    const $rootItem = this.option("position").of.find(".dx-context-menu-container-border");
    const position3 = {
      of: $submenu,
      precise: true
    };
    const containerOffset = arg.position;
    const vLocation = containerOffset.v.location;
    const hLocation = containerOffset.h.location;
    const rootOffset = $rootItem.offset();
    const offsetLeft = Math.round(rootOffset.left);
    const offsetTop = Math.round(rootOffset.top);
    const rootWidth = getWidth($rootItem);
    const rootHeight = getHeight($rootItem);
    const submenuWidth = getWidth($submenu);
    const submenuHeight = getHeight($submenu);
    this.$contentDelimiter.css("display", "block");
    setWidth(this.$contentDelimiter, this._isMenuHorizontal() ? rootWidth < submenuWidth ? rootWidth : submenuWidth : 3);
    setHeight(this.$contentDelimiter, this._isMenuHorizontal() ? 3 : rootHeight < submenuHeight ? rootHeight : submenuHeight);
    if (this._isMenuHorizontal()) {
      if (vLocation > offsetTop) {
        if (Math.round(hLocation) === offsetLeft) {
          position3.offset = "0 -2.5";
          position3.at = position3.my = "left top";
        } else {
          position3.offset = "0 -2.5";
          position3.at = position3.my = "right top";
        }
      } else {
        setHeight(this.$contentDelimiter, 5);
        if (Math.round(hLocation) === offsetLeft) {
          position3.offset = "0 5";
          position3.at = position3.my = "left bottom";
        } else {
          position3.offset = "0 5";
          position3.at = position3.my = "right bottom";
        }
      }
    } else if (hLocation > offsetLeft) {
      if (Math.round(vLocation) === offsetTop) {
        position3.offset = "-2.5 0";
        position3.at = position3.my = "left top";
      } else {
        position3.offset = "-2.5 0";
        position3.at = position3.my = "left bottom";
      }
    } else if (Math.round(vLocation) === offsetTop) {
      position3.offset = "2.5 0";
      position3.at = position3.my = "right top";
    } else {
      position3.offset = "2.5 0";
      position3.at = position3.my = "right bottom";
    }
    position_default.setup(this.$contentDelimiter, position3);
  }
  _getContextMenuPosition() {
    return this.option("position");
  }
  isOverlayVisible() {
    return this._overlay.option("visible");
  }
  getOverlayContent() {
    return this._overlay.$content();
  }
};
var m_submenu_default = Submenu;

// node_modules/devextreme/esm/__internal/ui/menu/m_menu.js
var DX_ADAPTIVE_MODE_CLASS = "dx-menu-adaptive-mode";
var DX_ADAPTIVE_MODE_OVERLAY_WRAPPER_CLASS = `${DX_ADAPTIVE_MODE_CLASS}-overlay-wrapper`;
var DEFAULT_DELAY2 = {
  show: 50,
  hide: 300
};
var ACTIONS2 = ["onSubmenuShowing", "onSubmenuShown", "onSubmenuHiding", "onSubmenuHidden", "onItemContextMenu", "onItemClick", "onSelectionChanged", "onItemRendered"];
var Menu = class extends m_menu_base_default {
  _getDefaultOptions() {
    return extend(super._getDefaultOptions(), {
      orientation: "horizontal",
      submenuDirection: "auto",
      showFirstSubmenuMode: {
        name: "onClick",
        delay: {
          show: 50,
          hide: 300
        }
      },
      hideSubmenuOnMouseLeave: false,
      onSubmenuShowing: null,
      onSubmenuShown: null,
      onSubmenuHiding: null,
      onSubmenuHidden: null,
      adaptivityEnabled: false
    });
  }
  _setOptionsByReference() {
    super._setOptionsByReference();
    extend(this._optionsByReference, {
      animation: true,
      selectedItem: true
    });
  }
  _itemElements() {
    const rootMenuElements = super._itemElements();
    const submenuElements = this._submenuItemElements();
    return rootMenuElements.add(submenuElements);
  }
  _submenuItemElements() {
    let elements = [];
    const currentSubmenu = this._submenus.length && this._submenus[0];
    if (currentSubmenu && currentSubmenu.itemsContainer()) {
      elements = currentSubmenu.itemsContainer().find(".dx-menu-item");
    }
    return elements;
  }
  _focusTarget() {
    return this.$element();
  }
  _isMenuHorizontal() {
    return "horizontal" === this.option("orientation");
  }
  _moveFocus(location) {
    const $items = this._getAvailableItems();
    const isMenuHorizontal = this._isMenuHorizontal();
    const $activeItem = this._getActiveItem(true);
    let argument;
    let operation;
    let navigationAction;
    let $newTarget;
    switch (location) {
      case "up":
        operation = isMenuHorizontal ? "showSubmenu" : this._getItemsNavigationOperation("prevItem");
        argument = isMenuHorizontal ? $activeItem : $items;
        navigationAction = this._getKeyboardNavigationAction(operation, argument);
        $newTarget = navigationAction();
        break;
      case "down":
        operation = isMenuHorizontal ? "showSubmenu" : this._getItemsNavigationOperation("nextItem");
        argument = isMenuHorizontal ? $activeItem : $items;
        navigationAction = this._getKeyboardNavigationAction(operation, argument);
        $newTarget = navigationAction();
        break;
      case "right":
        operation = isMenuHorizontal ? this._getItemsNavigationOperation("nextItem") : "showSubmenu";
        argument = isMenuHorizontal ? $items : $activeItem;
        navigationAction = this._getKeyboardNavigationAction(operation, argument);
        $newTarget = navigationAction();
        break;
      case "left":
        operation = isMenuHorizontal ? this._getItemsNavigationOperation("prevItem") : "showSubmenu";
        argument = isMenuHorizontal ? $items : $activeItem;
        navigationAction = this._getKeyboardNavigationAction(operation, argument);
        $newTarget = navigationAction();
        break;
      default:
        return super._moveFocus(location);
    }
    if ($newTarget && 0 !== $newTarget.length) {
      this.option("focusedElement", getPublicElement($newTarget));
    }
  }
  _getItemsNavigationOperation(operation) {
    let navOperation = operation;
    if (this.option("rtlEnabled")) {
      navOperation = "prevItem" === operation ? "nextItem" : "prevItem";
    }
    return navOperation;
  }
  _getKeyboardNavigationAction(operation, argument) {
    let action = noop2;
    switch (operation) {
      case "showSubmenu":
        if (!argument.hasClass("dx-state-disabled")) {
          action = this._showSubmenu.bind(this, argument);
        }
        break;
      case "nextItem":
        action = this._nextItem.bind(this, argument);
        break;
      case "prevItem":
        action = this._prevItem.bind(this, argument);
    }
    return action;
  }
  _clean() {
    super._clean();
    this.option("templatesRenderAsynchronously") && clearTimeout(this._resizeEventTimer);
  }
  _visibilityChanged(visible2) {
    if (visible2) {
      if (!this._menuItemsWidth) {
        this._updateItemsWidthCache();
      }
      this._dimensionChanged();
    }
  }
  _isAdaptivityEnabled() {
    return this.option("adaptivityEnabled") && "horizontal" === this.option("orientation");
  }
  _updateItemsWidthCache() {
    const $menuItems = this.$element().find("ul").first().children("li").children(".dx-menu-item");
    this._menuItemsWidth = this._getSummaryItemsSize("width", $menuItems, true);
  }
  _dimensionChanged() {
    if (!this._isAdaptivityEnabled()) {
      return;
    }
    const containerWidth = getOuterWidth(this.$element());
    this._toggleAdaptiveMode(this._menuItemsWidth > containerWidth);
  }
  _init() {
    super._init();
    this._submenus = [];
  }
  _initActions() {
    this._actions = {};
    each(ACTIONS2, (index2, action) => {
      this._actions[action] = this._createActionByOption(action);
    });
  }
  _initMarkup() {
    this._visibleSubmenu = null;
    this.$element().addClass("dx-menu");
    super._initMarkup();
    this._addCustomCssClass(this.$element());
    this.setAria("role", "menubar");
  }
  _setAriaRole(state) {
    const role = this._isAdaptivityEnabled() && state ? void 0 : "menubar";
    this.setAria({
      role
    });
  }
  _render() {
    super._render();
    this._initAdaptivity();
  }
  _isTargetOutOfComponent(relatedTarget) {
    const isInsideRootMenu = 0 !== renderer_default(relatedTarget).closest(".dx-menu").length;
    const isInsideContextMenu = 0 !== renderer_default(relatedTarget).closest(".dx-context-menu").length;
    const isTargetOutOfComponent = !(isInsideRootMenu || isInsideContextMenu);
    return isTargetOutOfComponent;
  }
  _focusOutHandler(e) {
    const {
      relatedTarget
    } = e;
    if (relatedTarget) {
      const isTargetOutside = this._isTargetOutOfComponent(relatedTarget);
      if (isTargetOutside) {
        this._hideVisibleSubmenu();
      }
    }
    super._focusOutHandler(e);
  }
  _renderHamburgerButton() {
    this._hamburger = new button_default2(renderer_default("<div>").addClass("dx-menu-hamburger-button"), {
      icon: "menu",
      activeStateEnabled: false,
      onClick: this._toggleTreeView.bind(this)
    });
    return this._hamburger.$element();
  }
  _toggleTreeView(state) {
    if (isPlainObject(state)) {
      state = !this._overlay.option("visible");
    }
    this._overlay.option("visible", state);
    if (state) {
      this._treeView.focus();
    }
    this._toggleHamburgerActiveState(state);
  }
  _toggleHamburgerActiveState(state) {
    var _this$_hamburger;
    null === (_this$_hamburger = this._hamburger) || void 0 === _this$_hamburger || _this$_hamburger.$element().toggleClass("dx-state-active", state);
  }
  _toggleAdaptiveMode(state) {
    const $menuItemsContainer = this.$element().find(".dx-menu-horizontal");
    const $adaptiveElements = this.$element().find(`.${DX_ADAPTIVE_MODE_CLASS}`);
    if (state) {
      this._hideVisibleSubmenu();
    } else {
      this._treeView && this._treeView.collapseAll();
      this._overlay && this._toggleTreeView(state);
    }
    this._setAriaRole(state);
    $menuItemsContainer.toggle(!state);
    $adaptiveElements.toggle(state);
  }
  _removeAdaptivity() {
    if (!this._$adaptiveContainer) {
      return;
    }
    this._toggleAdaptiveMode(false);
    this._$adaptiveContainer.remove();
    this._$adaptiveContainer = null;
    this._treeView = null;
    this._hamburger = null;
    this._overlay = null;
  }
  _treeviewItemClickHandler(e) {
    this._actions.onItemClick(e);
    if (!e.node.children.length) {
      this._toggleTreeView(false);
    }
  }
  _getAdaptiveOverlayOptions() {
    const rtl = this.option("rtlEnabled");
    const position3 = rtl ? "right" : "left";
    return {
      _ignoreFunctionValueDeprecation: true,
      maxHeight: () => getElementMaxHeightByWindow(this.$element()),
      deferRendering: false,
      shading: false,
      animation: false,
      hideOnParentScroll: true,
      onHidden: () => {
        this._toggleHamburgerActiveState(false);
      },
      height: "auto",
      hideOnOutsideClick: (e) => !renderer_default(e.target).closest(".dx-menu-hamburger-button").length,
      position: {
        collision: "flipfit",
        at: `bottom ${position3}`,
        my: `top ${position3}`,
        of: this._hamburger.$element()
      }
    };
  }
  _getTreeViewOptions() {
    const menuOptions = {};
    each(["rtlEnabled", "width", "accessKey", "activeStateEnabled", "animation", "dataSource", "disabled", "displayExpr", "displayExpr", "focusStateEnabled", "hint", "hoverStateEnabled", "itemsExpr", "items", "itemTemplate", "selectedExpr", "selectionMode", "tabIndex", "visible"], (_, option) => {
      menuOptions[option] = this.option(option);
    });
    each(["onItemContextMenu", "onSelectionChanged", "onItemRendered"], (_, actionName) => {
      menuOptions[actionName] = (e) => {
        this._actions[actionName](e);
      };
    });
    return extend(menuOptions, {
      dataSource: this.getDataSource(),
      animationEnabled: !!this.option("animation"),
      onItemClick: this._treeviewItemClickHandler.bind(this),
      onItemExpanded: (e) => {
        this._overlay.repaint();
        this._actions.onSubmenuShown(e);
      },
      onItemCollapsed: (e) => {
        this._overlay.repaint();
        this._actions.onSubmenuHidden(e);
      },
      selectNodesRecursive: false,
      selectByClick: this.option("selectByClick"),
      expandEvent: "click",
      _supportItemUrl: true
    });
  }
  _initAdaptivity() {
    if (!this._isAdaptivityEnabled()) {
      return;
    }
    this._$adaptiveContainer = renderer_default("<div>").addClass(DX_ADAPTIVE_MODE_CLASS);
    const $hamburger = this._renderHamburgerButton();
    this._treeView = this._createComponent(renderer_default("<div>"), tree_view_default, this._getTreeViewOptions());
    this._overlay = this._createComponent(renderer_default("<div>"), ui_overlay_default, this._getAdaptiveOverlayOptions());
    this._overlay.$content().append(this._treeView.$element()).addClass(DX_ADAPTIVE_MODE_CLASS).addClass(this.option("cssClass"));
    this._overlay.$wrapper().addClass(DX_ADAPTIVE_MODE_OVERLAY_WRAPPER_CLASS);
    this._$adaptiveContainer.append($hamburger);
    this._$adaptiveContainer.append(this._overlay.$element());
    this.$element().append(this._$adaptiveContainer);
    this._updateItemsWidthCache();
    this._dimensionChanged();
  }
  _getDelay(delayType) {
    const {
      delay
    } = this.option("showFirstSubmenuMode");
    if (!isDefined(delay)) {
      return DEFAULT_DELAY2[delayType];
    }
    return isObject(delay) ? delay[delayType] : delay;
  }
  _keyboardHandler(e) {
    return super._keyboardHandler(e, !!this._visibleSubmenu);
  }
  _renderContainer() {
    const $wrapper = renderer_default("<div>");
    $wrapper.appendTo(this.$element()).addClass(this._isMenuHorizontal() ? "dx-menu-horizontal" : "dx-menu-vertical");
    return super._renderContainer($wrapper);
  }
  _renderSubmenuItems(node, $itemFrame) {
    const submenu = this._createSubmenu(node, $itemFrame);
    this._submenus.push(submenu);
    this._renderBorderElement($itemFrame);
    return submenu;
  }
  _getKeyboardListeners() {
    return super._getKeyboardListeners().concat(this._visibleSubmenu);
  }
  _createSubmenu(node, $rootItem) {
    const $submenuContainer = renderer_default("<div>").addClass("dx-context-menu").appendTo($rootItem);
    const items = this._getChildNodes(node);
    const subMenu = this._createComponent($submenuContainer, m_submenu_default, extend(this._getSubmenuOptions(), {
      _dataAdapter: this._dataAdapter,
      _parentKey: node.internalFields.key,
      items,
      onHoverStart: this._clearTimeouts.bind(this),
      position: this.getSubmenuPosition($rootItem)
    }));
    this._attachSubmenuHandlers($rootItem, subMenu);
    return subMenu;
  }
  _getSubmenuOptions() {
    const $submenuTarget = renderer_default("<div>");
    const isMenuHorizontal = this._isMenuHorizontal();
    return {
      itemTemplate: this.option("itemTemplate"),
      target: $submenuTarget,
      orientation: this.option("orientation"),
      selectionMode: this.option("selectionMode"),
      cssClass: this.option("cssClass"),
      selectByClick: this.option("selectByClick"),
      hoverStateEnabled: this.option("hoverStateEnabled"),
      activeStateEnabled: this.option("activeStateEnabled"),
      focusStateEnabled: this.option("focusStateEnabled"),
      animation: this.option("animation"),
      showSubmenuMode: this.option("showSubmenuMode"),
      displayExpr: this.option("displayExpr"),
      disabledExpr: this.option("disabledExpr"),
      selectedExpr: this.option("selectedExpr"),
      itemsExpr: this.option("itemsExpr"),
      onFocusedItemChanged: (e) => {
        if (!e.component.option("visible")) {
          return;
        }
        this.option("focusedElement", e.component.option("focusedElement"));
      },
      onSelectionChanged: this._nestedItemOnSelectionChangedHandler.bind(this),
      onItemClick: this._nestedItemOnItemClickHandler.bind(this),
      onItemRendered: this._nestedItemOnItemRenderedHandler.bind(this),
      onLeftFirstItem: isMenuHorizontal ? null : this._moveMainMenuFocus.bind(this, "prevItem"),
      onLeftLastItem: isMenuHorizontal ? null : this._moveMainMenuFocus.bind(this, "nextItem"),
      onCloseRootSubmenu: this._moveMainMenuFocus.bind(this, isMenuHorizontal ? "prevItem" : null),
      onExpandLastSubmenu: isMenuHorizontal ? this._moveMainMenuFocus.bind(this, "nextItem") : null
    };
  }
  _getShowFirstSubmenuMode() {
    if (!this._isDesktopDevice()) {
      return "onClick";
    }
    const optionValue = this.option("showFirstSubmenuMode");
    return isObject(optionValue) ? optionValue.name : optionValue;
  }
  _moveMainMenuFocus(direction) {
    const $items = this._getAvailableItems();
    const itemCount = $items.length;
    const $currentItem = $items.filter(".dx-menu-item-expanded").eq(0);
    let itemIndex = $items.index($currentItem);
    this._hideSubmenu(this._visibleSubmenu);
    itemIndex += "prevItem" === direction ? -1 : 1;
    if (itemIndex >= itemCount) {
      itemIndex = 0;
    } else if (itemIndex < 0) {
      itemIndex = itemCount - 1;
    }
    const $newItem = $items.eq(itemIndex);
    this.option("focusedElement", getPublicElement($newItem));
  }
  _nestedItemOnSelectionChangedHandler(args) {
    const selectedItem = args.addedItems.length && args.addedItems[0];
    const submenu = m_submenu_default.getInstance(args.element);
    const {
      onSelectionChanged
    } = this._actions;
    onSelectionChanged(args);
    selectedItem && this._clearSelectionInSubmenus(selectedItem[0], submenu);
    this._clearRootSelection();
    this._setOptionWithoutOptionChange("selectedItem", selectedItem);
  }
  _clearSelectionInSubmenus(item, targetSubmenu) {
    const cleanAllSubmenus = !arguments.length;
    each(this._submenus, (index2, submenu) => {
      const $submenu = submenu._itemContainer();
      const isOtherItem = !$submenu.is(null === targetSubmenu || void 0 === targetSubmenu ? void 0 : targetSubmenu._itemContainer());
      const $selectedItem = $submenu.find(`.${this._selectedItemClass()}`);
      if (isOtherItem && $selectedItem.length || cleanAllSubmenus) {
        $selectedItem.removeClass(this._selectedItemClass());
        const selectedItemData = this._getItemData($selectedItem);
        if (selectedItemData) {
          selectedItemData.selected = false;
        }
        submenu._clearSelectedItems();
      }
    });
  }
  _clearRootSelection() {
    const $prevSelectedItem = this.$element().find(".dx-menu-items-container").first().children().children().filter(`.${this._selectedItemClass()}`);
    if ($prevSelectedItem.length) {
      const prevSelectedItemData = this._getItemData($prevSelectedItem);
      prevSelectedItemData.selected = false;
      $prevSelectedItem.removeClass(this._selectedItemClass());
    }
  }
  _nestedItemOnItemClickHandler(e) {
    this._actions.onItemClick(e);
  }
  _nestedItemOnItemRenderedHandler(e) {
    this._actions.onItemRendered(e);
  }
  _attachSubmenuHandlers($menuAnchorItem, submenu) {
    const $submenuOverlayContent = submenu.getOverlayContent();
    const submenus = $submenuOverlayContent.find(".dx-submenu");
    const submenuMouseLeaveName = addNamespace2(HOVEREND, `${this.NAME}_submenu`);
    submenu.option({
      onShowing: this._submenuOnShowingHandler.bind(this, $menuAnchorItem, submenu),
      onShown: this._submenuOnShownHandler.bind(this, $menuAnchorItem, submenu),
      onHiding: this._submenuOnHidingHandler.bind(this, $menuAnchorItem, submenu),
      onHidden: this._submenuOnHiddenHandler.bind(this, $menuAnchorItem, submenu)
    });
    each(submenus, (index2, submenu2) => {
      m_events_engine_default.off(submenu2, submenuMouseLeaveName);
      m_events_engine_default.on(submenu2, submenuMouseLeaveName, null, this._submenuMouseLeaveHandler.bind(this, $menuAnchorItem));
    });
  }
  _submenuOnShowingHandler($menuAnchorItem, submenu, _ref) {
    let {
      rootItem
    } = _ref;
    const $border = $menuAnchorItem.children(".dx-context-menu-container-border");
    const params = this._getVisibilityChangeEventParams(rootItem, submenu, $menuAnchorItem);
    this._actions.onSubmenuShowing(params);
    $border.show();
    $menuAnchorItem.addClass("dx-menu-item-expanded");
  }
  _submenuOnShownHandler($menuAnchorItem, submenu, _ref2) {
    let {
      rootItem
    } = _ref2;
    const params = this._getVisibilityChangeEventParams(rootItem, submenu, $menuAnchorItem);
    this._actions.onSubmenuShown(params);
  }
  _submenuOnHidingHandler($menuAnchorItem, submenu, eventArgs) {
    const $border = $menuAnchorItem.children(".dx-context-menu-container-border");
    const params = this._getVisibilityChangeEventParams(eventArgs.rootItem, submenu, $menuAnchorItem, true);
    eventArgs.itemData = params.itemData;
    eventArgs.rootItem = params.rootItem;
    eventArgs.submenuContainer = params.submenuContainer;
    eventArgs.submenu = params.submenu;
    this._actions.onSubmenuHiding(eventArgs);
    const {
      focusedElement
    } = this.option();
    const {
      focusedElement: submenuFocusedElement
    } = submenu.option();
    const isVisibleSubmenuHiding = this._visibleSubmenu === submenu;
    const isFocusedElementHiding = focusedElement === submenuFocusedElement;
    if (isVisibleSubmenuHiding && isFocusedElementHiding) {
      this.option("focusedElement", $menuAnchorItem);
    }
    if (!eventArgs.cancel) {
      if (isVisibleSubmenuHiding) {
        this._visibleSubmenu = null;
      }
      $border.hide();
      $menuAnchorItem.removeClass("dx-menu-item-expanded");
    }
  }
  _submenuOnHiddenHandler($menuAnchorItem, submenu, _ref3) {
    let {
      rootItem
    } = _ref3;
    const params = this._getVisibilityChangeEventParams(rootItem, submenu, $menuAnchorItem, true);
    this._actions.onSubmenuHidden(params);
  }
  _getVisibilityChangeEventParams(submenuItem, submenu, $menuAnchorItem, isHide) {
    let itemData;
    let $submenuContainer;
    if (submenuItem) {
      const anchor = isHide ? renderer_default(submenuItem).closest(".dx-menu-item")[0] : submenuItem;
      itemData = this._getItemData(anchor);
      $submenuContainer = renderer_default(anchor).find(".dx-submenu").first();
    } else {
      const $overlayContent = renderer_default(submenu._overlay.content());
      itemData = this._getItemData($menuAnchorItem);
      $submenuContainer = $overlayContent.find(".dx-submenu").first();
    }
    return {
      itemData,
      rootItem: getPublicElement($menuAnchorItem),
      submenuContainer: getPublicElement($submenuContainer),
      submenu
    };
  }
  _submenuMouseLeaveHandler($rootItem, eventArgs) {
    const target = renderer_default(eventArgs.relatedTarget).parents(".dx-context-menu")[0];
    const contextMenu2 = this._getSubmenuByRootElement($rootItem).getOverlayContent()[0];
    if (this.option("hideSubmenuOnMouseLeave") && target !== contextMenu2) {
      this._clearTimeouts();
      setTimeout(this._hideSubmenuAfterTimeout.bind(this), this._getDelay("hide"));
    }
  }
  _hideSubmenuAfterTimeout() {
    if (!this._visibleSubmenu) {
      return;
    }
    const isRootItemHovered = renderer_default(this._visibleSubmenu.$element().context).hasClass("dx-state-hover");
    const isSubmenuItemHovered = this._visibleSubmenu.getOverlayContent().find(".dx-state-hover").length;
    const hoveredElementFromSubMenu = this._visibleSubmenu.getOverlayContent().get(0).querySelector(":hover");
    if (!hoveredElementFromSubMenu && !isSubmenuItemHovered && !isRootItemHovered) {
      this._visibleSubmenu.hide();
    }
  }
  _getSubmenuByRootElement($rootItem) {
    if (!$rootItem) {
      return false;
    }
    const $submenu = $rootItem.children(".dx-context-menu");
    return $submenu.length && m_submenu_default.getInstance($submenu);
  }
  getSubmenuPosition($rootItem) {
    const isHorizontalMenu = this._isMenuHorizontal();
    const submenuDirection = this.option("submenuDirection").toLowerCase();
    const rtlEnabled = this.option("rtlEnabled");
    const submenuPosition = {
      collision: "flip",
      of: $rootItem,
      precise: true
    };
    switch (submenuDirection) {
      case "leftortop":
        submenuPosition.at = "left top";
        submenuPosition.my = isHorizontalMenu ? "left bottom" : "right top";
        break;
      case "rightorbottom":
        submenuPosition.at = isHorizontalMenu ? "left bottom" : "right top";
        submenuPosition.my = "left top";
        break;
      default:
        if (isHorizontalMenu) {
          submenuPosition.at = rtlEnabled ? "right bottom" : "left bottom";
          submenuPosition.my = rtlEnabled ? "right top" : "left top";
        } else {
          submenuPosition.at = rtlEnabled ? "left top" : "right top";
          submenuPosition.my = rtlEnabled ? "right top" : "left top";
        }
    }
    return submenuPosition;
  }
  _renderBorderElement($item) {
    renderer_default("<div>").appendTo($item).addClass("dx-context-menu-container-border").hide();
  }
  _itemPointerDownHandler(e) {
    const $target = renderer_default(e.target);
    const $closestItem = $target.closest(this._itemElements());
    if ($closestItem.hasClass("dx-menu-item-has-submenu")) {
      this.option("focusedElement", null);
      return;
    }
    super._itemPointerDownHandler(e);
  }
  _hoverStartHandler(e) {
    const mouseMoveEventName = addNamespace2(m_pointer_default.move, this.NAME);
    const $item = this._getItemElementByEventArgs(e);
    const node = this._dataAdapter.getNodeByItem(this._getItemData($item));
    const isSelectionActive = isDefined(e.buttons) && 1 === e.buttons || !isDefined(e.buttons) && 1 === e.which;
    if (this._isItemDisabled($item)) {
      return;
    }
    m_events_engine_default.off($item, mouseMoveEventName);
    if (!this._hasChildren(node)) {
      this._showSubmenuTimer = setTimeout(this._hideSubmenuAfterTimeout.bind(this), this._getDelay("hide"));
      return;
    }
    if ("onHover" === this._getShowFirstSubmenuMode() && !isSelectionActive) {
      const submenu = this._getSubmenuByElement($item);
      this._clearTimeouts();
      if (!submenu.isOverlayVisible()) {
        m_events_engine_default.on($item, mouseMoveEventName, this._itemMouseMoveHandler.bind(this));
        this._showSubmenuTimer = this._getDelay("hide");
      }
    }
  }
  _hoverEndHandler(eventArg) {
    const $item = this._getItemElementByEventArgs(eventArg);
    const relatedTarget = renderer_default(eventArg.relatedTarget);
    super._hoverEndHandler(eventArg);
    this._clearTimeouts();
    if (this._isItemDisabled($item)) {
      return;
    }
    if (relatedTarget.hasClass("dx-context-menu-content-delimiter")) {
      return;
    }
    if (this.option("hideSubmenuOnMouseLeave") && !relatedTarget.hasClass("dx-menu-items-container")) {
      this._hideSubmenuTimer = setTimeout(() => {
        this._hideSubmenuAfterTimeout();
      }, this._getDelay("hide"));
    }
  }
  _hideVisibleSubmenu() {
    if (!this._visibleSubmenu) {
      return false;
    }
    this._hideSubmenu(this._visibleSubmenu);
    return true;
  }
  _showSubmenu($itemElement) {
    const submenu = this._getSubmenuByElement($itemElement);
    if (this._visibleSubmenu !== submenu) {
      this._hideVisibleSubmenu();
    }
    if (submenu) {
      this._clearTimeouts();
      this.focus();
      submenu.show();
      this.option("focusedElement", submenu.option("focusedElement"));
    }
    this._visibleSubmenu = submenu;
    this._hoveredRootItem = $itemElement;
  }
  _hideSubmenu(submenu) {
    if (submenu) {
      submenu.hide();
    }
    if (this._visibleSubmenu === submenu) {
      this._visibleSubmenu = null;
    }
    this._hoveredRootItem = null;
  }
  _itemMouseMoveHandler(e) {
    var _e$pointers;
    if (null !== (_e$pointers = e.pointers) && void 0 !== _e$pointers && _e$pointers.length) {
      return;
    }
    const $item = renderer_default(e.currentTarget);
    if (!isDefined(this._showSubmenuTimer)) {
      return;
    }
    this._clearTimeouts();
    this._showSubmenuTimer = setTimeout(() => {
      const submenu = this._getSubmenuByElement($item);
      if (submenu && !submenu.isOverlayVisible()) {
        this._showSubmenu($item);
      }
    }, this._getDelay("show"));
  }
  _clearTimeouts() {
    clearTimeout(this._hideSubmenuTimer);
    clearTimeout(this._showSubmenuTimer);
  }
  _getSubmenuByElement($itemElement, itemData) {
    const submenu = this._getSubmenuByRootElement($itemElement);
    if (submenu) {
      return submenu;
    }
    itemData = itemData ?? this._getItemData($itemElement);
    const node = this._dataAdapter.getNodeByItem(itemData);
    return this._hasChildren(node) && this._renderSubmenuItems(node, $itemElement);
  }
  _updateSubmenuVisibilityOnClick(actionArgs) {
    const args = actionArgs.args.length && actionArgs.args[0];
    if (!args || this._disabledGetter(args.itemData)) {
      return;
    }
    const $itemElement = renderer_default(args.itemElement);
    const currentSubmenu = this._getSubmenuByElement($itemElement, args.itemData);
    this._updateSelectedItemOnClick(actionArgs);
    if (this._visibleSubmenu) {
      if (this._visibleSubmenu === currentSubmenu) {
        if ("onClick" === this.option("showFirstSubmenuMode")) {
          this._hideSubmenu(this._visibleSubmenu);
        }
        return;
      }
      this._hideSubmenu(this._visibleSubmenu);
    }
    if (!currentSubmenu) {
      return;
    }
    if (!currentSubmenu.isOverlayVisible()) {
      this._showSubmenu($itemElement);
    }
  }
  _optionChanged(args) {
    if (ACTIONS2.includes(args.name)) {
      this._initActions();
      return;
    }
    switch (args.name) {
      case "orientation":
      case "submenuDirection":
        this._invalidate();
        break;
      case "showFirstSubmenuMode":
      case "hideSubmenuOnMouseLeave":
        break;
      case "showSubmenuMode":
        this._changeSubmenusOption(args.name, args.value);
        break;
      case "adaptivityEnabled":
        args.value ? this._initAdaptivity() : this._removeAdaptivity();
        break;
      case "width":
        if (this._isAdaptivityEnabled()) {
          this._treeView.option(args.name, args.value);
          this._overlay.option(args.name, args.value);
        }
        super._optionChanged(args);
        this._dimensionChanged();
        break;
      case "animation":
        if (this._isAdaptivityEnabled()) {
          this._treeView.option("animationEnabled", !!args.value);
        }
        super._optionChanged(args);
        break;
      default:
        if (this._isAdaptivityEnabled() && (args.name === args.fullName || "items" === args.name)) {
          this._treeView.option(args.fullName, args.value);
        }
        super._optionChanged(args);
    }
  }
  _changeSubmenusOption(name2, value2) {
    each(this._submenus, (index2, submenu) => {
      submenu.option(name2, value2);
    });
  }
  selectItem(itemElement) {
    this._hideSubmenu(this._visibleSubmenu);
    super.selectItem(itemElement);
  }
  unselectItem(itemElement) {
    this._hideSubmenu(this._visibleSubmenu);
    super.unselectItem(itemElement);
  }
};
component_registrator_default("dxMenu", Menu);
var m_menu_default = Menu;

// node_modules/devextreme/esm/ui/menu.js
var menu_default = m_menu_default;

// node_modules/devextreme/esm/__internal/grids/grid_core/filter/m_filter_row.js
var OPERATION_ICONS = {
  "=": "filter-operation-equals",
  "<>": "filter-operation-not-equals",
  "<": "filter-operation-less",
  "<=": "filter-operation-less-equal",
  ">": "filter-operation-greater",
  ">=": "filter-operation-greater-equal",
  default: "filter-operation-default",
  notcontains: "filter-operation-not-contains",
  contains: "filter-operation-contains",
  startswith: "filter-operation-starts-with",
  endswith: "filter-operation-ends-with",
  between: "filter-operation-between"
};
var OPERATION_DESCRIPTORS = {
  "=": "equal",
  "<>": "notEqual",
  "<": "lessThan",
  "<=": "lessThanOrEqual",
  ">": "greaterThan",
  ">=": "greaterThanOrEqual",
  startswith: "startsWith",
  contains: "contains",
  notcontains: "notContains",
  endswith: "endsWith",
  between: "between"
};
var FILTER_MENU = "dx-filter-menu";
var EDITORS_INPUT_SELECTOR2 = "input:not([type='hidden'])";
var BETWEEN_OPERATION_DATA_TYPES = ["date", "datetime", "number"];
var ARIA_SEARCH_BOX = message_default.format("dxDataGrid-ariaSearchBox");
function isOnClickApplyFilterMode(that) {
  return "onClick" === that.option("filterRow.applyFilter");
}
var getEditorInstance = function($editorContainer) {
  const $editor = null === $editorContainer || void 0 === $editorContainer ? void 0 : $editorContainer.children();
  const componentNames3 = null === $editor || void 0 === $editor ? void 0 : $editor.data("dxComponents");
  const editor = (null === componentNames3 || void 0 === componentNames3 ? void 0 : componentNames3.length) && $editor.data(componentNames3[0]);
  if (editor instanceof editor_default2) {
    return editor;
  }
  return null;
};
var getRangeTextByFilterValue = function(that, column) {
  let result2 = "";
  let rangeEnd = "";
  const filterValue = getColumnFilterValue(that, column);
  const formatOptions = m_utils_default.getFormatOptionsByColumn(column, "filterRow");
  if (Array.isArray(filterValue)) {
    result2 = m_utils_default.formatValue(filterValue[0], formatOptions);
    rangeEnd = m_utils_default.formatValue(filterValue[1], formatOptions);
    if ("" !== rangeEnd) {
      result2 += ` - ${rangeEnd}`;
    }
  } else if (isDefined(filterValue)) {
    result2 = m_utils_default.formatValue(filterValue, formatOptions);
  }
  return result2;
};
function getColumnFilterValue(that, column) {
  if (column) {
    return isOnClickApplyFilterMode(that) && void 0 !== column.bufferedFilterValue ? column.bufferedFilterValue : column.filterValue;
  }
}
var getColumnSelectedFilterOperation = function(that, column) {
  if (column) {
    return isOnClickApplyFilterMode(that) && void 0 !== column.bufferedSelectedFilterOperation ? column.bufferedSelectedFilterOperation : column.selectedFilterOperation;
  }
};
var isValidFilterValue = function(filterValue, column) {
  if (column && BETWEEN_OPERATION_DATA_TYPES.includes(column.dataType) && Array.isArray(filterValue)) {
    return false;
  }
  return void 0 !== filterValue;
};
var getFilterValue2 = function(that, columnIndex, $editorContainer) {
  const column = that._columnsController.columnOption(columnIndex);
  const filterValue = getColumnFilterValue(that, column);
  const isFilterRange = $editorContainer.closest(`.${that.addWidgetPrefix("filter-range-overlay")}`).length;
  const isRangeStart = $editorContainer.hasClass(that.addWidgetPrefix("filter-range-start"));
  if (filterValue && Array.isArray(filterValue) && "between" === getColumnSelectedFilterOperation(that, column)) {
    if (isRangeStart) {
      return filterValue[0];
    }
    return filterValue[1];
  }
  return !isFilterRange && isValidFilterValue(filterValue, column) ? filterValue : null;
};
var normalizeFilterValue = function(that, filterValue, column, $editorContainer) {
  if ("between" === getColumnSelectedFilterOperation(that, column)) {
    const columnFilterValue = getColumnFilterValue(that, column);
    if ($editorContainer.hasClass(that.addWidgetPrefix("filter-range-start"))) {
      return [filterValue, Array.isArray(columnFilterValue) ? columnFilterValue[1] : void 0];
    }
    return [Array.isArray(columnFilterValue) ? columnFilterValue[0] : columnFilterValue, filterValue];
  }
  return filterValue;
};
var updateFilterValue = function(that, options2) {
  const value2 = "" === options2.value ? null : options2.value;
  const $editorContainer = options2.container;
  const column = that._columnsController.columnOption(options2.column.index);
  const filterValue = getFilterValue2(that, column.index, $editorContainer);
  if (!isDefined(filterValue) && !isDefined(value2)) {
    return;
  }
  that._applyFilterViewController.setHighLight($editorContainer, filterValue !== value2);
  const columnOptionName = isOnClickApplyFilterMode(that) ? "bufferedFilterValue" : "filterValue";
  const normalizedValue = normalizeFilterValue(that, value2, column, $editorContainer);
  const isBetween = "between" === getColumnSelectedFilterOperation(that, column);
  const notFireEvent = options2.notFireEvent || isBetween && Array.isArray(normalizedValue) && normalizedValue.includes(void 0);
  that._columnsController.columnOption(column.index, columnOptionName, normalizedValue, notFireEvent);
};
var columnHeadersView3 = (Base) => class extends Base {
  init() {
    super.init();
    this._applyFilterViewController = this.getController("applyFilter");
  }
  optionChanged(args) {
    switch (args.name) {
      case "filterRow":
      case "showColumnLines":
        this._invalidate(true, true);
        args.handled = true;
        break;
      case "syncLookupFilterValues":
        if (args.value) {
          this.updateLookupDataSource();
        } else {
          this.render();
        }
        args.handled = true;
        break;
      default:
        super.optionChanged(args);
    }
  }
  _updateEditorValue(column, $editorContainer) {
    const editor = getEditorInstance($editorContainer);
    editor && editor.option("value", getFilterValue2(this, column.index, $editorContainer));
  }
  _columnOptionChanged(e) {
    const that = this;
    const {
      optionNames
    } = e;
    let $cell;
    let $editorContainer;
    let $editorRangeElements;
    let $menu;
    if (m_utils_default.checkChanges(optionNames, ["filterValue", "bufferedFilterValue", "selectedFilterOperation", "bufferedSelectedFilterOperation", "filterValues", "filterType"]) && void 0 !== e.columnIndex) {
      const visibleIndex = that._columnsController.getVisibleIndex(e.columnIndex);
      const column = that._columnsController.columnOption(e.columnIndex);
      $cell = that._getCellElement(that.element().find(`.${that.addWidgetPrefix("filter-row")}`).index(), visibleIndex) ?? renderer_default();
      $editorContainer = $cell.find(".dx-editor-container").first();
      if (optionNames.filterValue || optionNames.bufferedFilterValue) {
        that._updateEditorValue(column, $editorContainer);
        const overlayInstance = $cell.find(`.${that.addWidgetPrefix("filter-range-overlay")}`).data("dxOverlay");
        if (overlayInstance) {
          $editorRangeElements = overlayInstance.$content().find(".dx-editor-container");
          that._updateEditorValue(column, $editorRangeElements.first());
          that._updateEditorValue(column, $editorRangeElements.last());
        }
        if (!(null !== overlayInstance && void 0 !== overlayInstance && overlayInstance.option("visible"))) {
          that._updateFilterRangeContent($cell, getRangeTextByFilterValue(that, column));
        }
      }
      if (optionNames.selectedFilterOperation || optionNames.bufferedSelectedFilterOperation) {
        if (visibleIndex >= 0 && column) {
          $menu = $cell.find(".dx-menu");
          if ($menu.length) {
            that._updateFilterOperationChooser($menu, column, $editorContainer);
            if ("between" === getColumnSelectedFilterOperation(that, column)) {
              that._renderFilterRangeContent($cell, column);
            } else if ($editorContainer.find(".dx-filter-range-content").length) {
              that._renderEditor($editorContainer, that._getEditorOptions($editorContainer, column));
              that._hideFilterRange();
            }
          }
        }
      }
      return;
    }
    super._columnOptionChanged(e);
  }
  _renderCore() {
    this._filterRangeOverlayInstance = null;
    return super._renderCore.apply(this, arguments);
  }
  _resizeCore() {
    var _this$_filterRangeOve;
    super._resizeCore.apply(this, arguments);
    null === (_this$_filterRangeOve = this._filterRangeOverlayInstance) || void 0 === _this$_filterRangeOve || _this$_filterRangeOve.repaint();
  }
  isFilterRowVisible() {
    return this._isElementVisible(this.option("filterRow"));
  }
  isVisible() {
    return super.isVisible() || this.isFilterRowVisible();
  }
  _initFilterRangeOverlay($cell, column) {
    const that = this;
    const sharedData = {};
    const $editorContainer = $cell.find(".dx-editor-container");
    const filterRangeOverlayClass = that.addWidgetPrefix("filter-range-overlay");
    const $overlay = renderer_default("<div>").addClass(filterRangeOverlayClass).appendTo($cell);
    return that._createComponent($overlay, ui_overlay_default, {
      height: "auto",
      shading: false,
      showTitle: false,
      focusStateEnabled: false,
      hideOnOutsideClick: true,
      hideOnParentScroll: true,
      _hideOnParentScrollTarget: $overlay,
      wrapperAttr: {
        class: filterRangeOverlayClass
      },
      animation: false,
      position: {
        my: "top",
        at: "top",
        of: $editorContainer.length && $editorContainer || $cell,
        offset: "0 -1"
      },
      contentTemplate(contentElement) {
        let editorOptions;
        let $editor = renderer_default("<div>").addClass(`dx-editor-container ${that.addWidgetPrefix("filter-range-start")}`).appendTo(contentElement);
        column = that._columnsController.columnOption(column.index);
        editorOptions = that._getEditorOptions($editor, column);
        editorOptions.sharedData = sharedData;
        that._renderEditor($editor, editorOptions);
        m_events_engine_default.on($editor.find(EDITORS_INPUT_SELECTOR2), "keydown", (e) => {
          let $prevElement = $cell.find("[tabindex]").not(e.target).first();
          if ("tab" === normalizeKeyName(e) && e.shiftKey) {
            e.preventDefault();
            that._hideFilterRange();
            if (!$prevElement.length) {
              $prevElement = $cell.prev().find("[tabindex]").last();
            }
            m_events_engine_default.trigger($prevElement, "focus");
          }
        });
        $editor = renderer_default("<div>").addClass(`dx-editor-container ${that.addWidgetPrefix("filter-range-end")}`).appendTo(contentElement);
        editorOptions = that._getEditorOptions($editor, column);
        editorOptions.sharedData = sharedData;
        that._renderEditor($editor, editorOptions);
        m_events_engine_default.on($editor.find(EDITORS_INPUT_SELECTOR2), "keydown", (e) => {
          if ("tab" === normalizeKeyName(e) && !e.shiftKey) {
            e.preventDefault();
            that._hideFilterRange();
            m_events_engine_default.trigger($cell.next().find("[tabindex]").first(), "focus");
          }
        });
        return renderer_default(contentElement).addClass(that.getWidgetContainerClass());
      },
      onShown(e) {
        const $editor = e.component.$content().find(".dx-editor-container").first();
        m_events_engine_default.trigger($editor.find(EDITORS_INPUT_SELECTOR2), "focus");
      },
      onHidden() {
        column = that._columnsController.columnOption(column.index);
        $cell.find(".dx-menu").parent().addClass("dx-editor-with-menu");
        if ("between" === getColumnSelectedFilterOperation(that, column)) {
          that._updateFilterRangeContent($cell, getRangeTextByFilterValue(that, column));
          that.component.updateDimensions();
        }
      }
    });
  }
  _updateFilterRangeOverlay(options2) {
    const overlayInstance = this._filterRangeOverlayInstance;
    null === overlayInstance || void 0 === overlayInstance || overlayInstance.option(options2);
  }
  _showFilterRange($cell, column) {
    const that = this;
    const $overlay = $cell.children(`.${that.addWidgetPrefix("filter-range-overlay")}`);
    let overlayInstance = $overlay.length && $overlay.data("dxOverlay");
    if (!overlayInstance && column) {
      overlayInstance = that._initFilterRangeOverlay($cell, column);
    }
    if (!overlayInstance.option("visible")) {
      var _that$_filterRangeOve, _that$_filterRangeOve2;
      null === (_that$_filterRangeOve = that._filterRangeOverlayInstance) || void 0 === _that$_filterRangeOve || _that$_filterRangeOve.hide();
      that._filterRangeOverlayInstance = overlayInstance;
      that._updateFilterRangeOverlay({
        width: getOuterWidth($cell, true) + 1
      });
      null === (_that$_filterRangeOve2 = that._filterRangeOverlayInstance) || void 0 === _that$_filterRangeOve2 || _that$_filterRangeOve2.show();
    }
  }
  _hideFilterRange() {
    const overlayInstance = this._filterRangeOverlayInstance;
    null === overlayInstance || void 0 === overlayInstance || overlayInstance.hide();
  }
  getFilterRangeOverlayInstance() {
    return this._filterRangeOverlayInstance;
  }
  _createRow(row) {
    const $row = super._createRow(row);
    if ("filter" === row.rowType) {
      $row.addClass(this.addWidgetPrefix("filter-row"));
      if (!this.option("useLegacyKeyboardNavigation")) {
        m_events_engine_default.on($row, "keydown", (event) => selectView("filterRow", this, event));
      }
    }
    return $row;
  }
  _getRows() {
    const result2 = super._getRows();
    if (this.isFilterRowVisible()) {
      result2.push({
        rowType: "filter"
      });
    }
    return result2;
  }
  _renderFilterCell(cell, options2) {
    var _column$filterOperati;
    const that = this;
    const {
      column
    } = options2;
    const $cell = renderer_default(cell);
    if (that.component.option("showColumnHeaders")) {
      that.setAria("describedby", column.headerId, $cell);
    }
    that.setAria("label", message_default.format("dxDataGrid-ariaFilterCell"), $cell);
    $cell.addClass("dx-editor-cell");
    const $container = renderer_default("<div>").appendTo($cell);
    const $editorContainer = renderer_default("<div>").addClass("dx-editor-container").appendTo($container);
    if ("between" === getColumnSelectedFilterOperation(that, column)) {
      that._renderFilterRangeContent($cell, column);
    } else {
      const editorOptions = that._getEditorOptions($editorContainer, column);
      that._renderEditor($editorContainer, editorOptions);
    }
    const {
      alignment
    } = column;
    if (alignment && "center" !== alignment) {
      $cell.find(EDITORS_INPUT_SELECTOR2).first().css("textAlign", column.alignment);
    }
    if (null !== (_column$filterOperati = column.filterOperations) && void 0 !== _column$filterOperati && _column$filterOperati.length) {
      that._renderFilterOperationChooser($container, column, $editorContainer);
    }
  }
  _renderCellContent($cell, options2) {
    const that = this;
    const {
      column
    } = options2;
    if ("filter" === options2.rowType) {
      if (column.command) {
        $cell.html("&nbsp;");
      } else if (column.allowFiltering) {
        that.renderTemplate($cell, that._renderFilterCell.bind(that), options2).done(() => {
          that._updateCell($cell, options2);
        });
        return;
      }
    }
    super._renderCellContent.apply(this, arguments);
  }
  _getEditorOptions($editorContainer, column) {
    const that = this;
    const accessibilityOptions = {
      editorOptions: {
        inputAttr: that._getFilterInputAccessibilityAttributes(column)
      }
    };
    const result2 = extend(accessibilityOptions, column, {
      value: getFilterValue2(that, column.index, $editorContainer),
      parentType: "filterRow",
      showAllText: that.option("filterRow.showAllText"),
      updateValueTimeout: "onClick" === that.option("filterRow.applyFilter") ? 0 : 700,
      width: null,
      setValue(value2, notFireEvent) {
        updateFilterValue(that, {
          column,
          value: value2,
          container: $editorContainer,
          notFireEvent
        });
      }
    });
    if ("between" === getColumnSelectedFilterOperation(that, column)) {
      if ($editorContainer.hasClass(that.addWidgetPrefix("filter-range-start"))) {
        result2.placeholder = that.option("filterRow.betweenStartText");
      } else {
        result2.placeholder = that.option("filterRow.betweenEndText");
      }
    }
    return result2;
  }
  _getFilterInputAccessibilityAttributes(column) {
    const columnAriaLabel = message_default.format("dxDataGrid-ariaFilterCell");
    if (this.component.option("showColumnHeaders")) {
      return {
        "aria-label": columnAriaLabel,
        "aria-describedby": column.headerId
      };
    }
    return {
      "aria-label": columnAriaLabel
    };
  }
  _renderEditor($editorContainer, options2) {
    $editorContainer.empty();
    const $element = renderer_default("<div>").appendTo($editorContainer);
    const dataSource = this._dataController.dataSource();
    if (options2.lookup && this.option("syncLookupFilterValues")) {
      this._applyFilterViewController.setCurrentColumnForFiltering(options2);
      const filter = this._dataController.getCombinedFilter();
      this._applyFilterViewController.setCurrentColumnForFiltering(null);
      const lookupDataSource = m_utils_default.getWrappedLookupDataSource(options2, dataSource, filter);
      const lookupOptions = _extends({}, options2, {
        lookup: _extends({}, options2.lookup, {
          dataSource: lookupDataSource
        })
      });
      return this._editorFactoryController.createEditor($element, lookupOptions);
    }
    return this._editorFactoryController.createEditor($element, options2);
  }
  _renderFilterRangeContent($cell, column) {
    const that = this;
    const $editorContainer = $cell.find(".dx-editor-container").first();
    $editorContainer.empty();
    const $filterRangeContent = renderer_default("<div>").addClass("dx-filter-range-content").attr("tabindex", this.option("tabIndex"));
    m_events_engine_default.on($filterRangeContent, "focusin", () => {
      that._showFilterRange($cell, column);
    });
    $filterRangeContent.appendTo($editorContainer);
    that._updateFilterRangeContent($cell, getRangeTextByFilterValue(that, column));
  }
  _updateFilterRangeContent($cell, value2) {
    const $filterRangeContent = $cell.find(".dx-filter-range-content");
    if ($filterRangeContent.length) {
      if ("" === value2) {
        $filterRangeContent.html("&nbsp;");
      } else {
        $filterRangeContent.text(value2);
      }
    }
  }
  _updateFilterOperationChooser($menu, column, $editorContainer) {
    var _column$filterOperati2;
    const that = this;
    let isCellWasFocused;
    const restoreFocus3 = function() {
      const menu = menu_default.getInstance($menu);
      menu && menu.option("focusedElement", null);
      isCellWasFocused && that._focusEditor($editorContainer);
    };
    const editorFactoryController = this._editorFactoryController;
    that._createComponent($menu, menu_default, {
      integrationOptions: {},
      activeStateEnabled: false,
      selectionMode: "single",
      cssClass: `${that.getWidgetContainerClass()} dx-cell-focus-disabled ${FILTER_MENU}`,
      showFirstSubmenuMode: "onHover",
      hideSubmenuOnMouseLeave: true,
      items: [{
        name: getColumnSelectedFilterOperation(that, column) || ARIA_SEARCH_BOX,
        disabled: !(null !== (_column$filterOperati2 = column.filterOperations) && void 0 !== _column$filterOperati2 && _column$filterOperati2.length),
        icon: OPERATION_ICONS[getColumnSelectedFilterOperation(that, column) || "default"],
        selectable: false,
        items: that._getFilterOperationMenuItems(column)
      }],
      onItemRendered: (_ref) => {
        let {
          itemElement,
          itemData
        } = _ref;
        if (null !== itemData && void 0 !== itemData && itemData.items && null !== itemData && void 0 !== itemData && itemData.name) {
          const labelText = that._getOperationDescriptionFromDescriptor(itemData.name) || ARIA_SEARCH_BOX;
          this.setAria("label", labelText, renderer_default(itemElement));
        }
      },
      onItemClick(properties) {
        var _properties$itemData;
        const selectedFilterOperation = properties.itemData.name;
        const columnSelectedFilterOperation = getColumnSelectedFilterOperation(that, column);
        let notFocusEditor = false;
        const isOnClickMode = isOnClickApplyFilterMode(that);
        const options2 = {};
        if (properties.itemData.items || selectedFilterOperation && selectedFilterOperation === columnSelectedFilterOperation) {
          return;
        }
        if (selectedFilterOperation) {
          options2[isOnClickMode ? "bufferedSelectedFilterOperation" : "selectedFilterOperation"] = selectedFilterOperation;
          if ("between" === selectedFilterOperation || "between" === columnSelectedFilterOperation) {
            notFocusEditor = "between" === selectedFilterOperation;
            options2[isOnClickMode ? "bufferedFilterValue" : "filterValue"] = null;
          }
        } else {
          options2[isOnClickMode ? "bufferedFilterValue" : "filterValue"] = null;
          options2[isOnClickMode ? "bufferedSelectedFilterOperation" : "selectedFilterOperation"] = column.defaultSelectedFilterOperation || null;
        }
        const isResetFilterOperation = !(null !== (_properties$itemData = properties.itemData) && void 0 !== _properties$itemData && _properties$itemData.name);
        const isNotFireEvent = isResetFilterOperation ? false : void 0;
        that._columnsController.columnOption(column.index, options2, void 0, isNotFireEvent);
        that._applyFilterViewController.setHighLight($editorContainer, true);
        if (!selectedFilterOperation) {
          const editor = getEditorInstance($editorContainer);
          if (editor && "dxDateBox" === editor.NAME && !editor.option("isValid")) {
            editor.clear();
            editor.option("isValid", true);
          }
        }
        if (!notFocusEditor) {
          that._focusEditor($editorContainer);
        } else {
          that._showFilterRange($editorContainer.closest(".dx-editor-cell"), column);
        }
      },
      onSubmenuShowing() {
        isCellWasFocused = that._isEditorFocused($editorContainer);
        editorFactoryController.loseFocus();
      },
      onSubmenuHiding() {
        m_events_engine_default.trigger($menu, "blur");
        restoreFocus3();
      },
      onContentReady(e) {
        m_events_engine_default.on($menu, "blur", () => {
          const menu = e.component;
          menu._hideSubmenuAfterTimeout();
          restoreFocus3();
        });
      },
      rtlEnabled: that.option("rtlEnabled")
    });
  }
  _isEditorFocused($container) {
    return $container.hasClass("dx-focused") || $container.parents(".dx-focused").length;
  }
  _focusEditor($container) {
    this._editorFactoryController.focus($container);
    m_events_engine_default.trigger($container.find(EDITORS_INPUT_SELECTOR2), "focus");
  }
  _renderFilterOperationChooser($container, column, $editorContainer) {
    const that = this;
    let $menu;
    if (that.option("filterRow.showOperationChooser")) {
      $container.addClass("dx-editor-with-menu");
      $menu = renderer_default("<div>").prependTo($container);
      that._updateFilterOperationChooser($menu, column, $editorContainer);
    }
  }
  _getFilterOperationMenuItems(column) {
    var _column$filterOperati3;
    const that = this;
    let result2 = [{}];
    const filterRowOptions = that.option("filterRow");
    if (null !== (_column$filterOperati3 = column.filterOperations) && void 0 !== _column$filterOperati3 && _column$filterOperati3.length) {
      const availableFilterOperations = column.filterOperations.filter((value2) => isDefined(OPERATION_DESCRIPTORS[value2]));
      result2 = map(availableFilterOperations, (value2) => ({
        name: value2,
        selected: (getColumnSelectedFilterOperation(that, column) || column.defaultFilterOperation) === value2,
        text: that._getOperationDescriptionFromDescriptor(value2),
        icon: OPERATION_ICONS[value2]
      }));
      result2.push({
        name: null,
        text: null === filterRowOptions || void 0 === filterRowOptions ? void 0 : filterRowOptions.resetOperationText,
        icon: OPERATION_ICONS.default
      });
    }
    return result2;
  }
  _getOperationDescriptionFromDescriptor(value2) {
    const filterRowOptions = this.option("filterRow");
    const operationDescriptions = (null === filterRowOptions || void 0 === filterRowOptions ? void 0 : filterRowOptions.operationDescriptions) || {};
    const descriptionName = OPERATION_DESCRIPTORS[value2];
    return operationDescriptions[descriptionName];
  }
  _handleDataChanged(e) {
    var _this$_dataController, _this$_dataController2, _dataSource$lastLoadO, _e$operationTypes, _e$operationTypes2;
    const dataSource = null === (_this$_dataController = this._dataController) || void 0 === _this$_dataController || null === (_this$_dataController2 = _this$_dataController.dataSource) || void 0 === _this$_dataController2 ? void 0 : _this$_dataController2.call(_this$_dataController);
    const lastLoadOptions = null === dataSource || void 0 === dataSource || null === (_dataSource$lastLoadO = dataSource.lastLoadOptions) || void 0 === _dataSource$lastLoadO ? void 0 : _dataSource$lastLoadO.call(dataSource);
    super._handleDataChanged.apply(this, arguments);
    if (null !== (_e$operationTypes = e.operationTypes) && void 0 !== _e$operationTypes && _e$operationTypes.filtering || null !== (_e$operationTypes2 = e.operationTypes) && void 0 !== _e$operationTypes2 && _e$operationTypes2.fullReload) {
      var _e$operationTypes3;
      this.updateLookupDataSource((null === (_e$operationTypes3 = e.operationTypes) || void 0 === _e$operationTypes3 ? void 0 : _e$operationTypes3.filtering) || (null === lastLoadOptions || void 0 === lastLoadOptions ? void 0 : lastLoadOptions.filter));
    }
  }
  updateLookupDataSource(filterChanged) {
    if (!this.option("syncLookupFilterValues")) {
      return;
    }
    if (!this.element()) {
      return;
    }
    const columns7 = this._columnsController.getVisibleColumns();
    const dataSource = this._dataController.dataSource();
    const applyFilterViewController = this._applyFilterViewController;
    const rowIndex = this.element().find(`.${this.addWidgetPrefix("filter-row")}`).index();
    if (-1 === rowIndex) {
      return;
    }
    columns7.forEach((column, index2) => {
      if (!column.lookup || column.calculateCellValue !== column.defaultCalculateCellValue) {
        return;
      }
      const $cell = this._getCellElement(rowIndex, index2);
      const editor = getEditorInstance(null === $cell || void 0 === $cell ? void 0 : $cell.find(".dx-editor-container"));
      if (editor) {
        applyFilterViewController.setCurrentColumnForFiltering(column);
        const filter = this._dataController.getCombinedFilter() || null;
        applyFilterViewController.setCurrentColumnForFiltering(null);
        const editorDataSource = editor.option("dataSource");
        const shouldUpdateFilter = !filterChanged || !equalByValue(editorDataSource.__dataGridSourceFilter || null, filter);
        if (shouldUpdateFilter) {
          const lookupDataSource = m_utils_default.getWrappedLookupDataSource(column, dataSource, filter);
          editor.option("dataSource", lookupDataSource);
        }
      }
    });
  }
  getColumnElements(index2, bandColumnIndex) {
    var _rows$index;
    const rows = this._getRows();
    if ("filter" === (null === rows || void 0 === rows || null === (_rows$index = rows[index2]) || void 0 === _rows$index ? void 0 : _rows$index.rowType) && arguments.length < 2) {
      return this.getCellElements(index2);
    }
    return super.getColumnElements(index2, bandColumnIndex);
  }
  isFilterRowCell($cell) {
    return !!$cell.closest(`.${this.addWidgetPrefix("filter-row")}`).length;
  }
};
var data8 = (Base) => class extends Base {
  skipCalculateColumnFilters() {
    return false;
  }
  _calculateAdditionalFilter() {
    if (this.skipCalculateColumnFilters()) {
      return super._calculateAdditionalFilter();
    }
    const filters = [super._calculateAdditionalFilter()];
    const columns7 = this._columnsController.getVisibleColumns(null, true);
    const applyFilterController = this._applyFilterController;
    each(columns7, function() {
      var _applyFilterControlle;
      const shouldSkip = (null === (_applyFilterControlle = applyFilterController.getCurrentColumnForFiltering()) || void 0 === _applyFilterControlle ? void 0 : _applyFilterControlle.index) === this.index;
      if (this.allowFiltering && this.calculateFilterExpression && isDefined(this.filterValue) && !shouldSkip) {
        const filter = this.createFilterExpression(this.filterValue, this.selectedFilterOperation || this.defaultFilterOperation, "filterRow");
        filters.push(filter);
      }
    });
    return m_utils_default.combineFilters(filters);
  }
};
var ApplyFilterViewController = class extends m_modules_default.ViewController {
  init() {
    this._columnsController = this.getController("columns");
  }
  _getHeaderPanel() {
    if (!this._headerPanel) {
      this._headerPanel = this.getView("headerPanel");
    }
    return this._headerPanel;
  }
  setHighLight($element, value2) {
    if (isOnClickApplyFilterMode(this)) {
      (null === $element || void 0 === $element ? void 0 : $element.toggleClass("dx-highlight-outline", value2)) && $element.closest(".dx-editor-cell").toggleClass("dx-filter-modified", value2);
      this._getHeaderPanel().enableApplyButton(value2);
    }
  }
  applyFilter() {
    const columns7 = this._columnsController.getColumns();
    this._columnsController.beginUpdate();
    for (let i = 0; i < columns7.length; i++) {
      const column = columns7[i];
      if (void 0 !== column.bufferedFilterValue) {
        this._columnsController.columnOption(i, "filterValue", column.bufferedFilterValue);
        column.bufferedFilterValue = void 0;
      }
      if (void 0 !== column.bufferedSelectedFilterOperation) {
        this._columnsController.columnOption(i, "selectedFilterOperation", column.bufferedSelectedFilterOperation);
        column.bufferedSelectedFilterOperation = void 0;
      }
    }
    this._columnsController.endUpdate();
    this.removeHighLights();
  }
  removeHighLights() {
    if (isOnClickApplyFilterMode(this)) {
      const columnHeadersViewElement = this.getView("columnHeadersView").element();
      columnHeadersViewElement.find(`.${this.addWidgetPrefix("filter-row")} .dx-highlight-outline`).removeClass("dx-highlight-outline");
      columnHeadersViewElement.find(`.${this.addWidgetPrefix("filter-row")} .dx-filter-modified`).removeClass("dx-filter-modified");
      this._getHeaderPanel().enableApplyButton(false);
    }
  }
  setCurrentColumnForFiltering(column) {
    this._currentColumn = column;
  }
  getCurrentColumnForFiltering() {
    return this._currentColumn;
  }
};
var columnsResizer = (Base) => class extends Base {
  _startResizing() {
    const that = this;
    super._startResizing.apply(that, arguments);
    if (that.isResizing()) {
      const overlayInstance = that._columnHeadersView.getFilterRangeOverlayInstance();
      if (overlayInstance) {
        const cellIndex = overlayInstance.$element().closest("td").index();
        if (cellIndex === that._targetPoint.columnIndex || cellIndex === that._targetPoint.columnIndex + 1) {
          overlayInstance.$content().hide();
        }
      }
    }
  }
  _endResizing() {
    const that = this;
    let $cell;
    if (that.isResizing()) {
      const overlayInstance = that._columnHeadersView.getFilterRangeOverlayInstance();
      if (overlayInstance) {
        $cell = overlayInstance.$element().closest("td");
        that._columnHeadersView._updateFilterRangeOverlay({
          width: getOuterWidth($cell, true) + 1
        });
        overlayInstance.$content().show();
      }
    }
    super._endResizing.apply(that, arguments);
  }
};
var editing = (Base) => class extends Base {
  updateFieldValue(options2) {
    if (options2.column.lookup) {
      this._needUpdateLookupDataSource = true;
    }
    return super.updateFieldValue.apply(this, arguments);
  }
  _afterSaveEditData(cancel2) {
    if (this._needUpdateLookupDataSource && !cancel2) {
      var _this$getView;
      null === (_this$getView = this.getView("columnHeadersView")) || void 0 === _this$getView || _this$getView.updateLookupDataSource();
    }
    this._needUpdateLookupDataSource = false;
    return super._afterSaveEditData.apply(this, arguments);
  }
  _afterCancelEditData() {
    this._needUpdateLookupDataSource = false;
    return super._afterCancelEditData.apply(this, arguments);
  }
};
var headerPanel4 = (Base) => class extends Base {
  init() {
    super.init();
    this._dataController = this.getController("data");
    this._applyFilterViewController = this.getController("applyFilter");
  }
  optionChanged(args) {
    if ("filterRow" === args.name) {
      this._invalidate();
      args.handled = true;
    } else {
      super.optionChanged(args);
    }
  }
  _getToolbarItems() {
    const items = super._getToolbarItems();
    const filterItem = this._prepareFilterItem();
    return filterItem.concat(items);
  }
  _prepareFilterItem() {
    const that = this;
    const filterItem = [];
    if (that._isShowApplyFilterButton()) {
      const hintText = that.option("filterRow.applyFilterText");
      const columns7 = that._columnsController.getColumns();
      const disabled = !columns7.filter((column) => void 0 !== column.bufferedFilterValue).length;
      const onInitialized = function(e) {
        renderer_default(e.element).addClass(that._getToolbarButtonClass("dx-apply-button"));
      };
      const onClickHandler = function() {
        that._applyFilterViewController.applyFilter();
      };
      const toolbarItem = {
        widget: "dxButton",
        options: {
          icon: "apply-filter",
          disabled,
          onClick: onClickHandler,
          hint: hintText,
          text: hintText,
          onInitialized
        },
        showText: "inMenu",
        name: "applyFilterButton",
        location: "after",
        locateInMenu: "auto",
        sortIndex: 10
      };
      filterItem.push(toolbarItem);
    }
    return filterItem;
  }
  _isShowApplyFilterButton() {
    const filterRowOptions = this.option("filterRow");
    return !!(null !== filterRowOptions && void 0 !== filterRowOptions && filterRowOptions.visible) && "onClick" === filterRowOptions.applyFilter;
  }
  enableApplyButton(value2) {
    this.setToolbarItemDisabled("applyFilterButton", !value2);
  }
};
var filterRowModule = {
  defaultOptions: () => ({
    syncLookupFilterValues: true,
    filterRow: {
      visible: false,
      showOperationChooser: true,
      showAllText: message_default.format("dxDataGrid-filterRowShowAllText"),
      resetOperationText: message_default.format("dxDataGrid-filterRowResetOperationText"),
      applyFilter: "auto",
      applyFilterText: message_default.format("dxDataGrid-applyFilterText"),
      operationDescriptions: {
        equal: message_default.format("dxDataGrid-filterRowOperationEquals"),
        notEqual: message_default.format("dxDataGrid-filterRowOperationNotEquals"),
        lessThan: message_default.format("dxDataGrid-filterRowOperationLess"),
        lessThanOrEqual: message_default.format("dxDataGrid-filterRowOperationLessOrEquals"),
        greaterThan: message_default.format("dxDataGrid-filterRowOperationGreater"),
        greaterThanOrEqual: message_default.format("dxDataGrid-filterRowOperationGreaterOrEquals"),
        startsWith: message_default.format("dxDataGrid-filterRowOperationStartsWith"),
        contains: message_default.format("dxDataGrid-filterRowOperationContains"),
        notContains: message_default.format("dxDataGrid-filterRowOperationNotContains"),
        endsWith: message_default.format("dxDataGrid-filterRowOperationEndsWith"),
        between: message_default.format("dxDataGrid-filterRowOperationBetween"),
        isBlank: message_default.format("dxFilterBuilder-filterOperationIsBlank"),
        isNotBlank: message_default.format("dxFilterBuilder-filterOperationIsNotBlank")
      },
      betweenStartText: message_default.format("dxDataGrid-filterRowOperationBetweenStartText"),
      betweenEndText: message_default.format("dxDataGrid-filterRowOperationBetweenEndText")
    }
  }),
  controllers: {
    applyFilter: ApplyFilterViewController
  },
  extenders: {
    controllers: {
      data: data8,
      columnsResizer,
      editing
    },
    views: {
      columnHeadersView: columnHeadersView3,
      headerPanel: headerPanel4
    }
  }
};

// node_modules/devextreme/esm/__internal/grids/data_grid/module_not_extended/filter_row.js
m_core_default.registerModule("filterRow", filterRowModule);

// node_modules/devextreme/esm/__internal/ui/list/modules/m_search.js
ui_search_box_mixin_default.setEditorClass(text_box_default2);

// node_modules/devextreme/esm/__internal/grids/grid_core/header_filter/m_header_filter_core.js
function resetChildrenItemSelection(items) {
  items = items || [];
  for (let i = 0; i < items.length; i++) {
    items[i].selected = false;
    resetChildrenItemSelection(items[i].items);
  }
}
function getSelectAllCheckBox(listComponent) {
  const selector = "dxTreeView" === listComponent.NAME ? ".dx-treeview-select-all-item" : ".dx-list-select-all-checkbox";
  return listComponent.$element().find(selector).dxCheckBox("instance");
}
function updateListSelectAllState(listComponent, filterValues) {
  if (listComponent.option("searchValue")) {
    return;
  }
  const selectAllCheckBox = getSelectAllCheckBox(listComponent);
  if (selectAllCheckBox && null !== filterValues && void 0 !== filterValues && filterValues.length) {
    selectAllCheckBox.option("value", void 0);
    const originalValueChanged = selectAllCheckBox.option("onValueChanged");
    selectAllCheckBox.option("onValueChanged", (event) => {
      selectAllCheckBox.option("onValueChanged", originalValueChanged);
      const deferred = listComponent.unselectAll();
      if (isDeferred(deferred)) {
        deferred.always(() => {
          null === originalValueChanged || void 0 === originalValueChanged || originalValueChanged(event);
        });
      } else {
        null === originalValueChanged || void 0 === originalValueChanged || originalValueChanged(event);
      }
    });
  }
}
function updateHeaderFilterItemSelectionState(item, filterValuesMatch, isExcludeFilter) {
  if (filterValuesMatch ^ isExcludeFilter) {
    item.selected = true;
    if (isExcludeFilter && item.items) {
      for (let j = 0; j < item.items.length; j++) {
        if (!item.items[j].selected) {
          item.selected = void 0;
          break;
        }
      }
    }
  } else if (isExcludeFilter || item.selected) {
    item.selected = false;
    resetChildrenItemSelection(item.items);
  }
}
var HeaderFilterView = class extends m_modules_default.View {
  getPopupContainer() {
    return this._popupContainer;
  }
  getListComponent() {
    return this._listComponent;
  }
  applyHeaderFilter(options2) {
    const list = this.getListComponent();
    const searchValue = list.option("searchValue");
    const selectAllCheckBox = getSelectAllCheckBox(list);
    const isAllSelected = !searchValue && !options2.isFilterBuilder && (null === selectAllCheckBox || void 0 === selectAllCheckBox ? void 0 : selectAllCheckBox.option("value"));
    const filterValues = [];
    const fillSelectedItemKeys = function(filterValues2, items, isExclude) {
      each(items, (_, item) => {
        if (void 0 !== item.selected && !!item.selected ^ isExclude) {
          const node = list._getNode(item);
          const hasChildren2 = list._hasChildren(node);
          const hasChildrenWithSelection = hasChildren2 && item.items && item.items.some((item2) => item2.selected);
          if (!searchValue || !hasChildrenWithSelection) {
            filterValues2.push(item.value);
            return;
          }
        }
        if (item.items && item.items.length) {
          fillSelectedItemKeys(filterValues2, item.items, isExclude);
        }
      });
    };
    if (!isAllSelected) {
      if ("tree" === options2.type) {
        if (options2.filterType) {
          options2.filterType = "include";
        }
        fillSelectedItemKeys(filterValues, list.option("items"), false);
        options2.filterValues = filterValues;
      }
    } else {
      if ("tree" === options2.type) {
        options2.filterType = "exclude";
      }
      if (Array.isArray(options2.filterValues)) {
        options2.filterValues = [];
      }
    }
    if (options2.filterValues && !options2.filterValues.length) {
      options2.filterValues = null;
    }
    options2.apply();
    this.hideHeaderFilterMenu();
  }
  showHeaderFilterMenu($columnElement, options2) {
    const that = this;
    if (options2) {
      that._initializePopupContainer(options2);
      const popupContainer = that.getPopupContainer();
      that.hideHeaderFilterMenu();
      that.updatePopup($columnElement, options2);
      popupContainer.show();
    }
  }
  hideHeaderFilterMenu() {
    const headerFilterMenu = this.getPopupContainer();
    headerFilterMenu && headerFilterMenu.hide();
  }
  updatePopup($element, options2) {
    const that = this;
    const showColumnLines = this.option("showColumnLines");
    const alignment = "right" === options2.alignment ^ !showColumnLines ? "left" : "right";
    that._popupContainer.setAria({
      role: "dialog",
      label: message_default.format("dxDataGrid-headerFilterLabel")
    });
    if (that._popupContainer) {
      that._cleanPopupContent();
      that._popupContainer.option("position", {
        my: `${alignment} top`,
        at: `${alignment} bottom`,
        of: $element,
        collision: "fit fit"
      });
    }
  }
  _getSearchExpr(options2, headerFilterOptions) {
    const {
      lookup
    } = options2;
    const {
      useDefaultSearchExpr
    } = options2;
    const headerFilterDataSource = headerFilterOptions.dataSource;
    const filterSearchExpr = headerFilterOptions.search.searchExpr;
    if (filterSearchExpr) {
      return filterSearchExpr;
    }
    if (useDefaultSearchExpr || isDefined(headerFilterDataSource) && !isFunction(headerFilterDataSource)) {
      return "text";
    }
    if (lookup) {
      return lookup.displayExpr || "this";
    }
    if (options2.dataSource) {
      const {
        group
      } = options2.dataSource;
      if (Array.isArray(group) && group.length > 0) {
        return group[0].selector;
      }
      if (isFunction(group) && !options2.remoteFiltering) {
        return group;
      }
    }
    return options2.dataField || options2.selector;
  }
  _cleanPopupContent() {
    this._popupContainer && this._popupContainer.$content().empty();
  }
  _initializePopupContainer(options2) {
    const that = this;
    const $element = that.element();
    const headerFilterOptions = this._normalizeHeaderFilterOptions(options2);
    const {
      hidePopupCallback
    } = options2;
    const {
      height,
      width
    } = headerFilterOptions;
    const dxPopupOptions = {
      width,
      height,
      visible: false,
      shading: false,
      showTitle: false,
      showCloseButton: false,
      hideOnParentScroll: false,
      dragEnabled: false,
      hideOnOutsideClick: true,
      wrapperAttr: {
        class: "dx-header-filter-menu"
      },
      focusStateEnabled: false,
      toolbarItems: [{
        toolbar: "bottom",
        location: "after",
        widget: "dxButton",
        options: {
          text: headerFilterOptions.texts.ok,
          onClick() {
            that.applyHeaderFilter(options2);
          }
        }
      }, {
        toolbar: "bottom",
        location: "after",
        widget: "dxButton",
        options: {
          text: headerFilterOptions.texts.cancel,
          onClick() {
            that.hideHeaderFilterMenu();
            null === hidePopupCallback || void 0 === hidePopupCallback || hidePopupCallback();
          }
        }
      }],
      resizeEnabled: true,
      onShowing(e) {
        e.component.$content().parent().addClass("dx-dropdowneditor-overlay");
        that._initializeListContainer(options2, headerFilterOptions);
        options2.onShowing && options2.onShowing(e);
      },
      onShown() {
        that.getListComponent().focus();
      },
      onHidden: options2.onHidden,
      onInitialized(e) {
        const {
          component
        } = e;
        component.option("animation", component._getDefaultOptions().animation);
      },
      _loopFocus: true
    };
    if (!isDefined(that._popupContainer)) {
      that._popupContainer = that._createComponent($element, ui_popup_default, dxPopupOptions);
    } else {
      that._popupContainer.option(dxPopupOptions);
    }
  }
  _initializeListContainer(options2, headerFilterOptions) {
    const that = this;
    const $content = that._popupContainer.$content();
    const needShowSelectAllCheckbox = !options2.isFilterBuilder && headerFilterOptions.allowSelectAll;
    const widgetOptions = {
      searchEnabled: headerFilterOptions.search.enabled,
      searchTimeout: headerFilterOptions.search.timeout,
      searchEditorOptions: headerFilterOptions.search.editorOptions,
      searchMode: headerFilterOptions.search.mode || "",
      dataSource: options2.dataSource,
      onContentReady() {
        that.renderCompleted.fire();
      },
      itemTemplate(data17, _, element) {
        const $element = renderer_default(element);
        if (options2.encodeHtml) {
          return $element.text(data17.text);
        }
        return $element.html(data17.text);
      }
    };
    const shouldChangeSelectAllCheckBoxVisibility = () => needShowSelectAllCheckbox && false !== that.option("headerFilter.hideSelectAllOnSearch");
    const onTreeViewOptionChanged = (event) => {
      switch (true) {
        case ("searchValue" === event.fullName && shouldChangeSelectAllCheckBoxVisibility()):
          event.component.option("showCheckBoxesMode", event.value ? "normal" : "selectAll");
          break;
        case "showCheckBoxesMode" === event.fullName:
          Promise.resolve().then(() => {
            event.component._searchEditor.focus();
          }).catch(() => {
          });
      }
    };
    const onListOptionChanged = (event) => {
      if ("searchValue" === event.fullName && shouldChangeSelectAllCheckBoxVisibility()) {
        event.component.option("selectionMode", event.value ? "multiple" : "all");
      }
    };
    if ("tree" === options2.type) {
      that._listComponent = that._createComponent(renderer_default("<div>").appendTo($content), tree_view_default, extend(widgetOptions, {
        showCheckBoxesMode: needShowSelectAllCheckbox ? "selectAll" : "normal",
        onOptionChanged: onTreeViewOptionChanged,
        keyExpr: "id"
      }));
    } else {
      that._listComponent = that._createComponent(renderer_default("<div>").appendTo($content), list_light_default, extend(widgetOptions, {
        searchExpr: that._getSearchExpr(options2, headerFilterOptions),
        pageLoadMode: "scrollBottom",
        showSelectionControls: true,
        selectionMode: needShowSelectAllCheckbox ? "all" : "multiple",
        onOptionChanged: onListOptionChanged,
        onSelectionChanged(event) {
          const {
            component: listComponent
          } = event;
          const items = listComponent.option("items");
          const selectedItems = listComponent.option("selectedItems");
          if (!listComponent._selectedItemsUpdating && !listComponent.option("searchValue") && !options2.isFilterBuilder) {
            const filterValues = options2.filterValues || [];
            const isExclude = "exclude" === options2.filterType;
            if (0 === selectedItems.length && items.length && (filterValues.length <= 1 || isExclude && filterValues.length === items.length - 1)) {
              options2.filterType = "include";
              options2.filterValues = [];
            } else if (selectedItems.length === items.length) {
              options2.filterType = "exclude";
              options2.filterValues = [];
            }
          }
          each(items, (index2, item) => {
            const selected = m_utils_default.getIndexByKey(item, selectedItems, null) >= 0;
            const oldSelected = !!item.selected;
            if (oldSelected !== selected) {
              item.selected = selected;
              options2.filterValues = options2.filterValues || [];
              const filterValueIndex = m_utils_default.getIndexByKey(item.value, options2.filterValues, null);
              if (filterValueIndex >= 0) {
                options2.filterValues.splice(filterValueIndex, 1);
              }
              const isExcludeFilterType = "exclude" === options2.filterType;
              if (selected ^ isExcludeFilterType) {
                options2.filterValues.push(item.value);
              }
            }
          });
          updateListSelectAllState(listComponent, options2.filterValues);
        },
        onContentReady(e) {
          const {
            component: listComponent
          } = e;
          const items = listComponent.option("items");
          const selectedItems = [];
          each(items, function() {
            if (this.selected) {
              selectedItems.push(this);
            }
          });
          listComponent._selectedItemsUpdating = true;
          listComponent.option("selectedItems", selectedItems);
          listComponent._selectedItemsUpdating = false;
          updateListSelectAllState(listComponent, options2.filterValues);
        }
      }));
    }
  }
  _normalizeHeaderFilterOptions(options2) {
    const generalHeaderFilter = this.option("headerFilter") || {};
    const specificHeaderFilter = options2.headerFilter || {};
    const generalDeprecated = {
      search: {
        enabled: generalHeaderFilter.allowSearch,
        timeout: generalHeaderFilter.searchTimeout
      }
    };
    const specificDeprecated = {
      search: {
        enabled: specificHeaderFilter.allowSearch,
        mode: specificHeaderFilter.searchMode,
        timeout: specificHeaderFilter.searchTimeout
      }
    };
    return extend(true, {}, generalHeaderFilter, generalDeprecated, specificHeaderFilter, specificDeprecated);
  }
  _renderCore() {
    this.element().addClass("dx-header-filter-menu");
  }
};
var allowHeaderFiltering = function(column) {
  return isDefined(column.allowHeaderFiltering) ? column.allowHeaderFiltering : column.allowFiltering;
};
var headerFilterMixin = (Base) => class extends Base {
  optionChanged(args) {
    if ("headerFilter" === args.name) {
      const requireReady = "columnHeadersView" === this.name;
      this._invalidate(requireReady, requireReady);
      args.handled = true;
    } else {
      super.optionChanged(args);
    }
  }
  _applyColumnState(options2) {
    let $headerFilterIndicator;
    const {
      rootElement
    } = options2;
    const {
      column
    } = options2;
    if ("headerFilter" === options2.name) {
      rootElement.find(".dx-header-filter").remove();
      if (allowHeaderFiltering(column)) {
        $headerFilterIndicator = super._applyColumnState(options2).toggleClass("dx-header-filter-empty", this._isHeaderFilterEmpty(column));
        if (!this.option("useLegacyKeyboardNavigation")) {
          $headerFilterIndicator.attr("tabindex", this.option("tabindex") || 0);
        }
        const indicatorLabel = message_default.format("dxDataGrid-headerFilterIndicatorLabel", column.caption);
        $headerFilterIndicator.attr("aria-label", indicatorLabel);
        $headerFilterIndicator.attr("aria-haspopup", "dialog");
        $headerFilterIndicator.attr("role", "button");
      }
      return $headerFilterIndicator;
    }
    return super._applyColumnState(options2);
  }
  _isHeaderFilterEmpty(column) {
    return !column.filterValues || !column.filterValues.length;
  }
  _getIndicatorClassName(name2) {
    if ("headerFilter" === name2) {
      return "dx-header-filter";
    }
    return super._getIndicatorClassName(name2);
  }
  _renderIndicator(options2) {
    const $container = options2.container;
    const $indicator = options2.indicator;
    if ("headerFilter" === options2.name) {
      const rtlEnabled = this.option("rtlEnabled");
      if ($container.children().length && (!rtlEnabled && "right" === options2.columnAlignment || rtlEnabled && "left" === options2.columnAlignment)) {
        $container.prepend($indicator);
        return;
      }
    }
    super._renderIndicator(options2);
  }
};

// node_modules/devextreme/esm/__internal/grids/grid_core/header_filter/m_header_filter.js
var DATE_INTERVAL_FORMATS = {
  month: (value2) => date_default3.getMonthNames()[value2 - 1],
  quarter: (value2) => date_default3.format(new Date(2e3, 3 * value2 - 1), "quarter")
};
function ungroupUTCDates(items, dateParts, dates) {
  dateParts = dateParts || [];
  dates = dates || [];
  items.forEach((item) => {
    if (isDefined(item.key)) {
      const isMonthPart = 1 === dateParts.length;
      dateParts.push(isMonthPart ? item.key - 1 : item.key);
      if (item.items) {
        ungroupUTCDates(item.items, dateParts, dates);
      } else {
        const date = new Date(Date.UTC.apply(Date, dateParts));
        dates.push(date);
      }
      dateParts.pop();
    } else {
      dates.push(null);
    }
  });
  return dates;
}
function convertDataFromUTCToLocal(data17, column) {
  const dates = ungroupUTCDates(data17);
  const query2 = m_query_default(dates);
  const group = m_utils_default.getHeaderFilterGroupParameters(_extends({}, column, {
    calculateCellValue: (date) => date
  }));
  return m_store_helper_default.queryByOptions(query2, {
    group
  }).toArray();
}
function isUTCFormat(format2) {
  return "Z" === (null === format2 || void 0 === format2 ? void 0 : format2.slice(-1)) || "'Z'" === (null === format2 || void 0 === format2 ? void 0 : format2.slice(-3));
}
var getFormatOptions = function(value2, column, currentLevel) {
  const groupInterval = filtering_default.getGroupInterval(column);
  const result2 = m_utils_default.getFormatOptionsByColumn(column, "headerFilter");
  if (groupInterval) {
    result2.groupInterval = groupInterval[currentLevel];
    if (m_utils_default.isDateType(column.dataType)) {
      result2.format = DATE_INTERVAL_FORMATS[groupInterval[currentLevel]];
    } else if ("number" === column.dataType) {
      result2.getDisplayFormat = function() {
        const formatOptions = {
          format: column.format,
          target: "headerFilter"
        };
        const firstValueText = m_utils_default.formatValue(value2, formatOptions);
        const secondValue = value2 + groupInterval[currentLevel];
        const secondValueText = m_utils_default.formatValue(secondValue, formatOptions);
        return firstValueText && secondValueText ? `${firstValueText} - ${secondValueText}` : "";
      };
    }
  }
  return result2;
};
var HeaderFilterController = class extends m_modules_default.ViewController {
  init() {
    this._columnsController = this.getController("columns");
    this._dataController = this.getController("data");
    this._headerFilterView = this.getView("headerFilterView");
  }
  _updateSelectedState(items, column) {
    let i = items.length;
    const isExclude = "exclude" === column.filterType;
    while (i--) {
      const item = items[i];
      if ("items" in items[i]) {
        this._updateSelectedState(items[i].items, column);
      }
      updateHeaderFilterItemSelectionState(item, m_utils_default.getIndexByKey(items[i].value, column.filterValues, null) > -1, isExclude);
    }
  }
  _normalizeGroupItem(item, currentLevel, options2) {
    let value2;
    let displayValue;
    const {
      path
    } = options2;
    const {
      valueSelector
    } = options2;
    const {
      displaySelector
    } = options2;
    const {
      column
    } = options2;
    if (valueSelector && displaySelector) {
      value2 = valueSelector(item);
      displayValue = displaySelector(item);
    } else {
      value2 = item.key;
      displayValue = value2;
    }
    if (!isObject(item)) {
      item = {};
    } else {
      item = extend({}, item);
    }
    path.push(value2);
    if (1 === path.length) {
      item.value = path[0];
    } else {
      item.value = path.join("/");
    }
    item.text = this.getHeaderItemText(displayValue, column, currentLevel, options2.headerFilterOptions);
    return item;
  }
  getHeaderItemText(displayValue, column, currentLevel, headerFilterOptions) {
    let text = m_utils_default.formatValue(displayValue, getFormatOptions(displayValue, column, currentLevel));
    if (!text) {
      text = headerFilterOptions.texts.emptyValue;
    }
    return text;
  }
  _processGroupItems(groupItems, currentLevel, path, options2) {
    const that = this;
    let displaySelector;
    let valueSelector;
    const {
      column
    } = options2;
    const {
      lookup
    } = column;
    const {
      level
    } = options2;
    path = path || [];
    currentLevel = currentLevel || 0;
    if (lookup) {
      displaySelector = compileGetter(lookup.displayExpr);
      valueSelector = compileGetter(lookup.valueExpr);
    }
    for (let i = 0; i < groupItems.length; i++) {
      groupItems[i] = that._normalizeGroupItem(groupItems[i], currentLevel, {
        column: options2.column,
        headerFilterOptions: options2.headerFilterOptions,
        displaySelector,
        valueSelector,
        path
      });
      if ("items" in groupItems[i]) {
        if (currentLevel === level || !isDefined(groupItems[i].value)) {
          delete groupItems[i].items;
        } else {
          that._processGroupItems(groupItems[i].items, currentLevel + 1, path, options2);
        }
      }
      path.pop();
    }
  }
  getDataSource(column) {
    var _column$headerFilter;
    const dataSource = this._dataController.dataSource();
    const remoteGrouping = null === dataSource || void 0 === dataSource ? void 0 : dataSource.remoteOperations().grouping;
    const group = m_utils_default.getHeaderFilterGroupParameters(column, remoteGrouping);
    const headerFilterDataSource = null === (_column$headerFilter = column.headerFilter) || void 0 === _column$headerFilter ? void 0 : _column$headerFilter.dataSource;
    const headerFilterOptions = this.option("headerFilter");
    let isLookup = false;
    const options2 = {
      component: this.component
    };
    if (!dataSource) {
      return;
    }
    if (isDefined(headerFilterDataSource) && !isFunction(headerFilterDataSource)) {
      options2.dataSource = normalizeDataSourceOptions(headerFilterDataSource);
    } else if (column.lookup) {
      isLookup = true;
      if (this.option("syncLookupFilterValues")) {
        this._currentColumn = column;
        const filter = this._dataController.getCombinedFilter();
        this._currentColumn = null;
        options2.dataSource = m_utils_default.getWrappedLookupDataSource(column, dataSource, filter);
      } else {
        options2.dataSource = m_utils_default.normalizeLookupDataSource(column.lookup);
      }
    } else {
      const cutoffLevel = Array.isArray(group) ? group.length - 1 : 0;
      this._currentColumn = column;
      const filter = this._dataController.getCombinedFilter();
      this._currentColumn = null;
      options2.dataSource = {
        filter,
        group,
        useDefaultSearch: true,
        load: (options3) => {
          const d = new Deferred();
          options3.dataField = column.dataField || column.name;
          dataSource.load(options3).done((data17) => {
            const convertUTCDates = remoteGrouping && isUTCFormat(column.serializationFormat) && cutoffLevel > 3;
            if (convertUTCDates) {
              data17 = convertDataFromUTCToLocal(data17, column);
            }
            that._processGroupItems(data17, null, null, {
              level: cutoffLevel,
              column,
              headerFilterOptions
            });
            d.resolve(data17);
          }).fail(d.reject);
          return d;
        }
      };
    }
    if (isFunction(headerFilterDataSource)) {
      headerFilterDataSource.call(column, options2);
    }
    const origPostProcess = options2.dataSource.postProcess;
    const that = this;
    options2.dataSource.postProcess = function(data17) {
      let items = data17;
      if (isLookup) {
        items = items.filter((item) => null !== item[column.lookup.valueExpr]);
        if (0 === this.pageIndex() && !this.searchValue()) {
          items = items.slice(0);
          items.unshift(null);
        }
        that._processGroupItems(items, null, null, {
          level: 0,
          column,
          headerFilterOptions
        });
      }
      items = origPostProcess && origPostProcess.call(this, items) || items;
      that._updateSelectedState(items, column);
      return items;
    };
    return options2.dataSource;
  }
  getCurrentColumn() {
    return this._currentColumn;
  }
  showHeaderFilterMenu(columnIndex, isGroupPanel) {
    const columnsController = this._columnsController;
    const column = extend(true, {}, this._columnsController.getColumns()[columnIndex]);
    if (column) {
      const visibleIndex = columnsController.getVisibleIndex(columnIndex);
      const view = isGroupPanel ? this.getView("headerPanel") : this.getView("columnHeadersView");
      const $columnElement = view.getColumnElements().eq(isGroupPanel ? column.groupIndex : visibleIndex);
      this.showHeaderFilterMenuBase({
        columnElement: $columnElement,
        column,
        applyFilter: true,
        apply() {
          columnsController.columnOption(columnIndex, {
            filterValues: this.filterValues,
            filterType: this.filterType
          });
        }
      });
    }
  }
  showHeaderFilterMenuBase(options2) {
    const that = this;
    const {
      column
    } = options2;
    if (column) {
      const groupInterval = filtering_default.getGroupInterval(column);
      const dataSource = that._dataController.dataSource();
      const remoteFiltering = dataSource && dataSource.remoteOperations().filtering;
      const previousOnHidden = options2.onHidden;
      extend(options2, column, {
        type: groupInterval && groupInterval.length > 1 ? "tree" : "list",
        remoteFiltering,
        onShowing: (e) => {
          const dxResizableInstance = e.component.$overlayContent().dxResizable("instance");
          dxResizableInstance && dxResizableInstance.option("onResizeEnd", (e2) => {
            let headerFilterByColumn = this._columnsController.columnOption(options2.dataField, "headerFilter");
            headerFilterByColumn = headerFilterByColumn || {};
            headerFilterByColumn.width = e2.width;
            headerFilterByColumn.height = e2.height;
            this._columnsController.columnOption(options2.dataField, "headerFilter", headerFilterByColumn, true);
          });
        },
        onHidden: () => {
          null === previousOnHidden || void 0 === previousOnHidden || previousOnHidden();
          restoreFocus(this);
        }
      });
      options2.dataSource = that.getDataSource(options2);
      if (options2.isFilterBuilder) {
        options2.dataSource.filter = null;
        options2.alignment = "right";
      }
      that._headerFilterView.showHeaderFilterMenu(options2.columnElement, options2);
    }
  }
  hideHeaderFilterMenu() {
    this._headerFilterView.hideHeaderFilterMenu();
  }
};
var columnHeadersView4 = (Base) => class extends headerFilterMixin(Base) {
  _renderCellContent($cell, options2) {
    const that = this;
    let $headerFilterIndicator;
    const {
      column
    } = options2;
    if (!column.command && allowHeaderFiltering(column) && that.option("headerFilter.visible") && "header" === options2.rowType) {
      $headerFilterIndicator = that._applyColumnState({
        name: "headerFilter",
        rootElement: $cell,
        column,
        showColumnLines: that.option("showColumnLines")
      });
      $headerFilterIndicator && that._subscribeToIndicatorEvent($headerFilterIndicator, column, "headerFilter");
    }
    super._renderCellContent.apply(this, arguments);
  }
  _subscribeToIndicatorEvent($indicator, column, indicatorName) {
    if ("headerFilter" === indicatorName) {
      m_events_engine_default.on($indicator, CLICK_EVENT_NAME, this.createAction((e) => {
        e.event.stopPropagation();
        saveFocusedElementInfo($indicator, this);
        this._headerFilterController.showHeaderFilterMenu(column.index, false);
      }));
    }
  }
  _updateIndicator($cell, column, indicatorName) {
    const $indicator = super._updateIndicator($cell, column, indicatorName);
    $indicator && this._subscribeToIndicatorEvent($indicator, column, indicatorName);
  }
  _updateHeaderFilterIndicators() {
    if (this.option("headerFilter.visible")) {
      this._updateIndicators("headerFilter");
    }
  }
  _needUpdateFilterIndicators() {
    return true;
  }
  _columnOptionChanged(e) {
    const {
      optionNames
    } = e;
    const isFilterRowAndHeaderFilterValuesChanged = m_utils_default.checkChanges(optionNames, ["filterValues", "filterValue"]);
    const isHeaderFilterValuesAndTypeChanged = m_utils_default.checkChanges(optionNames, ["filterValues", "filterType"]);
    const shouldUpdateFilterIndicators = (isFilterRowAndHeaderFilterValuesChanged || isHeaderFilterValuesAndTypeChanged) && this._needUpdateFilterIndicators();
    if (shouldUpdateFilterIndicators) {
      this._updateHeaderFilterIndicators();
    }
    if (!isHeaderFilterValuesAndTypeChanged) {
      super._columnOptionChanged(e);
    }
  }
};
var headerPanel5 = (Base) => class extends headerFilterMixin(Base) {
  _createGroupPanelItem($rootElement, groupColumn) {
    const that = this;
    const $item = super._createGroupPanelItem.apply(that, arguments);
    let $headerFilterIndicator;
    if (!groupColumn.command && allowHeaderFiltering(groupColumn) && that.option("headerFilter.visible")) {
      $headerFilterIndicator = that._applyColumnState({
        name: "headerFilter",
        rootElement: $item,
        column: {
          alignment: getDefaultAlignment(that.option("rtlEnabled")),
          filterValues: groupColumn.filterValues,
          allowHeaderFiltering: true,
          caption: groupColumn.caption
        },
        showColumnLines: true
      });
      $headerFilterIndicator && m_events_engine_default.on($headerFilterIndicator, CLICK_EVENT_NAME, that.createAction((e) => {
        const {
          event
        } = e;
        event.stopPropagation();
        this._headerFilterController.showHeaderFilterMenu(groupColumn.index, true);
      }));
    }
    return $item;
  }
};
var data9 = (Base) => class extends Base {
  skipCalculateColumnFilters() {
    return false;
  }
  _calculateAdditionalFilter() {
    if (this.skipCalculateColumnFilters()) {
      return super._calculateAdditionalFilter();
    }
    const filters = [super._calculateAdditionalFilter()];
    const columns7 = this._columnsController.getVisibleColumns(null, true);
    const headerFilterController = this._headerFilterController;
    const currentColumn = headerFilterController.getCurrentColumn();
    each(columns7, (_, column) => {
      let filter;
      if (currentColumn && currentColumn.index === column.index) {
        return;
      }
      if (allowHeaderFiltering(column) && column.calculateFilterExpression && Array.isArray(column.filterValues) && column.filterValues.length) {
        let filterValues = [];
        each(column.filterValues, (_2, filterValue) => {
          if (Array.isArray(filterValue)) {
            filter = filterValue;
          } else {
            if (column.deserializeValue && !m_utils_default.isDateType(column.dataType) && "number" !== column.dataType) {
              filterValue = column.deserializeValue(filterValue);
            }
            filter = column.createFilterExpression(filterValue, "=", "headerFilter");
          }
          if (filter) {
            filter.columnIndex = column.index;
          }
          filterValues.push(filter);
        });
        filterValues = m_utils_default.combineFilters(filterValues, "or");
        filters.push("exclude" === column.filterType ? ["!", filterValues] : filterValues);
      }
    });
    return m_utils_default.combineFilters(filters);
  }
};
var headerFilterModule = {
  defaultOptions: () => ({
    syncLookupFilterValues: true,
    headerFilter: {
      visible: false,
      width: 252,
      height: 325,
      allowSelectAll: true,
      search: {
        enabled: false,
        timeout: 500,
        mode: "contains",
        editorOptions: {}
      },
      texts: {
        emptyValue: message_default.format("dxDataGrid-headerFilterEmptyValue"),
        ok: message_default.format("dxDataGrid-headerFilterOK"),
        cancel: message_default.format("dxDataGrid-headerFilterCancel")
      }
    }
  }),
  controllers: {
    headerFilter: HeaderFilterController
  },
  views: {
    headerFilterView: HeaderFilterView
  },
  extenders: {
    controllers: {
      data: data9
    },
    views: {
      columnHeadersView: columnHeadersView4,
      headerPanel: headerPanel5
    }
  }
};

// node_modules/devextreme/esm/__internal/grids/data_grid/module_not_extended/header_filter.js
m_core_default.registerModule("headerFilter", headerFilterModule);

// node_modules/devextreme/esm/__internal/filter_builder/m_between.js
function editorTemplate(conditionInfo, container) {
  const $editorStart = renderer_default("<div>").addClass("dx-filterbuilder-range-start");
  const $editorEnd = renderer_default("<div>").addClass("dx-filterbuilder-range-end");
  let values = conditionInfo.value || [];
  const getStartValue = function(values2) {
    return values2 && values2.length > 0 ? values2[0] : null;
  };
  const getEndValue = function(values2) {
    return values2 && 2 === values2.length ? values2[1] : null;
  };
  container.append($editorStart);
  container.append(renderer_default("<span>").addClass("dx-filterbuilder-range-separator").text("–"));
  container.append($editorEnd);
  container.addClass("dx-filterbuilder-range");
  this._editorFactory.createEditor.call(this, $editorStart, extend({}, conditionInfo.field, conditionInfo, {
    value: getStartValue(values),
    parentType: "filterBuilder",
    setValue(value2) {
      values = [value2, getEndValue(values)];
      conditionInfo.setValue(values);
    }
  }));
  this._editorFactory.createEditor.call(this, $editorEnd, extend({}, conditionInfo.field, conditionInfo, {
    value: getEndValue(values),
    parentType: "filterBuilder",
    setValue(value2) {
      values = [getStartValue(values), value2];
      conditionInfo.setValue(values);
    }
  }));
}
function getConfig2(caption, context2) {
  return {
    name: "between",
    caption,
    icon: "range",
    valueSeparator: "–",
    dataTypes: ["number", "date", "datetime"],
    editorTemplate: editorTemplate.bind(context2),
    notForLookup: true
  };
}

// node_modules/devextreme/esm/__internal/filter_builder/m_filter_operations_dictionary.js
var OPERATION_ICONS2 = {
  "=": "equal",
  "<>": "notequal",
  "<": "less",
  "<=": "lessorequal",
  ">": "greater",
  ">=": "greaterorequal",
  notcontains: "doesnotcontain",
  contains: "contains",
  startswith: "startswith",
  endswith: "endswith",
  isblank: "isblank",
  isnotblank: "isnotblank"
};
var OPERATION_NAME = {
  "=": "equal",
  "<>": "notEqual",
  "<": "lessThan",
  "<=": "lessThanOrEqual",
  ">": "greaterThan",
  ">=": "greaterThanOrEqual",
  startswith: "startsWith",
  contains: "contains",
  notcontains: "notContains",
  endswith: "endsWith",
  isblank: "isBlank",
  isnotblank: "isNotBlank",
  between: "between"
};
var m_filter_operations_dictionary_default = {
  getIconByFilterOperation: (filterOperation) => OPERATION_ICONS2[filterOperation],
  getNameByFilterOperation: (filterOperation) => OPERATION_NAME[filterOperation]
};

// node_modules/devextreme/esm/__internal/filter_builder/m_utils.js
var DATATYPE_OPERATIONS2 = {
  number: ["=", "<>", "<", ">", "<=", ">=", "isblank", "isnotblank"],
  string: ["contains", "notcontains", "startswith", "endswith", "=", "<>", "isblank", "isnotblank"],
  date: ["=", "<>", "<", ">", "<=", ">=", "isblank", "isnotblank"],
  datetime: ["=", "<>", "<", ">", "<=", ">=", "isblank", "isnotblank"],
  boolean: ["=", "<>", "isblank", "isnotblank"],
  object: ["isblank", "isnotblank"]
};
var DEFAULT_FORMAT = {
  date: "shortDate",
  datetime: "shortDateShortTime"
};
var LOOKUP_OPERATIONS = ["=", "<>", "isblank", "isnotblank"];
var AVAILABLE_FIELD_PROPERTIES = ["caption", "customizeText", "dataField", "dataType", "editorTemplate", "falseText", "editorOptions", "filterOperations", "format", "lookup", "trueText", "calculateFilterExpression", "name"];
function getFormattedValueText(field, value2) {
  const fieldFormat = field.format || DEFAULT_FORMAT[field.dataType];
  return format_helper_default.format(value2, fieldFormat);
}
function isNegationGroup(group) {
  return group && group.length > 1 && "!" === group[0] && !isCondition(group);
}
function getGroupCriteria(group) {
  return isNegationGroup(group) ? group[1] : group;
}
function setGroupCriteria(group, criteria) {
  if (isNegationGroup(group)) {
    group[1] = criteria;
  } else {
    group = criteria;
  }
  return group;
}
function convertGroupToNewStructure(group, value2) {
  if (function(value3) {
    return -1 !== value3.indexOf("!");
  }(value2)) {
    if (!isNegationGroup(group)) {
      !function(group2) {
        const criteria = group2.slice(0);
        group2.length = 0;
        group2.push("!", criteria);
      }(group);
    }
  } else if (isNegationGroup(group)) {
    !function(group2) {
      const criteria = getGroupCriteria(group2);
      group2.length = 0;
      [].push.apply(group2, criteria);
    }(group);
  }
}
function setGroupValue(group, value2) {
  convertGroupToNewStructure(group, value2);
  const criteria = getGroupCriteria(group);
  let i;
  value2 = function(value3) {
    return -1 === value3.indexOf("!") ? value3 : value3.substring(1);
  }(value2);
  !function(criteria2, value3) {
    for (i = 0; i < criteria2.length; i++) {
      if (!Array.isArray(criteria2[i])) {
        criteria2[i] = value3;
      }
    }
  }(criteria, value2);
  return group;
}
function getGroupMenuItem(group, availableGroups) {
  const groupValue = getGroupValue(group);
  return availableGroups.filter((item) => item.value === groupValue)[0];
}
function getCriteriaOperation(criteria) {
  if (isCondition(criteria)) {
    return "and";
  }
  let value2 = "";
  for (let i = 0; i < criteria.length; i++) {
    const item = criteria[i];
    if (!Array.isArray(item)) {
      if (value2 && value2 !== item) {
        throw errors.Error("E4019");
      }
      if ("!" !== item) {
        value2 = item;
      }
    }
  }
  return value2;
}
function getGroupValue(group) {
  const criteria = getGroupCriteria(group);
  let value2 = getCriteriaOperation(criteria);
  if (!value2) {
    value2 = "and";
  }
  if (criteria !== group) {
    value2 = `!${value2}`;
  }
  return value2;
}
function getDefaultFilterOperations(field) {
  return field.lookup && LOOKUP_OPERATIONS || DATATYPE_OPERATIONS2[field.dataType || "string"];
}
function containItems(entity) {
  return Array.isArray(entity) && entity.length;
}
function getFilterOperations(field) {
  const result2 = containItems(field.filterOperations) ? field.filterOperations : getDefaultFilterOperations(field);
  return extend([], result2);
}
function getCaptionByOperation(operation, filterOperationDescriptions) {
  const operationName = m_filter_operations_dictionary_default.getNameByFilterOperation(operation);
  return filterOperationDescriptions && filterOperationDescriptions[operationName] ? filterOperationDescriptions[operationName] : operationName;
}
function getOperationFromAvailable(operation, availableOperations) {
  for (let i = 0; i < availableOperations.length; i++) {
    if (availableOperations[i].value === operation) {
      return availableOperations[i];
    }
  }
  throw new ui_errors_default.Error("E1048", operation);
}
function getCustomOperation(customOperations, name2) {
  const filteredOperations = customOperations.filter((item) => item.name === name2);
  return filteredOperations.length ? filteredOperations[0] : null;
}
function getAvailableOperations(field, filterOperationDescriptions, customOperations) {
  const filterOperations = getFilterOperations(field);
  const isLookupField = !!field.lookup;
  customOperations.forEach((customOperation) => {
    if (!field.filterOperations && -1 === filterOperations.indexOf(customOperation.name)) {
      const dataTypes = customOperation && customOperation.dataTypes;
      const isOperationForbidden = isLookupField ? !!customOperation.notForLookup : false;
      if (!isOperationForbidden && dataTypes && dataTypes.indexOf(field.dataType || "string") >= 0) {
        filterOperations.push(customOperation.name);
      }
    }
  });
  return filterOperations.map((operation) => {
    const customOperation = getCustomOperation(customOperations, operation);
    if (customOperation) {
      return {
        icon: customOperation.icon || "icon-none",
        text: customOperation.caption || captionize(customOperation.name),
        value: customOperation.name,
        isCustom: true
      };
    }
    return {
      icon: m_filter_operations_dictionary_default.getIconByFilterOperation(operation) || "icon-none",
      text: getCaptionByOperation(operation, filterOperationDescriptions),
      value: operation
    };
  });
}
function getDefaultOperation(field) {
  return field.defaultFilterOperation || getFilterOperations(field)[0];
}
function createCondition(field, customOperations) {
  const condition = [field.dataField, "", ""];
  const filterOperation = getDefaultOperation(field);
  updateConditionByOperation(condition, filterOperation, customOperations);
  return condition;
}
function removeItem(group, item) {
  const criteria = getGroupCriteria(group);
  const index2 = criteria.indexOf(item);
  criteria.splice(index2, 1);
  if (1 !== criteria.length) {
    criteria.splice(index2, 1);
  }
  return group;
}
function createEmptyGroup(value2) {
  const isNegation = isNegationGroupOperation(value2);
  const groupOperation = isNegation ? getGroupOperationFromNegationOperation(value2) : value2;
  return isNegation ? ["!", [groupOperation]] : [groupOperation];
}
function addItem(item, group) {
  const criteria = getGroupCriteria(group);
  const groupValue = getGroupValue(criteria);
  1 === criteria.length ? criteria.unshift(item) : criteria.push(item, groupValue);
  return group;
}
function getField(dataField, fields) {
  for (let i = 0; i < fields.length; i++) {
    if (fields[i].name === dataField) {
      return fields[i];
    }
    if (fields[i].dataField.toLowerCase() === dataField.toLowerCase()) {
      return fields[i];
    }
  }
  const extendedFields = getItems2(fields, true).filter((item) => item.dataField.toLowerCase() === dataField.toLowerCase());
  if (extendedFields.length > 0) {
    return extendedFields[0];
  }
  throw new ui_errors_default.Error("E1047", dataField);
}
function isGroup(criteria) {
  if (!Array.isArray(criteria)) {
    return false;
  }
  return criteria.length < 2 || Array.isArray(criteria[0]) || Array.isArray(criteria[1]);
}
function isCondition(criteria) {
  if (!Array.isArray(criteria)) {
    return false;
  }
  return criteria.length > 1 && !Array.isArray(criteria[0]) && !Array.isArray(criteria[1]);
}
function convertToInnerGroup(group, customOperations, defaultGroupOperation) {
  defaultGroupOperation = defaultGroupOperation || "and";
  const groupOperation = getCriteriaOperation(group).toLowerCase() || defaultGroupOperation;
  let innerGroup = [];
  for (let i = 0; i < group.length; i++) {
    if (isGroup(group[i])) {
      innerGroup.push(convertToInnerStructure(group[i], customOperations, defaultGroupOperation));
      innerGroup = appendGroupOperationToGroup(innerGroup, groupOperation);
    } else if (isCondition(group[i])) {
      innerGroup.push(convertToInnerCondition(group[i], customOperations));
      innerGroup = appendGroupOperationToGroup(innerGroup, groupOperation);
    }
  }
  if (0 === innerGroup.length) {
    innerGroup = appendGroupOperationToGroup(innerGroup, groupOperation);
  }
  return innerGroup;
}
function conditionHasCustomOperation(condition, customOperations) {
  const customOperation = getCustomOperation(customOperations, condition[1]);
  return customOperation && customOperation.name === condition[1];
}
function convertToInnerCondition(condition, customOperations) {
  if (conditionHasCustomOperation(condition, customOperations)) {
    return condition;
  }
  if (condition.length < 3) {
    condition[2] = condition[1];
    condition[1] = "=";
  }
  return condition;
}
function isNegationGroupOperation(operation) {
  return -1 !== operation.indexOf("not");
}
function getGroupOperationFromNegationOperation(operation) {
  return operation.substring(3).toLowerCase();
}
function appendGroupOperationToCriteria(criteria, groupOperation) {
  const isNegation = isNegationGroupOperation(groupOperation);
  groupOperation = isNegation ? getGroupOperationFromNegationOperation(groupOperation) : groupOperation;
  return isNegation ? ["!", criteria, groupOperation] : [criteria, groupOperation];
}
function appendGroupOperationToGroup(group, groupOperation) {
  const isNegation = isNegationGroupOperation(groupOperation);
  groupOperation = isNegation ? getGroupOperationFromNegationOperation(groupOperation) : groupOperation;
  group.push(groupOperation);
  let result2 = group;
  if (isNegation) {
    result2 = ["!", result2];
  }
  return result2;
}
function convertToInnerStructure(value2, customOperations, defaultGroupOperation) {
  defaultGroupOperation = defaultGroupOperation || "and";
  if (!value2) {
    return createEmptyGroup(defaultGroupOperation);
  }
  value2 = extend(true, [], value2);
  if (isCondition(value2)) {
    return appendGroupOperationToCriteria(convertToInnerCondition(value2, customOperations), defaultGroupOperation);
  }
  if (isNegationGroup(value2)) {
    return ["!", isCondition(value2[1]) ? appendGroupOperationToCriteria(convertToInnerCondition(value2[1], customOperations), defaultGroupOperation) : isNegationGroup(value2[1]) ? appendGroupOperationToCriteria(convertToInnerStructure(value2[1], customOperations), defaultGroupOperation) : convertToInnerGroup(value2[1], customOperations, defaultGroupOperation)];
  }
  return convertToInnerGroup(value2, customOperations, defaultGroupOperation);
}
function getNormalizedFields(fields) {
  return fields.reduce((result2, field) => {
    if (isDefined(field.dataField)) {
      const normalizedField = {};
      for (const key in field) {
        if (field[key] && AVAILABLE_FIELD_PROPERTIES.includes(key)) {
          normalizedField[key] = field[key];
        }
      }
      normalizedField.defaultCalculateFilterExpression = filtering_default.defaultCalculateFilterExpression;
      if (!isDefined(normalizedField.dataType)) {
        normalizedField.dataType = "string";
      }
      if (!isDefined(normalizedField.trueText)) {
        normalizedField.trueText = message_default.format("dxDataGrid-trueText");
      }
      if (!isDefined(normalizedField.falseText)) {
        normalizedField.falseText = message_default.format("dxDataGrid-falseText");
      }
      result2.push(normalizedField);
    }
    return result2;
  }, []);
}
function getConditionFilterExpression(condition, fields, customOperations, target) {
  const field = getField(condition[0], fields);
  const filterExpression = convertToInnerCondition(condition, customOperations);
  const customOperation = customOperations.length && getCustomOperation(customOperations, filterExpression[1]);
  if (customOperation && customOperation.calculateFilterExpression) {
    return customOperation.calculateFilterExpression.apply(customOperation, [filterExpression[2], field, fields]);
  }
  if (field.createFilterExpression) {
    return field.createFilterExpression.apply(field, [filterExpression[2], filterExpression[1], target]);
  }
  if (field.calculateFilterExpression) {
    return field.calculateFilterExpression.apply(field, [filterExpression[2], filterExpression[1], target]);
  }
  return field.defaultCalculateFilterExpression.apply(field, [filterExpression[2], filterExpression[1], target]);
}
function getFilterExpression(value2, fields, customOperations, target) {
  if (!isDefined(value2)) {
    return null;
  }
  if (isNegationGroup(value2)) {
    const filterExpression2 = getFilterExpression(value2[1], fields, customOperations, target);
    return ["!", filterExpression2];
  }
  const criteria = getGroupCriteria(value2);
  if (isCondition(criteria)) {
    return getConditionFilterExpression(criteria, fields, customOperations, target) || null;
  }
  let result2 = [];
  let filterExpression;
  const groupValue = getGroupValue(criteria);
  for (let i = 0; i < criteria.length; i++) {
    if (isGroup(criteria[i])) {
      filterExpression = getFilterExpression(criteria[i], fields, customOperations, target);
      if (filterExpression) {
        i && result2.push(groupValue);
        result2.push(filterExpression);
      }
    } else if (isCondition(criteria[i])) {
      filterExpression = getConditionFilterExpression(criteria[i], fields, customOperations, target);
      if (filterExpression) {
        result2.length && result2.push(groupValue);
        result2.push(filterExpression);
      }
    }
  }
  if (1 === result2.length) {
    result2 = result2[0];
  }
  return result2.length ? result2 : null;
}
function getNormalizedFilter(group) {
  const criteria = getGroupCriteria(group);
  let i;
  if (0 === criteria.length) {
    return null;
  }
  const itemsForRemove = [];
  for (i = 0; i < criteria.length; i++) {
    if (isGroup(criteria[i])) {
      const normalizedGroupValue = getNormalizedFilter(criteria[i]);
      if (normalizedGroupValue) {
        criteria[i] = normalizedGroupValue;
      } else {
        itemsForRemove.push(criteria[i]);
      }
    } else if (isCondition(criteria[i])) {
      if (!isValidCondition(criteria[i])) {
        itemsForRemove.push(criteria[i]);
      }
    }
  }
  for (i = 0; i < itemsForRemove.length; i++) {
    removeItem(criteria, itemsForRemove[i]);
  }
  if (1 === criteria.length) {
    return null;
  }
  criteria.splice(criteria.length - 1, 1);
  if (1 === criteria.length) {
    group = setGroupCriteria(group, criteria[0]);
  }
  if (0 === group.length) {
    return null;
  }
  return group;
}
function getCurrentLookupValueText(field, value2, handler) {
  if ("" === value2) {
    handler("");
    return;
  }
  const {
    lookup
  } = field;
  if (lookup.items) {
    handler(lookup.calculateCellValue(value2) || "");
  } else {
    const lookupDataSource = isFunction(lookup.dataSource) ? lookup.dataSource({}) : lookup.dataSource;
    const dataSource = new DataSource(lookupDataSource);
    dataSource.loadSingle(lookup.valueExpr, value2).done((result2) => {
      let valueText = "";
      if (result2) {
        valueText = lookup.displayExpr ? compileGetter(lookup.displayExpr)(result2) : result2;
      }
      if (field.customizeText) {
        valueText = field.customizeText({
          value: value2,
          valueText
        });
      }
      handler(valueText);
    }).fail(() => {
      handler("");
    });
  }
}
function getPrimitiveValueText(field, value2, customOperation, target, options2) {
  let valueText;
  if (true === value2) {
    valueText = field.trueText || message_default.format("dxDataGrid-trueText");
  } else if (false === value2) {
    valueText = field.falseText || message_default.format("dxDataGrid-falseText");
  } else {
    valueText = getFormattedValueText(field, value2);
  }
  if (field.customizeText) {
    valueText = field.customizeText.call(field, {
      value: value2,
      valueText,
      target
    });
  }
  if (customOperation && customOperation.customizeText) {
    valueText = customOperation.customizeText.call(customOperation, {
      value: value2,
      valueText,
      field,
      target
    }, options2);
  }
  return valueText;
}
function getArrayValueText(field, value2, customOperation, target) {
  const options2 = {
    values: value2
  };
  return value2.map((v) => getPrimitiveValueText(field, v, customOperation, target, options2));
}
function checkDefaultValue(value2) {
  return "" === value2 || null === value2;
}
function getCurrentValueText(field, value2, customOperation) {
  let target = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : "filterBuilder";
  if (checkDefaultValue(value2)) {
    return "";
  }
  if (Array.isArray(value2)) {
    const result2 = new Deferred();
    when.apply(this, getArrayValueText(field, value2, customOperation, target)).done(function() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      const text = args.some((item) => !checkDefaultValue(item)) ? args.map((item) => !checkDefaultValue(item) ? item : "?") : "";
      result2.resolve(text);
    });
    return result2;
  }
  return getPrimitiveValueText(field, value2, customOperation, target);
}
function itemExists(plainItems, parentId) {
  return plainItems.some((item) => item.dataField === parentId);
}
function pushItemAndCheckParent(originalItems, plainItems, item) {
  const {
    dataField
  } = item;
  if (hasParent(dataField)) {
    item.parentId = getParentIdFromItemDataField(dataField);
    if (!itemExists(plainItems, item.parentId) && !itemExists(originalItems, item.parentId)) {
      pushItemAndCheckParent(originalItems, plainItems, {
        id: item.parentId,
        dataType: "object",
        dataField: item.parentId,
        caption: generateCaptionByDataField(item.parentId, true),
        filterOperations: ["isblank", "isnotblank"],
        defaultCalculateFilterExpression: filtering_default.defaultCalculateFilterExpression
      });
    }
  }
  plainItems.push(item);
}
function generateCaptionByDataField(dataField, allowHierarchicalFields) {
  let caption = "";
  if (allowHierarchicalFields) {
    dataField = dataField.substring(dataField.lastIndexOf(".") + 1);
  } else if (hasParent(dataField)) {
    dataField.split(".").forEach((field, index2, arr) => {
      caption += captionize(field);
      if (index2 !== arr.length - 1) {
        caption += ".";
      }
    });
    return caption;
  }
  return captionize(dataField);
}
function getItems2(fields, allowHierarchicalFields) {
  const items = [];
  for (let i = 0; i < fields.length; i++) {
    const item = extend(true, {
      caption: generateCaptionByDataField(fields[i].dataField, allowHierarchicalFields)
    }, fields[i]);
    item.id = item.name || item.dataField;
    if (allowHierarchicalFields) {
      pushItemAndCheckParent(fields, items, item);
    } else {
      items.push(item);
    }
  }
  return items;
}
function hasParent(dataField) {
  return -1 !== dataField.lastIndexOf(".");
}
function getParentIdFromItemDataField(dataField) {
  return dataField.substring(0, dataField.lastIndexOf("."));
}
function getCaptionWithParents(item, plainItems) {
  if (hasParent(item.dataField)) {
    const parentId = getParentIdFromItemDataField(item.dataField);
    for (let i = 0; i < plainItems.length; i++) {
      if (plainItems[i].dataField === parentId) {
        return `${getCaptionWithParents(plainItems[i], plainItems)}.${item.caption}`;
      }
    }
  }
  return item.caption;
}
function updateConditionByOperation(condition, operation, customOperations) {
  let customOperation = getCustomOperation(customOperations, operation);
  if (customOperation) {
    if (false === customOperation.hasValue) {
      condition[1] = operation;
      condition.length = 2;
    } else {
      condition[1] = operation;
      condition[2] = "";
    }
    return condition;
  }
  if ("isblank" === operation) {
    condition[1] = "=";
    condition[2] = null;
  } else if ("isnotblank" === operation) {
    condition[1] = "<>";
    condition[2] = null;
  } else {
    customOperation = getCustomOperation(customOperations, condition[1]);
    if (customOperation || 2 === condition.length || null === condition[2]) {
      condition[2] = "";
    }
    condition[1] = operation;
  }
  return condition;
}
function getOperationValue(condition) {
  let caption;
  if (null === condition[2]) {
    if ("=" === condition[1]) {
      caption = "isblank";
    } else {
      caption = "isnotblank";
    }
  } else {
    caption = condition[1];
  }
  return caption;
}
function isValidCondition(condition) {
  return "" !== condition[2];
}
function getMergedOperations(customOperations, betweenCaption, context2) {
  const result2 = extend(true, [], customOperations);
  let betweenIndex = -1;
  result2.some((customOperation, index2) => {
    if ("between" === customOperation.name) {
      betweenIndex = index2;
      return true;
    }
    return;
  });
  if (-1 !== betweenIndex) {
    result2[betweenIndex] = extend(getConfig2(betweenCaption, context2), result2[betweenIndex]);
  } else {
    result2.unshift(getConfig2(betweenCaption, context2));
  }
  return result2;
}
function isMatchedCondition(filter, addedFilterDataField) {
  return filter[0] === addedFilterDataField;
}
function removeFieldConditionsFromFilter(filter, dataField) {
  if (!filter || 0 === filter.length) {
    return null;
  }
  if (isCondition(filter)) {
    const hasMatchedCondition = isMatchedCondition(filter, dataField);
    return !hasMatchedCondition ? filter : null;
  }
  return syncConditionIntoGroup(filter, [dataField], false);
}
function syncConditionIntoGroup(filter, addedFilter, canPush) {
  const result2 = [];
  const isNegation = isNegationGroup(filter);
  filter.forEach((item) => {
    if (isCondition(item)) {
      if (isMatchedCondition(item, addedFilter[0])) {
        if (canPush) {
          result2.push(addedFilter);
          canPush = false;
        } else {
          result2.splice(result2.length - 1, 1);
        }
      } else {
        result2.push(item);
      }
    } else {
      (result2.length || isGroup(item)) && result2.push(item);
    }
  });
  if (0 === result2.length) {
    return null;
  }
  if (canPush) {
    result2.push("and");
    result2.push(addedFilter);
  }
  if (isNegation) {
    return ["!", 1 === result2.length ? result2[0] : result2];
  }
  return 1 === result2.length ? result2[0] : result2;
}
function syncFilters(filter, addedFilter) {
  if (null === filter || 0 === filter.length) {
    return addedFilter;
  }
  if (isCondition(filter)) {
    if (isMatchedCondition(filter, addedFilter[0])) {
      return addedFilter;
    }
    return [filter, "and", addedFilter];
  }
  const groupValue = getGroupValue(filter);
  if ("and" !== groupValue) {
    return [addedFilter, "and", filter];
  }
  return syncConditionIntoGroup(filter, addedFilter, true);
}
function getMatchedConditions(filter, dataField) {
  if (null === filter || 0 === filter.length) {
    return [];
  }
  if (isCondition(filter)) {
    if (isMatchedCondition(filter, dataField)) {
      return [filter];
    }
    return [];
  }
  const groupValue = getGroupValue(filter);
  if ("and" !== groupValue) {
    return [];
  }
  const result2 = filter.filter((item) => isCondition(item) && isMatchedCondition(item, dataField));
  return result2;
}
function filterHasField(filter, dataField) {
  if (null === filter || 0 === filter.length) {
    return false;
  }
  if (isCondition(filter)) {
    return filter[0] === dataField;
  }
  return filter.some((item) => (isCondition(item) || isGroup(item)) && filterHasField(item, dataField));
}
var renderValueText = function($container, value2, customOperation) {
  if (Array.isArray(value2)) {
    const lastItemIndex = value2.length - 1;
    $container.empty();
    value2.forEach((t, i) => {
      renderer_default("<span>").addClass("dx-filterbuilder-text-part").text(t).appendTo($container);
      if (i !== lastItemIndex) {
        renderer_default("<span>").addClass("dx-filterbuilder-text-separator").text(customOperation && customOperation.valueSeparator ? customOperation.valueSeparator : "|").addClass("dx-filterbuilder-text-separator-empty").appendTo($container);
      }
    });
  } else if (value2) {
    $container.text(value2);
  } else {
    $container.text(message_default.format("dxFilterBuilder-enterValueText"));
  }
};

// node_modules/devextreme/esm/__internal/grids/grid_core/filter/m_filter_custom_operations.js
function baseOperation(grid) {
  const getFullText = function(itemText, parentText) {
    return parentText ? `${parentText}/${itemText}` : itemText;
  };
  const getSelectedItemsTexts = function(items, parentText) {
    let result2 = [];
    items.forEach((item) => {
      if (item.items) {
        const selectedItemsTexts = getSelectedItemsTexts(item.items, getFullText(item.text, parentText));
        result2 = result2.concat(selectedItemsTexts);
      }
      item.selected && result2.push(getFullText(item.text, parentText));
    });
    return result2;
  };
  const headerFilterController = grid && grid.getController("headerFilter");
  return {
    dataTypes: ["string", "date", "datetime", "number", "boolean", "object"],
    calculateFilterExpression: function(filterValue, field, fields) {
      const result2 = [];
      const lastIndex = filterValue.length - 1;
      filterValue && filterValue.forEach((value2, index2) => {
        if (isCondition(value2) || isGroup(value2)) {
          const filterExpression = getFilterExpression(value2, fields, [], "headerFilter");
          result2.push(filterExpression);
        } else {
          const filterExpression = getFilterExpression([field.dataField, "=", value2], fields, [], "headerFilter");
          result2.push(filterExpression);
        }
        index2 !== lastIndex && result2.push("or");
      });
      if (1 === result2.length) {
        return result2[0];
      }
      return result2;
    },
    editorTemplate(conditionInfo, container) {
      const div = renderer_default("<div>").addClass("dx-filterbuilder-item-value-text").appendTo(container);
      const column = extend(true, {}, grid.columnOption(conditionInfo.field.dataField));
      renderValueText(div, conditionInfo.text && conditionInfo.text.split("|"));
      column.filterType = "include";
      column.filterValues = conditionInfo.value ? conditionInfo.value.slice() : [];
      headerFilterController.showHeaderFilterMenuBase({
        columnElement: div,
        column,
        apply() {
          value2 = this.filterValues, void conditionInfo.setValue(value2);
          var value2;
          headerFilterController.hideHeaderFilterMenu();
          conditionInfo.closeEditor();
        },
        onHidden() {
          conditionInfo.closeEditor();
        },
        isFilterBuilder: true
      });
      return container;
    },
    customizeText: function(fieldInfo, options2) {
      options2 = options2 || {};
      const {
        value: value2
      } = fieldInfo;
      let column = grid.columnOption(fieldInfo.field.dataField);
      const headerFilter = column && column.headerFilter;
      const lookup = column && column.lookup;
      const values = options2.values || [value2];
      if (headerFilter && headerFilter.dataSource || lookup && lookup.dataSource) {
        const result2 = new Deferred();
        const itemsDeferred = options2.items || new Deferred();
        if (!options2.items) {
          column = extend({}, column, {
            filterType: "include",
            filterValues: values
          });
          const dataSourceOptions = headerFilterController.getDataSource(column);
          dataSourceOptions.paginate = false;
          const dataSource = new DataSource(dataSourceOptions);
          const key = dataSource.store().key();
          if (key) {
            const {
              values: values2
            } = options2;
            if (values2 && values2.length > 1) {
              const filter = values2.reduce((result3, value3) => {
                if (result3.length) {
                  result3.push("or");
                }
                result3.push([key, "=", value3]);
                return result3;
              }, []);
              dataSource.filter(filter);
            } else {
              dataSource.filter([key, "=", fieldInfo.value]);
            }
          } else if (fieldInfo.field.calculateDisplayValue) {
            ui_errors_default.log("W1017");
          }
          options2.items = itemsDeferred;
          dataSource.load().done(itemsDeferred.resolve);
        }
        itemsDeferred.done((items) => {
          const index2 = values.indexOf(fieldInfo.value);
          result2.resolve(getSelectedItemsTexts(items, null)[index2]);
        });
        return result2;
      }
      const text = headerFilterController.getHeaderItemText(value2, column, 0, grid.option("headerFilter"));
      return text;
    }
  };
}
function anyOf(grid) {
  return extend(baseOperation(grid), {
    name: "anyof",
    icon: "selectall",
    caption: message_default.format("dxFilterBuilder-filterOperationAnyOf")
  });
}
function noneOf(grid) {
  const baseOp = baseOperation(grid);
  return extend({}, baseOp, {
    calculateFilterExpression(filterValue, field, fields) {
      const baseFilter = baseOp.calculateFilterExpression(filterValue, field, fields);
      if (!baseFilter || 0 === baseFilter.length) {
        return null;
      }
      return "!" === baseFilter[0] ? baseFilter : ["!", baseFilter];
    },
    name: "noneof",
    icon: "unselectall",
    caption: message_default.format("dxFilterBuilder-filterOperationNoneOf")
  });
}

// node_modules/devextreme/esm/__internal/grids/grid_core/filter/m_filter_sync.js
var FILTER_ROW_OPERATIONS = ["=", "<>", "<", "<=", ">", ">=", "notcontains", "contains", "startswith", "endswith", "between"];
function getColumnIdentifier(column) {
  return column.name || column.dataField;
}
function checkForErrors(columns7) {
  columns7.forEach((column) => {
    const identifier = getColumnIdentifier(column);
    if (!isDefined(identifier) && column.allowFiltering) {
      throw new ui_errors_default.Error("E1049", column.caption);
    }
  });
}
var getEmptyFilterValues = function() {
  return {
    filterType: "include",
    filterValues: void 0
  };
};
var canSyncHeaderFilterWithFilterRow = function(column) {
  const filterValues = column.filterValues || [];
  return !filtering_default.getGroupInterval(column) && !(column.headerFilter && column.headerFilter.dataSource) || 1 === filterValues.length && null === filterValues[0];
};
var getHeaderFilterFromCondition = function(headerFilterCondition, column) {
  if (!headerFilterCondition) {
    return getEmptyFilterValues();
  }
  let filterType;
  const selectedFilterOperation = headerFilterCondition[1];
  const value2 = headerFilterCondition[2];
  const hasArrayValue = Array.isArray(value2);
  if (!hasArrayValue) {
    if (!canSyncHeaderFilterWithFilterRow(column)) {
      return getEmptyFilterValues();
    }
  }
  switch (selectedFilterOperation) {
    case "anyof":
    case "=":
      filterType = "include";
      break;
    case "noneof":
    case "<>":
      filterType = "exclude";
      break;
    default:
      return getEmptyFilterValues();
  }
  return {
    filterType,
    filterValues: hasArrayValue ? value2 : [value2]
  };
};
var getConditionFromFilterRow = function(column) {
  const value2 = column.filterValue;
  if (isDefined(value2)) {
    const operation = column.selectedFilterOperation || column.defaultFilterOperation || getDefaultOperation(column);
    const filter = [getColumnIdentifier(column), operation, column.filterValue];
    return filter;
  }
  return null;
};
var getConditionFromHeaderFilter = function(column) {
  let selectedOperation;
  let value2;
  const {
    filterValues
  } = column;
  if (!filterValues) {
    return null;
  }
  if (1 === filterValues.length && canSyncHeaderFilterWithFilterRow(column) && !Array.isArray(filterValues[0])) {
    "exclude" === column.filterType ? selectedOperation = "<>" : selectedOperation = "=";
    value2 = filterValues[0];
  } else {
    "exclude" === column.filterType ? selectedOperation = "noneof" : selectedOperation = "anyof";
    value2 = filterValues;
  }
  return [getColumnIdentifier(column), selectedOperation, value2];
};
var updateHeaderFilterCondition = function(columnsController, column, headerFilterCondition) {
  const headerFilter = getHeaderFilterFromCondition(headerFilterCondition, column);
  columnsController.columnOption(getColumnIdentifier(column), headerFilter);
};
var updateFilterRowCondition = function(columnsController, column, condition) {
  let filterRowOptions;
  let selectedFilterOperation = null === condition || void 0 === condition ? void 0 : condition[1];
  const filterValue = null === condition || void 0 === condition ? void 0 : condition[2];
  const filterOperations = column.filterOperations || column.defaultFilterOperations;
  const selectedOperationExists = !filterOperations || filterOperations.indexOf(selectedFilterOperation) >= 0;
  const defaultOperationSelected = selectedFilterOperation === column.defaultFilterOperation;
  const builtInOperationSelected = FILTER_ROW_OPERATIONS.includes(selectedFilterOperation);
  const filterValueNotNullOrEmpty = null !== filterValue && "" !== filterValue;
  if ((selectedOperationExists || defaultOperationSelected) && builtInOperationSelected && filterValueNotNullOrEmpty) {
    if (defaultOperationSelected && !isDefined(column.selectedFilterOperation)) {
      selectedFilterOperation = column.selectedFilterOperation;
    }
    filterRowOptions = {
      filterValue,
      selectedFilterOperation
    };
  } else {
    filterRowOptions = {
      filterValue: void 0,
      selectedFilterOperation: void 0
    };
  }
  columnsController.columnOption(getColumnIdentifier(column), filterRowOptions);
};
var FilterSyncController = class extends m_modules_default.Controller {
  init() {
    this._dataController = this.getController("data");
    this._columnsController = this.getController("columns");
    if (this._dataController.isFilterSyncActive()) {
      if (this._columnsController.isAllDataTypesDefined()) {
        this._initSync();
      } else {
        this._dataController.dataSourceChanged.add(() => this._initSync());
      }
    }
  }
  publicMethods() {
    return ["getCustomFilterOperations"];
  }
  syncFilterValue() {
    const that = this;
    const columns7 = this._columnsController.getFilteringColumns();
    this._skipSyncColumnOptions = true;
    columns7.forEach((column) => {
      const filterConditions = getMatchedConditions(that.option("filterValue"), getColumnIdentifier(column));
      if (1 === filterConditions.length) {
        const filterCondition = filterConditions[0];
        updateHeaderFilterCondition(this._columnsController, column, filterCondition);
        updateFilterRowCondition(this._columnsController, column, filterCondition);
      } else {
        isDefined(column.filterValues) && updateHeaderFilterCondition(this._columnsController, column, null);
        isDefined(column.filterValue) && updateFilterRowCondition(this._columnsController, column, null);
      }
    });
    this._skipSyncColumnOptions = false;
  }
  _initSync() {
    const columns7 = this._columnsController.getColumns();
    const pageIndex = this._dataController.pageIndex();
    checkForErrors(columns7);
    if (!this.option("filterValue")) {
      const filteringColumns = this._columnsController.getFilteringColumns();
      const filterValue = this.getFilterValueFromColumns(filteringColumns);
      this._silentOption("filterValue", filterValue);
    }
    this.syncFilterValue();
    this._dataController.pageIndex(pageIndex);
  }
  _getSyncFilterRow(filterValue, column) {
    const filter = getConditionFromFilterRow(column);
    if (isDefined(filter)) {
      return syncFilters(filterValue, filter);
    }
    return removeFieldConditionsFromFilter(filterValue, getColumnIdentifier(column));
  }
  _getSyncHeaderFilter(filterValue, column) {
    const filter = getConditionFromHeaderFilter(column);
    if (filter) {
      return syncFilters(filterValue, filter);
    }
    return removeFieldConditionsFromFilter(filterValue, getColumnIdentifier(column));
  }
  getFilterValueFromColumns(columns7) {
    if (!this._dataController.isFilterSyncActive()) {
      return null;
    }
    const filterValue = ["and"];
    columns7 && columns7.forEach((column) => {
      const headerFilter = getConditionFromHeaderFilter(column);
      const filterRow = getConditionFromFilterRow(column);
      headerFilter && addItem(headerFilter, filterValue);
      filterRow && addItem(filterRow, filterValue);
    });
    return getNormalizedFilter(filterValue);
  }
  syncFilterRow(column, filterValue) {
    this.option("filterValue", this._getSyncFilterRow(this.option("filterValue"), column));
  }
  syncHeaderFilter(column) {
    this.option("filterValue", this._getSyncHeaderFilter(this.option("filterValue"), column));
  }
  getCustomFilterOperations() {
    const filterBuilderCustomOperations = this.option("filterBuilder.customOperations") ?? [];
    return [anyOf(this.component), noneOf(this.component)].concat(filterBuilderCustomOperations);
  }
};
var data10 = (Base) => class extends Base {
  optionChanged(args) {
    switch (args.name) {
      case "filterValue":
        this._applyFilter();
        this.isFilterSyncActive() && this._filterSyncController.syncFilterValue();
        args.handled = true;
        break;
      case "filterSyncEnabled":
        args.handled = true;
        break;
      case "columns":
        if (this.isFilterSyncActive()) {
          const column = this._columnsController.getColumnByPath(args.fullName);
          if (column && !this._filterSyncController._skipSyncColumnOptions) {
            const propertyName = this._parseColumnPropertyName(args.fullName);
            this._filterSyncController._skipSyncColumnOptions = true;
            if ("filterType" === propertyName) {
              if ("exclude" === args.value || "exclude" === args.previousValue) {
                this._filterSyncController.syncHeaderFilter(column);
              }
            } else if ("filterValues" === propertyName) {
              this._filterSyncController.syncHeaderFilter(column);
            } else if (["filterValue", "selectedFilterOperation"].includes(propertyName)) {
              this._filterSyncController.syncFilterRow(column, column.filterValue);
            }
            this._filterSyncController._skipSyncColumnOptions = false;
          }
        }
        super.optionChanged(args);
        break;
      default:
        super.optionChanged(args);
    }
  }
  isFilterSyncActive() {
    const filterSyncEnabledValue = this.option("filterSyncEnabled");
    return "auto" === filterSyncEnabledValue ? this.option("filterPanel.visible") : filterSyncEnabledValue;
  }
  skipCalculateColumnFilters() {
    return (isDefined(this.option("filterValue")) || this._filterSyncController._skipSyncColumnOptions) && this.isFilterSyncActive();
  }
  _calculateAdditionalFilter() {
    if (false === this.option("filterPanel.filterEnabled")) {
      return super._calculateAdditionalFilter();
    }
    const filters = [super._calculateAdditionalFilter()];
    const columns7 = this._columnsController.getFilteringColumns();
    let filterValue = this.option("filterValue");
    if (this.isFilterSyncActive()) {
      const currentColumnForHeaderFilter = this._headerFilterController.getCurrentColumn();
      const currentColumnForFilterRow = this._applyFilterController.getCurrentColumnForFiltering();
      const currentColumn = currentColumnForHeaderFilter || currentColumnForFilterRow;
      const needRemoveCurrentColumnFilter = currentColumnForHeaderFilter || isDefined(null === currentColumnForFilterRow || void 0 === currentColumnForFilterRow ? void 0 : currentColumnForFilterRow.filterValue);
      if (needRemoveCurrentColumnFilter && filterValue) {
        filterValue = removeFieldConditionsFromFilter(filterValue, getColumnIdentifier(currentColumn));
      }
    }
    const customOperations = this._filterSyncController.getCustomFilterOperations();
    const calculatedFilterValue = getFilterExpression(filterValue, columns7, customOperations, "filterBuilder");
    if (calculatedFilterValue) {
      filters.push(calculatedFilterValue);
    }
    return m_utils_default.combineFilters(filters);
  }
  _parseColumnPropertyName(fullName) {
    const matched = fullName.match(/.*\.(.*)/);
    if (matched) {
      return matched[1];
    }
    return null;
  }
  clearFilter(filterName) {
    this.component.beginUpdate();
    if (arguments.length > 0) {
      if ("filterValue" === filterName) {
        this.option("filterValue", null);
      }
      super.clearFilter(filterName);
    } else {
      this.option("filterValue", null);
      super.clearFilter();
    }
    this.component.endUpdate();
  }
  _applyFilter() {
    if (this._filterSyncController._skipSyncColumnOptions) {
      return new Deferred().resolve();
    }
    return super._applyFilter.apply(this, arguments);
  }
};
var columnHeadersView5 = (Base) => class extends Base {
  optionChanged(args) {
    if ("filterValue" === args.name) {
      this._updateHeaderFilterIndicators();
    } else {
      super.optionChanged(args);
    }
  }
  _isHeaderFilterEmpty(column) {
    if (this._dataController.isFilterSyncActive()) {
      return !filterHasField(this.option("filterValue"), getColumnIdentifier(column));
    }
    return super._isHeaderFilterEmpty(column);
  }
  _needUpdateFilterIndicators() {
    return !this._dataController.isFilterSyncActive();
  }
};
var filterSyncModule = {
  defaultOptions: () => ({
    filterValue: null,
    filterSyncEnabled: "auto"
  }),
  controllers: {
    filterSync: FilterSyncController
  },
  extenders: {
    controllers: {
      data: data10
    },
    views: {
      columnHeadersView: columnHeadersView5
    }
  }
};

// node_modules/devextreme/esm/__internal/grids/data_grid/module_not_extended/filter_sync.js
m_core_default.registerModule("filterSync", filterSyncModule);

// node_modules/devextreme/esm/__internal/filter_builder/m_filter_builder.js
var FILTER_BUILDER_IMAGE_CLASS = "dx-filterbuilder-action-icon";
var ACTIVE_CLASS = "dx-state-active";
var SOURCE = "filterBuilder";
var TREEVIEW_NODE_CONTAINER = "dx-treeview-node-container";
var ACTIONS3 = [{
  name: "onEditorPreparing",
  config: {
    excludeValidators: ["disabled", "readOnly"],
    category: "rendering"
  }
}, {
  name: "onEditorPrepared",
  config: {
    excludeValidators: ["disabled", "readOnly"],
    category: "rendering"
  }
}, {
  name: "onValueChanged",
  config: {
    excludeValidators: ["disabled", "readOnly"]
  }
}];
var OPERATORS = {
  and: "and",
  or: "or",
  notAnd: "!and",
  notOr: "!or"
};
var EditorFactory2 = ui_editor_factory_mixin_default(class {
});
var FilterBuilder = class extends ui_widget_default {
  _getDefaultOptions() {
    return extend(super._getDefaultOptions(), {
      onEditorPreparing: null,
      onEditorPrepared: null,
      onValueChanged: null,
      fields: [],
      groupOperations: ["and", "or", "notAnd", "notOr"],
      maxGroupLevel: void 0,
      value: null,
      allowHierarchicalFields: false,
      groupOperationDescriptions: {
        and: message_default.format("dxFilterBuilder-and"),
        or: message_default.format("dxFilterBuilder-or"),
        notAnd: message_default.format("dxFilterBuilder-notAnd"),
        notOr: message_default.format("dxFilterBuilder-notOr")
      },
      customOperations: [],
      closePopupOnTargetScroll: true,
      filterOperationDescriptions: {
        between: message_default.format("dxFilterBuilder-filterOperationBetween"),
        equal: message_default.format("dxFilterBuilder-filterOperationEquals"),
        notEqual: message_default.format("dxFilterBuilder-filterOperationNotEquals"),
        lessThan: message_default.format("dxFilterBuilder-filterOperationLess"),
        lessThanOrEqual: message_default.format("dxFilterBuilder-filterOperationLessOrEquals"),
        greaterThan: message_default.format("dxFilterBuilder-filterOperationGreater"),
        greaterThanOrEqual: message_default.format("dxFilterBuilder-filterOperationGreaterOrEquals"),
        startsWith: message_default.format("dxFilterBuilder-filterOperationStartsWith"),
        contains: message_default.format("dxFilterBuilder-filterOperationContains"),
        notContains: message_default.format("dxFilterBuilder-filterOperationNotContains"),
        endsWith: message_default.format("dxFilterBuilder-filterOperationEndsWith"),
        isBlank: message_default.format("dxFilterBuilder-filterOperationIsBlank"),
        isNotBlank: message_default.format("dxFilterBuilder-filterOperationIsNotBlank")
      }
    });
  }
  _optionChanged(args) {
    switch (args.name) {
      case "closePopupOnTargetScroll":
        break;
      case "onEditorPreparing":
      case "onEditorPrepared":
      case "onValueChanged":
        this._initActions();
        break;
      case "customOperations":
        this._initCustomOperations();
        this._invalidate();
        break;
      case "fields":
      case "maxGroupLevel":
      case "groupOperations":
      case "allowHierarchicalFields":
      case "groupOperationDescriptions":
      case "filterOperationDescriptions":
        this._invalidate();
        break;
      case "value":
        if (args.value !== args.previousValue) {
          const disableInvalidateForValue = this._disableInvalidateForValue;
          if (!disableInvalidateForValue) {
            this._initModel();
            this._invalidate();
          }
          this._disableInvalidateForValue = false;
          this.executeAction("onValueChanged", {
            value: args.value,
            previousValue: args.previousValue
          });
          this._disableInvalidateForValue = disableInvalidateForValue;
        }
        break;
      default:
        super._optionChanged(args);
    }
  }
  getFilterExpression() {
    const fields = this._getNormalizedFields();
    const value2 = extend(true, [], this._model);
    return getFilterExpression(getNormalizedFilter(value2), fields, this._customOperations, SOURCE);
  }
  _getNormalizedFields() {
    return getNormalizedFields(this.option("fields"));
  }
  _updateFilter() {
    this._disableInvalidateForValue = true;
    const value2 = extend(true, [], this._model);
    const normalizedValue = getNormalizedFilter(value2);
    const oldValue = getNormalizedFilter(this._getModel(this.option("value")));
    if (JSON.stringify(oldValue) !== JSON.stringify(normalizedValue)) {
      this.option("value", normalizedValue);
    }
    this._disableInvalidateForValue = false;
    this._fireContentReadyAction();
  }
  _init() {
    this._initCustomOperations();
    this._initModel();
    this._initEditorFactory();
    this._initActions();
    super._init();
  }
  _initEditorFactory() {
    this._editorFactory = new EditorFactory2();
  }
  _initCustomOperations() {
    this._customOperations = getMergedOperations(this.option("customOperations"), this.option("filterOperationDescriptions.between"), this);
  }
  _getDefaultGroupOperation() {
    var _this$option;
    return (null === (_this$option = this.option("groupOperations")) || void 0 === _this$option ? void 0 : _this$option[0]) ?? OPERATORS.and;
  }
  _getModel(value2) {
    return convertToInnerStructure(value2, this._customOperations, this._getDefaultGroupOperation());
  }
  _initModel() {
    this._model = this._getModel(this.option("value"));
  }
  _initActions() {
    const that = this;
    that._actions = {};
    ACTIONS3.forEach((action) => {
      const actionConfig = extend({}, action.config);
      that._actions[action.name] = that._createActionByOption(action.name, actionConfig);
    });
  }
  executeAction(actionName, options2) {
    const action = this._actions[actionName];
    return action && action(options2);
  }
  _initMarkup() {
    this.$element().addClass("dx-filterbuilder");
    super._initMarkup();
    this._addAriaAttributes(this.$element(), message_default.format("dxFilterBuilder-filterAriaRootElement"), "group");
    this._createGroupElementByCriteria(this._model).appendTo(this.$element());
  }
  _addAriaAttributes($element, ariaLabel, role, hasPopup, hasExpanded, ariaLevel) {
    if (!$element || !$element.length) {
      return;
    }
    const attributes = {
      role
    };
    if (ariaLabel) {
      if ($element.text().length > 0) {
        attributes.title = ariaLabel;
      } else {
        attributes["aria-label"] = ariaLabel;
      }
    }
    if (isDefined(hasPopup)) {
      attributes["aria-haspopup"] = `${hasPopup}`;
    }
    if (isDefined(hasExpanded)) {
      attributes["aria-expanded"] = `${hasExpanded}`;
    }
    if (isDefined(ariaLevel)) {
      attributes["aria-level"] = `${ariaLevel}`;
    }
    $element.attr(attributes);
  }
  _createConditionElement(condition, parent, groupLevel) {
    return renderer_default("<div>").addClass("dx-filterbuilder-group").append(this._createConditionItem(condition, parent, groupLevel)).attr("role", "group");
  }
  _createGroupElementByCriteria(criteria, parent) {
    let groupLevel = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
    const $group = this._createGroupElement(criteria, parent, groupLevel);
    const $groupContent = $group.find(".dx-filterbuilder-group-content");
    const groupCriteria = getGroupCriteria(criteria);
    for (let i = 0; i < groupCriteria.length; i++) {
      const innerCriteria = groupCriteria[i];
      if (isGroup(innerCriteria)) {
        this._createGroupElementByCriteria(innerCriteria, criteria, groupLevel + 1).appendTo($groupContent);
      } else if (isCondition(innerCriteria)) {
        this._createConditionElement(innerCriteria, criteria, `${groupLevel + 1}`).appendTo($groupContent);
      }
    }
    return $group;
  }
  _createGroupElement(criteria, parent, groupLevel) {
    const $guid = new guid_default2();
    const $groupItem = renderer_default("<div>").addClass("dx-filterbuilder-group-item");
    const $groupContent = renderer_default("<div>").addClass("dx-filterbuilder-group-content").attr("id", `${$guid}`);
    const $group = renderer_default("<div>").addClass("dx-filterbuilder-group").append($groupItem).append($groupContent);
    if (null != parent) {
      this._createRemoveButton(() => {
        removeItem(parent, criteria);
        $group.remove();
        this._updateFilter();
      }, "group").appendTo($groupItem);
    }
    let groupItemLevel = groupLevel;
    if (0 === groupLevel) {
      this._addAriaAttributes($group, "", "tree");
      groupItemLevel += 1;
    }
    this._addAriaAttributes($groupItem, message_default.format("dxFilterBuilder-filterAriaGroupItem"), "treeitem", null, null, groupItemLevel);
    $groupItem.attr("aria-owns", `${$guid}`);
    this._createGroupOperationButton(criteria).appendTo($groupItem);
    this._createAddButton(() => {
      const newGroup = createEmptyGroup(this._getDefaultGroupOperation());
      addItem(newGroup, criteria);
      this._createGroupElement(newGroup, criteria, groupLevel + 1).appendTo($groupContent);
      this._updateFilter();
    }, () => {
      const field = this.option("fields")[0];
      const newCondition = createCondition(field, this._customOperations);
      addItem(newCondition, criteria);
      this._createConditionElement(newCondition, criteria, groupLevel + 1).appendTo($groupContent);
      this._updateFilter();
    }, groupLevel).appendTo($groupItem);
    return $group;
  }
  _createButton(caption) {
    return renderer_default("<div>").text(caption);
  }
  _createGroupOperationButton(criteria) {
    const groupOperations = this._getGroupOperations(criteria);
    let groupMenuItem = getGroupMenuItem(criteria, groupOperations);
    const caption = groupMenuItem.text;
    const $operationButton = groupOperations && groupOperations.length < 2 ? this._createButton(caption).addClass("dx-state-disabled") : this._createButtonWithMenu({
      caption,
      menu: {
        items: groupOperations,
        displayExpr: "text",
        keyExpr: "value",
        onItemClick: (e) => {
          if (groupMenuItem !== e.itemData) {
            setGroupValue(criteria, e.itemData.value);
            $operationButton.text(e.itemData.text);
            groupMenuItem = e.itemData;
            this._updateFilter();
          }
        },
        onContentReady(e) {
          e.component.selectItem(groupMenuItem);
        },
        cssClass: "dx-filterbuilder-group-operations"
      }
    });
    this._addAriaAttributes($operationButton, message_default.format("dxFilterBuilder-filterAriaOperationButton"), "combobox", true, false);
    return $operationButton.addClass("dx-filterbuilder-text").addClass("dx-filterbuilder-group-operation").attr("tabindex", 0);
  }
  _createButtonWithMenu(options2) {
    const that = this;
    const removeMenu = function() {
      that.$element().find(`.${ACTIVE_CLASS}`).removeClass(ACTIVE_CLASS).attr("aria-expanded", "false");
      that.$element().find(".dx-overlay .dx-treeview").remove();
      that.$element().find(".dx-overlay").remove();
    };
    const rtlEnabled = this.option("rtlEnabled");
    const position3 = rtlEnabled ? "right" : "left";
    const $button = this._createButton(options2.caption);
    const $guid = new guid_default2();
    $button.attr("aria-controls", `${$guid}`);
    extend(options2.menu, {
      id: $guid,
      focusStateEnabled: true,
      selectionMode: "single",
      onItemClick: (handler = options2.menu.onItemClick, function(e) {
        handler(e);
        if ("dxclick" === e.event.type) {
          removeMenu();
        }
      }),
      onHiding() {
        $button.removeClass(ACTIVE_CLASS).attr("aria-expanded", "false");
      },
      position: {
        my: `${position3} top`,
        at: `${position3} bottom`,
        offset: "0 1",
        of: $button,
        collision: "flip"
      },
      animation: null,
      onHidden() {
        removeMenu();
      },
      cssClass: `dx-filterbuilder-overlay ${options2.menu.cssClass}`,
      rtlEnabled
    });
    var handler;
    options2.popup = {
      onShown(info) {
        const treeViewContentElement = renderer_default(info.component.content());
        const treeViewElement = treeViewContentElement.find(".dx-treeview");
        if (treeViewElement.length) {
          that._applyAccessibilityAttributes(treeViewElement);
        }
        m_events_engine_default.on(treeViewElement, "keyup keydown", (e) => {
          const keyName = normalizeKeyName(e);
          if ("keydown" === e.type && "tab" === keyName || "keyup" === e.type && ("escape" === keyName || "enter" === keyName)) {
            info.component.hide();
            m_events_engine_default.trigger(options2.menu.position.of, "focus");
          }
        });
        const treeView = treeViewElement.dxTreeView("instance");
        treeView.focus();
        treeView.option("focusedElement", null);
      }
    };
    this._subscribeOnClickAndEnterKey($button, () => {
      removeMenu();
      that._createPopupWithTreeView(options2, that.$element());
      $button.addClass(ACTIVE_CLASS).attr("aria-expanded", "true");
    });
    return $button;
  }
  _hasValueButton(condition) {
    const customOperation = getCustomOperation(this._customOperations, condition[1]);
    return customOperation ? false !== customOperation.hasValue : null !== condition[2];
  }
  _createOperationButtonWithMenu(condition, field) {
    const that = this;
    const availableOperations = getAvailableOperations(field, this.option("filterOperationDescriptions"), this._customOperations);
    let currentOperation = getOperationFromAvailable(getOperationValue(condition), availableOperations);
    const $operationButton = this._createButtonWithMenu({
      caption: currentOperation.text,
      menu: {
        items: availableOperations,
        displayExpr: "text",
        onItemRendered(e) {
          e.itemData.isCustom && renderer_default(e.itemElement).addClass("dx-filterbuilder-menu-custom-operation");
        },
        onContentReady(e) {
          e.component.selectItem(currentOperation);
        },
        onItemClick: (e) => {
          if (currentOperation !== e.itemData) {
            currentOperation = e.itemData;
            updateConditionByOperation(condition, currentOperation.value, that._customOperations);
            const $valueButton = $operationButton.siblings().filter(".dx-filterbuilder-item-value");
            if (that._hasValueButton(condition)) {
              if (0 !== $valueButton.length) {
                $valueButton.remove();
              }
              that._createValueButton(condition, field).appendTo($operationButton.parent());
            } else {
              $valueButton.remove();
            }
            $operationButton.text(currentOperation.text);
            this._updateFilter();
          }
        },
        cssClass: "dx-filterbuilder-operations"
      }
    }).addClass("dx-filterbuilder-text").addClass("dx-filterbuilder-item-operation").attr("tabindex", 0);
    this._addAriaAttributes($operationButton, message_default.format("dxFilterBuilder-filterAriaItemOperation"), "combobox", true, false);
    return $operationButton;
  }
  _createOperationAndValueButtons(condition, field, $item) {
    this._createOperationButtonWithMenu(condition, field).appendTo($item);
    if (this._hasValueButton(condition)) {
      this._createValueButton(condition, field).appendTo($item);
    }
  }
  _createFieldButtonWithMenu(fields, condition, field) {
    const that = this;
    const allowHierarchicalFields = this.option("allowHierarchicalFields");
    const items = getItems2(fields, allowHierarchicalFields);
    let item = getField(field.name || field.dataField, items);
    const getFullCaption = function(item2, items2) {
      return allowHierarchicalFields ? getCaptionWithParents(item2, items2) : item2.caption;
    };
    condition[0] = item.name || item.dataField;
    const $fieldButton = this._createButtonWithMenu({
      caption: getFullCaption(item, items),
      menu: {
        items,
        dataStructure: "plain",
        keyExpr: "id",
        parentId: "parentId",
        displayExpr: "caption",
        onItemClick: (e) => {
          if (item !== e.itemData) {
            item = e.itemData;
            condition[0] = item.name || item.dataField;
            condition[2] = "object" === item.dataType ? null : "";
            updateConditionByOperation(condition, getDefaultOperation(item), that._customOperations);
            $fieldButton.siblings().filter(".dx-filterbuilder-text").remove();
            that._createOperationAndValueButtons(condition, item, $fieldButton.parent());
            const caption = getFullCaption(item, e.component.option("items"));
            $fieldButton.text(caption);
            this._updateFilter();
          }
        },
        onContentReady(e) {
          e.component.selectItem(item);
        },
        cssClass: "dx-filterbuilder-fields"
      }
    }).addClass("dx-filterbuilder-text").addClass("dx-filterbuilder-item-field").attr("tabindex", 0);
    this._addAriaAttributes($fieldButton, message_default.format("dxFilterBuilder-filterAriaItemField"), "combobox", true, false);
    return $fieldButton;
  }
  _createConditionItem(condition, parent, groupLevel) {
    const $item = renderer_default("<div>").addClass("dx-filterbuilder-group-item");
    const fields = this._getNormalizedFields();
    const field = getField(condition[0], fields);
    this._addAriaAttributes($item, "", "treeitem", null, null, groupLevel);
    this._createRemoveButton(() => {
      removeItem(parent, condition);
      const isSingleChild = 1 === $item.parent().children().length;
      if (isSingleChild) {
        $item.parent().remove();
      } else {
        $item.remove();
      }
      this._updateFilter();
    }, "condition").appendTo($item);
    this._createFieldButtonWithMenu(fields, condition, field).appendTo($item);
    this._createOperationAndValueButtons(condition, field, $item);
    return $item;
  }
  _getGroupOperations(criteria) {
    let groupOperations = this.option("groupOperations");
    const groupOperationDescriptions = this.option("groupOperationDescriptions");
    if (!groupOperations || !groupOperations.length) {
      groupOperations = [getGroupValue(criteria).replace("!", "not")];
    }
    return groupOperations.map((operation) => ({
      text: groupOperationDescriptions[operation],
      value: OPERATORS[operation]
    }));
  }
  _createRemoveButton(handler, type2) {
    const $removeButton = renderer_default("<div>").addClass(FILTER_BUILDER_IMAGE_CLASS).addClass("dx-icon-remove").addClass("dx-filterbuilder-action").attr("tabindex", 0);
    if (type2) {
      const removeMessage = message_default.format("dxFilterBuilder-filterAriaRemoveButton", type2);
      this._addAriaAttributes($removeButton, removeMessage, "button");
    }
    this._subscribeOnClickAndEnterKey($removeButton, handler);
    return $removeButton;
  }
  _createAddButton(addGroupHandler, addConditionHandler, groupLevel) {
    let $button;
    const maxGroupLevel = this.option("maxGroupLevel");
    if (isDefined(maxGroupLevel) && groupLevel >= maxGroupLevel) {
      $button = this._createButton();
      this._subscribeOnClickAndEnterKey($button, addConditionHandler);
    } else {
      $button = this._createButtonWithMenu({
        menu: {
          items: [{
            caption: message_default.format("dxFilterBuilder-addCondition"),
            click: addConditionHandler
          }, {
            caption: message_default.format("dxFilterBuilder-addGroup"),
            click: addGroupHandler
          }],
          displayExpr: "caption",
          onItemClick(e) {
            e.itemData.click();
          },
          cssClass: "dx-filterbuilder-add-condition"
        }
      });
    }
    this._addAriaAttributes($button, message_default.format("dxFilterBuilder-filterAriaAddButton"), "combobox", true, false);
    return $button.addClass(FILTER_BUILDER_IMAGE_CLASS).addClass("dx-icon-plus").addClass("dx-filterbuilder-action").attr("tabindex", 0);
  }
  _createValueText(item, field, $container) {
    const that = this;
    const $text = renderer_default("<div>").html("&nbsp;").addClass("dx-filterbuilder-item-value-text").attr("tabindex", 0).appendTo($container);
    this._addAriaAttributes($text, message_default.format("dxFilterBuilder-filterAriaItemValue"), "button", true);
    const value2 = item[2];
    const customOperation = getCustomOperation(that._customOperations, item[1]);
    if (!customOperation && field.lookup) {
      getCurrentLookupValueText(field, value2, (result2) => {
        renderValueText($text, result2);
      });
    } else {
      when(getCurrentValueText(field, value2, customOperation)).done((result2) => {
        renderValueText($text, result2, customOperation);
      });
    }
    that._subscribeOnClickAndEnterKey($text, (e) => {
      if ("keyup" === e.type) {
        e.stopPropagation();
      }
      that._createValueEditorWithEvents(item, field, $container);
    });
    return $text;
  }
  _updateConditionValue(item, value2, callback) {
    const areValuesDifferent = item[2] !== value2;
    if (areValuesDifferent) {
      item[2] = value2;
    }
    callback();
    this._updateFilter();
  }
  _addDocumentKeyUp($editor, handler) {
    let isComposing = false;
    let hasCompositionJustEnded = false;
    const document2 = dom_adapter_default.getDocument();
    const documentKeyUpHandler = (e) => {
      if (isComposing || hasCompositionJustEnded) {
        hasCompositionJustEnded = false;
        return;
      }
      handler(e);
    };
    m_events_engine_default.on(document2, "keyup", documentKeyUpHandler);
    const input = $editor.find("input");
    m_events_engine_default.on(input, "compositionstart", () => {
      isComposing = true;
    });
    m_events_engine_default.on(input, "compositionend", () => {
      isComposing = false;
      hasCompositionJustEnded = true;
    });
    m_events_engine_default.on(input, "keydown", (event) => {
      if (229 !== event.which) {
        hasCompositionJustEnded = false;
      }
    });
    this._documentKeyUpHandler = documentKeyUpHandler;
  }
  _addDocumentClick($editor, closeEditorFunc) {
    const document2 = dom_adapter_default.getDocument();
    const documentClickHandler = (e) => {
      if (!this._isFocusOnEditorParts($editor, e.target)) {
        m_events_engine_default.trigger($editor.find("input"), "change");
        closeEditorFunc();
      }
    };
    m_events_engine_default.on(document2, "dxpointerdown", documentClickHandler);
    this._documentClickHandler = documentClickHandler;
  }
  _isFocusOnEditorParts($editor, target) {
    const activeElement = target || dom_adapter_default.getActiveElement();
    return renderer_default(activeElement).closest($editor.children()).length || renderer_default(activeElement).closest(".dx-dropdowneditor-overlay").length;
  }
  _removeEvents() {
    const document2 = dom_adapter_default.getDocument();
    isDefined(this._documentKeyUpHandler) && m_events_engine_default.off(document2, "keyup", this._documentKeyUpHandler);
    isDefined(this._documentClickHandler) && m_events_engine_default.off(document2, "dxpointerdown", this._documentClickHandler);
  }
  _dispose() {
    this._removeEvents();
    super._dispose();
  }
  _createValueEditorWithEvents(item, field, $container) {
    let value2 = item[2];
    const createValueText = () => {
      $container.empty();
      this._removeEvents();
      return this._createValueText(item, field, $container);
    };
    const closeEditor = () => {
      this._updateConditionValue(item, value2, () => {
        createValueText();
      });
    };
    const options2 = {
      value: "" === value2 ? null : value2,
      filterOperation: getOperationValue(item),
      setValue(data17) {
        value2 = null === data17 ? "" : data17;
      },
      closeEditor,
      text: $container.text()
    };
    $container.empty();
    const $editor = this._createValueEditor($container, field, options2);
    m_events_engine_default.trigger($editor.find("input").not(":hidden").eq(0), "focus");
    this._removeEvents();
    this._addDocumentClick($editor, closeEditor);
    this._addDocumentKeyUp($editor, (e) => {
      const keyName = normalizeKeyName(e);
      if ("tab" === keyName) {
        if (this._isFocusOnEditorParts($editor)) {
          return;
        }
        this._updateConditionValue(item, value2, () => {
          createValueText();
          if (e.shiftKey) {
            m_events_engine_default.trigger($container.prev(), "focus");
          }
        });
      }
      if ("escape" === keyName) {
        m_events_engine_default.trigger(createValueText(), "focus");
      }
      if ("enter" === keyName) {
        this._updateConditionValue(item, value2, () => {
          m_events_engine_default.trigger(createValueText(), "focus");
        });
      }
    });
    this._fireContentReadyAction();
  }
  _createValueButton(item, field) {
    const $valueButton = renderer_default("<div>").addClass("dx-filterbuilder-text").addClass("dx-filterbuilder-item-value");
    this._createValueText(item, field, $valueButton);
    return $valueButton;
  }
  _createValueEditor($container, field, options2) {
    const $editor = renderer_default("<div>").attr("tabindex", 0).appendTo($container);
    const customOperation = getCustomOperation(this._customOperations, options2.filterOperation);
    const editorTemplate2 = customOperation && customOperation.editorTemplate ? customOperation.editorTemplate : field.editorTemplate;
    if (editorTemplate2) {
      const template = this._getTemplate(editorTemplate2);
      template.render({
        model: extend({
          field
        }, options2),
        container: $editor
      });
    } else {
      this._editorFactory.createEditor.call(this, $editor, extend({}, field, options2, {
        parentType: SOURCE
      }));
    }
    return $editor;
  }
  _createPopupWithTreeView(options2, $container) {
    const that = this;
    const $popup = renderer_default("<div>").addClass(options2.menu.cssClass).appendTo($container);
    this._createComponent($popup, ui_popup_default, {
      onHiding: options2.menu.onHiding,
      onHidden: options2.menu.onHidden,
      rtlEnabled: options2.menu.rtlEnabled,
      position: options2.menu.position,
      animation: options2.menu.animation,
      contentTemplate(contentElement) {
        const $menuContainer = renderer_default("<div>").appendTo(contentElement);
        that._createComponent($menuContainer, tree_view_default, options2.menu);
        $menuContainer.attr("id", `${options2.menu.id}`);
        this.repaint();
      },
      _ignoreFunctionValueDeprecation: true,
      maxHeight: () => getElementMaxHeightByWindow(options2.menu.position.of),
      visible: true,
      focusStateEnabled: false,
      preventScrollEvents: false,
      container: $popup,
      hideOnOutsideClick: true,
      onShown: options2.popup.onShown,
      shading: false,
      width: "auto",
      height: "auto",
      showTitle: false,
      _wrapperClassExternal: options2.menu.cssClass,
      _ignorePreventScrollEventsDeprecation: true
    });
  }
  _subscribeOnClickAndEnterKey($button, handler) {
    m_events_engine_default.on($button, "dxclick", handler);
    m_events_engine_default.on($button, "keyup", (e) => {
      if ("enter" === normalizeKeyName(e)) {
        handler(e);
      }
    });
  }
  _applyAccessibilityAttributes($element) {
    var _treeViewPopup$find;
    const treeViewPopup = $element.closest(".dx-overlay-content");
    null === treeViewPopup || void 0 === treeViewPopup || treeViewPopup.removeAttr("role");
    const treeViewNode = null === treeViewPopup || void 0 === treeViewPopup || null === (_treeViewPopup$find = treeViewPopup.find) || void 0 === _treeViewPopup$find ? void 0 : _treeViewPopup$find.call(treeViewPopup, `.${TREEVIEW_NODE_CONTAINER}`);
    null === treeViewNode || void 0 === treeViewNode || treeViewNode.attr("role", "presentation");
  }
};
component_registrator_default("dxFilterBuilder", FilterBuilder);
var m_filter_builder_default = FilterBuilder;

// node_modules/devextreme/esm/ui/filter_builder.js
var filter_builder_default = m_filter_builder_default;

// node_modules/devextreme/esm/__internal/grids/grid_core/filter/m_filter_builder.js
var FilterBuilderView = class extends m_modules_default.View {
  init() {
    super.init();
    this._columnsController = this.getController("columns");
    this._filterSyncController = this.getController("filterSync");
  }
  optionChanged(args) {
    switch (args.name) {
      case "filterBuilder":
      case "filterBuilderPopup":
        this._invalidate();
        args.handled = true;
        break;
      default:
        super.optionChanged(args);
    }
  }
  _renderCore() {
    this._updatePopupOptions();
  }
  _updatePopupOptions() {
    if (this.option("filterBuilderPopup.visible")) {
      this._initPopup();
    } else if (this._filterBuilderPopup) {
      this._filterBuilderPopup.hide();
    }
  }
  _disposePopup() {
    if (this._filterBuilderPopup) {
      this._filterBuilderPopup.dispose();
      this._filterBuilderPopup = void 0;
    }
    if (this._filterBuilder) {
      this._filterBuilder.dispose();
      this._filterBuilder = void 0;
    }
  }
  _initPopup() {
    const that = this;
    that._disposePopup();
    that._filterBuilderPopup = that._createComponent(that.element(), ui_popup_default, extend({
      title: message_default.format("dxDataGrid-filterBuilderPopupTitle"),
      contentTemplate: ($contentElement) => that._getPopupContentTemplate($contentElement),
      onOptionChanged(args) {
        if ("visible" === args.name) {
          that.option("filterBuilderPopup.visible", args.value);
        }
      },
      toolbarItems: that._getPopupToolbarItems()
    }, that.option("filterBuilderPopup"), {
      onHidden() {
        restoreFocus(that);
        that._disposePopup();
      }
    }));
  }
  _getPopupContentTemplate(contentElement) {
    const $contentElement = renderer_default(contentElement);
    const $filterBuilderContainer = renderer_default("<div>").appendTo(renderer_default(contentElement));
    this._filterBuilder = this._createComponent($filterBuilderContainer, filter_builder_default, extend({
      value: this.option("filterValue"),
      fields: this._columnsController.getFilteringColumns()
    }, this.option("filterBuilder"), {
      customOperations: this._filterSyncController.getCustomFilterOperations()
    }));
    this._createComponent($contentElement, scroll_view_default, {
      direction: "both"
    });
  }
  _getPopupToolbarItems() {
    const that = this;
    return [{
      toolbar: "bottom",
      location: "after",
      widget: "dxButton",
      options: {
        text: message_default.format("OK"),
        onClick() {
          const filter = that._filterBuilder.option("value");
          that.option("filterValue", filter);
          that._filterBuilderPopup.hide();
        }
      }
    }, {
      toolbar: "bottom",
      location: "after",
      widget: "dxButton",
      options: {
        text: message_default.format("Cancel"),
        onClick() {
          that._filterBuilderPopup.hide();
        }
      }
    }];
  }
};
var filterBuilderModule = {
  defaultOptions: () => ({
    filterBuilder: {
      groupOperationDescriptions: {
        and: message_default.format("dxFilterBuilder-and"),
        or: message_default.format("dxFilterBuilder-or"),
        notAnd: message_default.format("dxFilterBuilder-notAnd"),
        notOr: message_default.format("dxFilterBuilder-notOr")
      },
      filterOperationDescriptions: {
        between: message_default.format("dxFilterBuilder-filterOperationBetween"),
        equal: message_default.format("dxFilterBuilder-filterOperationEquals"),
        notEqual: message_default.format("dxFilterBuilder-filterOperationNotEquals"),
        lessThan: message_default.format("dxFilterBuilder-filterOperationLess"),
        lessThanOrEqual: message_default.format("dxFilterBuilder-filterOperationLessOrEquals"),
        greaterThan: message_default.format("dxFilterBuilder-filterOperationGreater"),
        greaterThanOrEqual: message_default.format("dxFilterBuilder-filterOperationGreaterOrEquals"),
        startsWith: message_default.format("dxFilterBuilder-filterOperationStartsWith"),
        contains: message_default.format("dxFilterBuilder-filterOperationContains"),
        notContains: message_default.format("dxFilterBuilder-filterOperationNotContains"),
        endsWith: message_default.format("dxFilterBuilder-filterOperationEndsWith"),
        isBlank: message_default.format("dxFilterBuilder-filterOperationIsBlank"),
        isNotBlank: message_default.format("dxFilterBuilder-filterOperationIsNotBlank")
      }
    },
    filterBuilderPopup: {}
  }),
  views: {
    filterBuilderView: FilterBuilderView
  }
};

// node_modules/devextreme/esm/__internal/grids/data_grid/module_not_extended/filter_builder.js
m_core_default.registerModule("filterBuilder", filterBuilderModule);

// node_modules/devextreme/esm/__internal/grids/grid_core/filter/m_filter_panel.js
var FilterPanelView = class extends m_modules_default.View {
  init() {
    this._dataController = this.getController("data");
    this._columnsController = this.getController("columns");
    this._filterSyncController = this.getController("filterSync");
    this._dataController.dataSourceChanged.add(() => this.render());
  }
  isVisible() {
    return this.option("filterPanel.visible") && this._dataController.dataSource();
  }
  _renderCore() {
    const $element = this.element();
    $element.empty();
    const isColumnsDefined = !!this._columnsController.getColumns().length;
    if (!isColumnsDefined) {
      return;
    }
    $element.addClass(this.addWidgetPrefix("filter-panel"));
    const $leftContainer = renderer_default("<div>").addClass(this.addWidgetPrefix("filter-panel-left")).appendTo($element);
    this._renderFilterBuilderText($element, $leftContainer);
  }
  _renderFilterBuilderText($element, $leftContainer) {
    const $filterElement = this._getFilterElement();
    const $textElement = this._getTextElement();
    if (this.option("filterValue") || this._filterValueBuffer) {
      const $checkElement = this._getCheckElement();
      const $removeButtonElement = this._getRemoveButtonElement();
      $leftContainer.append($checkElement).append($filterElement).append($textElement);
      $element.append($removeButtonElement);
      return;
    }
    $leftContainer.append($filterElement).append($textElement);
  }
  _getCheckElement() {
    const that = this;
    const $element = renderer_default("<div>").addClass(this.addWidgetPrefix("filter-panel-checkbox"));
    that._createComponent($element, check_box_default2, {
      value: that.option("filterPanel.filterEnabled"),
      onValueChanged(e) {
        that.option("filterPanel.filterEnabled", e.value);
      }
    });
    $element.attr("title", this.option("filterPanel.texts.filterEnabledHint"));
    return $element;
  }
  _getFilterElement() {
    const that = this;
    const $element = renderer_default("<div>").addClass("dx-icon-filter");
    m_events_engine_default.on($element, "click", () => that._showFilterBuilder());
    registerKeyboardAction2("filterPanel", that, $element, void 0, () => that._showFilterBuilder());
    that._addTabIndexToElement($element);
    return $element;
  }
  _getTextElement() {
    const that = this;
    const $textElement = renderer_default("<div>").addClass(that.addWidgetPrefix("filter-panel-text"));
    let filterText;
    const filterValue = that.option("filterValue");
    if (filterValue) {
      when(that.getFilterText(filterValue, this._filterSyncController.getCustomFilterOperations())).done((filterText2) => {
        const customizeText = that.option("filterPanel.customizeText");
        if (customizeText) {
          const customText = customizeText({
            component: that.component,
            filterValue,
            text: filterText2
          });
          if ("string" === typeof customText) {
            filterText2 = customText;
          }
        }
        $textElement.text(filterText2);
      });
    } else {
      filterText = that.option("filterPanel.texts.createFilter");
      $textElement.text(filterText);
    }
    m_events_engine_default.on($textElement, "click", () => that._showFilterBuilder());
    registerKeyboardAction2("filterPanel", that, $textElement, void 0, () => that._showFilterBuilder());
    that._addTabIndexToElement($textElement);
    return $textElement;
  }
  _showFilterBuilder() {
    this.option("filterBuilderPopup.visible", true);
  }
  _getRemoveButtonElement() {
    const that = this;
    const clearFilterValue = () => that.option("filterValue", null);
    const $element = renderer_default("<div>").addClass(that.addWidgetPrefix("filter-panel-clear-filter")).text(that.option("filterPanel.texts.clearFilter"));
    m_events_engine_default.on($element, "click", clearFilterValue);
    registerKeyboardAction2("filterPanel", this, $element, void 0, clearFilterValue);
    that._addTabIndexToElement($element);
    return $element;
  }
  _addTabIndexToElement($element) {
    if (!this.option("useLegacyKeyboardNavigation")) {
      const tabindex = this.option("tabindex") || 0;
      $element.attr("tabindex", tabindex);
    }
  }
  optionChanged(args) {
    switch (args.name) {
      case "filterValue":
        this._invalidate();
        this.option("filterPanel.filterEnabled", true);
        args.handled = true;
        break;
      case "filterPanel":
        this._invalidate();
        args.handled = true;
        break;
      default:
        super.optionChanged(args);
    }
  }
  _getConditionText(fieldText, operationText, valueText) {
    let result2 = `[${fieldText}] ${operationText}`;
    if (isDefined(valueText)) {
      result2 += valueText;
    }
    return result2;
  }
  _getValueMaskedText(value2) {
    return Array.isArray(value2) ? `('${value2.join("', '")}')` : ` '${value2}'`;
  }
  _getValueText(field, customOperation, value2) {
    const deferred = new Deferred();
    const hasCustomOperation = customOperation && customOperation.customizeText;
    if (isDefined(value2) || hasCustomOperation) {
      if (!hasCustomOperation && field.lookup) {
        getCurrentLookupValueText(field, value2, (data17) => {
          deferred.resolve(this._getValueMaskedText(data17));
        });
      } else {
        const displayValue = Array.isArray(value2) ? value2 : m_utils_default.getDisplayValue(field, value2, null);
        when(getCurrentValueText(field, displayValue, customOperation, "filterPanel")).done((data17) => {
          deferred.resolve(this._getValueMaskedText(data17));
        });
      }
    } else {
      deferred.resolve("");
    }
    return deferred.promise();
  }
  getConditionText(filterValue, options2) {
    const that = this;
    const operation = filterValue[1];
    const deferred = new Deferred();
    const customOperation = getCustomOperation(options2.customOperations, operation);
    let operationText;
    const field = getField(filterValue[0], options2.columns);
    const fieldText = field.caption || "";
    const value2 = filterValue[2];
    if (customOperation) {
      operationText = customOperation.caption || m_inflector_default.captionize(customOperation.name);
    } else if (null === value2) {
      operationText = getCaptionByOperation("=" === operation ? "isblank" : "isnotblank", options2.filterOperationDescriptions);
    } else {
      operationText = getCaptionByOperation(operation, options2.filterOperationDescriptions);
    }
    this._getValueText(field, customOperation, value2).done((valueText) => {
      deferred.resolve(that._getConditionText(fieldText, operationText, valueText));
    });
    return deferred;
  }
  getGroupText(filterValue, options2, isInnerGroup) {
    const that = this;
    const result2 = new Deferred();
    const textParts = [];
    const groupValue = getGroupValue(filterValue);
    filterValue.forEach((item) => {
      if (isCondition(item)) {
        textParts.push(that.getConditionText(item, options2));
      } else if (isGroup(item)) {
        textParts.push(that.getGroupText(item, options2, true));
      }
    });
    when.apply(this, textParts).done(function() {
      let text;
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      if (groupValue.startsWith("!")) {
        const groupText = options2.groupOperationDescriptions[`not${groupValue.substring(1, 2).toUpperCase()}${groupValue.substring(2)}`].split(" ");
        text = `${groupText[0]} ${args[0]}`;
      } else {
        text = args.join(` ${options2.groupOperationDescriptions[groupValue]} `);
      }
      if (isInnerGroup) {
        text = `(${text})`;
      }
      result2.resolve(text);
    });
    return result2;
  }
  getFilterText(filterValue, customOperations) {
    const options2 = {
      customOperations,
      columns: this._columnsController.getFilteringColumns(),
      filterOperationDescriptions: this.option("filterBuilder.filterOperationDescriptions"),
      groupOperationDescriptions: this.option("filterBuilder.groupOperationDescriptions")
    };
    return isCondition(filterValue) ? this.getConditionText(filterValue, options2) : this.getGroupText(filterValue, options2);
  }
};
var data11 = (Base) => class extends Base {
  optionChanged(args) {
    if ("filterPanel" === args.name) {
      this._applyFilter();
      args.handled = true;
    } else {
      super.optionChanged(args);
    }
  }
};
var filterPanelModule = {
  defaultOptions: () => ({
    filterPanel: {
      visible: false,
      filterEnabled: true,
      texts: {
        createFilter: message_default.format("dxDataGrid-filterPanelCreateFilter"),
        clearFilter: message_default.format("dxDataGrid-filterPanelClearFilter"),
        filterEnabledHint: message_default.format("dxDataGrid-filterPanelFilterEnabledHint")
      }
    }
  }),
  views: {
    filterPanelView: FilterPanelView
  },
  extenders: {
    controllers: {
      data: data11
    }
  }
};

// node_modules/devextreme/esm/__internal/grids/data_grid/module_not_extended/filter_panel.js
m_core_default.registerModule("filterPanel", filterPanelModule);

// node_modules/devextreme/esm/__internal/grids/grid_core/search/m_search.js
function allowSearch(column) {
  return !!(column.allowSearch ?? column.allowFiltering);
}
function parseValue2(column, text) {
  const {
    lookup
  } = column;
  if (!column.parseValue) {
    return text;
  }
  if (lookup) {
    return column.parseValue.call(lookup, text);
  }
  return column.parseValue(text);
}
var dataController = (base2) => class extends base2 {
  optionChanged(args) {
    switch (args.fullName) {
      case "searchPanel.text":
      case "searchPanel":
        this._applyFilter();
        args.handled = true;
        break;
      default:
        super.optionChanged(args);
    }
  }
  publicMethods() {
    return super.publicMethods().concat(["searchByText"]);
  }
  _calculateAdditionalFilter() {
    var _this$_dataController, _this$_dataController2, _dataSource$loadOptio;
    const dataSource = null === (_this$_dataController = this._dataController) || void 0 === _this$_dataController || null === (_this$_dataController2 = _this$_dataController.getDataSource) || void 0 === _this$_dataController2 ? void 0 : _this$_dataController2.call(_this$_dataController);
    const langParams = null === dataSource || void 0 === dataSource || null === (_dataSource$loadOptio = dataSource.loadOptions) || void 0 === _dataSource$loadOptio || null === (_dataSource$loadOptio = _dataSource$loadOptio.call(dataSource)) || void 0 === _dataSource$loadOptio ? void 0 : _dataSource$loadOptio.langParams;
    const filter = super._calculateAdditionalFilter();
    const searchFilter = this.calculateSearchFilter(this.option("searchPanel.text"), langParams);
    return m_utils_default.combineFilters([filter, searchFilter]);
  }
  searchByText(text) {
    this.option("searchPanel.text", text);
  }
  calculateSearchFilter(text, langParams) {
    let column;
    const columns7 = this._columnsController.getColumns();
    const searchVisibleColumnsOnly = this.option("searchPanel.searchVisibleColumnsOnly");
    let lookup;
    const filters = [];
    if (!text) {
      return null;
    }
    function onQueryDone(items) {
      const valueGetter = compileGetter(lookup.valueExpr);
      for (let i = 0; i < items.length; i++) {
        const value2 = valueGetter(items[i]);
        filters.push(column.createFilterExpression(value2, null, "search"));
      }
    }
    for (let i = 0; i < columns7.length; i++) {
      column = columns7[i];
      if (searchVisibleColumnsOnly && !column.visible) {
        continue;
      }
      if (allowSearch(column) && column.calculateFilterExpression) {
        var _lookup;
        lookup = column.lookup;
        const filterValue = parseValue2(column, text);
        if (null !== (_lookup = lookup) && void 0 !== _lookup && _lookup.items) {
          m_query_default(lookup.items, {
            langParams
          }).filter(column.createFilterExpression.call({
            dataField: lookup.displayExpr,
            dataType: lookup.dataType,
            calculateFilterExpression: column.calculateFilterExpression
          }, filterValue, null, "search")).enumerate().done(onQueryDone);
        } else if (void 0 !== filterValue) {
          filters.push(column.createFilterExpression(filterValue, null, "search"));
        }
      }
    }
    if (0 === filters.length) {
      return ["!"];
    }
    return m_utils_default.combineFilters(filters, "or");
  }
};
var headerPanel6 = (Base) => class extends Base {
  optionChanged(args) {
    if ("searchPanel" === args.name) {
      if ("searchPanel.text" === args.fullName) {
        const editor = this.getSearchTextEditor();
        if (editor) {
          editor.option("value", args.value);
        }
      } else {
        this._invalidate();
      }
      args.handled = true;
    } else {
      super.optionChanged(args);
    }
  }
  _getToolbarItems() {
    const items = super._getToolbarItems();
    return this._prepareSearchItem(items);
  }
  _prepareSearchItem(items) {
    const that = this;
    const dataController2 = this._dataController;
    const searchPanelOptions = this.option("searchPanel");
    if (searchPanelOptions && searchPanelOptions.visible) {
      const toolbarItem = {
        template(data17, index2, container) {
          const $search = renderer_default("<div>").addClass(that.addWidgetPrefix("search-panel")).appendTo(container);
          that._editorFactoryController.createEditor($search, {
            width: searchPanelOptions.width,
            placeholder: searchPanelOptions.placeholder,
            parentType: "searchPanel",
            value: that.option("searchPanel.text"),
            updateValueTimeout: 700,
            setValue(value2) {
              dataController2.searchByText(value2);
            },
            editorOptions: {
              inputAttr: {
                "aria-label": message_default.format(`${that.component.NAME}-ariaSearchInGrid`)
              }
            }
          });
          that.resize();
        },
        name: "searchPanel",
        location: "after",
        locateInMenu: "never",
        sortIndex: 40
      };
      items.push(toolbarItem);
    }
    return items;
  }
  getSearchTextEditor() {
    const that = this;
    const $element = that.element();
    const $searchPanel = $element.find(`.${that.addWidgetPrefix("search-panel")}`).filter(function() {
      return renderer_default(this).closest(`.${that.addWidgetPrefix("header-panel")}`).is($element);
    });
    if ($searchPanel.length) {
      return $searchPanel.dxTextBox("instance");
    }
    return null;
  }
};
var rowsView8 = (Base) => class extends Base {
  init() {
    super.init.apply(this, arguments);
    this._searchParams = [];
    this._dataController = this.getController("data");
  }
  dispose() {
    clearTimeout(this._highlightTimer);
    super.dispose();
  }
  _getFormattedSearchText(column, searchText) {
    const value2 = parseValue2(column, searchText);
    const formatOptions = m_utils_default.getFormatOptionsByColumn(column, "search");
    return m_utils_default.formatValue(value2, formatOptions);
  }
  _getStringNormalizer() {
    var _this$_dataController3, _this$_dataController4, _dataSource$loadOptio2;
    const isCaseSensitive = this.option("searchPanel.highlightCaseSensitive");
    const dataSource = null === (_this$_dataController3 = this._dataController) || void 0 === _this$_dataController3 || null === (_this$_dataController4 = _this$_dataController3.getDataSource) || void 0 === _this$_dataController4 ? void 0 : _this$_dataController4.call(_this$_dataController3);
    const langParams = null === dataSource || void 0 === dataSource || null === (_dataSource$loadOptio2 = dataSource.loadOptions) || void 0 === _dataSource$loadOptio2 || null === (_dataSource$loadOptio2 = _dataSource$loadOptio2.call(dataSource)) || void 0 === _dataSource$loadOptio2 ? void 0 : _dataSource$loadOptio2.langParams;
    return (str) => toComparable(str, isCaseSensitive, langParams);
  }
  _findHighlightingTextNodes(column, cellElement, searchText) {
    var _$items;
    const that = this;
    let $parent = cellElement.parent();
    let $items;
    const stringNormalizer = this._getStringNormalizer();
    const normalizedSearchText = stringNormalizer(searchText);
    const resultTextNodes = [];
    if (!$parent.length) {
      $parent = renderer_default("<div>").append(cellElement);
    } else if (column) {
      if (column.groupIndex >= 0 && !column.showWhenGrouped) {
        $items = cellElement;
      } else {
        const columnIndex = that._columnsController.getVisibleIndex(column.index);
        $items = $parent.children("td").eq(columnIndex).find("*");
      }
    }
    $items = null !== (_$items = $items) && void 0 !== _$items && _$items.length ? $items : $parent.find("*");
    $items.each((_, element) => {
      const $contents = renderer_default(element).contents();
      for (let i = 0; i < $contents.length; i++) {
        const node = $contents.get(i);
        if (3 === node.nodeType) {
          const normalizedText = stringNormalizer(node.textContent ?? node.nodeValue ?? "");
          if (normalizedText.includes(normalizedSearchText)) {
            resultTextNodes.push(node);
          }
        }
      }
    });
    return resultTextNodes;
  }
  _highlightSearchTextCore($textNode, searchText) {
    const that = this;
    const $searchTextSpan = renderer_default("<span>").addClass(that.addWidgetPrefix("search-text"));
    const text = $textNode.text();
    const firstContentElement = $textNode[0];
    const stringNormalizer = this._getStringNormalizer();
    const index2 = stringNormalizer(text).indexOf(stringNormalizer(searchText));
    if (index2 >= 0) {
      if (firstContentElement.textContent) {
        firstContentElement.textContent = text.substr(0, index2);
      } else {
        firstContentElement.nodeValue = text.substr(0, index2);
      }
      $textNode.after($searchTextSpan.text(text.substr(index2, searchText.length)));
      $textNode = renderer_default(dom_adapter_default.createTextNode(text.substr(index2 + searchText.length))).insertAfter($searchTextSpan);
      return that._highlightSearchTextCore($textNode, searchText);
    }
  }
  _highlightSearchText(cellElement, isEquals, column) {
    const that = this;
    const stringNormalizer = this._getStringNormalizer();
    let searchText = that.option("searchPanel.text");
    if (isEquals && column) {
      searchText = searchText && that._getFormattedSearchText(column, searchText);
    }
    if (searchText && that.option("searchPanel.highlightSearchText")) {
      const textNodes = that._findHighlightingTextNodes(column, cellElement, searchText);
      textNodes.forEach((textNode) => {
        if (isEquals) {
          if (stringNormalizer(renderer_default(textNode).text()) === stringNormalizer(searchText ?? "")) {
            renderer_default(textNode).replaceWith(renderer_default("<span>").addClass(that.addWidgetPrefix("search-text")).text(renderer_default(textNode).text()));
          }
        } else {
          that._highlightSearchTextCore(renderer_default(textNode), searchText);
        }
      });
    }
  }
  _renderCore() {
    const deferred = super._renderCore.apply(this, arguments);
    if (this.option().rowTemplate || this.option("dataRowTemplate")) {
      if (this.option("templatesRenderAsynchronously")) {
        clearTimeout(this._highlightTimer);
        this._highlightTimer = setTimeout(() => {
          this._highlightSearchText(this.getTableElement());
        });
      } else {
        this._highlightSearchText(this.getTableElement());
      }
    }
    return deferred;
  }
  _updateCell($cell, parameters) {
    const {
      column
    } = parameters;
    const dataType = column.lookup && column.lookup.dataType || column.dataType;
    const isEquals = "string" !== dataType;
    if (allowSearch(column) && !parameters.isOnForm) {
      if (this.option("templatesRenderAsynchronously")) {
        if (!this._searchParams.length) {
          clearTimeout(this._highlightTimer);
          this._highlightTimer = setTimeout(() => {
            this._searchParams.forEach((params) => {
              this._highlightSearchText.apply(this, params);
            });
            this._searchParams = [];
          });
        }
        this._searchParams.push([$cell, isEquals, column]);
      } else {
        this._highlightSearchText($cell, isEquals, column);
      }
    }
    super._updateCell($cell, parameters);
  }
};
var searchModule = {
  defaultOptions: () => ({
    searchPanel: {
      visible: false,
      width: 160,
      placeholder: message_default.format("dxDataGrid-searchPanelPlaceholder"),
      highlightSearchText: true,
      highlightCaseSensitive: false,
      text: "",
      searchVisibleColumnsOnly: false
    }
  }),
  extenders: {
    controllers: {
      data: dataController
    },
    views: {
      headerPanel: headerPanel6,
      rowsView: rowsView8
    }
  }
};

// node_modules/devextreme/esm/__internal/grids/data_grid/module_not_extended/search.js
m_core_default.registerModule("search", searchModule);

// node_modules/devextreme/esm/__internal/pagination/common/base_pagination_props.js
var BasePaginationDefaultProps = _extends({}, BaseWidgetDefaultProps, {
  isGridCompatibilityMode: false,
  showInfo: false,
  displayMode: "adaptive",
  maxPagesCount: 10,
  pageCount: 1,
  visible: true,
  hasKnownLastPage: true,
  pagesNavigatorVisible: "auto",
  showPageSizeSelector: true,
  allowedPageSizes: [5, 10],
  showNavigationButtons: false,
  itemCount: 1,
  label: message_default.format("dxPagination-ariaLabel")
});

// node_modules/devextreme/esm/__internal/pagination/common/pagination_props.js
var PaginationDefaultProps = _extends({}, BasePaginationDefaultProps, {
  pageSize: 5,
  pageIndex: 1,
  pageIndexChangedInternal: () => {
  },
  pageSizeChangedInternal: () => {
  }
});

// node_modules/devextreme/esm/__internal/pagination/common/consts.js
var PAGER_CLASS = "dx-pager";
var PAGINATION_CLASS = "dx-pagination";
var LIGHT_MODE_CLASS = "dx-light-mode";
var PAGINATION_PAGES_CLASS = "dx-pages";
var PAGINATION_PAGE_INDEXES_CLASS = "dx-page-indexes";
var PAGINATION_PAGE_CLASS = "dx-page";
var PAGINATION_SELECTION_CLASS = "dx-selection";
var PAGINATION_PAGE_SIZE_CLASS = "dx-page-size";
var PAGINATION_PAGE_SIZES_CLASS = "dx-page-sizes";
var PAGINATION_SELECTED_PAGE_SIZE_CLASS = "dx-page-size dx-selection";
var FIRST_CHILD_CLASS = "dx-first-child";

// node_modules/devextreme/esm/__internal/pagination/common/keyboard_action_context.js
var KeyboardActionContext = createContext(void 0);

// node_modules/devextreme/esm/__internal/pagination/common/pagination_config_context.js
var PaginationConfigContext = createContext(void 0);

// node_modules/devextreme/esm/__internal/pagination/common/pagination_config_provider.js
var PaginationConfigProviderDefaultProps = {};
var PaginationConfigProvider = class extends BaseInfernoComponent {
  constructor() {
    super(...arguments);
    this.state = {};
  }
  getConfig() {
    return {
      isGridCompatibilityMode: this.props.isGridCompatibilityMode
    };
  }
  getChildContext() {
    return _extends({}, this.context, {
      [PaginationConfigContext.id]: this.getConfig() || PaginationConfigContext.defaultValue
    });
  }
  render() {
    return this.props.children;
  }
};
PaginationConfigProvider.defaultProps = PaginationConfigProviderDefaultProps;

// node_modules/devextreme/esm/__internal/pagination/utils/compatibility_utils.js
function getPaginationConfig(context2) {
  if (context2[PaginationConfigContext.id]) {
    return context2[PaginationConfigContext.id];
  }
  return PaginationConfigContext.defaultValue;
}
function isGridCompatibilityMode(context2) {
  var _getPaginationConfig;
  return !!(null !== (_getPaginationConfig = getPaginationConfig(context2)) && void 0 !== _getPaginationConfig && _getPaginationConfig.isGridCompatibilityMode);
}
function getLocalizationMessage(context2, key) {
  let actualKey = key;
  if (isGridCompatibilityMode(context2)) {
    actualKey = key.replace("dxPagination", "dxPager");
  }
  return message_default.getFormatter(actualKey)();
}

// node_modules/devextreme/esm/__internal/pagination/info.js
var PAGER_INFO_CLASS = "dx-info";
var InfoTextDefaultProps = {
  pageCount: PaginationDefaultProps.pageCount,
  pageIndex: PaginationDefaultProps.pageIndex,
  itemCount: PaginationDefaultProps.itemCount
};
var InfoText = class extends BaseInfernoComponent {
  constructor() {
    super(...arguments);
    this.state = {};
    this.refs = null;
    this.rootElementRef = createRef();
  }
  getInfoText() {
    return this.props.infoText ?? getLocalizationMessage(this.context, "dxPagination-infoText");
  }
  getText() {
    const {
      pageCount,
      pageIndex,
      itemCount
    } = this.props;
    return format(this.getInfoText(), (pageIndex + 1).toString(), null === pageCount || void 0 === pageCount ? void 0 : pageCount.toString(), null === itemCount || void 0 === itemCount ? void 0 : itemCount.toString());
  }
  render() {
    return createVNode(1, "div", "dx-info", this.getText(), 0, null, null, this.props.rootElementRef);
  }
};
InfoText.defaultProps = InfoTextDefaultProps;

// node_modules/devextreme/esm/__internal/pagination/common/light_button.js
var LightButtonDefaultProps = {
  className: "",
  label: "",
  tabIndex: 0,
  selected: false
};
var LightButton = class extends InfernoComponent {
  constructor(props) {
    super(props);
    this.state = {};
    this.refs = null;
    this.widgetRef = createRef();
    this.keyboardEffect = this.keyboardEffect.bind(this);
    this.subscribeToClick = this.subscribeToClick.bind(this);
  }
  getComponentProps() {
    return this.props;
  }
  getKeyboardContext() {
    if (this.context[KeyboardActionContext.id]) {
      return this.context[KeyboardActionContext.id];
    }
    return KeyboardActionContext.defaultValue;
  }
  componentWillUpdate(nextProps, nextState, context2) {
    super.componentWillUpdate(nextProps, nextState, context2);
  }
  createEffects() {
    return [new InfernoEffect(this.keyboardEffect, [this.getKeyboardContext(), this.props.onClick]), new InfernoEffect(this.subscribeToClick, [this.props.onClick])];
  }
  updateEffects() {
    var _this$_effects$, _this$_effects$2;
    null === (_this$_effects$ = this._effects[0]) || void 0 === _this$_effects$ || _this$_effects$.update([this.getKeyboardContext(), this.props.onClick]);
    null === (_this$_effects$2 = this._effects[1]) || void 0 === _this$_effects$2 || _this$_effects$2.update([this.props.onClick]);
  }
  keyboardEffect() {
    return this.getKeyboardContext().registerKeyboardAction(this.widgetRef.current, this.props.onClick);
  }
  subscribeToClick() {
    return subscribeToClickEvent(this.widgetRef.current, this.props.onClick);
  }
  render() {
    return createVNode(1, "div", this.props.className, this.props.children, 0, {
      tabindex: this.props.tabIndex,
      role: "button",
      "aria-label": this.props.label,
      "aria-current": this.props.selected ? "page" : void 0
    }, null, this.widgetRef);
  }
};
LightButton.defaultProps = LightButtonDefaultProps;

// node_modules/devextreme/esm/__internal/pagination/page_size/large.js
var PageSizeLargeDefaultProps = {
  allowedPageSizes: [],
  pageSize: PaginationDefaultProps.pageSize,
  pageSizeChangedInternal: PaginationDefaultProps.pageSizeChangedInternal
};
var PageSizeLarge = class extends BaseInfernoComponent {
  constructor(props) {
    super(props);
    this.state = {};
    this.refs = null;
    this.__getterCache = {
      pageSizesText: void 0
    };
    this.state = {};
    this.onPageSizeChange = this.onPageSizeChange.bind(this);
  }
  getPageSizesText() {
    if (void 0 !== this.__getterCache.pageSizesText) {
      return this.__getterCache.pageSizesText;
    }
    const result2 = (() => {
      const {
        pageSize,
        allowedPageSizes
      } = this.props;
      return allowedPageSizes.map((_ref3, index2) => {
        const {
          text,
          value: processedPageSize
        } = _ref3;
        const selected = processedPageSize === pageSize;
        const className = combineClasses({
          [selected ? PAGINATION_SELECTED_PAGE_SIZE_CLASS : PAGINATION_PAGE_SIZE_CLASS]: true,
          [FIRST_CHILD_CLASS]: 0 === index2
        });
        return {
          className,
          click: this.onPageSizeChange(processedPageSize),
          label: format(getLocalizationMessage(this.context, "dxPagination-pageSize"), processedPageSize || getLocalizationMessage(this.context, "dxPagination-pageSizesAllText")),
          text
        };
      });
    })();
    this.__getterCache.pageSizesText = result2;
    return result2;
  }
  onPageSizeChange(processedPageSize) {
    return () => {
      this.props.pageSizeChangedInternal(processedPageSize);
      return this.props.pageSize;
    };
  }
  componentWillUpdate(nextProps) {
    const componentChanged = this.props.pageSize !== nextProps.pageSize || this.props.allowedPageSizes !== nextProps.allowedPageSizes || this.props.pageSizeChangedInternal !== nextProps.pageSizeChangedInternal;
    if (componentChanged) {
      this.__getterCache.pageSizesText = void 0;
    }
  }
  render() {
    return createFragment(this.getPageSizesText().map((_ref) => {
      let {
        text,
        className,
        label,
        click: click2
      } = _ref;
      return createComponentVNode(2, LightButton, {
        className,
        label,
        onClick: click2,
        children: text
      }, text);
    }), 0);
  }
};
PageSizeLarge.defaultProps = PageSizeLargeDefaultProps;

// node_modules/devextreme/esm/__internal/pagination/editors/common/editor_label_props.js
var EditorLabelDefaultProps = {
  label: "",
  labelMode: isMaterial(current()) ? "floating" : "static"
};

// node_modules/devextreme/esm/__internal/pagination/editors/common/base_widget_props.js
var BaseWidgetDefaultProps2 = {
  className: "",
  activeStateEnabled: false,
  disabled: false,
  focusStateEnabled: false,
  hoverStateEnabled: false,
  tabIndex: 0,
  visible: true,
  rtlEnabled: false
};

// node_modules/devextreme/esm/__internal/pagination/editors/common/widget_props.js
var WidgetDefaultProps2 = _extends({}, BaseWidgetDefaultProps, {
  _feedbackHideTimeout: 400,
  _feedbackShowTimeout: 30,
  cssText: "",
  aria: {},
  classes: "",
  name: "",
  addWidgetClass: true
});

// node_modules/devextreme/esm/__internal/pagination/editors/common/editor_props.js
var EditorDefaultProps = _extends({}, BaseWidgetDefaultProps2, {
  aria: WidgetDefaultProps2.aria,
  classes: WidgetDefaultProps2.classes,
  readOnly: false,
  name: "",
  value: null,
  validationError: null,
  validationErrors: null,
  validationMessageMode: "auto",
  validationMessagePosition: "bottom",
  validationStatus: "valid",
  isValid: true,
  isDirty: false,
  inputAttr: {}
});

// node_modules/devextreme/esm/__internal/pagination/editors/common/editor_state_props.js
var EditorStateDefaultProps = {
  hoverStateEnabled: true,
  activeStateEnabled: true,
  focusStateEnabled: "desktop" === devices_default.real().deviceType && !devices_default.isSimulator()
};

// node_modules/devextreme/esm/__internal/pagination/drop_down_editors/select_box.js
var NumberBoxDefaultProps = _extends({}, EditorDefaultProps, EditorStateDefaultProps, EditorLabelDefaultProps, {
  placeholder: "",
  hoverStateEnabled: true,
  searchEnabled: false,
  value: null,
  isReactComponentWrapper: true
});
var SelectBox2 = class extends BaseInfernoComponent {
  constructor() {
    super(...arguments);
    this.state = {};
    this.refs = null;
  }
  get componentProps() {
    return this.props;
  }
  render() {
    return createComponentVNode(2, DomComponentWrapper, {
      componentType: select_box_default,
      componentProps: this.componentProps,
      templateNames: ["dropDownButtonTemplate", "groupTemplate", "itemTemplate"]
    });
  }
};
SelectBox2.defaultProps = NumberBoxDefaultProps;

// node_modules/devextreme/esm/__internal/pagination/utils/calculate_values_fitted_width.js
function calculateValuesFittedWidth(minWidth, values) {
  return minWidth + 10 * Math.max(...values).toString().length;
}

// node_modules/devextreme/esm/__internal/core/r1/utils/get_computed_style.js
function getElementComputedStyle2(el) {
  var _window$getComputedSt;
  const window31 = getWindow();
  return el ? null === (_window$getComputedSt = window31.getComputedStyle) || void 0 === _window$getComputedSt ? void 0 : _window$getComputedSt.call(window31, el) : null;
}

// node_modules/devextreme/esm/__internal/core/r1/utils/type_conversion.js
function toNumber3(attribute) {
  return attribute ? Number(attribute.replace("px", "")) : 0;
}

// node_modules/devextreme/esm/__internal/pagination/utils/get_element_width.js
function getElementStyle2(name2, element) {
  const computedStyle = getElementComputedStyle2(element) ?? {};
  return toNumber3(computedStyle[name2]);
}
function getElementContentWidth(element) {
  const padding = getElementStyle2("paddingLeft", element) + getElementStyle2("paddingRight", element);
  const width = getElementStyle2("width", element);
  return width - padding;
}
function getElementWidth2(element) {
  const margin = getElementStyle2("marginLeft", element) + getElementStyle2("marginRight", element);
  const width = getElementStyle2("width", element);
  return margin + width;
}
function getElementMinWidth(element) {
  return getElementStyle2("minWidth", element);
}

// node_modules/devextreme/esm/__internal/pagination/page_size/small.js
var PaginationSmallDefaultProps = {
  allowedPageSizes: []
};
var PageSizeSmallDefaultProps = _extends({}, PaginationSmallDefaultProps, {
  pageSize: PaginationDefaultProps.pageSize,
  pageSizeChangedInternal: PaginationDefaultProps.pageSizeChangedInternal
});
var PageSizeSmall = class extends InfernoComponent {
  constructor(props) {
    super(props);
    this.state = {
      minWidth: 10
    };
    this.refs = null;
    this.updateWidth = this.updateWidth.bind(this);
  }
  componentWillUpdate(nextProps, nextState, context2) {
    super.componentWillUpdate(nextProps, nextState, context2);
  }
  createEffects() {
    const dependency = [this.props, this.state.minWidth, this.props.pageSize, this.props.pageSizeChangedInternal, this.props.allowedPageSizes];
    return [new InfernoEffect(this.updateWidth, dependency)];
  }
  updateEffects() {
    var _this$_effects$;
    const dependency = [this.props, this.state.minWidth, this.props.pageSize, this.props.pageSizeChangedInternal, this.props.allowedPageSizes];
    null === (_this$_effects$ = this._effects[0]) || void 0 === _this$_effects$ || _this$_effects$.update(dependency);
  }
  updateWidth() {
    var _this$props$parentRef;
    const minWidth = getElementMinWidth(null === (_this$props$parentRef = this.props.parentRef) || void 0 === _this$props$parentRef ? void 0 : _this$props$parentRef.current);
    this.setState((state) => ({
      minWidth: minWidth > 0 ? minWidth : state.minWidth
    }));
  }
  getWidth() {
    var _this$props$allowedPa;
    return calculateValuesFittedWidth(this.state.minWidth, null === (_this$props$allowedPa = this.props.allowedPageSizes) || void 0 === _this$props$allowedPa ? void 0 : _this$props$allowedPa.map((p2) => p2.value));
  }
  getInputAttributes() {
    return {
      "aria-label": getLocalizationMessage(this.context, "dxPagination-ariaPageSize")
    };
  }
  render() {
    const {
      allowedPageSizes,
      pageSize,
      pageSizeChangedInternal
    } = this.props;
    return createComponentVNode(2, SelectBox2, {
      displayExpr: "text",
      valueExpr: "value",
      dataSource: allowedPageSizes,
      value: pageSize,
      valueChange: pageSizeChangedInternal,
      width: this.getWidth(),
      inputAttr: this.getInputAttributes()
    });
  }
};
PageSizeSmall.defaultProps = PageSizeSmallDefaultProps;

// node_modules/devextreme/esm/__internal/pagination/page_size/selector.js
var PageSizeSelectorDefaultProps = {
  isLargeDisplayMode: true,
  pageSize: PaginationDefaultProps.pageSize,
  pageSizeChangedInternal: PaginationDefaultProps.pageSizeChangedInternal,
  allowedPageSizes: PaginationDefaultProps.allowedPageSizes
};
var PageSizeSelector = class extends InfernoComponent {
  constructor(props) {
    super(props);
    this.state = {};
    this.refs = null;
    this.rootElementRef = createRef();
    this.htmlRef = createRef();
    this.__getterCache = {
      normalizedPageSizes: void 0
    };
    this.setRootElementRef = this.setRootElementRef.bind(this);
  }
  createEffects() {
    return [new InfernoEffect(this.setRootElementRef, [])];
  }
  setRootElementRef() {
    const {
      rootElementRef
    } = this.props;
    if (rootElementRef) {
      rootElementRef.current = this.htmlRef.current;
    }
  }
  getAllText() {
    return getLocalizationMessage(this.context, "dxPagination-pageSizesAllText");
  }
  getNormalizedPageSizes() {
    if (void 0 !== this.__getterCache.normalizedPageSizes) {
      return this.__getterCache.normalizedPageSizes;
    }
    const result2 = this.props.allowedPageSizes.map((p2) => "all" === p2 || 0 === p2 ? {
      text: this.getAllText(),
      value: 0
    } : {
      text: String(p2),
      value: p2
    });
    this.__getterCache.normalizedPageSizes = result2;
    return result2;
  }
  componentWillUpdate(nextProps) {
    super.componentWillUpdate();
    if (this.props.allowedPageSizes !== nextProps.allowedPageSizes) {
      this.__getterCache.normalizedPageSizes = void 0;
    }
  }
  render() {
    const normalizedPageSizes = this.getNormalizedPageSizes();
    const {
      pageSize,
      pageSizeChangedInternal,
      isLargeDisplayMode
    } = this.props;
    return createVNode(1, "div", PAGINATION_PAGE_SIZES_CLASS, [isLargeDisplayMode && createComponentVNode(2, PageSizeLarge, {
      allowedPageSizes: normalizedPageSizes,
      pageSize,
      pageSizeChangedInternal
    }), !isLargeDisplayMode && createComponentVNode(2, PageSizeSmall, {
      parentRef: this.htmlRef,
      allowedPageSizes: normalizedPageSizes,
      pageSize,
      pageSizeChangedInternal
    })], 0, null, null, this.htmlRef);
  }
};
PageSizeSelector.defaultProps = PageSizeSelectorDefaultProps;

// node_modules/devextreme/esm/__internal/pagination/pages/page.js
var PageDefaultProps = {
  index: 0,
  selected: false,
  className: PAGINATION_PAGE_CLASS
};
var Page = class extends BaseInfernoComponent {
  constructor() {
    super(...arguments);
    this.state = {};
    this.refs = null;
  }
  getLabel() {
    return format(getLocalizationMessage(this.context, "dxPagination-page"), this.getValue());
  }
  getValue() {
    return this.props.index + 1;
  }
  getClassName() {
    return combineClasses({
      [`${this.props.className}`]: !!this.props.className,
      [PAGINATION_SELECTION_CLASS]: !!this.props.selected
    });
  }
  render() {
    return createComponentVNode(2, LightButton, {
      className: this.getClassName(),
      label: this.getLabel(),
      onClick: this.props.onClick,
      selected: this.props.selected,
      children: this.getValue()
    });
  }
};
Page.defaultProps = PageDefaultProps;

// node_modules/devextreme/esm/__internal/pagination/pages/large.js
var PagesLargeDefaultProps = {
  maxPagesCount: PaginationDefaultProps.maxPagesCount,
  pageCount: PaginationDefaultProps.pageCount,
  pageIndex: PaginationDefaultProps.pageIndex,
  pageIndexChangedInternal: PaginationDefaultProps.pageIndexChangedInternal
};
function getDelimiterType(startIndex, slidingWindowSize, pageCount) {
  switch (true) {
    case 1 === startIndex:
      return "high";
    case startIndex + slidingWindowSize === pageCount - 1:
      return "low";
    default:
      return "both";
  }
}
function createPageIndexesBySlidingWindowIndexes(slidingWindowIndexes, pageCount, delimiter) {
  let pageIndexes = [];
  let indexesForReuse = [];
  switch (delimiter) {
    case "none":
      pageIndexes = [...slidingWindowIndexes];
      break;
    case "both":
      pageIndexes = [0, "low", ...slidingWindowIndexes, "high", pageCount - 1];
      indexesForReuse = slidingWindowIndexes.slice(1, -1);
      break;
    case "high":
      pageIndexes = [0, ...slidingWindowIndexes, "high", pageCount - 1];
      indexesForReuse = slidingWindowIndexes.slice(0, -1);
      break;
    case "low":
      pageIndexes = [0, "low", ...slidingWindowIndexes, pageCount - 1];
      indexesForReuse = slidingWindowIndexes.slice(1);
  }
  return {
    slidingWindowIndexes,
    indexesForReuse,
    pageIndexes
  };
}
function createPageIndexes(startIndex, slidingWindowSize, pageCount, delimiter) {
  const slidingWindowIndexes = [];
  for (let i = 0; i < slidingWindowSize; i += 1) {
    slidingWindowIndexes.push(i + startIndex);
  }
  return createPageIndexesBySlidingWindowIndexes(slidingWindowIndexes, pageCount, delimiter);
}
var PagesLarge = class extends BaseInfernoComponent {
  constructor(props) {
    super(props);
    this.state = {};
    this.refs = null;
    this.canReuseSlidingWindow = this.canReuseSlidingWindow.bind(this);
    this.generatePageIndexes = this.generatePageIndexes.bind(this);
    this.isSlidingWindowMode = this.isSlidingWindowMode.bind(this);
    this.onPageClick = this.onPageClick.bind(this);
  }
  getConfig() {
    if (this.context[ConfigContext.id]) {
      return this.context[ConfigContext.id];
    }
    return ConfigContext.defaultValue;
  }
  getSlidingWindowState() {
    const slidingWindowState = this.slidingWindowStateHolder;
    if (!slidingWindowState) {
      return {
        indexesForReuse: [],
        slidingWindowIndexes: []
      };
    }
    return slidingWindowState;
  }
  canReuseSlidingWindow(currentPageCount, pageIndex) {
    const {
      indexesForReuse
    } = this.getSlidingWindowState();
    const lastPageIsFartherThanWindow = indexesForReuse.slice(-1)[0] < currentPageCount - 1;
    const pageIndexExistInIndexes = indexesForReuse.includes(pageIndex);
    return lastPageIsFartherThanWindow && pageIndexExistInIndexes;
  }
  generatePageIndexes() {
    const {
      pageCount,
      pageIndex
    } = this.props;
    let startIndex = 0;
    const {
      slidingWindowIndexes
    } = this.getSlidingWindowState();
    if (pageIndex === slidingWindowIndexes[0]) {
      startIndex = pageIndex - 1;
    } else if (pageIndex === slidingWindowIndexes[slidingWindowIndexes.length - 1]) {
      startIndex = pageIndex + 2 - 4;
    } else if (pageIndex < 4) {
      startIndex = 1;
    } else if (pageIndex >= pageCount - 4) {
      startIndex = pageCount - 4 - 1;
    } else {
      startIndex = pageIndex - 1;
    }
    const delimiter = getDelimiterType(startIndex, 4, pageCount);
    const indexes = createPageIndexes(startIndex, 4, pageCount, delimiter);
    const {
      pageIndexes
    } = indexes;
    this.slidingWindowStateHolder = indexes;
    return pageIndexes;
  }
  isSlidingWindowMode() {
    const {
      maxPagesCount,
      pageCount
    } = this.props;
    return pageCount <= 4 || pageCount <= maxPagesCount;
  }
  onPageClick(pageIndex) {
    this.props.pageIndexChangedInternal(pageIndex);
  }
  getPageIndexes() {
    const {
      pageCount
    } = this.props;
    if (this.isSlidingWindowMode()) {
      return createPageIndexes(0, pageCount, pageCount, "none").pageIndexes;
    }
    if (this.canReuseSlidingWindow(pageCount, this.props.pageIndex)) {
      const {
        slidingWindowIndexes
      } = this.getSlidingWindowState();
      const delimiter = getDelimiterType(slidingWindowIndexes[0], 4, pageCount);
      return createPageIndexesBySlidingWindowIndexes(slidingWindowIndexes, pageCount, delimiter).pageIndexes;
    }
    return this.generatePageIndexes();
  }
  getPages() {
    var _this$getConfig;
    const {
      pageIndex
    } = this.props;
    const createPage = (index2) => {
      const paginationProps = "low" === index2 || "high" === index2 ? null : {
        index: index2,
        onClick: () => this.onPageClick(index2),
        selected: pageIndex === index2
      };
      return {
        key: index2.toString(),
        pageProps: paginationProps
      };
    };
    const indices = this.getPageIndexes();
    const rtlPageIndexes = null !== (_this$getConfig = this.getConfig()) && void 0 !== _this$getConfig && _this$getConfig.rtlEnabled ? [...indices].reverse() : indices;
    return rtlPageIndexes.map((index2) => createPage(index2));
  }
  render() {
    const PagesMarkup = this.getPages().map((_ref) => {
      let {
        key,
        pageProps
      } = _ref;
      return pageProps ? createComponentVNode(2, Page, {
        index: pageProps.index,
        selected: pageProps.selected,
        onClick: pageProps.onClick
      }, key) : createVNode(1, "div", "dx-separator", ". . .", 16, null, key);
    });
    return createFragment(PagesMarkup, 0);
  }
};
PagesLarge.defaultProps = PagesLargeDefaultProps;

// node_modules/devextreme/esm/__internal/pagination/editors/number_box.js
var NumberBoxDefaultProps2 = _extends({}, EditorDefaultProps, EditorStateDefaultProps, EditorLabelDefaultProps, {
  value: 0,
  isReactComponentWrapper: true
});
var NumberBox = class extends BaseInfernoComponent {
  constructor() {
    super(...arguments);
    this.state = {};
    this.refs = null;
  }
  get componentProps() {
    return this.props;
  }
  render() {
    return createComponentVNode(2, DomComponentWrapper, {
      componentType: number_box_default,
      componentProps: this.componentProps,
      templateNames: []
    });
  }
};
NumberBox.defaultProps = NumberBoxDefaultProps2;

// node_modules/devextreme/esm/__internal/pagination/pages/small.js
var PAGER_INFO_TEXT_CLASS = `${PAGER_INFO_CLASS}  dx-info-text`;
var PaginationSmallDefaultProps2 = {
  pageIndex: PaginationDefaultProps.pageIndex,
  pageCount: PaginationDefaultProps.pageCount,
  pageIndexChangedInternal: PaginationDefaultProps.pageIndexChangedInternal
};
var PagesSmall = class extends InfernoComponent {
  constructor(props) {
    super(props);
    this.state = {
      minWidth: 10
    };
    this.refs = null;
    this.pageIndexRef = createRef();
    this.updateWidth = this.updateWidth.bind(this);
    this.selectLastPageIndex = this.selectLastPageIndex.bind(this);
    this.valueChange = this.valueChange.bind(this);
  }
  componentWillUpdate(nextProps, nextState, context2) {
    super.componentWillUpdate(nextProps, nextState, context2);
  }
  createEffects() {
    return [new InfernoEffect(this.updateWidth, [this.state.minWidth])];
  }
  updateEffects() {
    var _this$_effects$;
    null === (_this$_effects$ = this._effects[0]) || void 0 === _this$_effects$ || _this$_effects$.update([this.state.minWidth]);
  }
  updateWidth() {
    var _this$pageIndexRef$cu;
    const el = null === (_this$pageIndexRef$cu = this.pageIndexRef.current) || void 0 === _this$pageIndexRef$cu ? void 0 : _this$pageIndexRef$cu.querySelector(".dx-page-index");
    const minWidth = el ? getElementMinWidth(el) : 0;
    this.setState((state) => ({
      minWidth: minWidth > 0 ? minWidth : state.minWidth
    }));
  }
  getValue() {
    return this.props.pageIndex + 1;
  }
  getWidth() {
    return calculateValuesFittedWidth(this.state.minWidth, [this.props.pageCount]);
  }
  getPagesCountText() {
    return (this.props.pagesCountText ?? "") || getLocalizationMessage(this.context, "dxPagination-pagesCountText");
  }
  getInputAttributes() {
    return {
      "aria-label": getLocalizationMessage(this.context, "dxPagination-ariaPageNumber")
    };
  }
  selectLastPageIndex() {
    this.props.pageIndexChangedInternal(this.props.pageCount - 1);
  }
  valueChange(value2) {
    this.props.pageIndexChangedInternal(value2 - 1);
  }
  render() {
    return createVNode(1, "div", "dx-light-pages", [createComponentVNode(2, NumberBox, {
      className: "dx-page-index",
      min: 1,
      max: Math.max(this.props.pageCount, this.getValue()),
      width: this.getWidth(),
      value: this.getValue(),
      valueChange: this.valueChange,
      inputAttr: this.getInputAttributes()
    }), createVNode(1, "span", PAGER_INFO_TEXT_CLASS, this.getPagesCountText(), 0), createComponentVNode(2, Page, {
      className: "dx-pages-count",
      selected: false,
      index: this.props.pageCount - 1,
      onClick: this.selectLastPageIndex
    })], 4, null, null, this.pageIndexRef);
  }
};
PagesSmall.defaultProps = PaginationSmallDefaultProps2;

// node_modules/devextreme/esm/__internal/pagination/pages/page_index_selector.js
var classNames = {
  nextEnabledClass: "dx-navigate-button dx-next-button",
  prevEnabledClass: "dx-navigate-button dx-prev-button",
  nextDisabledClass: "dx-button-disable dx-navigate-button dx-next-button",
  prevDisabledClass: "dx-button-disable dx-navigate-button dx-prev-button"
};
var reverseDirections = {
  next: "prev",
  prev: "next"
};
function getIncrement(direction) {
  return "next" === direction ? 1 : -1;
}
var PageIndexSelectorDefaultProps = {
  isLargeDisplayMode: true,
  maxPagesCount: PaginationDefaultProps.maxPagesCount,
  pageCount: PaginationDefaultProps.pageCount,
  pageIndex: PaginationDefaultProps.pageIndex,
  pageIndexChangedInternal: PaginationDefaultProps.pageIndexChangedInternal,
  showNavigationButtons: PaginationDefaultProps.showNavigationButtons,
  itemCount: PaginationDefaultProps.itemCount
};
var PageIndexSelector = class extends BaseInfernoComponent {
  constructor(props) {
    super(props);
    this.state = {};
    this.refs = null;
    this.__getterCache = {
      prevButtonProps: void 0,
      nextButtonProps: void 0
    };
    this.pageIndexChangedInternal = this.pageIndexChangedInternal.bind(this);
    this.getButtonProps = this.getButtonProps.bind(this);
    this.canNavigateToPage = this.canNavigateToPage.bind(this);
    this.getNextPageIndex = this.getNextPageIndex.bind(this);
    this.canNavigateTo = this.canNavigateTo.bind(this);
    this.navigateToPage = this.navigateToPage.bind(this);
  }
  getConfig() {
    if (this.context[ConfigContext.id]) {
      return this.context[ConfigContext.id];
    }
    return ConfigContext.defaultValue;
  }
  pageIndexChangedInternal(pageIndex) {
    if (this.canNavigateToPage(pageIndex)) {
      this.props.pageIndexChangedInternal(pageIndex);
    }
  }
  getButtonProps(direction) {
    var _this$getConfig;
    const rtlAwareDirection = null !== (_this$getConfig = this.getConfig()) && void 0 !== _this$getConfig && _this$getConfig.rtlEnabled ? reverseDirections[direction] : direction;
    const canNavigate = this.canNavigateTo(rtlAwareDirection);
    const className = classNames[`${direction}${canNavigate ? "Enabled" : "Disabled"}Class`];
    return {
      className,
      tabIndex: canNavigate ? 0 : -1,
      navigate: () => this.navigateToPage(rtlAwareDirection)
    };
  }
  canNavigateToPage(pageIndex) {
    if (!this.props.hasKnownLastPage) {
      return pageIndex >= 0;
    }
    return pageIndex >= 0 && pageIndex <= this.props.pageCount - 1;
  }
  getNextPageIndex(direction) {
    return this.props.pageIndex + getIncrement(direction);
  }
  canNavigateTo(direction) {
    return this.canNavigateToPage(this.getNextPageIndex(direction));
  }
  navigateToPage(direction) {
    this.pageIndexChangedInternal(this.getNextPageIndex(direction));
  }
  getRenderPrevButton() {
    const {
      isLargeDisplayMode,
      showNavigationButtons
    } = this.props;
    return (!isLargeDisplayMode || showNavigationButtons) ?? false;
  }
  getRenderNextButton() {
    return this.getRenderPrevButton() || !this.props.hasKnownLastPage;
  }
  getPrevButtonProps() {
    if (void 0 !== this.__getterCache.prevButtonProps) {
      return this.__getterCache.prevButtonProps;
    }
    const result2 = (() => this.getButtonProps("prev"))();
    this.__getterCache.prevButtonProps = result2;
    return result2;
  }
  getNextButtonProps() {
    if (void 0 !== this.__getterCache.nextButtonProps) {
      return this.__getterCache.nextButtonProps;
    }
    const result2 = (() => this.getButtonProps("next"))();
    this.__getterCache.nextButtonProps = result2;
    return result2;
  }
  componentWillUpdate(nextProps, nextState, context2) {
    const isComponentUpdated = this.context[ConfigContext.id] !== context2[ConfigContext.id] || this.props.hasKnownLastPage !== nextProps.hasKnownLastPage || this.props.pageCount !== nextProps.pageCount || this.props.pageIndex !== nextProps.pageIndex || this.props.pageIndexChangedInternal !== nextProps.pageIndexChangedInternal;
    if (isComponentUpdated) {
      this.__getterCache.prevButtonProps = void 0;
      this.__getterCache.nextButtonProps = void 0;
    }
  }
  getPrevButtonLabel() {
    return getLocalizationMessage(this.context, "dxPagination-prevPage");
  }
  getNextButtonLabel() {
    return getLocalizationMessage(this.context, "dxPagination-nextPage");
  }
  render() {
    const {
      className,
      tabIndex,
      navigate
    } = this.getPrevButtonProps();
    const {
      isLargeDisplayMode,
      maxPagesCount,
      pageCount,
      pageIndex,
      pagesCountText
    } = this.props;
    return createFragment([this.getRenderPrevButton() && createComponentVNode(2, LightButton, {
      label: this.getPrevButtonLabel(),
      className,
      tabIndex,
      onClick: navigate
    }), isLargeDisplayMode && createComponentVNode(2, PagesLarge, {
      maxPagesCount,
      pageCount,
      pageIndex,
      pageIndexChangedInternal: this.pageIndexChangedInternal
    }), !isLargeDisplayMode && createComponentVNode(2, PagesSmall, {
      pageCount,
      pageIndex,
      pageIndexChangedInternal: this.pageIndexChangedInternal,
      pagesCountText
    }), this.getRenderNextButton() && createComponentVNode(2, LightButton, {
      label: this.getNextButtonLabel(),
      className: this.getNextButtonProps().className,
      tabIndex: this.getNextButtonProps().tabIndex,
      onClick: this.getNextButtonProps().navigate
    })], 0);
  }
};
PageIndexSelector.defaultProps = PageIndexSelectorDefaultProps;

// node_modules/devextreme/esm/__internal/pagination/content.js
var PaginationContentDefaultProps = _extends({}, PaginationDefaultProps, {
  infoTextVisible: true,
  isLargeDisplayMode: true
});
var PaginationContent = class extends InfernoComponent {
  constructor(props) {
    super(props);
    this.state = {};
    this.refs = null;
    this.widgetElementRef = createRef();
    this.widgetRootElementRef = createRef();
    this.pagesRef = createRef();
    this.infoTextRef = createRef();
    this.__getterCache = {
      keyboardAction: void 0
    };
    this.state = {};
    this.__getterCache = {};
    this.setRootElementRef = this.setRootElementRef.bind(this);
    this.createFakeInstance = this.createFakeInstance.bind(this);
  }
  createEffects() {
    return [new InfernoEffect(this.setRootElementRef, [])];
  }
  getChildContext() {
    return _extends({}, this.context, {
      [KeyboardActionContext.id]: this.getKeyboardAction() || KeyboardActionContext.defaultValue
    });
  }
  setRootElementRef() {
    const {
      rootElementRef
    } = this.props;
    if (rootElementRef && this.widgetRootElementRef) {
      rootElementRef.current = this.widgetRootElementRef.current;
    }
  }
  getWidgetRootElement() {
    var _this$widgetRootEleme;
    return null === (_this$widgetRootEleme = this.widgetRootElementRef) || void 0 === _this$widgetRootEleme ? void 0 : _this$widgetRootEleme.current;
  }
  createFakeInstance() {
    return {
      option: () => false,
      element: () => this.getWidgetRootElement(),
      component: this.props._getParentComponentRootNode ? {
        element: () => {
          var _this$props$_getParen, _this$props;
          return null === (_this$props$_getParen = (_this$props = this.props)._getParentComponentRootNode) || void 0 === _this$props$_getParen ? void 0 : _this$props$_getParen.call(_this$props);
        }
      } : {
        element: () => this.getWidgetRootElement()
      },
      _createActionByOption: () => (e) => {
        var _this$props$onKeyDown, _this$props2;
        null === (_this$props$onKeyDown = (_this$props2 = this.props).onKeyDown) || void 0 === _this$props$onKeyDown || _this$props$onKeyDown.call(_this$props2, e);
      }
    };
  }
  getKeyboardAction() {
    return {
      registerKeyboardAction: (element, action) => {
        const fakePaginationInstance = this.createFakeInstance();
        return registerKeyboardAction("pager", fakePaginationInstance, element, void 0, action);
      }
    };
  }
  getInfoVisible() {
    const {
      infoTextVisible,
      showInfo
    } = this.props;
    return !!showInfo && infoTextVisible;
  }
  getPageIndexSelectorVisible() {
    return 0 !== this.props.pageSize;
  }
  getNormalizedDisplayMode() {
    const {
      displayMode,
      lightModeEnabled
    } = this.props;
    if ("adaptive" === displayMode && void 0 !== lightModeEnabled) {
      return lightModeEnabled ? "compact" : "full";
    }
    return displayMode ?? "adaptive";
  }
  getPagesContainerVisible() {
    return !!this.props.pagesNavigatorVisible && this.props.pageCount > 0;
  }
  getPagesContainerVisibility() {
    if ("auto" === this.props.pagesNavigatorVisible && 1 === this.props.pageCount && this.props.hasKnownLastPage) {
      return "hidden";
    }
    return;
  }
  getIsLargeDisplayMode() {
    const displayMode = this.getNormalizedDisplayMode();
    let result2 = false;
    if ("adaptive" === displayMode) {
      result2 = this.props.isLargeDisplayMode;
    } else {
      result2 = "full" === displayMode;
    }
    return result2;
  }
  getClasses() {
    const classesMap = {
      [`${this.props.className}`]: !!this.props.className,
      [PAGER_CLASS]: !!this.props.isGridCompatibilityMode,
      [PAGINATION_CLASS]: !this.props.isGridCompatibilityMode,
      [LIGHT_MODE_CLASS]: !this.getIsLargeDisplayMode()
    };
    return combineClasses(classesMap);
  }
  getAria() {
    return {
      role: "navigation",
      label: this.props.label ?? ""
    };
  }
  componentWillUpdate(nextProps) {
    super.componentWillUpdate();
    if (this.props.onKeyDown !== nextProps.onKeyDown) {
      this.__getterCache.keyboardAction = void 0;
    }
  }
  render() {
    const {
      isGridCompatibilityMode: isGridCompatibilityMode2,
      rtlEnabled,
      visible: visible2,
      showPageSizeSelector,
      allowedPageSizesRef,
      pageSize,
      pageSizeChangedInternal,
      allowedPageSizes,
      infoTextRef,
      infoText,
      pageCount,
      pageIndex,
      itemCount,
      pagesRef,
      hasKnownLastPage,
      maxPagesCount,
      pageIndexChangedInternal,
      pagesCountText,
      showNavigationButtons,
      style,
      width,
      height,
      elementAttr,
      hint,
      disabled,
      tabIndex,
      accessKey,
      activeStateEnabled,
      focusStateEnabled,
      hoverStateEnabled
    } = this.props;
    const content = normalizeProps(createComponentVNode(2, Widget2, _extends({
      rootElementRef: this.widgetRootElementRef,
      rtlEnabled,
      classes: this.getClasses(),
      visible: visible2,
      aria: this.getAria(),
      style,
      width,
      height,
      hint,
      disabled,
      tabIndex,
      accessKey,
      activeStateEnabled,
      focusStateEnabled,
      hoverStateEnabled
    }, elementAttr, {
      children: [showPageSizeSelector && createComponentVNode(2, PageSizeSelector, {
        rootElementRef: allowedPageSizesRef,
        isLargeDisplayMode: this.getIsLargeDisplayMode(),
        itemCount,
        pageSize,
        pageSizeChangedInternal,
        allowedPageSizes
      }), this.getPagesContainerVisible() && createVNode(1, "div", PAGINATION_PAGES_CLASS, [this.getInfoVisible() && createComponentVNode(2, InfoText, {
        rootElementRef: infoTextRef,
        infoText,
        pageCount,
        pageIndex,
        itemCount
      }), this.getPageIndexSelectorVisible() && createVNode(1, "div", PAGINATION_PAGE_INDEXES_CLASS, createComponentVNode(2, PageIndexSelector, {
        hasKnownLastPage,
        isLargeDisplayMode: this.getIsLargeDisplayMode(),
        maxPagesCount,
        pageCount,
        pageIndex,
        pageIndexChangedInternal,
        pagesCountText,
        showNavigationButtons,
        itemCount
      }), 2, null, null, pagesRef)], 0, {
        style: {
          visibility: this.getPagesContainerVisibility()
        }
      })]
    })));
    return createComponentVNode(2, PaginationConfigProvider, {
      isGridCompatibilityMode: isGridCompatibilityMode2,
      children: content
    });
  }
};
PaginationContent.defaultProps = PaginationContentDefaultProps;

// node_modules/devextreme/esm/__internal/pagination/resizable_container.js
function calculateLargeDisplayMode(_ref) {
  let {
    parent: parentWidth,
    allowedPageSizes: pageSizesWidth,
    pages: pagesWidth
  } = _ref;
  return parentWidth - (pageSizesWidth + pagesWidth) > 0;
}
function calculateInfoTextVisible(_ref2) {
  let {
    parent: parentWidth,
    allowedPageSizes: pageSizesWidth,
    pages: pagesWidth,
    info: infoWidth
  } = _ref2;
  const minimalWidth = pageSizesWidth + pagesWidth + infoWidth;
  return parentWidth - minimalWidth > 0;
}
function getElementsWidth(_ref3) {
  let {
    parent,
    allowedPageSizes,
    pages,
    info
  } = _ref3;
  const parentWidth = getElementContentWidth(parent);
  const pageSizesWidth = getElementWidth2(allowedPageSizes);
  const infoWidth = getElementWidth2(info);
  const pagesHtmlWidth = getElementWidth2(pages);
  return {
    parent: parentWidth,
    allowedPageSizes: pageSizesWidth,
    info: infoWidth + getElementStyle2("marginLeft", info) + getElementStyle2("marginRight", info),
    pages: pagesHtmlWidth
  };
}
var ResizableContainerDefaultProps = {
  paginationProps: _extends({}, PaginationDefaultProps)
};
var ResizableContainer = class extends InfernoComponent {
  constructor(props) {
    super(props);
    this.state = {
      infoTextVisible: true,
      isLargeDisplayMode: true
    };
    this.refs = null;
    this.parentRef = createRef();
    this.infoTextRef = createRef();
    this.pagesRef = createRef();
    this.allowedPageSizesRef = createRef();
    this.elementsWidth = {};
    this.actualIsLargeDisplayMode = true;
    this.actualInfoTextVisible = true;
    this.subscribeToResize = this.subscribeToResize.bind(this);
    this.effectUpdateChildProps = this.effectUpdateChildProps.bind(this);
    this.updateAdaptivityProps = this.updateAdaptivityProps.bind(this);
  }
  componentWillUpdate(nextProps, nextState, context2) {
    super.componentWillUpdate(nextProps, nextState, context2);
  }
  createEffects() {
    return [new InfernoEffect(this.subscribeToResize, [this.state.infoTextVisible, this.state.isLargeDisplayMode]), new InfernoEffect(this.effectUpdateChildProps, [this.props, this.state.infoTextVisible, this.state.isLargeDisplayMode, this.props.paginationProps, this.props.contentTemplate])];
  }
  updateEffects() {
    var _this$_effects$, _this$_effects$2;
    null === (_this$_effects$ = this._effects[0]) || void 0 === _this$_effects$ || _this$_effects$.update([this.state.infoTextVisible, this.state.isLargeDisplayMode]);
    null === (_this$_effects$2 = this._effects[1]) || void 0 === _this$_effects$2 || _this$_effects$2.update([this.props, this.state.infoTextVisible, this.state.isLargeDisplayMode, this.props.paginationProps, this.props.contentTemplate]);
  }
  subscribeToResize() {
    const callback = () => {
      if (this.getParentWidth() > 0) {
        this.updateAdaptivityProps();
      }
    };
    resize_callbacks_default.add(callback);
    return () => {
      resize_callbacks_default.remove(callback);
    };
  }
  effectUpdateChildProps() {
    if (this.getParentWidth() > 0) {
      this.updateAdaptivityProps();
    }
  }
  getContentAttributes() {
    const {
      className,
      displayMode,
      isGridCompatibilityMode: isGridCompatibilityMode2,
      _getParentComponentRootNode,
      hasKnownLastPage,
      infoText,
      label,
      lightModeEnabled,
      maxPagesCount,
      onKeyDown,
      pageCount,
      pageIndex,
      pageIndexChangedInternal,
      pageSize,
      pageSizeChangedInternal,
      allowedPageSizes,
      pagesCountText,
      pagesNavigatorVisible,
      rtlEnabled,
      showInfo,
      showNavigationButtons,
      showPageSizeSelector,
      itemCount,
      visible: visible2,
      style,
      width,
      height,
      elementAttr,
      hint,
      disabled,
      tabIndex,
      accessKey,
      activeStateEnabled,
      focusStateEnabled,
      hoverStateEnabled
    } = this.props.paginationProps;
    return {
      pageSize,
      pageIndex,
      pageIndexChangedInternal,
      pageSizeChangedInternal,
      isGridCompatibilityMode: isGridCompatibilityMode2,
      _getParentComponentRootNode,
      className,
      showInfo,
      infoText,
      lightModeEnabled,
      displayMode,
      maxPagesCount,
      pageCount,
      pagesCountText,
      visible: visible2,
      hasKnownLastPage,
      pagesNavigatorVisible,
      showPageSizeSelector,
      allowedPageSizes,
      rtlEnabled,
      showNavigationButtons,
      itemCount,
      onKeyDown,
      label,
      style,
      width,
      height,
      elementAttr,
      hint,
      disabled,
      tabIndex,
      accessKey,
      activeStateEnabled,
      focusStateEnabled,
      hoverStateEnabled
    };
  }
  getParentWidth() {
    var _this$parentRef;
    return null !== (_this$parentRef = this.parentRef) && void 0 !== _this$parentRef && _this$parentRef.current ? getElementWidth2(this.parentRef.current) : 0;
  }
  updateAdaptivityProps() {
    var _this$parentRef2, _this$allowedPageSize, _this$infoTextRef, _this$pagesRef;
    const currentElementsWidth = getElementsWidth({
      parent: null === (_this$parentRef2 = this.parentRef) || void 0 === _this$parentRef2 ? void 0 : _this$parentRef2.current,
      allowedPageSizes: null === (_this$allowedPageSize = this.allowedPageSizesRef) || void 0 === _this$allowedPageSize ? void 0 : _this$allowedPageSize.current,
      info: null === (_this$infoTextRef = this.infoTextRef) || void 0 === _this$infoTextRef ? void 0 : _this$infoTextRef.current,
      pages: null === (_this$pagesRef = this.pagesRef) || void 0 === _this$pagesRef ? void 0 : _this$pagesRef.current
    });
    if (this.actualInfoTextVisible !== this.state.infoTextVisible || this.actualIsLargeDisplayMode !== this.state.isLargeDisplayMode) {
      return;
    }
    const isEmpty3 = !isDefined(this.elementsWidth);
    if (isEmpty3) {
      this.elementsWidth = {};
    }
    if (isEmpty3 || this.state.isLargeDisplayMode) {
      this.elementsWidth.allowedPageSizes = currentElementsWidth.allowedPageSizes;
      this.elementsWidth.pages = currentElementsWidth.pages;
    }
    if (isEmpty3 || this.state.infoTextVisible) {
      this.elementsWidth.info = currentElementsWidth.info;
    }
    this.actualIsLargeDisplayMode = calculateLargeDisplayMode({
      parent: currentElementsWidth.parent,
      allowedPageSizes: this.elementsWidth.allowedPageSizes,
      pages: this.elementsWidth.pages
    });
    this.actualInfoTextVisible = calculateInfoTextVisible(_extends({}, currentElementsWidth, {
      info: this.elementsWidth.info
    }));
    this.setState(() => ({
      infoTextVisible: this.actualInfoTextVisible
    }));
    this.setState(() => ({
      isLargeDisplayMode: this.actualIsLargeDisplayMode
    }));
  }
  render() {
    const {
      infoTextVisible,
      isLargeDisplayMode
    } = this.state;
    const {
      props: {
        contentTemplate: Content
      }
    } = this;
    return normalizeProps(createComponentVNode(2, Content, _extends({
      rootElementRef: this.parentRef,
      allowedPageSizesRef: this.allowedPageSizesRef,
      infoTextRef: this.infoTextRef,
      pagesRef: this.pagesRef,
      infoTextVisible,
      isLargeDisplayMode
    }, this.getContentAttributes())));
  }
};
ResizableContainer.defaultProps = ResizableContainerDefaultProps;

// node_modules/devextreme/esm/__internal/pagination/pagination.js
var Pagination = class extends InfernoWrapperComponent {
  constructor(props) {
    super(props);
    this.__getterCache = {};
    this.pageIndexChangedInternal = this.pageIndexChangedInternal.bind(this);
    this.pageSizeChangedInternal = this.pageSizeChangedInternal.bind(this);
  }
  createEffects() {
    return [createReRenderEffect()];
  }
  pageIndexChangedInternal(newPageIndex) {
    const newValue = newPageIndex + 1;
    this.setState(() => ({
      pageIndex: newValue
    }));
    this.props.pageIndexChangedInternal(newValue);
  }
  getPageIndex() {
    return this.props.pageIndex - 1;
  }
  pageSizeChangedInternal(newPageSize) {
    this.setState(() => ({
      pageSize: newPageSize
    }));
    this.props.pageSizeChangedInternal(newPageSize);
  }
  getClassName() {
    return combineClasses({
      "dx-datagrid-pager": isGridCompatibilityMode(this.context),
      [`${this.props.className}`]: !!this.props.className
    });
  }
  getPaginationProps() {
    return _extends({}, this.props, {
      className: this.getClassName(),
      pageIndex: this.getPageIndex(),
      pageIndexChangedInternal: (pageIndex) => this.pageIndexChangedInternal(pageIndex),
      pageSizeChangedInternal: (pageSize) => this.pageSizeChangedInternal(pageSize)
    });
  }
  render() {
    return createComponentVNode(2, ResizableContainer, {
      contentTemplate: PaginationContent,
      paginationProps: this.getPaginationProps()
    });
  }
};
Pagination.defaultProps = PaginationDefaultProps;

// node_modules/devextreme/esm/__internal/pagination/utils/validation_utils.js
function getPageSize(pageSize) {
  if (pageSize < 0) {
    return 1;
  }
  return pageSize;
}
function getItemCount(itemCount) {
  if (itemCount < 0) {
    return 0;
  }
  return itemCount;
}
function getPageCount(pageSize, itemCount) {
  if (pageSize > 0 && itemCount > 0) {
    return Math.max(1, Math.ceil(itemCount / pageSize));
  }
  return 1;
}
function getPageIndex(pageIndex, pageSize, itemCount) {
  if (pageIndex < 1) {
    return 1;
  }
  const pageCount = getPageCount(pageSize, itemCount);
  return Math.min(pageIndex, pageCount);
}
function validateOptions(oldPageSize, oldPageIndex, oldItemCount) {
  const pageSize = getPageSize(oldPageSize);
  const itemCount = getItemCount(oldItemCount);
  const pageCount = getPageCount(pageSize, oldItemCount);
  const pageIndex = getPageIndex(oldPageIndex, pageSize, itemCount);
  return {
    pageSize,
    pageIndex,
    itemCount,
    pageCount
  };
}

// node_modules/devextreme/esm/__internal/pagination/wrappers/pagination_wrapper.js
var _excluded12 = ["pageSize", "pageIndex", "itemCount"];
var PaginationWrapper = class extends ComponentWrapper {
  _optionChanged(args) {
    switch (args.name) {
      case "pageIndex": {
        const pageIndexChanged = this.option("pageIndexChanged");
        if (pageIndexChanged) {
          pageIndexChanged(args.value);
        }
        break;
      }
      case "pageSize": {
        const pageSizeChanged = this.option("pageSizeChanged");
        if (pageSizeChanged) {
          pageSizeChanged(args.value);
        }
        break;
      }
    }
    super._optionChanged(args);
  }
  getPageCount() {
    return this.option("pageCount");
  }
  _validateOptions(options2) {
    if (options2._skipValidation || this.option("_skipValidation")) {
      return options2;
    }
    const initialOptions = super._validateOptions(options2);
    let {
      pageSize,
      pageIndex,
      itemCount
    } = initialOptions, rest = _objectWithoutPropertiesLoose(initialOptions, _excluded12);
    if (void 0 === pageSize) {
      pageSize = this.option("pageSize");
    }
    if (void 0 === pageIndex) {
      pageIndex = this.option("pageIndex");
    }
    if (void 0 === itemCount) {
      itemCount = this.option("itemCount");
    }
    const validatedOptions = validateOptions(pageSize, pageIndex, itemCount);
    return _extends({}, rest, validatedOptions);
  }
};

// node_modules/devextreme/esm/__internal/pagination/wrappers/pagination.js
var Pagination2 = class extends PaginationWrapper {
  getProps() {
    const props = super.getProps();
    props.onKeyDown = this._wrapKeyDownHandler(props.onKeyDown);
    return props;
  }
  get _propsInfo() {
    return {
      twoWay: [
        ["pageSize", "defaultPageSize", "pageSizeChangedInternal", "pageSizeChanged"],
        ["pageIndex", "defaultPageIndex", "pageIndexChangedInternal", "pageIndexChanged"]
      ],
      allowNull: [],
      elements: [],
      templates: [],
      props: ["defaultPageSize", "pageSizeChanged", "pageSizeChangedInternal", "defaultPageIndex", "pageIndexChanged", "pageIndexChangedInternal", "isGridCompatibilityMode", "className", "showInfo", "infoText", "lightModeEnabled", "displayMode", "maxPagesCount", "pageCount", "pagesCountText", "visible", "hasKnownLastPage", "pagesNavigatorVisible", "showPageSizeSelector", "allowedPageSizes", "rtlEnabled", "showNavigationButtons", "itemCount", "label", "onKeyDown", "pageSize", "pageIndex", "width", "height", "elementAttr", "hint", "disabled", "tabIndex", "accessKey", "activeStateEnabled", "focusStateEnabled", "hoverStateEnabled", "_skipValidation", "_getParentComponentRootNode"]
    };
  }
  get _viewComponent() {
    return Pagination;
  }
};

// node_modules/devextreme/esm/__internal/grids/grid_core/pager/m_pager.js
var getPageIndex2 = function(dataController2) {
  return 1 + (parseInt(dataController2.pageIndex()) || 0);
};
var PagerView = class extends m_modules_default.View {
  init() {
    const dataController2 = this.getController("data");
    dataController2.changed.add((e) => {
      if (e && e.repaintChangesOnly) {
        const pager = this._pager;
        if (pager) {
          pager.option({
            pageIndex: getPageIndex2(dataController2),
            pageSize: dataController2.pageSize(),
            pageCount: dataController2.pageCount(),
            itemCount: dataController2.totalCount(),
            hasKnownLastPage: dataController2.hasKnownLastPage()
          });
        } else {
          this.render();
        }
      } else if (!e || "update" !== e.changeType && "updateSelection" !== e.changeType && "updateFocusedRow" !== e.changeType) {
        this._pager = null;
        this.render();
      }
    });
  }
  dispose() {
    this._pager = null;
  }
  optionChanged(args) {
    const {
      name: name2
    } = args;
    const isPager = "pager" === name2;
    const isPaging = "paging" === name2;
    const isDataSource = "dataSource" === name2;
    const isScrolling = "scrolling" === name2;
    const dataController2 = this.getController("data");
    if (isPager || isPaging || isScrolling || isDataSource) {
      args.handled = true;
      if (dataController2.skipProcessingPagingChange(args.fullName)) {
        return;
      }
      if (isPager || isPaging) {
        this._pageSizes = null;
      }
      if (!isDataSource) {
        this._pager = null;
        this._invalidate();
        if (hasWindow() && isPager && this.component) {
          this.component.resize();
        }
      }
    }
  }
  _renderCore() {
    const that = this;
    const $element = that.element().addClass(that.addWidgetPrefix("pager"));
    const pagerOptions = that.option("pager") ?? {};
    const dataController2 = that.getController("data");
    const keyboardController = that.getController("keyboardNavigation");
    const options2 = {
      maxPagesCount: 10,
      pageIndex: getPageIndex2(dataController2),
      pageCount: dataController2.pageCount(),
      pageSize: dataController2.pageSize(),
      showPageSizeSelector: pagerOptions.showPageSizeSelector,
      showInfo: pagerOptions.showInfo,
      displayMode: pagerOptions.displayMode,
      pagesNavigatorVisible: pagerOptions.visible,
      showNavigationButtons: pagerOptions.showNavigationButtons,
      label: pagerOptions.label,
      allowedPageSizes: that.getPageSizes(),
      itemCount: dataController2.totalCount(),
      hasKnownLastPage: dataController2.hasKnownLastPage(),
      rtlEnabled: that.option("rtlEnabled"),
      isGridCompatibilityMode: true,
      _getParentComponentRootNode: () => this.component.element(),
      _skipValidation: true,
      pageIndexChanged(pageIndex) {
        if (dataController2.pageIndex() !== pageIndex - 1) {
          dataController2.pageIndex(pageIndex - 1);
        }
      },
      pageSizeChanged(pageSize) {
        dataController2.pageSize(pageSize);
      },
      onKeyDown: (e) => keyboardController && keyboardController.executeAction("onKeyDown", e)
    };
    if (isDefined(pagerOptions.infoText)) {
      options2.infoText = pagerOptions.infoText;
    }
    if (this._pager) {
      this._pager.repaint();
      return;
    }
    if (hasWindow()) {
      this._pager = that._createComponent($element, Pagination2, options2);
    } else {
      $element.addClass("dx-pager").html('<div class="dx-pages"><div class="dx-page"></div></div>');
    }
  }
  getPager() {
    return this._pager;
  }
  getPageSizes() {
    const that = this;
    const dataController2 = that.getController("data");
    const pagerOptions = that.option("pager");
    const allowedPageSizes = pagerOptions && pagerOptions.allowedPageSizes;
    const pageSize = dataController2.pageSize();
    if (!isDefined(that._pageSizes) || !that._pageSizes.includes(pageSize)) {
      that._pageSizes = [];
      if (pagerOptions) {
        if (Array.isArray(allowedPageSizes)) {
          that._pageSizes = allowedPageSizes;
        } else if (allowedPageSizes && pageSize > 1) {
          that._pageSizes = [Math.floor(pageSize / 2), pageSize, 2 * pageSize];
        }
      }
    }
    return that._pageSizes;
  }
  isVisible() {
    const dataController2 = this.getController("data");
    const pagerOptions = this.option("pager");
    let pagerVisible = pagerOptions && pagerOptions.visible;
    const scrolling = this.option("scrolling");
    if ("auto" === pagerVisible) {
      if (scrolling && ("virtual" === scrolling.mode || "infinite" === scrolling.mode)) {
        pagerVisible = false;
      } else {
        pagerVisible = dataController2.pageCount() > 1 || dataController2.isLoaded() && !dataController2.hasKnownLastPage();
      }
    }
    return !!pagerVisible;
  }
  getHeight() {
    return this.getElementHeight();
  }
};
var pagerModule = {
  defaultOptions: () => ({
    pager: {
      visible: "auto",
      showPageSizeSelector: false,
      allowedPageSizes: "auto",
      label: message_default.format("dxPager-ariaLabel")
    }
  }),
  views: {
    pagerView: PagerView
  }
};

// node_modules/devextreme/esm/__internal/grids/data_grid/module_not_extended/pager.js
m_core_default.registerModule("pager", pagerModule);

// node_modules/devextreme/esm/__internal/grids/grid_core/columns_resizing_reordering/m_columns_resizing_reordering.js
var COLUMNS_SEPARATOR_TRANSPARENT = "columns-separator-transparent";
var MODULE_NAMESPACE2 = "dxDataGridResizingReordering";
var allowResizing = function(that) {
  return that.option("allowColumnResizing") || that.getController("columns").isColumnOptionUsed("allowResizing");
};
var allowReordering = function(that) {
  return that.option("allowColumnReordering") || that.getController("columns").isColumnOptionUsed("allowReordering");
};
var TrackerView = class extends m_modules_default.View {
  init() {
    super.init();
    this._tablePositionController = this.getController("tablePosition");
    this._subscribeToCallback();
  }
  dispose() {
    this._unsubscribeFromCallback();
    super.dispose();
  }
  optionChanged(args) {
    if ("allowColumnResizing" === args.name) {
      this._unsubscribeFromCallback();
      if (args.value) {
        this._subscribeToCallback();
        this._invalidate();
      }
    }
    super.optionChanged(args);
  }
  _renderCore() {
    const deferred = super._renderCore();
    this.element().addClass(this.addWidgetPrefix("tracker"));
    this.hide();
    return deferred;
  }
  _unsubscribeFromCallback() {
    if (this._positionChanged) {
      this._tablePositionController.positionChanged.remove(this._positionChanged);
    }
  }
  _subscribeToCallback() {
    const that = this;
    that._positionChanged = function(position3) {
      const $element = that.element();
      if (null !== $element && void 0 !== $element && $element.hasClass(that.addWidgetPrefix("tracker"))) {
        $element.css({
          top: position3.top
        });
        setHeight($element, position3.height);
      }
    };
    this._tablePositionController.positionChanged.add(that._positionChanged);
  }
  isVisible() {
    return allowResizing(this);
  }
  show() {
    this.element().show();
  }
  hide() {
    var _this$element;
    null === (_this$element = this.element()) || void 0 === _this$element || _this$element.hide();
  }
  setHeight(value2) {
    setHeight(this.element(), value2);
  }
};
var SeparatorView = class extends m_modules_default.View {
  _renderSeparator() {
  }
  _renderCore(options2) {
    const deferred = super._renderCore(options2);
    this._isShown = true;
    this._renderSeparator();
    this.hide();
    return deferred;
  }
  show() {
    this._isShown = true;
  }
  hide() {
    this._isShown = false;
  }
  height(value2) {
    const $element = this.element();
    if ($element) {
      if (isDefined(value2)) {
        setHeight($element, value2);
      } else {
        return getHeight($element);
      }
    }
  }
  width(value2) {
    const $element = this.element();
    if ($element) {
      if (isDefined(value2)) {
        setWidth($element, value2);
      } else {
        return getWidth($element);
      }
    }
  }
};
var ColumnsSeparatorView = class extends SeparatorView {
  init() {
    super.init();
    this._tablePositionController = this.getController("tablePosition");
    this._init();
  }
  dispose() {
    this._unsubscribeFromCallback();
    super.dispose();
  }
  optionChanged(args) {
    if ("allowColumnResizing" === args.name) {
      if (args.value) {
        this._init();
        this._invalidate();
        this.hide(true);
      } else {
        this._unsubscribeFromCallback();
        this._isTransparent = allowResizing(this);
        this.hide(true);
      }
    }
    super.optionChanged(args);
  }
  _renderSeparator() {
    super._renderSeparator();
    const $element = this.element();
    $element.addClass(this.addWidgetPrefix("columns-separator"));
  }
  _subscribeToCallback() {
    const that = this;
    let $element;
    that._positionChanged = function(position3) {
      $element = that.element();
      if ($element) {
        $element.css({
          top: position3.top
        });
        setHeight($element, position3.height);
      }
    };
    that._tablePositionController.positionChanged.add(that._positionChanged);
  }
  _unsubscribeFromCallback() {
    this._positionChanged && this._tablePositionController.positionChanged.remove(this._positionChanged);
  }
  _init() {
    this._isTransparent = allowResizing(this);
    if (this.isVisible()) {
      this._subscribeToCallback();
    }
  }
  isVisible() {
    return this.option("showColumnHeaders") && (allowReordering(this) || allowResizing(this));
  }
  show() {
    const that = this;
    const $element = this.element();
    if ($element && !that._isShown) {
      if (that._isTransparent) {
        $element.removeClass(that.addWidgetPrefix(COLUMNS_SEPARATOR_TRANSPARENT));
      } else {
        $element.show();
      }
    }
    super.show();
  }
  hide(force) {
    const $element = this.element();
    const columnsSeparatorTransparent = this.addWidgetPrefix(COLUMNS_SEPARATOR_TRANSPARENT);
    if ($element && (this._isShown || force)) {
      if (this._isTransparent) {
        $element.addClass(columnsSeparatorTransparent);
        $element.css("left", "");
        $element.show();
      } else {
        if ($element.hasClass(columnsSeparatorTransparent)) {
          $element.removeClass(columnsSeparatorTransparent);
        }
        $element.hide();
      }
    }
    super.hide();
  }
  moveByX(outerX) {
    const $element = this.element();
    if ($element) {
      $element.css("left", null === outerX ? 0 : outerX - this._parentElement().offset().left);
    }
  }
  changeCursor(cursorName) {
    cursorName = isDefined(cursorName) ? cursorName : "";
    const $element = this.element();
    if ($element) {
      $element.css("cursor", cursorName);
    }
  }
};
var BlockSeparatorView = class extends SeparatorView {
  init() {
    super.init();
    const dataController2 = this.getController("data");
    dataController2.loadingChanged.add((isLoading) => {
      if (!isLoading) {
        this.hide();
      }
    });
  }
  _renderSeparator() {
    super._renderSeparator();
    this.element().addClass("dx-block-separator").html("&nbsp;");
  }
  hide() {
    const that = this;
    const $parent = this._parentElement();
    const $element = this.element();
    if ($element && this._isShown) {
      $element.css("display", "none");
    }
    if ($parent && !$parent.children(".dx-block-separator").length) {
      $parent.prepend(that.element());
    }
    super.hide();
  }
  isVisible() {
    const groupPanelOptions = this.option("groupPanel");
    const columnChooserOptions = this.option("columnChooser");
    return (null === groupPanelOptions || void 0 === groupPanelOptions ? void 0 : groupPanelOptions.visible) || (null === columnChooserOptions || void 0 === columnChooserOptions ? void 0 : columnChooserOptions.enabled);
  }
  show(targetLocation) {
    const $element = this.element();
    if ($element && !this._isShown) {
      switch (targetLocation) {
        case "group":
          this.element().css("display", "block");
          break;
        case "columnChooser":
          !function(toOptions) {
            fx_default.stop($element, true);
            fx_default.animate($element, {
              type: "slide",
              from: {
                width: 0,
                display: toOptions.display
              },
              to: toOptions,
              duration: 300,
              easing: "swing"
            });
          }({
            width: "100%",
            display: "block"
          });
          break;
        default:
          $element.css("display", "");
      }
    }
    super.show();
  }
};
var DraggingHeaderView = class extends m_modules_default.View {
  init() {
    super.init();
    const dataController2 = this.getController("data");
    this._controller = this.getController("draggingHeader");
    this._columnsResizerViewController = this.getController("columnsResizer");
    this._columnsController = this.getController("columns");
    this._isDragging = false;
    dataController2.loadingChanged.add((isLoading) => {
      const element = this.element();
      if (!isLoading && element) {
        element.hide();
      }
    });
  }
  isDragging() {
    return this._isDragging;
  }
  _getDraggingPanelByPos(pos) {
    let result2;
    each(this._dragOptions.draggingPanels, (index2, draggingPanel) => {
      if (draggingPanel) {
        const boundingRect = draggingPanel.getBoundingRect();
        if (boundingRect && (void 0 === boundingRect.bottom || pos.y < boundingRect.bottom) && (void 0 === boundingRect.top || pos.y > boundingRect.top) && (void 0 === boundingRect.left || pos.x > boundingRect.left) && (void 0 === boundingRect.right || pos.x < boundingRect.right)) {
          result2 = draggingPanel;
          return false;
        }
      }
      return;
    });
    return result2;
  }
  _renderCore() {
    this.element().addClass(`${this.addWidgetPrefix("drag-header")} ${this.addWidgetPrefix("text-content")} dx-widget`).hide();
  }
  _resetTargetColumnOptions() {
    const params = this._dropOptions;
    params.targetColumnIndex = -1;
    delete params.targetColumnElement;
    delete params.isLast;
    delete params.posX;
    delete params.posY;
  }
  _getVisibleIndexObject(rowIndex, visibleIndex) {
    if (isDefined(rowIndex)) {
      return {
        columnIndex: visibleIndex,
        rowIndex
      };
    }
    return visibleIndex;
  }
  dispose() {
    const element = this.element();
    this._dragOptions = null;
    null === element || void 0 === element || element.parent().find(`.${this.addWidgetPrefix("drag-header")}`).remove();
  }
  isVisible() {
    const commonColumnSettings = this._columnsController.getCommonSettings();
    return this.option("showColumnHeaders") && (allowReordering(this) || commonColumnSettings.allowGrouping || commonColumnSettings.allowHiding);
  }
  dragHeader(options2) {
    const {
      columnElement
    } = options2;
    const isCommandColumn = !!options2.sourceColumn.type;
    this._isDragging = true;
    this._dragOptions = options2;
    this._dropOptions = {
      sourceIndex: options2.index,
      sourceColumnIndex: this._getVisibleIndexObject(options2.rowIndex, options2.columnIndex),
      sourceColumnElement: options2.columnElement,
      sourceLocation: options2.sourceLocation
    };
    const document2 = dom_adapter_default.getDocument();
    this._onSelectStart = document2.onselectstart;
    document2.onselectstart = function() {
      return false;
    };
    this._controller.drag(this._dropOptions);
    this.element().css({
      textAlign: null === columnElement || void 0 === columnElement ? void 0 : columnElement.css("textAlign"),
      height: columnElement && (isCommandColumn && columnElement.get(0).clientHeight || getHeight(columnElement)),
      width: columnElement && (isCommandColumn && columnElement.get(0).clientWidth || getWidth(columnElement)),
      whiteSpace: null === columnElement || void 0 === columnElement ? void 0 : columnElement.css("whiteSpace")
    }).addClass(this.addWidgetPrefix("drag-action")).toggleClass("dx-drag-command-cell", isCommandColumn).text(isCommandColumn ? "" : options2.sourceColumn.caption);
    this.element().appendTo(swatch_container_default.getSwatchContainer(columnElement));
  }
  moveHeader(args) {
    const e = args.event;
    const {
      that
    } = e.data;
    const eventData2 = eventData(e);
    const isResizing = that._columnsResizerViewController ? that._columnsResizerViewController.isResizing() : false;
    const dragOptions = that._dragOptions;
    if (that._isDragging && !isResizing) {
      const $element = that.element();
      const moveDeltaX = Math.abs(eventData2.x - dragOptions.columnElement.offset().left - dragOptions.deltaX);
      const moveDeltaY = Math.abs(eventData2.y - dragOptions.columnElement.offset().top - dragOptions.deltaY);
      if ($element.is(":visible") || moveDeltaX > 5 || moveDeltaY > 5) {
        $element.show();
        const newLeft = eventData2.x - dragOptions.deltaX;
        const newTop = eventData2.y - dragOptions.deltaY;
        $element.css({
          left: newLeft,
          top: newTop
        });
        that.dockHeader(eventData2);
      }
      e.preventDefault();
    }
  }
  dockHeader(eventData2) {
    const that = this;
    const targetDraggingPanel = that._getDraggingPanelByPos(eventData2);
    const controller = that._controller;
    const params = that._dropOptions;
    const dragOptions = that._dragOptions;
    if (targetDraggingPanel) {
      const rtlEnabled = that.option("rtlEnabled");
      const isVerticalOrientation = "columnChooser" === targetDraggingPanel.getName();
      const axisName = isVerticalOrientation ? "y" : "x";
      const targetLocation = targetDraggingPanel.getName();
      const rowIndex = "headers" === targetLocation ? dragOptions.rowIndex : void 0;
      const {
        sourceColumn
      } = dragOptions;
      const columnElements = targetDraggingPanel.getColumnElements(rowIndex, null === sourceColumn || void 0 === sourceColumn ? void 0 : sourceColumn.ownerBand) || [];
      const pointsByTarget = dragOptions.pointsByTarget = dragOptions.pointsByTarget || {};
      const pointsByColumns = "columnChooser" === targetLocation ? [] : pointsByTarget[targetLocation] || controller._generatePointsByColumns(extend({}, dragOptions, {
        targetDraggingPanel,
        columns: targetDraggingPanel.getColumns(rowIndex),
        columnElements,
        isVerticalOrientation,
        startColumnIndex: "headers" === targetLocation ? renderer_default(columnElements[0]).index() : 0
      }));
      pointsByTarget[targetLocation] = pointsByColumns;
      params.targetLocation = targetLocation;
      if (pointsByColumns.length > 0) {
        for (let i = 0; i < pointsByColumns.length; i++) {
          const centerPosition = pointsByColumns[i + 1] && (pointsByColumns[i][axisName] + pointsByColumns[i + 1][axisName]) / 2;
          if (void 0 === centerPosition || (rtlEnabled && "x" === axisName ? eventData2[axisName] > centerPosition : eventData2[axisName] < centerPosition)) {
            params.targetColumnIndex = that._getVisibleIndexObject(rowIndex, pointsByColumns[i].columnIndex);
            if (columnElements[i]) {
              params.targetColumnElement = columnElements.eq(i);
              params.isLast = false;
            } else {
              params.targetColumnElement = columnElements.last();
              params.isLast = true;
            }
            params.posX = pointsByColumns[i].x;
            params.posY = pointsByColumns[i].y;
            controller.dock(params);
            break;
          }
        }
      } else {
        that._resetTargetColumnOptions();
        controller.dock(params);
      }
    }
  }
  dropHeader(args) {
    const e = args.event;
    const {
      that
    } = e.data;
    const controller = that._controller;
    that.element().hide();
    if (controller && that._isDragging) {
      controller.drop(that._dropOptions);
    }
    that.element().appendTo(that._parentElement());
    that._dragOptions = null;
    that._dropOptions = null;
    that._isDragging = false;
    dom_adapter_default.getDocument().onselectstart = that._onSelectStart || null;
  }
};
var isNextColumnResizingMode = function(that) {
  return "widget" !== that.option("columnResizingMode");
};
var ColumnsResizerViewController = class extends m_modules_default.ViewController {
  init() {
    this._subscribesToCallbacks = [];
    if (allowResizing(this)) {
      this._init();
    }
  }
  dispose() {
    this._unsubscribes();
    super.dispose();
  }
  optionChanged(args) {
    super.optionChanged(args);
    if ("allowColumnResizing" === args.name) {
      if (args.value) {
        this._init();
        this._subscribeToEvents();
      } else {
        this._unsubscribes();
      }
    }
  }
  _isHeadersRowArea(posY) {
    if (this._columnHeadersView) {
      const element = this._columnHeadersView.element();
      if (element) {
        const offsetTop = element.offset().top;
        const headersRowHeight = this._columnHeadersView.getHeadersRowHeight();
        return posY >= offsetTop && posY <= offsetTop + headersRowHeight;
      }
    }
    return false;
  }
  _isRtlParentStyle() {
    var _this$_$parentContain;
    const rtlEnabled = this.option("rtlEnabled");
    return rtlEnabled && "rtl" === (null === (_this$_$parentContain = this._$parentContainer) || void 0 === _this$_$parentContain ? void 0 : _this$_$parentContain.parent().css("direction"));
  }
  _correctColumnIndexForPoint(point, correctionValue, columns7) {
    point.columnIndex -= correctionValue;
  }
  _pointCreated(point, cellsLength, columns7) {
    const isNextColumnMode = isNextColumnResizingMode(this);
    const rtlEnabled = this.option("rtlEnabled");
    const isRtlParentStyle = this._isRtlParentStyle();
    const firstPointColumnIndex = !isNextColumnMode && rtlEnabled && !isRtlParentStyle ? 0 : 1;
    if (point.index >= firstPointColumnIndex && point.index < cellsLength + (!isNextColumnMode && (!rtlEnabled || isRtlParentStyle) ? 1 : 0)) {
      this._correctColumnIndexForPoint(point, firstPointColumnIndex, columns7);
      const currentColumn = columns7[point.columnIndex] || {};
      const nextColumn = columns7[point.columnIndex + 1] || {};
      return !(isNextColumnMode ? currentColumn.allowResizing && nextColumn.allowResizing : currentColumn.allowResizing);
    }
    return true;
  }
  _getTargetPoint(pointsByColumns, currentX, deltaX) {
    if (pointsByColumns) {
      for (let i = 0; i < pointsByColumns.length; i++) {
        if (pointsByColumns[i].x === pointsByColumns[0].x && pointsByColumns[i + 1] && pointsByColumns[i].x === pointsByColumns[i + 1].x) {
          continue;
        }
        if (pointsByColumns[i].x - deltaX <= currentX && currentX <= pointsByColumns[i].x + deltaX) {
          return pointsByColumns[i];
        }
      }
    }
    return null;
  }
  getSeparatorOffsetX($cell) {
    var _$cell$offset;
    const isNextColumnMode = isNextColumnResizingMode(this);
    const rtlEnabled = this.option("rtlEnabled");
    const isRtlParentStyle = this._isRtlParentStyle();
    const outerWidth = $cell[0].getBoundingClientRect().width;
    const cellOffset = (null === (_$cell$offset = $cell.offset()) || void 0 === _$cell$offset ? void 0 : _$cell$offset.left) ?? 0;
    return cellOffset + ((isNextColumnMode || isRtlParentStyle) && rtlEnabled ? 0 : outerWidth);
  }
  _moveSeparator(args) {
    var _that$_draggingHeader;
    const e = args.event;
    const that = e.data;
    const columnsSeparatorWidth = that._columnsSeparatorView.width();
    const isNextColumnMode = isNextColumnResizingMode(that);
    const deltaX = columnsSeparatorWidth / 2;
    const parentOffset = that._$parentContainer.offset();
    const parentOffsetLeft = parentOffset.left;
    const eventData2 = eventData(e);
    const isRtlParentStyle = this._isRtlParentStyle();
    const isDragging = null === (_that$_draggingHeader = that._draggingHeaderView) || void 0 === _that$_draggingHeader ? void 0 : _that$_draggingHeader.isDragging();
    if (that._isResizing && that._resizingInfo) {
      if ((parentOffsetLeft <= eventData2.x || !isNextColumnMode && isRtlParentStyle) && (!isNextColumnMode || eventData2.x <= parentOffsetLeft + getWidth(that._$parentContainer))) {
        if (that._updateColumnsWidthIfNeeded(eventData2.x)) {
          const $cell = that._columnHeadersView.getColumnElements().eq(that._resizingInfo.currentColumnIndex);
          if ($cell.length) {
            const offsetX = this.getSeparatorOffsetX($cell);
            that._columnsSeparatorView.moveByX(offsetX);
            that._tablePositionController.update(that._targetPoint.y);
            e.preventDefault();
          }
        }
      }
    } else if (!isDragging) {
      if (that._isHeadersRowArea(eventData2.y)) {
        if (that._previousParentOffset) {
          if (that._previousParentOffset.left !== parentOffset.left || that._previousParentOffset.top !== parentOffset.top) {
            that.pointsByColumns(null);
          }
        }
        that._targetPoint = that._getTargetPoint(that.pointsByColumns(), eventData2.x, columnsSeparatorWidth);
        that._previousParentOffset = parentOffset;
        that._isReadyResizing = false;
        if (that._targetPoint) {
          that._columnsSeparatorView.changeCursor("col-resize");
          that._columnsSeparatorView.moveByX(that._targetPoint.x - deltaX);
          that._tablePositionController.update(that._targetPoint.y);
          that._isReadyResizing = true;
          e.preventDefault();
        } else {
          that._columnsSeparatorView.changeCursor();
          that._columnsSeparatorView.moveByX(null);
        }
      } else {
        that.pointsByColumns(null);
        that._isReadyResizing = false;
        that._columnsSeparatorView.changeCursor();
        that._columnsSeparatorView.moveByX(null);
      }
    }
  }
  _endResizing(args) {
    const e = args.event;
    const that = e.data;
    if (that._isResizing) {
      that.pointsByColumns(null);
      that._resizingInfo = null;
      that._columnsSeparatorView.hide();
      that._columnsSeparatorView.changeCursor();
      that._trackerView.hide();
      that._isReadyResizing = false;
      that._isResizing = false;
    }
  }
  _getNextColumnIndex(currentColumnIndex) {
    return currentColumnIndex + 1;
  }
  _setupResizingInfo(posX) {
    const currentColumnIndex = this._targetPoint.columnIndex;
    const nextColumnIndex = this._getNextColumnIndex(currentColumnIndex);
    const $currentHeader = this._columnHeadersView.getHeaderElement(currentColumnIndex);
    const $nextHeader = this._columnHeadersView.getHeaderElement(nextColumnIndex);
    this._resizingInfo = {
      startPosX: posX,
      currentColumnIndex,
      currentColumnWidth: null !== $currentHeader && void 0 !== $currentHeader && $currentHeader.length ? getBoundingRect($currentHeader[0]).width : 0,
      nextColumnIndex,
      nextColumnWidth: null !== $nextHeader && void 0 !== $nextHeader && $nextHeader.length ? getBoundingRect($nextHeader[0]).width : 0,
      needToInvertResizing: this._needToInvertResizing($currentHeader)
    };
  }
  _startResizing(args) {
    const e = args.event;
    const that = e.data;
    const eventData2 = eventData(e);
    if (isTouchEvent(e)) {
      if (that._isHeadersRowArea(eventData2.y)) {
        that._targetPoint = that._getTargetPoint(that.pointsByColumns(), eventData2.x, 10);
        if (that._targetPoint) {
          that._columnsSeparatorView.moveByX(that._targetPoint.x - that._columnsSeparatorView.width() / 2);
          that._isReadyResizing = true;
        }
      } else {
        that._isReadyResizing = false;
      }
    }
    if (that._isReadyResizing) {
      that._setupResizingInfo(eventData2.x);
      that._isResizing = true;
      that._tablePositionController.update(that._targetPoint.y);
      that._columnsSeparatorView.show();
      that._trackerView.show();
      const scrollable = that.component.getScrollable();
      if (scrollable && that._isRtlParentStyle()) {
        that._scrollRight = getWidth(scrollable.$content()) - getWidth(scrollable.container()) - scrollable.scrollLeft();
      }
      e.preventDefault();
      e.stopPropagation();
    }
    if (this.isResizing()) {
      this._editorFactoryController.loseFocus();
    }
  }
  _generateColumnsTopYIndex() {
    let needToCheckPrevPoint = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : false;
    const that = this;
    const rowCount = that._columnsController.getRowCount();
    const topYMap = {};
    const pointCreated = (point) => {
      const x = Math.ceil(point.x);
      if (!topYMap[x]) {
        topYMap[x] = point.y;
      }
      return true;
    };
    for (let rowIndex = 0; rowIndex < rowCount - 1; rowIndex++) {
      const cells = that._columnHeadersView.getColumnElements(rowIndex);
      if (cells && cells.length > 0) {
        m_utils_default.getPointsByColumns(cells, pointCreated, false, 0, needToCheckPrevPoint);
      }
    }
    return topYMap;
  }
  _generatePointsByColumns() {
    let needToCheckPrevPoint = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : false;
    const that = this;
    const topYMap = that._generateColumnsTopYIndex(needToCheckPrevPoint);
    const columns7 = that._columnsController ? that._columnsController.getVisibleColumns() : [];
    const cells = that._columnHeadersView.getColumnElements();
    that._pointsByColumns = [];
    if (cells && cells.length > 0) {
      that._pointsByColumns = m_utils_default.getPointsByColumns(cells, (point) => that._pointCreated(((point2) => {
        const x = Math.ceil(point2.x);
        if (topYMap[x]) {
          point2.y = topYMap[x];
        }
        return point2;
      })(point), cells.length, columns7), false, 0, needToCheckPrevPoint);
    }
  }
  _needToInvertResizing($cell) {
    const rtlEnabled = this.option("rtlEnabled");
    const isRtlParentStyle = this._isRtlParentStyle();
    const isNextColumnMode = isNextColumnResizingMode(this);
    return (isNextColumnMode || isRtlParentStyle) && rtlEnabled;
  }
  _unsubscribeFromEvents() {
    this._moveSeparatorHandler && m_events_engine_default.off(dom_adapter_default.getDocument(), addNamespace2(m_pointer_default.move, MODULE_NAMESPACE2), this._moveSeparatorHandler);
    this._startResizingHandler && m_events_engine_default.off(this._$parentContainer, addNamespace2(m_pointer_default.down, MODULE_NAMESPACE2), this._startResizingHandler);
    if (this._endResizingHandler) {
      m_events_engine_default.off(this._columnsSeparatorView.element(), addNamespace2(m_pointer_default.up, MODULE_NAMESPACE2), this._endResizingHandler);
      m_events_engine_default.off(dom_adapter_default.getDocument(), addNamespace2(m_pointer_default.up, MODULE_NAMESPACE2), this._endResizingHandler);
    }
  }
  _subscribeToEvents() {
    this._moveSeparatorHandler = this.createAction(this._moveSeparator);
    this._startResizingHandler = this.createAction(this._startResizing);
    this._endResizingHandler = this.createAction(this._endResizing);
    m_events_engine_default.on(dom_adapter_default.getDocument(), addNamespace2(m_pointer_default.move, MODULE_NAMESPACE2), this, this._moveSeparatorHandler);
    m_events_engine_default.on(this._$parentContainer, addNamespace2(m_pointer_default.down, MODULE_NAMESPACE2), this, this._startResizingHandler);
    m_events_engine_default.on(this._columnsSeparatorView.element(), addNamespace2(m_pointer_default.up, MODULE_NAMESPACE2), this, this._endResizingHandler);
    m_events_engine_default.on(dom_adapter_default.getDocument(), addNamespace2(m_pointer_default.up, MODULE_NAMESPACE2), this, this._endResizingHandler);
  }
  _updateColumnsWidthIfNeeded(posX) {
    let deltaX;
    let needUpdate = false;
    let contentWidth = this._rowsView.contentWidth();
    const resizingInfo = this._resizingInfo;
    const columnsController = this._columnsController;
    const visibleColumns = columnsController.getVisibleColumns();
    const columnsSeparatorWidth = this._columnsSeparatorView.width();
    const isNextColumnMode = isNextColumnResizingMode(this);
    const adaptColumnWidthByRatio = isNextColumnMode && this.option("adaptColumnWidthByRatio") && !this.option("columnAutoWidth");
    const isRtlParentStyle = this._isRtlParentStyle();
    const column = visibleColumns[resizingInfo.currentColumnIndex];
    const nextColumn = visibleColumns[resizingInfo.nextColumnIndex];
    const {
      needToInvertResizing
    } = resizingInfo;
    function isPercentWidth2(width) {
      return isString(width) && width.endsWith("%");
    }
    function setColumnWidth(column2, columnWidth, contentWidth2, adaptColumnWidthByRatio2) {
      if (column2) {
        const oldColumnWidth = column2.width;
        if (oldColumnWidth) {
          adaptColumnWidthByRatio2 = isPercentWidth2(oldColumnWidth);
        }
        if (adaptColumnWidthByRatio2) {
          columnsController.columnOption(column2.index, "visibleWidth", columnWidth);
          columnsController.columnOption(column2.index, "width", `${(columnWidth / contentWidth2 * 100).toFixed(3)}%`);
        } else {
          columnsController.columnOption(column2.index, "visibleWidth", null);
          columnsController.columnOption(column2.index, "width", columnWidth);
        }
      }
    }
    deltaX = posX - resizingInfo.startPosX;
    if (needToInvertResizing) {
      deltaX = -deltaX;
    }
    let {
      cellWidth,
      nextCellWidth
    } = function(delta) {
      let nextMinWidth;
      let nextCellWidth2;
      let needCorrectionNextCellWidth;
      const cellWidth2 = resizingInfo.currentColumnWidth + delta;
      const minWidth = (null === column || void 0 === column ? void 0 : column.minWidth) || columnsSeparatorWidth;
      const result2 = {};
      if (cellWidth2 >= minWidth) {
        result2.cellWidth = cellWidth2;
      } else {
        result2.cellWidth = minWidth;
        needCorrectionNextCellWidth = true;
      }
      if (isNextColumnMode) {
        nextCellWidth2 = resizingInfo.nextColumnWidth - delta;
        nextMinWidth = (null === nextColumn || void 0 === nextColumn ? void 0 : nextColumn.minWidth) || columnsSeparatorWidth;
        if (nextCellWidth2 >= nextMinWidth) {
          if (needCorrectionNextCellWidth) {
            result2.nextCellWidth = resizingInfo.nextColumnWidth - (delta + minWidth - cellWidth2);
          } else {
            result2.nextCellWidth = nextCellWidth2;
          }
        } else {
          result2.nextCellWidth = nextMinWidth;
          result2.cellWidth = resizingInfo.currentColumnWidth + (delta - nextMinWidth + nextCellWidth2);
        }
      }
      return result2;
    }(deltaX);
    needUpdate = column.width !== cellWidth;
    if (needUpdate) {
      columnsController.beginUpdate();
      cellWidth = Math.floor(cellWidth);
      contentWidth = function(contentWidth2, visibleColumns2) {
        const allColumnsHaveWidth = visibleColumns2.every((column2) => column2.width);
        if (allColumnsHaveWidth) {
          const totalPercent = visibleColumns2.reduce((sum, column2) => {
            if (isPercentWidth2(column2.width)) {
              sum += parseFloat(column2.width);
            }
            return sum;
          }, 0);
          if (totalPercent > 100) {
            contentWidth2 = contentWidth2 / totalPercent * 100;
          }
        }
        return contentWidth2;
      }(contentWidth, visibleColumns);
      setColumnWidth(column, cellWidth, contentWidth, adaptColumnWidthByRatio);
      if (isNextColumnMode) {
        nextCellWidth = Math.floor(nextCellWidth);
        setColumnWidth(nextColumn, nextCellWidth, contentWidth, adaptColumnWidthByRatio);
      } else {
        const columnWidths = this._columnHeadersView.getColumnWidths();
        columnWidths[resizingInfo.currentColumnIndex] = cellWidth;
        const hasScroll = columnWidths.reduce((totalWidth, width) => totalWidth + width, 0) > this._rowsView.contentWidth();
        if (!hasScroll) {
          const lastColumnIndex = m_utils_default.getLastResizableColumnIndex(visibleColumns);
          if (lastColumnIndex >= 0) {
            columnsController.columnOption(visibleColumns[lastColumnIndex].index, "visibleWidth", "auto");
          }
        }
        for (let i = 0; i < columnWidths.length; i++) {
          if (visibleColumns[i] && visibleColumns[i] !== column && void 0 === visibleColumns[i].width) {
            columnsController.columnOption(visibleColumns[i].index, "width", columnWidths[i]);
          }
        }
      }
      columnsController.endUpdate();
      if (!isNextColumnMode) {
        this.component.updateDimensions();
        const scrollable = this.component.getScrollable();
        if (scrollable && isRtlParentStyle) {
          const left = getWidth(scrollable.$content()) - getWidth(scrollable.container()) - this._scrollRight;
          scrollable.scrollTo({
            left
          });
        }
      }
    }
    return needUpdate;
  }
  _subscribeToCallback(callback, handler) {
    callback.add(handler);
    this._subscribesToCallbacks.push({
      callback,
      handler
    });
  }
  _unsubscribeFromCallbacks() {
    for (let i = 0; i < this._subscribesToCallbacks.length; i++) {
      const subscribe = this._subscribesToCallbacks[i];
      subscribe.callback.remove(subscribe.handler);
    }
    this._subscribesToCallbacks = [];
  }
  _unsubscribes() {
    this._unsubscribeFromEvents();
    this._unsubscribeFromCallbacks();
  }
  _init() {
    const generatePointsByColumnsHandler = () => {
      if (!this._isResizing) {
        this.pointsByColumns(null);
      }
    };
    const generatePointsByColumnsScrollHandler = (offset2) => {
      if (this._scrollLeft !== offset2.left) {
        this._scrollLeft = offset2.left;
        this.pointsByColumns(null);
      }
    };
    this._columnsSeparatorView = this.getView("columnsSeparatorView");
    this._columnHeadersView = this.getView("columnHeadersView");
    this._trackerView = this.getView("trackerView");
    this._rowsView = this.getView("rowsView");
    this._columnsController = this.getController("columns");
    this._tablePositionController = this.getController("tablePosition");
    this._editorFactoryController = this.getController("editorFactory");
    this._draggingHeaderView = this.component.getView("draggingHeaderView");
    this._$parentContainer = this.component.$element();
    this._subscribeToCallback(this._columnHeadersView.renderCompleted, generatePointsByColumnsHandler);
    this._subscribeToCallback(this._columnHeadersView.resizeCompleted, generatePointsByColumnsHandler);
    this._subscribeToCallback(this._columnsSeparatorView.renderCompleted, () => {
      this._unsubscribeFromEvents();
      this._subscribeToEvents();
    });
    this._subscribeToCallback(this._rowsView.renderCompleted, () => {
      this._rowsView.scrollChanged.remove(generatePointsByColumnsScrollHandler);
      this._rowsView.scrollChanged.add(generatePointsByColumnsScrollHandler);
    });
    let previousScrollbarVisibility = 0 !== this._rowsView.getScrollbarWidth();
    let previousTableHeight = 0;
    this._subscribeToCallback(this._tablePositionController.positionChanged, (e) => {
      if (this._isResizing && !this._rowsView.isResizing) {
        const scrollbarVisibility = 0 !== this._rowsView.getScrollbarWidth();
        if (previousScrollbarVisibility !== scrollbarVisibility || previousTableHeight && previousTableHeight !== e.height) {
          previousScrollbarVisibility = scrollbarVisibility;
          previousTableHeight = e.height;
          this.component.updateDimensions();
        } else {
          this._rowsView.updateFreeSpaceRowHeight();
        }
      }
      previousTableHeight = e.height;
    });
  }
  isResizing() {
    return this._isResizing;
  }
  pointsByColumns(value2) {
    if (void 0 !== value2) {
      this._pointsByColumns = value2;
    } else {
      if (!this._pointsByColumns) {
        this._generatePointsByColumns();
      }
      return this._pointsByColumns;
    }
  }
};
var TablePositionViewController = class extends m_modules_default.ViewController {
  constructor(component) {
    super(component);
    this.positionChanged = callbacks_default();
  }
  init() {
    super.init();
    this._columnsResizerController = this.getController("columnsResizer");
    this._columnHeadersView = this.getView("columnHeadersView");
    this._rowsView = this.getView("rowsView");
    this._pagerView = this.getView("pagerView");
    this._rowsView.resizeCompleted.add(() => {
      if (this.option("allowColumnResizing")) {
        const targetPoint = this._columnsResizerController._targetPoint;
        this.update(targetPoint ? targetPoint.y : null);
      }
    });
  }
  update(top) {
    const params = {};
    const $element = this._columnHeadersView.element();
    const offset2 = null === $element || void 0 === $element ? void 0 : $element.offset();
    const offsetTop = (null === offset2 || void 0 === offset2 ? void 0 : offset2.top) || 0;
    const diffOffsetTop = isDefined(top) ? Math.abs(top - offsetTop) : 0;
    const columnsHeadersHeight = this._columnHeadersView ? this._columnHeadersView.getHeight() : 0;
    const scrollBarWidth = this._rowsView.getScrollbarWidth(true);
    const rowsHeight = this._rowsView ? this._rowsView.height() - scrollBarWidth : 0;
    const draggingHeaderView = this.component.getView("draggingHeaderView");
    params.height = columnsHeadersHeight;
    const isDraggingOrResizing = this._columnsResizerController.isResizing() || draggingHeaderView.isDragging();
    if (isDraggingOrResizing) {
      params.height += rowsHeight - diffOffsetTop;
    }
    if (null !== top && null !== $element && void 0 !== $element && $element.length) {
      params.top = $element[0].offsetTop + diffOffsetTop;
    }
    this.positionChanged.fire(params);
  }
};
var DraggingHeaderViewController = class extends m_modules_default.ViewController {
  init() {
    var _this$_headerPanelVie, _this$_columnChooserV;
    super.init();
    this._columnsController = this.getController("columns");
    this._tablePositionController = this.getController("tablePosition");
    this._columnHeadersView = this.getView("columnHeadersView");
    this._columnsSeparatorView = this.getView("columnsSeparatorView");
    this._draggingHeaderView = this.getView("draggingHeaderView");
    this._rowsView = this.getView("rowsView");
    this._blockSeparatorView = this.getView("blockSeparatorView");
    this._headerPanelView = this.getView("headerPanel");
    this._columnChooserView = this.getView("columnChooserView");
    const subscribeToEvents = () => {
      if (this._draggingHeaderView) {
        const draggingPanels = [this._columnChooserView, this._columnHeadersView, this._headerPanelView];
        this._unsubscribeFromEvents(this._draggingHeaderView, draggingPanels);
        this._subscribeToEvents(this._draggingHeaderView, draggingPanels);
      }
    };
    this._columnHeadersView.renderCompleted.add(subscribeToEvents);
    null === (_this$_headerPanelVie = this._headerPanelView) || void 0 === _this$_headerPanelVie || _this$_headerPanelVie.renderCompleted.add(subscribeToEvents);
    null === (_this$_columnChooserV = this._columnChooserView) || void 0 === _this$_columnChooserV || _this$_columnChooserV.renderCompleted.add(subscribeToEvents);
  }
  dispose() {
    if (this._draggingHeaderView) {
      this._unsubscribeFromEvents(this._draggingHeaderView, [this._columnChooserView, this._columnHeadersView, this._headerPanelView]);
    }
  }
  _generatePointsByColumns(options2) {
    let needToCheckPrevPoint = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : false;
    this.isCustomGroupColumnPosition = this.checkIsCustomGroupColumnPosition(options2);
    const points = m_utils_default.getPointsByColumns(options2.columnElements, (point) => this._pointCreated(point, options2.columns, options2.targetDraggingPanel.getName(), options2.sourceColumn), options2.isVerticalOrientation, options2.startColumnIndex, needToCheckPrevPoint);
    return points;
  }
  checkIsCustomGroupColumnPosition(options2) {
    let wasOnlyCommandColumns = true;
    for (let i = 0; i < options2.columns.length; i += 1) {
      const col = options2.columns[i];
      if ("expand" === col.command && !wasOnlyCommandColumns) {
        return true;
      }
      if (!col.command) {
        wasOnlyCommandColumns = false;
      }
    }
    return false;
  }
  _pointCreated(point, columns7, location, sourceColumn) {
    const targetColumn = columns7[point.columnIndex];
    const prevColumn = columns7[point.columnIndex - 1];
    const isColumnAfterExpandColumn = "expand" === (null === prevColumn || void 0 === prevColumn ? void 0 : prevColumn.command);
    const isFirstExpandColumn = "expand" === (null === targetColumn || void 0 === targetColumn ? void 0 : targetColumn.command) && "expand" !== (null === prevColumn || void 0 === prevColumn ? void 0 : prevColumn.command);
    const sourceColumnReorderingDisabled = sourceColumn && !sourceColumn.allowReordering;
    const otherColumnsReorderingDisabled = !(null !== targetColumn && void 0 !== targetColumn && targetColumn.allowReordering) && !(null !== prevColumn && void 0 !== prevColumn && prevColumn.allowReordering);
    switch (location) {
      case "columnChooser":
        return true;
      case "headers":
        if (sourceColumnReorderingDisabled) {
          return true;
        }
        if (!isFirstExpandColumn) {
          return isColumnAfterExpandColumn || otherColumnsReorderingDisabled;
        }
        if (this.isCustomGroupColumnPosition) {
          return false;
        }
        while ("expand" === (null === (_columns$point$column = columns7[point.columnIndex]) || void 0 === _columns$point$column ? void 0 : _columns$point$column.command)) {
          var _columns$point$column;
          point.columnIndex += 1;
        }
        return false;
      default:
        return 0 === columns7.length;
    }
  }
  _subscribeToEvents(draggingHeader4, draggingPanels) {
    const that = this;
    each(draggingPanels, (_, draggingPanel) => {
      if (draggingPanel) {
        let columns7;
        const rowCount = draggingPanel.getRowCount ? draggingPanel.getRowCount() : 1;
        const nameDraggingPanel = draggingPanel.getName();
        const subscribeToEvents = function(index2, columnElement) {
          if (!columnElement) {
            return;
          }
          const $columnElement = renderer_default(columnElement);
          const column = columns7[index2];
          if (column && draggingPanel.allowDragging(column)) {
            $columnElement.addClass(that.addWidgetPrefix("drag-action"));
            m_events_engine_default.on($columnElement, addNamespace2(DRAG_START_EVENT, MODULE_NAMESPACE2), that.createAction((args) => {
              const e = args.event;
              const eventData2 = eventData(e);
              draggingHeader4.dragHeader({
                deltaX: eventData2.x - renderer_default(e.currentTarget).offset().left,
                deltaY: eventData2.y - renderer_default(e.currentTarget).offset().top,
                sourceColumn: column,
                index: column.index,
                columnIndex: index2,
                columnElement: $columnElement,
                sourceLocation: nameDraggingPanel,
                draggingPanels,
                rowIndex: that._columnsController.getRowIndex(column.index, true)
              });
            }));
            m_events_engine_default.on($columnElement, addNamespace2(DRAG_EVENT, MODULE_NAMESPACE2), {
              that: draggingHeader4
            }, that.createAction(draggingHeader4.moveHeader));
            m_events_engine_default.on($columnElement, addNamespace2(DRAG_END_EVENT, MODULE_NAMESPACE2), {
              that: draggingHeader4
            }, that.createAction(draggingHeader4.dropHeader));
          }
        };
        for (let i = 0; i < rowCount; i++) {
          const columnElements = draggingPanel.getColumnElements(i) || [];
          if (columnElements.length) {
            columns7 = draggingPanel.getColumns(i) || [];
            each(columnElements, subscribeToEvents);
          }
        }
      }
    });
  }
  _unsubscribeFromEvents(draggingHeader4, draggingPanels) {
    const that = this;
    each(draggingPanels, (_, draggingPanel) => {
      if (draggingPanel) {
        const columnElements = draggingPanel.getColumnElements() || [];
        each(columnElements, (index2, columnElement) => {
          const $columnElement = renderer_default(columnElement);
          m_events_engine_default.off($columnElement, addNamespace2(DRAG_START_EVENT, MODULE_NAMESPACE2));
          m_events_engine_default.off($columnElement, addNamespace2(DRAG_EVENT, MODULE_NAMESPACE2));
          m_events_engine_default.off($columnElement, addNamespace2(DRAG_END_EVENT, MODULE_NAMESPACE2));
          $columnElement.removeClass(that.addWidgetPrefix("drag-action"));
        });
      }
    });
  }
  _getSeparator(targetLocation) {
    return "headers" === targetLocation ? this._columnsSeparatorView : this._blockSeparatorView;
  }
  hideSeparators(type2) {
    const blockSeparator = this._blockSeparatorView;
    const columnsSeparator = this._columnsSeparatorView;
    this._animationColumnIndex = void 0;
    blockSeparator && blockSeparator.hide();
    "block" !== type2 && columnsSeparator && columnsSeparator.hide();
  }
  allowDrop(parameters) {
    return this._columnsController.allowMoveColumn(parameters.sourceColumnIndex, parameters.targetColumnIndex, parameters.sourceLocation, parameters.targetLocation);
  }
  drag(parameters) {
    const {
      sourceIndex
    } = parameters;
    const {
      sourceLocation
    } = parameters;
    const {
      sourceColumnElement
    } = parameters;
    const headersView = this._columnHeadersView;
    const rowsView18 = this._rowsView;
    if (sourceColumnElement) {
      sourceColumnElement.addClass(this.addWidgetPrefix(CLASSES.draggableColumn));
      if ("headers" === sourceLocation) {
        headersView && headersView.toggleDraggableColumnClass(sourceIndex, true);
        rowsView18 && rowsView18.toggleDraggableColumnClass(sourceIndex, true);
      }
    }
  }
  dock(parameters) {
    const that = this;
    const targetColumnIndex = isObject(parameters.targetColumnIndex) ? parameters.targetColumnIndex.columnIndex : parameters.targetColumnIndex;
    const {
      sourceLocation
    } = parameters;
    const {
      targetLocation
    } = parameters;
    const separator = that._getSeparator(targetLocation);
    const hasTargetVisibleIndex = targetColumnIndex >= 0;
    that._columnHeadersView.element().find(".dx-header-row").toggleClass(that.addWidgetPrefix("drop-highlight"), "headers" !== sourceLocation && "headers" === targetLocation && !hasTargetVisibleIndex);
    if (separator) {
      if (that.allowDrop(parameters) && hasTargetVisibleIndex) {
        if ("group" === targetLocation || "columnChooser" === targetLocation) {
          !function() {
            if (that._animationColumnIndex !== targetColumnIndex) {
              that.hideSeparators();
              separator.element()[parameters.isLast ? "insertAfter" : "insertBefore"](parameters.targetColumnElement);
              that._animationColumnIndex = targetColumnIndex;
              separator.show(targetLocation);
            }
          }();
        } else {
          that.hideSeparators("block");
          that._tablePositionController.update(parameters.posY);
          separator.moveByX(parameters.posX - separator.width());
          separator.show();
        }
      } else {
        that.hideSeparators();
      }
    }
  }
  drop(parameters) {
    const {
      sourceColumnElement
    } = parameters;
    if (sourceColumnElement) {
      sourceColumnElement.removeClass(this.addWidgetPrefix(CLASSES.draggableColumn));
      this._columnHeadersView.toggleDraggableColumnClass(parameters.sourceIndex, false);
      this._rowsView.toggleDraggableColumnClass(parameters.sourceIndex, false);
      this._columnHeadersView.element().find(".dx-header-row").removeClass(this.addWidgetPrefix("drop-highlight"));
    }
    if (this.allowDrop(parameters)) {
      const separator = this._getSeparator(parameters.targetLocation);
      if (separator) {
        separator.hide();
      }
      this._columnsController.moveColumn(parameters.sourceColumnIndex, parameters.targetColumnIndex, parameters.sourceLocation, parameters.targetLocation);
    }
  }
};
var rowsView9 = (Base) => class extends Base {
  _needUpdateRowHeight(itemCount) {
    const wordWrapEnabled = this.option("wordWrapEnabled");
    const isResizing = this._columnsResizerController.isResizing();
    return super._needUpdateRowHeight.apply(this, arguments) || itemCount > 0 && !!wordWrapEnabled && !!isResizing;
  }
};
var editorFactory = (Base) => class extends Base {
  renderFocusOverlay() {
    if (this._columnsResizerController.isResizing()) {
      return;
    }
    return super.renderFocusOverlay.apply(this, arguments);
  }
};
var columnsResizingReorderingModule = {
  views: {
    columnsSeparatorView: ColumnsSeparatorView,
    blockSeparatorView: BlockSeparatorView,
    draggingHeaderView: DraggingHeaderView,
    trackerView: TrackerView
  },
  controllers: {
    draggingHeader: DraggingHeaderViewController,
    tablePosition: TablePositionViewController,
    columnsResizer: ColumnsResizerViewController
  },
  extenders: {
    views: {
      rowsView: rowsView9
    },
    controllers: {
      editorFactory
    }
  }
};

// node_modules/devextreme/esm/__internal/grids/data_grid/module_not_extended/columns_resizing_reordering.js
var DraggingHeaderView2 = columnsResizingReorderingModule.views.draggingHeaderView;
var DraggingHeaderViewController2 = columnsResizingReorderingModule.controllers.draggingHeader;
var ColumnsSeparatorView2 = columnsResizingReorderingModule.views.columnsSeparatorView;
var TablePositionViewController2 = columnsResizingReorderingModule.controllers.tablePosition;
var ColumnsResizerViewController2 = columnsResizingReorderingModule.controllers.columnsResizer;
var TrackerView2 = columnsResizingReorderingModule.views.trackerView;
m_core_default.registerModule("columnsResizingReordering", columnsResizingReorderingModule);

// node_modules/devextreme/esm/__internal/utils/memoize.js
var compareByReference = (args, lastArgs) => args.length === lastArgs.length && !Object.keys(args).some((key) => args[key] !== lastArgs[key]);
var compareByValue2 = (args, lastArgs) => equalByValue(args, lastArgs, {
  maxDepth: 4
});
var createCacheFunc = (firstArgs, firstResult, originFunc, compareFunc) => {
  let lastArgs = firstArgs;
  let lastResult = firstResult;
  return function() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    const argsEquals = compareFunc(args, lastArgs);
    if (argsEquals) {
      return lastResult;
    }
    lastArgs = args;
    lastResult = originFunc(...lastArgs);
    return lastResult;
  };
};
var MEMOIZE_DEFAULT_OPTIONS = {
  compareType: "reference"
};
var memoize = function(func) {
  let {
    compareType
  } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : MEMOIZE_DEFAULT_OPTIONS;
  let cachedFunc = null;
  return function() {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    if (!cachedFunc) {
      const firstResult = func(...args);
      cachedFunc = createCacheFunc(args, firstResult, func, "reference" === compareType ? compareByReference : compareByValue2);
      return firstResult;
    }
    return cachedFunc(...args);
  };
};

// node_modules/devextreme/esm/__internal/grids/grid_core/keyboard_navigation/dom.js
var isDragCell = ($cell) => void 0 !== $cell.attr(ATTRIBUTES.dragCell);
var getFocusableCellSelector = (columnIndex) => [`[${ATTRIBUTES.ariaColIndex}="${columnIndex + 1}"]`, `:not([${ATTRIBUTES.dragCell}])`, ":not([aria-hidden=true])"].join("");
var getCellToFocus = ($cellElements, columnIndex) => $cellElements.filter(getFocusableCellSelector(columnIndex)).first();
var GridCoreKeyboardNavigationDom = {
  isDragCell,
  getCellToFocus
};

// node_modules/devextreme/esm/__internal/grids/grid_core/keyboard_navigation/m_keyboard_navigation_utils.js
function isGroupRow2($row) {
  return $row && $row.hasClass(GROUP_ROW_CLASS);
}
function isGroupFooterRow($row) {
  return $row && $row.hasClass("dx-datagrid-group-footer");
}
function isDetailRow($row) {
  return $row && $row.hasClass(MASTER_DETAIL_ROW_CLASS);
}
function isAdaptiveItem($element) {
  return $element && $element.hasClass(ADAPTIVE_ITEM_TEXT_CLASS);
}
function isEditForm($row) {
  return $row && $row.hasClass(MASTER_DETAIL_ROW_CLASS) && $row.hasClass(EDIT_FORM_CLASS);
}
function isDataRow($row) {
  return $row && $row.hasClass(DATA_ROW_CLASS);
}
function isNotFocusedRow($row) {
  return !$row || $row.hasClass(FREESPACE_ROW_CLASS) || $row.hasClass(VIRTUAL_ROW_CLASS);
}
function isEditorCell(that, $cell) {
  return !that._isRowEditMode() && $cell && !$cell.hasClass(COMMAND_SELECT_CLASS) && $cell.hasClass(EDITOR_CELL_CLASS);
}
function isElementDefined($element) {
  return isDefined($element) && $element.length > 0;
}
function isMobile() {
  return "desktop" !== devices_default.current().deviceType;
}
function isCellInHeaderRow($cell) {
  return !!$cell.parent(`.${HEADER_ROW_CLASS}`).length;
}
function isFixedColumnIndexOffsetRequired(that, column) {
  const rtlEnabled = that.option("rtlEnabled");
  if (rtlEnabled) {
    return !("right" === column.fixedPosition || isDefined(column.command) && !isDefined(column.fixedPosition));
  }
  return !(!isDefined(column.fixedPosition) || "left" === column.fixedPosition);
}
function shouldPreventScroll(that) {
  const keyboardController = that.getController("keyboardNavigation");
  return keyboardController._isVirtualScrolling() ? that.option("focusedRowIndex") === keyboardController.getRowIndex() : false;
}

// node_modules/devextreme/esm/__internal/grids/grid_core/keyboard_navigation/m_keyboard_navigation_core.js
var KeyboardNavigationController = class extends m_modules_default.ViewController {
  constructor() {
    super(...arguments);
    this.needToRestoreFocus = false;
  }
  _applyColumnIndexBoundaries(columnIndex) {
    const visibleColumnCount = this._columnsController.getVisibleColumns(null, true).length;
    if (columnIndex < 0) {
      columnIndex = 0;
    } else if (columnIndex >= visibleColumnCount) {
      columnIndex = visibleColumnCount - 1;
    }
    return columnIndex;
  }
  unsubscribeFromKeyDownEvent() {
    if (this.keyDownListener) {
      keyboard.off(this.keyDownListener);
    }
  }
  subscribeToKeyDownEvent() {
    const $focusedViewElement = this.getFocusedViewElement();
    if ($focusedViewElement) {
      this.keyDownListener = keyboard.on($focusedViewElement, null, (e) => this.keyDownHandler(e));
    }
  }
  resizeCompleted() {
  }
  getColumnIndexOffset(visibleIndex) {
    let offset2 = 0;
    const column = this._columnsController.getVisibleColumns()[visibleIndex];
    if (null !== column && void 0 !== column && column.fixed) {
      offset2 = this._getFixedColumnIndexOffset(column);
    } else if (visibleIndex >= 0) {
      offset2 = this._columnsController.getColumnIndexOffset();
    }
    return offset2;
  }
  getFocusedViewElement() {
    var _this$getFocusedView;
    return null === (_this$getFocusedView = this.getFocusedView()) || void 0 === _this$getFocusedView ? void 0 : _this$getFocusedView.element();
  }
  keyDownHandler(e) {
  }
  initKeyDownHandler() {
    this.unsubscribeFromKeyDownEvent();
    this.subscribeToKeyDownEvent();
  }
  unsubscribeFromFocusinEvent() {
    const $focusedView = this.getFocusedViewElement();
    if ($focusedView) {
      m_events_engine_default.off($focusedView, "focusin", this.focusinHandlerContext);
    }
  }
  subscribeToFocusinEvent() {
    const $focusedView = this.getFocusedViewElement();
    const focusinSelector = this.getFocusinSelector();
    if ($focusedView) {
      m_events_engine_default.on($focusedView, "focusin", focusinSelector, this.focusinHandlerContext);
    }
  }
  getFocusinSelector() {
    return "";
  }
  focusinHandler(e) {
  }
  initHandlers() {
    var _focusedView$renderCo, _this$_resizeControll;
    const focusedView = this.getFocusedView();
    this.unsubscribeFromKeyDownEvent();
    null === focusedView || void 0 === focusedView || null === (_focusedView$renderCo = focusedView.renderCompleted) || void 0 === _focusedView$renderCo || _focusedView$renderCo.remove(this.renderCompletedWithContext);
    null === (_this$_resizeControll = this._resizeController) || void 0 === _this$_resizeControll || null === (_this$_resizeControll = _this$_resizeControll.resizeCompleted) || void 0 === _this$_resizeControll || _this$_resizeControll.remove(this.resizeCompletedWithContext);
    if (this.isKeyboardEnabled()) {
      var _focusedView$renderCo2, _this$_resizeControll2;
      null === focusedView || void 0 === focusedView || null === (_focusedView$renderCo2 = focusedView.renderCompleted) || void 0 === _focusedView$renderCo2 || _focusedView$renderCo2.add(this.renderCompletedWithContext);
      null === (_this$_resizeControll2 = this._resizeController) || void 0 === _this$_resizeControll2 || null === (_this$_resizeControll2 = _this$_resizeControll2.resizeCompleted) || void 0 === _this$_resizeControll2 || _this$_resizeControll2.add(this.resizeCompletedWithContext);
    }
  }
  getFocusedView() {
  }
  _getCell(cellPosition) {
  }
  _getRowIndex($row) {
    return null === $row || void 0 === $row ? void 0 : $row.index();
  }
  getCellIndex($cell, rowIndex) {
    return null === $cell || void 0 === $cell ? void 0 : $cell.index();
  }
  _getFixedColumnIndexOffset(column) {
    const visibleColumnCount = this._columnsController.getVisibleColumns(null, true).length;
    const offset2 = isFixedColumnIndexOffsetRequired(this, column) ? visibleColumnCount - this._columnsController.getVisibleColumns().length : 0;
    return offset2;
  }
  getNewVisibleIndex(visibleIndex, rowIndex, direction) {
    return "previous" === direction ? visibleIndex - 1 : visibleIndex + 1;
  }
  _getCellPosition($cell, direction) {
    const $row = isElementDefined($cell) && $cell.closest("tr");
    if (isElementDefined($row)) {
      const rowIndex = this._getRowIndex($row);
      let columnIndex = this.getCellIndex($cell, rowIndex);
      columnIndex += this.getColumnIndexOffset(columnIndex);
      if (direction) {
        columnIndex = this.getNewVisibleIndex(columnIndex, rowIndex, direction);
        columnIndex = this._applyColumnIndexBoundaries(columnIndex);
      }
      return {
        rowIndex,
        columnIndex
      };
    }
    return;
  }
  _getColumnByCellElement($cell, rowIndex) {
    const cellIndex = this.getCellIndex($cell);
    const columnIndex = cellIndex + this._columnsController.getColumnIndexOffset();
    return this._columnsController.getVisibleColumns(rowIndex, true)[columnIndex];
  }
  processOnKeyDown(eventArgs) {
    const {
      originalEvent
    } = eventArgs;
    const args = {
      handled: false,
      event: originalEvent
    };
    this.executeAction("onKeyDown", args);
    eventArgs.ctrl = originalEvent.ctrlKey;
    eventArgs.alt = originalEvent.altKey;
    eventArgs.shift = originalEvent.shiftKey;
    return !!args.handled;
  }
  setFocusedColumnIndex(columnIndex) {
    if (!this._focusedCellPosition) {
      this._focusedCellPosition = {};
    }
    this._focusedCellPosition.columnIndex = columnIndex;
  }
  _updateFocusedCellPosition($cell, direction) {
    const position3 = this._getCellPosition($cell, direction);
    if (position3) {
      if (!$cell.length || position3.rowIndex >= 0 && position3.columnIndex >= 0) {
        this.setFocusedCellPosition(position3.rowIndex, position3.columnIndex);
      }
    }
    return position3;
  }
  renderCompleted(e) {
    this.initKeyDownHandler();
    this.unsubscribeFromFocusinEvent();
    this.subscribeToFocusinEvent();
  }
  init() {
    this._columnsController = this.getController("columns");
    this._resizeController = this.getController("resizing");
    this._focusedCellPosition = {};
    if (this.isKeyboardEnabled()) {
      this.createAction("onKeyDown");
    }
    this.renderCompletedWithContext = this.renderCompletedWithContext ?? this.renderCompleted.bind(this);
    this.resizeCompletedWithContext = this.resizeCompletedWithContext ?? this.resizeCompleted.bind(this);
    this.focusinHandlerContext = this.focusinHandlerContext ?? this.focusinHandler.bind(this);
    this.initHandlers();
  }
  dispose() {
    keyboard.off(this.keyDownListener);
  }
  setFocusedRowIndex(rowIndex) {
    if (!this._focusedCellPosition) {
      this._focusedCellPosition = {};
    }
    this._focusedCellPosition.rowIndex = rowIndex;
  }
  setFocusedCellPosition(rowIndex, columnIndex) {
    this.setFocusedRowIndex(rowIndex);
    this.setFocusedColumnIndex(columnIndex);
  }
  optionChanged(args) {
    switch (args.name) {
      case "keyboardNavigation":
        if ("keyboardNavigation.enabled" === args.fullName) {
          this.init();
        }
        args.handled = true;
        break;
      case "useLegacyKeyboardNavigation":
        this.init();
        args.handled = true;
        break;
      default:
        super.optionChanged(args);
    }
  }
  isKeyboardEnabled() {
    return this.option("keyboardNavigation.enabled");
  }
  _getFocusedCell() {
    return renderer_default(this._getCell(this._focusedCellPosition));
  }
  getDirectionByKeyName(keyName) {
    const rtlEnabled = this.option("rtlEnabled");
    switch (keyName) {
      case "leftArrow":
        return rtlEnabled ? Direction.Next : Direction.Previous;
      case "rightArrow":
        return rtlEnabled ? Direction.Previous : Direction.Next;
      default:
        return Direction.Next;
    }
  }
};

// node_modules/devextreme/esm/__internal/grids/grid_core/keyboard_navigation/scrollable_a11y.js
var keyboardNavigationScrollableA11yExtender = (Base) => class extends Base {
  focusinHandler(event) {
    const $target = renderer_default(event.target);
    this.translateFocusIfNeed(event, $target);
    super.focusinHandler(event);
  }
  focusOutHandler(e) {
    super.focusOutHandler(e);
    this.makeScrollableFocusableIfNeed();
  }
  translateFocusIfNeed(event, $target) {
    const needTranslateFocus = this.isScrollableNeedFocusable();
    const isFirstCellFixed = this._isFixedColumn(0);
    if (!needTranslateFocus || !isFirstCellFixed) {
      return;
    }
    const $firstCell = this._rowsView.getCell({
      rowIndex: 0,
      columnIndex: 0
    });
    const firstCellHasTabIndex = !!$firstCell.attr("tabindex");
    const notFixedCellIsTarget = $target.is(this._$firstNotFixedCell);
    if (firstCellHasTabIndex && notFixedCellIsTarget) {
      event.preventDefault();
      this._focus($firstCell);
    }
  }
  renderCompleted(e) {
    this._$firstNotFixedCell = this.getFirstNotFixedCell();
    this.makeScrollableFocusableIfNeed();
    super.renderCompleted(e);
  }
  _focus($cell, disableFocus, skipFocusEvent) {
    super._focus($cell, disableFocus, skipFocusEvent);
    this.makeScrollableFocusableIfNeed();
  }
  _tabKeyHandler(eventArgs, isEditing) {
    const isCellPositionDefined = isDefined(this._focusedCellPosition) && !isEmptyObject(this._focusedCellPosition);
    const isOriginalHandlerRequired = !isCellPositionDefined || !eventArgs.shift && this._isLastValidCell(this._focusedCellPosition) || eventArgs.shift && this._isFirstValidCell(this._focusedCellPosition);
    const isNeedFocusable = this.isScrollableNeedFocusable();
    if (isOriginalHandlerRequired && isNeedFocusable) {
      var _this$_$firstNotFixed;
      null === (_this$_$firstNotFixed = this._$firstNotFixedCell) || void 0 === _this$_$firstNotFixed || _this$_$firstNotFixed.removeAttr("tabIndex");
    }
    super._tabKeyHandler(eventArgs, isEditing);
  }
  getFirstNotFixedCell() {
    var _this$_editingControl;
    const columns7 = this._columnsController.getVisibleColumns();
    const columnIndex = columns7.findIndex((_ref) => {
      let {
        fixed
      } = _ref;
      return !fixed;
    });
    const isEditing = null === (_this$_editingControl = this._editingController) || void 0 === _this$_editingControl ? void 0 : _this$_editingControl.isEditing();
    return -1 === columnIndex || isEditing ? void 0 : this._rowsView._getCellElement(0, columnIndex);
  }
  isScrollableNeedFocusable() {
    var _this$_rowsView$_fixe, _this$_rowsView$getCe;
    const hasScrollable = !!this._rowsView.getScrollable();
    const hasFixedTable = !!(null !== (_this$_rowsView$_fixe = this._rowsView._fixedTableElement) && void 0 !== _this$_rowsView$_fixe && _this$_rowsView$_fixe.length);
    const isCellsRendered = !!(null !== (_this$_rowsView$getCe = this._rowsView.getCellElements(0)) && void 0 !== _this$_rowsView$getCe && _this$_rowsView$getCe.length);
    return hasScrollable && hasFixedTable && isCellsRendered;
  }
  makeScrollableFocusableIfNeed() {
    const needFocusable = this.isScrollableNeedFocusable();
    if (!needFocusable || !this._$firstNotFixedCell) {
      return;
    }
    this._applyTabIndexToElement(this._$firstNotFixedCell);
  }
};

// node_modules/devextreme/esm/__internal/grids/grid_core/keyboard_navigation/m_keyboard_navigation.js
var KeyboardNavigationController2 = class extends KeyboardNavigationController {
  constructor() {
    super(...arguments);
    this._needNavigationToCell = false;
  }
  init() {
    this._dataController = this.getController("data");
    this._selectionController = this.getController("selection");
    this._editingController = this.getController("editing");
    this._headerPanel = this.getView("headerPanel");
    this._editorFactory = this.getController("editorFactory");
    this._focusController = this.getController("focus");
    this._adaptiveColumnsController = this.getController("adaptiveColumns");
    this._columnResizerController = this.getController("columnsResizer");
    this._rowsView = this.getView("rowsView");
    super.init();
    this._memoFireFocusedCellChanged = memoize(this._memoFireFocusedCellChanged.bind(this), {
      compareType: "value"
    });
    this._memoFireFocusedRowChanged = memoize(this._memoFireFocusedRowChanged.bind(this), {
      compareType: "value"
    });
    this.focusedHandlerWithContext = this.focusedHandlerWithContext || this.focusedHandler.bind(this);
    this.focusOutHandlerContext = this.focusOutHandlerContext ?? this.focusOutHandler.bind(this);
    this._updateFocusTimeout = null;
    this._fastEditingStarted = false;
    this._canceledCellPosition = null;
    if (this.isKeyboardEnabled()) {
      var _this$_editorFactory;
      subscribeVisibilityChange();
      null === (_this$_editorFactory = this._editorFactory) || void 0 === _this$_editorFactory || _this$_editorFactory.focused.add(this.focusedHandlerWithContext);
    } else {
      var _this$_editorFactory2;
      unsubscribeVisibilityChange();
      null === (_this$_editorFactory2 = this._editorFactory) || void 0 === _this$_editorFactory2 || _this$_editorFactory2.focused.remove(this.focusedHandlerWithContext);
    }
    this.initDocumentHandlers();
  }
  dispose() {
    super.dispose();
    this._resetFocusedView();
    m_events_engine_default.off(dom_adapter_default.getDocument(), addNamespace2(m_pointer_default.down, "dxDataGridKeyboardNavigation"), this._documentClickHandler);
    clearTimeout(this._updateFocusTimeout);
    unsubscribeVisibilityChange();
  }
  focusedHandler($element) {
    this.setupFocusedView();
    if (this._isNeedScroll) {
      if ($element.is(":visible") && this._focusedView && this._focusedView.getScrollable()) {
        this._focusedView._scrollToElement($element);
        this._isNeedScroll = false;
      }
    }
  }
  focusinHandler(event) {
    const $element = renderer_default(event.target);
    const isRelatedTargetInRowsView = renderer_default(event.relatedTarget).closest(this._rowsView.element()).length;
    const isLink = $element.is("a");
    if (event.relatedTarget && isLink && !isRelatedTargetInRowsView && this._isEventInCurrentGrid(event)) {
      let $focusedCell = this._getFocusedCell();
      $focusedCell = !isElementDefined($focusedCell) ? this._rowsView.getCellElements(0).filter("[tabindex]").eq(0) : $focusedCell;
      if (!$element.closest($focusedCell).length) {
        event.preventDefault();
        m_events_engine_default.trigger($focusedCell, "focus");
      }
    }
    const isCell = $element.is("td");
    const needSetFocusPosition = (this.option("focusedRowIndex") ?? -1) < 0;
    if (isCell && needSetFocusPosition) {
      this._updateFocusedCellPosition($element);
    }
  }
  focusOutHandler(e) {
    const {
      relatedTarget
    } = e;
    this._toggleInertAttr(false);
    if (relatedTarget && !this.isInsideFocusedView(renderer_default(relatedTarget))) {
      this._isNeedFocus = false;
      this._isHiddenFocus = false;
      this._isNeedScroll = false;
    }
  }
  subscribeToRowsViewFocusEvent() {
    var _this$_rowsView;
    const $rowsView = null === (_this$_rowsView = this._rowsView) || void 0 === _this$_rowsView ? void 0 : _this$_rowsView.element();
    m_events_engine_default.on($rowsView, "focusin", this.focusinHandlerContext);
    m_events_engine_default.on($rowsView, "focusout", this.focusOutHandlerContext);
  }
  unsubscribeFromRowsViewFocusEvent() {
    var _this$_rowsView2;
    const $rowsView = null === (_this$_rowsView2 = this._rowsView) || void 0 === _this$_rowsView2 ? void 0 : _this$_rowsView2.element();
    m_events_engine_default.off($rowsView, "focusin", this.focusinHandlerContext);
    m_events_engine_default.off($rowsView, "focusout", this.focusOutHandlerContext);
  }
  resizeCompleted() {
    var _this$_rowsView3;
    if (this.navigationToCellInProgress()) {
      this._resizeController.resetLastResizeTime();
    }
    if (!this.needToRestoreFocus) {
      return;
    }
    const scrollLeft = (null === (_this$_rowsView3 = this._rowsView) || void 0 === _this$_rowsView3 || null === (_this$_rowsView3 = _this$_rowsView3.getScrollable()) || void 0 === _this$_rowsView3 ? void 0 : _this$_rowsView3.scrollLeft()) ?? 0;
    if (!this._columnsController.isNeedToRenderVirtualColumns(scrollLeft)) {
      this.needToRestoreFocus = false;
      this.focusFirstOrLastCell();
    }
  }
  renderCompleted(e) {
    const $rowsView = this._rowsView.element();
    const isFullUpdate = !e || "refresh" === e.changeType;
    const isFocusedViewCorrect = this._focusedView && this._focusedView.name === this._rowsView.name;
    let needUpdateFocus = false;
    const isAppend = e && ("append" === e.changeType || "prepend" === e.changeType);
    const root = renderer_default(dom_adapter_default.getRootNode($rowsView.get && $rowsView.get(0)));
    const $focusedElement = root.find(":focus");
    const isFocusedElementCorrect = this._isFocusedElementCorrect($focusedElement, $rowsView, e);
    this.unsubscribeFromRowsViewFocusEvent();
    this.subscribeToRowsViewFocusEvent();
    this.initPointerEventHandler();
    this.initKeyDownHandler();
    this._setRowsViewAttributes();
    if (isFocusedViewCorrect && isFocusedElementCorrect) {
      needUpdateFocus = this._isNeedFocus ? !isAppend : this._isHiddenFocus && isFullUpdate && !(null !== e && void 0 !== e && e.virtualColumnsScrolling);
      if (needUpdateFocus) {
        var _e$event;
        const isScrollEvent = !!(null !== e && void 0 !== e && null !== (_e$event = e.event) && void 0 !== _e$event && _e$event.type);
        const skipFocusEvent = (null === e || void 0 === e ? void 0 : e.virtualColumnsScrolling) && isScrollEvent;
        this._updateFocus(true, skipFocusEvent);
      }
    }
  }
  _isFocusedElementCorrect($focusedElement, $rowsView, e) {
    if ($focusedElement.length && !$focusedElement.closest($rowsView).length) {
      return false;
    }
    if (!$focusedElement.length && null !== e && void 0 !== e && e.virtualColumnsScrolling) {
      var _this$_focusedCellPos;
      const focusedColumnIndex = (null === (_this$_focusedCellPos = this._focusedCellPosition) || void 0 === _this$_focusedCellPos ? void 0 : _this$_focusedCellPos.columnIndex) ?? -1;
      return this._isColumnRendered(focusedColumnIndex);
    }
    return true;
  }
  initHandlers() {
    this.unsubscribeFromRowsViewFocusEvent();
    this.unsubscribeFromPointerEvent();
    super.initHandlers();
  }
  initDocumentHandlers() {
    const document2 = dom_adapter_default.getDocument();
    this._documentClickHandler = this._documentClickHandler || this.createAction((e) => {
      var _this$_columnResizerC;
      const $target = renderer_default(e.event.target);
      const tableSelector = `.${this.addWidgetPrefix(TABLE_CLASS)}`;
      const rowsViewSelector = `.${this.addWidgetPrefix(ROWS_VIEW_CLASS)}`;
      const editorOverlaySelector = `.${DROPDOWN_EDITOR_OVERLAY_CLASS}`;
      const needKeepFocus = !!$target.closest(tableSelector).length && !isElementInDom($target);
      if (needKeepFocus) {
        e.event.preventDefault();
        return;
      }
      const isRowsViewClick = this._isEventInCurrentGrid(e.event) && !!$target.closest(rowsViewSelector).length;
      const isEditorOverlayClick = !!$target.closest(editorOverlaySelector).length;
      const isColumnResizing = !!(null !== (_this$_columnResizerC = this._columnResizerController) && void 0 !== _this$_columnResizerC && _this$_columnResizerC.isResizing());
      if (!isRowsViewClick && !isEditorOverlayClick && !isColumnResizing) {
        const isClickOutsideFocusedView = this._focusedView ? 0 === $target.closest(this._focusedView.element()).length : true;
        if (isClickOutsideFocusedView) {
          this._resetFocusedCell(true);
        }
        this._resetFocusedView();
      }
    });
    m_events_engine_default.off(document2, addNamespace2(m_pointer_default.down, "dxDataGridKeyboardNavigation"), this._documentClickHandler);
    if (this.isKeyboardEnabled()) {
      m_events_engine_default.on(document2, addNamespace2(m_pointer_default.down, "dxDataGridKeyboardNavigation"), this._documentClickHandler);
    }
  }
  _setRowsViewAttributes() {
    const $rowsView = this._getRowsViewElement();
    const isGridEmpty = !this._dataController.getVisibleRows().length;
    if (isGridEmpty) {
      this._applyTabIndexToElement($rowsView);
    }
  }
  unsubscribeFromPointerEvent() {
    const pointerEventName = !isMobile() ? m_pointer_default.down : CLICK_EVENT_NAME;
    const $rowsView = this._getRowsViewElement();
    this._pointerEventAction && m_events_engine_default.off($rowsView, addNamespace2(pointerEventName, "dxDataGridKeyboardNavigation"), this._pointerEventAction);
  }
  subscribeToPointerEvent() {
    const pointerEventName = !isMobile() ? m_pointer_default.down : CLICK_EVENT_NAME;
    const $rowsView = this._getRowsViewElement();
    const clickSelector = `.${ROW_CLASS} > td, .${ROW_CLASS}`;
    m_events_engine_default.on($rowsView, addNamespace2(pointerEventName, "dxDataGridKeyboardNavigation"), clickSelector, this._pointerEventAction);
  }
  initPointerEventHandler() {
    this._pointerEventAction = this._pointerEventAction || this.createAction(this._pointerEventHandler);
    this.unsubscribeFromPointerEvent();
    this.subscribeToPointerEvent();
  }
  isRowFocusType() {
    return this.focusType === FOCUS_TYPE_ROW;
  }
  isCellFocusType() {
    return this.focusType === FOCUS_TYPE_CELL;
  }
  setRowFocusType() {
    if (this.option("focusedRowEnabled")) {
      this.focusType = FOCUS_TYPE_ROW;
    }
  }
  setCellFocusType() {
    this.focusType = FOCUS_TYPE_CELL;
  }
  keyDownHandler(e) {
    var _this$_editingControl;
    let needStopPropagation = true;
    this._isNeedFocus = true;
    this._isNeedScroll = true;
    let isHandled = this.processOnKeyDown(e);
    const isEditing = null === (_this$_editingControl = this._editingController) || void 0 === _this$_editingControl ? void 0 : _this$_editingControl.isEditing();
    const {
      originalEvent
    } = e;
    if (originalEvent.isDefaultPrevented()) {
      this._isNeedFocus = false;
      this._isNeedScroll = false;
      return;
    }
    !FUNCTIONAL_KEYS.includes(e.keyName) && this._updateFocusedCellPositionByTarget(originalEvent.target);
    if (!isHandled) {
      switch (e.keyName) {
        case "leftArrow":
        case "rightArrow":
          this._leftRightKeysHandler(e, isEditing);
          isHandled = true;
          break;
        case "upArrow":
        case "downArrow":
          if (e.ctrl) {
            selectView("rowsView", this, originalEvent);
          } else {
            this._upDownKeysHandler(e, isEditing);
          }
          isHandled = true;
          break;
        case "pageUp":
        case "pageDown":
          this._pageUpDownKeyHandler(e);
          isHandled = true;
          break;
        case "space":
          isHandled = this._spaceKeyHandler(e, isEditing);
          break;
        case "A":
          if (isCommandKeyPressed(e.originalEvent)) {
            this._ctrlAKeyHandler(e, isEditing);
            isHandled = true;
          } else {
            isHandled = this._beginFastEditing(e.originalEvent);
          }
          break;
        case "tab":
          this._tabKeyHandler(e, isEditing);
          isHandled = true;
          break;
        case "enter":
          this._enterKeyHandler(e, isEditing);
          isHandled = true;
          break;
        case "escape":
          isHandled = this._escapeKeyHandler(e, isEditing);
          break;
        case "F":
          if (isCommandKeyPressed(e.originalEvent)) {
            this._ctrlFKeyHandler(e);
            isHandled = true;
          } else {
            isHandled = this._beginFastEditing(e.originalEvent);
          }
          break;
        case "F2":
          this._f2KeyHandler();
          isHandled = true;
          break;
        case "del":
        case "backspace":
          if (this._isFastEditingAllowed() && !this._isFastEditingStarted()) {
            isHandled = this._beginFastEditing(originalEvent, true);
          }
          break;
        case "home":
        case "end":
          this.homeOrEndKeyHandler(e);
      }
      if (!isHandled && !this._beginFastEditing(originalEvent)) {
        this._isNeedFocus = false;
        this._isNeedScroll = false;
        needStopPropagation = false;
      }
      if (needStopPropagation) {
        originalEvent.stopPropagation();
      }
    }
  }
  _closeEditCell() {
    const d = Deferred();
    setTimeout(() => {
      this._editingController.closeEditCell().always(d.resolve);
    });
    return d;
  }
  _leftRightKeysHandler(eventArgs, isEditing) {
    const rowIndex = this.getVisibleRowIndex();
    const $event = eventArgs.originalEvent;
    const $row = this._focusedView && this._focusedView.getRow(rowIndex);
    const directionCode = this._getDirectionCodeByKey(eventArgs.keyName);
    const isEditingNavigationMode = this._isFastEditingStarted();
    const allowNavigate = (!isEditing || isEditingNavigationMode) && isDataRow($row);
    if (allowNavigate) {
      this.setCellFocusType();
      isEditingNavigationMode && this._closeEditCell();
      if (this._isVirtualColumnRender()) {
        this._processVirtualHorizontalPosition(directionCode);
      }
      const $cell = this._getNextCell(directionCode);
      if (isElementDefined($cell)) {
        this._arrowKeysHandlerFocusCell($event, $cell, directionCode);
      }
      $event && $event.preventDefault();
    }
  }
  isInsideMasterDetail($target) {
    const $masterDetail = $target.closest(`.${MASTER_DETAIL_CELL_CLASS}`);
    return !!$masterDetail.get(0) && this.elementIsInsideGrid($masterDetail) && !$target.is($masterDetail);
  }
  _upDownKeysHandler(eventArgs, isEditing) {
    var _this$_editingControl2, _this$_editingControl3;
    const visibleRowIndex = this.getVisibleRowIndex();
    const $row = this._focusedView && this._focusedView.getRow(visibleRowIndex);
    const $event = eventArgs.originalEvent;
    const isUpArrow = "upArrow" === eventArgs.keyName;
    const dataSource = this._dataController.dataSource();
    const isRowEditingInCurrentRow = null === (_this$_editingControl2 = this._editingController) || void 0 === _this$_editingControl2 || null === (_this$_editingControl3 = _this$_editingControl2.isEditRowByIndex) || void 0 === _this$_editingControl3 ? void 0 : _this$_editingControl3.call(_this$_editingControl2, visibleRowIndex);
    const isEditingNavigationMode = this._isFastEditingStarted();
    const isInsideMasterDetail = this.isInsideMasterDetail(renderer_default(null === $event || void 0 === $event ? void 0 : $event.target));
    const allowNavigate = (!isRowEditingInCurrentRow || !isEditing || isEditingNavigationMode) && $row && !isEditForm($row) && !isInsideMasterDetail;
    if (allowNavigate) {
      isEditingNavigationMode && this._closeEditCell();
      if (!this._navigateNextCell($event, eventArgs.keyName)) {
        if (this._isVirtualRowRender() && isUpArrow && dataSource && !dataSource.isLoading()) {
          const rowHeight = getOuterHeight($row);
          const rowIndex = this._focusedCellPosition.rowIndex - 1;
          this._scrollBy(0, -rowHeight, rowIndex, $event);
        }
      }
      $event && $event.preventDefault();
    }
  }
  _pageUpDownKeyHandler(eventArgs) {
    const pageIndex = this._dataController.pageIndex();
    const pageCount = this._dataController.pageCount();
    const pagingEnabled = this.option("paging.enabled");
    const isPageUp = "pageUp" === eventArgs.keyName;
    const pageStep = isPageUp ? -1 : 1;
    const scrollable = this._rowsView.getScrollable();
    if (pagingEnabled && !this._isVirtualScrolling()) {
      if ((isPageUp ? pageIndex > 0 : pageIndex < pageCount - 1) && !this._isVirtualScrolling()) {
        this._dataController.pageIndex(pageIndex + pageStep);
        eventArgs.originalEvent.preventDefault();
      }
    } else if (scrollable && getHeight(scrollable.container()) < getHeight(scrollable.$content())) {
      this._scrollBy(0, getHeight(scrollable.container()) * pageStep);
      eventArgs.originalEvent.preventDefault();
    }
  }
  _spaceKeyHandler(eventArgs, isEditing) {
    const rowIndex = this.getVisibleRowIndex();
    const $target = renderer_default(eventArgs.originalEvent && eventArgs.originalEvent.target);
    if (this.option("selection") && "none" !== this.option("selection").mode && !isEditing) {
      const isFocusedRowElement = "row" === this._getElementType($target) && this.isRowFocusType() && isDataRow($target);
      const isFocusedSelectionCell = $target.hasClass(COMMAND_SELECT_CLASS);
      if (isFocusedSelectionCell && "onClick" === this.option("selection.showCheckBoxesMode")) {
        this._selectionController.startSelectionWithCheckboxes();
      }
      if (isFocusedRowElement || $target.parent().hasClass(DATA_ROW_CLASS) || $target.hasClass(this.addWidgetPrefix(ROWS_VIEW_CLASS))) {
        this._selectionController.changeItemSelection(rowIndex, {
          shift: eventArgs.shift,
          control: eventArgs.ctrl
        });
        eventArgs.originalEvent.preventDefault();
        return true;
      }
      return false;
    }
    return this._beginFastEditing(eventArgs.originalEvent);
  }
  _ctrlAKeyHandler(eventArgs, isEditing) {
    if (!isEditing && !eventArgs.alt && "multiple" === this.option("selection.mode") && this.option("selection.allowSelectAll")) {
      this._selectionController.selectAll();
      eventArgs.originalEvent.preventDefault();
    }
  }
  _toggleInertAttr(value2) {
  }
  _tabKeyHandler(eventArgs, isEditing) {
    const editingOptions = this.option("editing");
    const direction = eventArgs.shift ? "previous" : "next";
    const isCellPositionDefined = isDefined(this._focusedCellPosition) && !isEmptyObject(this._focusedCellPosition);
    const isFirstValidCell = eventArgs.shift && this._isFirstValidCell(this._focusedCellPosition);
    const isLastValidCell = !eventArgs.shift && this._isLastValidCell(this._focusedCellPosition);
    let isOriginalHandlerRequired = !isCellPositionDefined || isFirstValidCell || isLastValidCell;
    const eventTarget = eventArgs.originalEvent.target;
    const focusedViewElement = this._focusedView && this._focusedView.element();
    if (this._handleTabKeyOnMasterDetailCell(eventTarget, direction)) {
      return;
    }
    renderer_default(focusedViewElement).addClass(FOCUS_STATE_CLASS);
    if (editingOptions && eventTarget && !isOriginalHandlerRequired) {
      if (renderer_default(eventTarget).hasClass(this.addWidgetPrefix(ROWS_VIEW_CLASS))) {
        this._resetFocusedCell();
      }
      if (this._isVirtualColumnRender()) {
        this._processVirtualHorizontalPosition(direction);
      }
      if (isEditing) {
        if (!this._editingCellTabHandler(eventArgs, direction)) {
          return;
        }
      } else if (this._targetCellTabHandler(eventArgs, direction)) {
        isOriginalHandlerRequired = true;
      }
    }
    if (isOriginalHandlerRequired) {
      const $cell = this._getFocusedCell();
      const isCommandCell = $cell.is(COMMAND_CELL_SELECTOR);
      if (isLastValidCell && !isCommandCell) {
        this._toggleInertAttr(true);
      }
      this._editorFactory.loseFocus();
      if (this._editingController.isEditing() && !this._isRowEditMode()) {
        this._resetFocusedCell(true);
        this._resetFocusedView();
        this._closeEditCell();
      }
    } else {
      eventArgs.originalEvent.preventDefault();
    }
  }
  _getMaxVerticalOffset() {
    const scrollable = this.component.getScrollable();
    return scrollable ? scrollable.scrollHeight() - getHeight(this._rowsView.element()) : 0;
  }
  _getMaxHorizontalOffset() {
    const scrollable = this.component.getScrollable();
    return scrollable ? scrollable.scrollWidth() - getWidth(this._rowsView.element()) : 0;
  }
  _isColumnRendered(columnIndex) {
    const allVisibleColumns = this._columnsController.getVisibleColumns(null, true);
    const renderedVisibleColumns = this._columnsController.getVisibleColumns();
    const column = allVisibleColumns[columnIndex];
    let result2 = false;
    if (column) {
      result2 = renderedVisibleColumns.indexOf(column) >= 0;
    }
    return result2;
  }
  _isFixedColumn(columnIndex) {
    const allVisibleColumns = this._columnsController.getVisibleColumns(null, true);
    const column = allVisibleColumns[columnIndex];
    return !!column && !!column.fixed;
  }
  _isColumnVirtual(columnIndex) {
    const localColumnIndex = columnIndex - this._columnsController.getColumnIndexOffset();
    const visibleColumns = this._columnsController.getVisibleColumns();
    const column = visibleColumns[localColumnIndex];
    return !!column && "virtual" === column.command;
  }
  _processVirtualHorizontalPosition(direction) {
    const scrollable = this.component.getScrollable();
    const columnIndex = this.getColumnIndex();
    let nextColumnIndex;
    let horizontalScrollPosition = 0;
    let needToScroll = false;
    switch (direction) {
      case "next":
      case "nextInRow": {
        const columnsCount = this._getVisibleColumnCount();
        nextColumnIndex = columnIndex + 1;
        horizontalScrollPosition = this.option("rtlEnabled") ? this._getMaxHorizontalOffset() : 0;
        if ("next" === direction) {
          needToScroll = columnsCount === nextColumnIndex || this._isFixedColumn(columnIndex) && !this._isColumnRendered(nextColumnIndex);
        } else {
          needToScroll = columnsCount > nextColumnIndex && this._isFixedColumn(columnIndex) && !this._isColumnRendered(nextColumnIndex);
        }
        break;
      }
      case "previous":
      case "previousInRow":
        nextColumnIndex = columnIndex - 1;
        horizontalScrollPosition = this.option("rtlEnabled") ? 0 : this._getMaxHorizontalOffset();
        if ("previous" === direction) {
          const columnIndexOffset = this._columnsController.getColumnIndexOffset();
          const leftEdgePosition = nextColumnIndex < 0 && 0 === columnIndexOffset;
          needToScroll = leftEdgePosition || this._isFixedColumn(columnIndex) && !this._isColumnRendered(nextColumnIndex);
        } else {
          needToScroll = nextColumnIndex >= 0 && this._isFixedColumn(columnIndex) && !this._isColumnRendered(nextColumnIndex);
        }
    }
    if (needToScroll) {
      scrollable.scrollTo({
        left: horizontalScrollPosition
      });
    } else if (isDefined(nextColumnIndex) && isDefined(direction) && this._isColumnVirtual(nextColumnIndex)) {
      horizontalScrollPosition = this._getHorizontalScrollPositionOffset(direction);
      0 !== horizontalScrollPosition && scrollable.scrollBy({
        left: horizontalScrollPosition,
        top: 0
      });
    }
  }
  _getHorizontalScrollPositionOffset(direction) {
    let positionOffset = 0;
    const $currentCell = this._getCell(this._focusedCellPosition);
    const currentCellWidth = $currentCell && getOuterWidth($currentCell);
    if (currentCellWidth > 0) {
      const rtlMultiplier = this.option("rtlEnabled") ? -1 : 1;
      positionOffset = "nextInRow" === direction || "next" === direction ? currentCellWidth * rtlMultiplier : currentCellWidth * rtlMultiplier * -1;
    }
    return positionOffset;
  }
  _editingCellTabHandler(eventArgs, direction) {
    const eventTarget = eventArgs.originalEvent.target;
    let $cell = this._getCellElementFromTarget(eventTarget);
    let isEditingAllowed;
    const $event = eventArgs.originalEvent;
    const elementType = this._getElementType(eventTarget);
    if ($cell.is(COMMAND_CELL_SELECTOR)) {
      return !this._targetCellTabHandler(eventArgs, direction);
    }
    this._updateFocusedCellPosition($cell);
    const nextCellInfo = this._getNextCellByTabKey($event, direction, elementType);
    $cell = nextCellInfo.$cell;
    if (!$cell || this._handleTabKeyOnMasterDetailCell($cell, direction)) {
      return false;
    }
    const column = this._getColumnByCellElement($cell);
    const $row = $cell.parent();
    const rowIndex = this._getRowIndex($row);
    const row = this._dataController.items()[rowIndex];
    const editingController = this._editingController;
    if (column && column.allowEditing) {
      const isDataRow2 = !row || "data" === row.rowType;
      isEditingAllowed = editingController.allowUpdating({
        row
      }) ? isDataRow2 : row && row.isNewRow;
    }
    if (!isEditingAllowed) {
      this._closeEditCell();
    }
    if (this._focusCell($cell, !nextCellInfo.isHighlighted)) {
      if (!this._isRowEditMode() && isEditingAllowed) {
        this._editFocusedCell();
      } else {
        this._focusInteractiveElement($cell, eventArgs.shift);
      }
    }
    return true;
  }
  _targetCellTabHandler(eventArgs, direction) {
    const $event = eventArgs.originalEvent;
    let eventTarget = $event.target;
    let elementType = this._getElementType(eventTarget);
    let $cell = this._getCellElementFromTarget(eventTarget);
    const $lastInteractiveElement = "cell" === elementType && this._getInteractiveElement($cell, !eventArgs.shift);
    let isOriginalHandlerRequired = false;
    if (!isEditorCell(this, $cell) && null !== $lastInteractiveElement && void 0 !== $lastInteractiveElement && $lastInteractiveElement.length && eventTarget !== $lastInteractiveElement.get(0)) {
      isOriginalHandlerRequired = true;
    } else {
      if (void 0 === this._focusedCellPosition.rowIndex && renderer_default(eventTarget).hasClass(ROW_CLASS)) {
        this._updateFocusedCellPosition($cell);
      }
      elementType = this._getElementType(eventTarget);
      if (this.isRowFocusType()) {
        this.setCellFocusType();
        if ("row" === elementType && isDataRow(renderer_default(eventTarget))) {
          eventTarget = this.getFirstValidCellInRow(renderer_default(eventTarget));
          elementType = this._getElementType(eventTarget);
        }
      }
      const nextCellInfo = this._getNextCellByTabKey($event, direction, elementType);
      $cell = nextCellInfo.$cell;
      if (!$cell) {
        return false;
      }
      $cell = this._checkNewLineTransition($event, $cell);
      if (!$cell) {
        return false;
      }
      this._focusCell($cell, !nextCellInfo.isHighlighted);
      if (!isEditorCell(this, $cell)) {
        this._focusInteractiveElement($cell, eventArgs.shift);
      }
    }
    return isOriginalHandlerRequired;
  }
  _getNextCellByTabKey($event, direction, elementType) {
    let $cell = this._getNextCell(direction, elementType);
    const args = $cell && this._fireFocusedCellChanging($event, $cell, true);
    if (!args || args.cancel) {
      return {};
    }
    if (args.$newCellElement) {
      $cell = args.$newCellElement;
    }
    return {
      $cell,
      isHighlighted: args.isHighlighted
    };
  }
  _checkNewLineTransition($event, $cell) {
    const rowIndex = this.getVisibleRowIndex();
    const $row = $cell.parent();
    if (rowIndex !== this._getRowIndex($row)) {
      const cellPosition = this._getCellPosition($cell);
      const args = this._fireFocusedRowChanging($event, $row);
      if (args.cancel) {
        return;
      }
      if (args.rowIndexChanged && cellPosition) {
        this.setFocusedColumnIndex(cellPosition.columnIndex);
        $cell = this._getFocusedCell();
      }
    }
    return $cell;
  }
  _enterKeyHandler(eventArgs, isEditing) {
    var _this$_focusedView, _this$getMasterDetail;
    const rowIndex = this.getVisibleRowIndex();
    const key = this._dataController.getKeyByRowIndex(rowIndex);
    const $row = null === (_this$_focusedView = this._focusedView) || void 0 === _this$_focusedView ? void 0 : _this$_focusedView.getRow(rowIndex);
    const $cell = this._getFocusedCell();
    const needExpandGroupRow = this.option("grouping.allowCollapsing") && isGroupRow2($row);
    const needExpandMasterDetailRow = this.option("masterDetail.enabled") && (null === $cell || void 0 === $cell ? void 0 : $cell.hasClass(COMMAND_EXPAND_CLASS));
    const needExpandAdaptiveRow = null === $cell || void 0 === $cell ? void 0 : $cell.hasClass(ADAPTIVE_COLUMN_NAME_CLASS);
    if (needExpandGroupRow || needExpandMasterDetailRow) {
      const item = this._dataController.items()[rowIndex];
      const isNotContinuation = (null === item || void 0 === item ? void 0 : item.data) && !item.data.isContinuation;
      if (isDefined(key) && isNotContinuation) {
        this._dataController.changeRowExpand(key);
      }
    } else if (needExpandAdaptiveRow) {
      this._adaptiveColumnsController.toggleExpandAdaptiveDetailRow(key);
      this._updateFocusedCellPosition($cell);
    } else if (null !== (_this$getMasterDetail = this.getMasterDetailCell($cell)) && void 0 !== _this$getMasterDetail && _this$getMasterDetail.is($cell)) {
      if ($cell.is(":focus")) {
        this.focusFirstInteractiveElementInside($cell);
      }
    } else if (!(null !== $cell && void 0 !== $cell && $cell.hasClass(COMMAND_EDIT_CLASS))) {
      this._processEnterKeyForDataCell(eventArgs, isEditing);
    }
  }
  focusFirstInteractiveElementInside($el) {
    $el.find(INTERACTIVE_ELEMENTS_SELECTOR).get(0).focus();
  }
  _processEnterKeyForDataCell(eventArgs, isEditing) {
    const direction = this._getEnterKeyDirection(eventArgs);
    const allowEditingOnEnterKey = this._allowEditingOnEnterKey();
    if (isEditing || !allowEditingOnEnterKey && direction) {
      this._handleEnterKeyEditingCell(eventArgs.originalEvent).done(() => {
        if ("next" === direction || "previous" === direction) {
          this._targetCellTabHandler(eventArgs, direction);
        } else if ("upArrow" === direction || "downArrow" === direction) {
          this._navigateNextCell(eventArgs.originalEvent, direction);
        }
      });
    } else if (allowEditingOnEnterKey) {
      this._startEditing(eventArgs);
    }
  }
  _getEnterKeyDirection(eventArgs) {
    const enterKeyDirection = this.option("keyboardNavigation.enterKeyDirection");
    const isShift = eventArgs.shift;
    if ("column" === enterKeyDirection) {
      return isShift ? "upArrow" : "downArrow";
    }
    if ("row" === enterKeyDirection) {
      return isShift ? "previous" : "next";
    }
    return;
  }
  _handleEnterKeyEditingCell(event) {
    const d = Deferred();
    const {
      target
    } = event;
    const $cell = this._getCellElementFromTarget(target);
    const isRowEditMode = this._isRowEditMode();
    this._updateFocusedCellPosition($cell);
    if (isRowEditMode) {
      this._focusEditFormCell($cell);
      setTimeout(this._editingController.saveEditData.bind(this._editingController));
      d.resolve();
    } else {
      m_events_engine_default.trigger(renderer_default(target), "change");
      this._closeEditCell().always(d.resolve);
      event.preventDefault();
    }
    return d;
  }
  _escapeKeyHandler(eventArgs, isEditing) {
    const $cell = this._getCellElementFromTarget(eventArgs.originalEvent.target);
    if (isEditing) {
      this._updateFocusedCellPosition($cell);
      if (!this._isRowEditMode()) {
        if ("cell" === this._editingController.getEditMode()) {
          this._editingController.cancelEditData();
        } else {
          this._closeEditCell();
        }
      } else {
        this._focusEditFormCell($cell);
        this._editingController.cancelEditData();
        if (0 === this._dataController.items().length) {
          this._resetFocusedCell();
          this._editorFactory.loseFocus();
        }
      }
      eventArgs.originalEvent.preventDefault();
      return true;
    }
    const masterDetailCell = this.getMasterDetailCell($cell);
    if (masterDetailCell) {
      this._focusCell(masterDetailCell);
      return true;
    }
    return false;
  }
  _ctrlFKeyHandler(eventArgs) {
    if (this.option("searchPanel.visible")) {
      const searchTextEditor = this._headerPanel.getSearchTextEditor();
      if (searchTextEditor) {
        searchTextEditor.focus();
        eventArgs.originalEvent.preventDefault();
      }
    }
  }
  _f2KeyHandler() {
    const isEditing = this._editingController.isEditing();
    const rowIndex = this.getVisibleRowIndex();
    const $row = this._focusedView && this._focusedView.getRow(rowIndex);
    if (!isEditing && isDataRow($row)) {
      this._startEditing();
    }
  }
  _navigateNextCell($event, keyCode) {
    const $cell = this._getNextCell(keyCode);
    const directionCode = this._getDirectionCodeByKey(keyCode);
    const isCellValid = $cell && this._isCellValid($cell);
    const result2 = isCellValid ? this._arrowKeysHandlerFocusCell($event, $cell, directionCode) : false;
    return result2;
  }
  _arrowKeysHandlerFocusCell($event, $nextCell, direction) {
    const isVerticalDirection = "prevRow" === direction || "nextRow" === direction;
    const args = this._fireFocusChangingEvents($event, $nextCell, isVerticalDirection, true);
    $nextCell = args.$newCellElement;
    if (!args.cancel && this._isCellValid($nextCell)) {
      this._focus($nextCell, !args.isHighlighted);
      return true;
    }
    return false;
  }
  _beginFastEditing(originalEvent, isDeleting) {
    if (!this._isFastEditingAllowed() || originalEvent.altKey || originalEvent.ctrlKey || this._editingController.isEditing()) {
      return false;
    }
    if (isDeleting) {
      this._startEditing(originalEvent, FAST_EDITING_DELETE_KEY);
    } else {
      const {
        key
      } = originalEvent;
      const keyCode = originalEvent.keyCode || originalEvent.which;
      const fastEditingKey = key || keyCode && String.fromCharCode(keyCode);
      if (fastEditingKey && (1 === fastEditingKey.length || fastEditingKey === FAST_EDITING_DELETE_KEY)) {
        this._startEditing(originalEvent, fastEditingKey);
      }
    }
    return true;
  }
  isQuickNavigationPossible() {
    var _this$_rowsView4, _this$_editingControl4, _this$_editingControl5;
    const visibleRowIndex = this.getVisibleRowIndex();
    const $row = null === (_this$_rowsView4 = this._rowsView) || void 0 === _this$_rowsView4 ? void 0 : _this$_rowsView4.getRow(visibleRowIndex);
    const dataRowTemplate = this.option("dataRowTemplate");
    const isEditRowByIndex = null === (_this$_editingControl4 = this._editingController) || void 0 === _this$_editingControl4 || null === (_this$_editingControl5 = _this$_editingControl4.isEditRowByIndex) || void 0 === _this$_editingControl5 ? void 0 : _this$_editingControl5.call(_this$_editingControl4, visibleRowIndex);
    return !isEditRowByIndex && !dataRowTemplate && isDataRow($row);
  }
  getFirstOrLastColumnIndex(needFirstColumnIndex) {
    const allVisibleColumns = this._columnsController.getVisibleColumns(null, true);
    const findColumnIndex = (column) => this.isFocusableColumn(column);
    return needFirstColumnIndex ? allVisibleColumns.findIndex(findColumnIndex) : allVisibleColumns.findLastIndex(findColumnIndex);
  }
  getFirstOrLastRowIndex(needFirstRow) {
    var _this$_dataController;
    const rowCount = this._isVirtualScrolling() ? this._dataController.totalItemsCount() : null === (_this$_dataController = this._dataController.items(true)) || void 0 === _this$_dataController ? void 0 : _this$_dataController.length;
    return needFirstRow ? 0 : rowCount - 1;
  }
  calculateScrollLeft(needScrollToFirstCell) {
    var _this$_columnsControl;
    const result2 = needScrollToFirstCell ? 0 : this._getMaxHorizontalOffset();
    const isNeedToRenderVirtualColumns = null === (_this$_columnsControl = this._columnsController) || void 0 === _this$_columnsControl ? void 0 : _this$_columnsControl.isNeedToRenderVirtualColumns(result2);
    return isNeedToRenderVirtualColumns ? result2 : -1;
  }
  calculateScrollTop(needScrollToFirstCell) {
    const maxVerticalOffset = this._getMaxVerticalOffset();
    const hasScroll = maxVerticalOffset > 0;
    const isVirtualRowRender = this._isVirtualRowRender();
    if (isVirtualRowRender && hasScroll) {
      return needScrollToFirstCell ? 0 : maxVerticalOffset;
    }
    return -1;
  }
  scrollTo(scrollOffset) {
    var _this$_rowsView5;
    const scrollable = null === (_this$_rowsView5 = this._rowsView) || void 0 === _this$_rowsView5 ? void 0 : _this$_rowsView5.getScrollable();
    null === scrollable || void 0 === scrollable || scrollable.scrollTo(scrollOffset);
  }
  focusFirstOrLastCell(e) {
    var _this$_rowsView$getSc;
    const $cell = this._getFocusedCell();
    this._focusElement($cell, true, e);
    null === (_this$_rowsView$getSc = this._rowsView.getScrollable()) || void 0 === _this$_rowsView$getSc || _this$_rowsView$getSc.update();
  }
  navigateToFirstOrLastRow(needNavigateToFirstCell, e) {
    const scrollTop = this.calculateScrollTop(needNavigateToFirstCell);
    const firstOrLastRowIndex = this.getFirstOrLastRowIndex(needNavigateToFirstCell);
    const firstOrLastColumnIndex = this.getFirstOrLastColumnIndex(needNavigateToFirstCell);
    this.silentUpdateFocusedCellPosition({
      columnIndex: firstOrLastColumnIndex,
      rowIndex: firstOrLastRowIndex
    });
    if (scrollTop >= 0) {
      this._needNavigationToCell = true;
      this.scrollTo({
        top: scrollTop
      });
    } else {
      this.navigateToFirstOrLastCell(needNavigateToFirstCell, e);
    }
  }
  homeOrEndKeyHandler(e) {
    if (!this.isQuickNavigationPossible()) {
      return;
    }
    const needNavigateToFirstCell = "home" === e.keyName;
    const {
      originalEvent
    } = e;
    if (isCommandKeyPressed(originalEvent)) {
      this.navigateToFirstOrLastRow(needNavigateToFirstCell, originalEvent);
    } else {
      this.navigateToFirstOrLastCell(needNavigateToFirstCell, originalEvent);
    }
    originalEvent.preventDefault();
  }
  isFocusableColumn(column) {
    return column.type !== DRAG_COLUMN_NAME;
  }
  navigateToFirstOrLastCell(needNavigateToFirstCell, e) {
    const firstOrLastColumnIndex = this.getFirstOrLastColumnIndex(needNavigateToFirstCell);
    this._needNavigationToCell = false;
    if (firstOrLastColumnIndex < 0) {
      return;
    }
    const scrollLeft = this.calculateScrollLeft(needNavigateToFirstCell);
    this.silentUpdateFocusedCellPosition({
      columnIndex: firstOrLastColumnIndex
    });
    if (scrollLeft >= 0) {
      this.needToRestoreFocus = true;
      this.scrollTo({
        left: scrollLeft
      });
    } else {
      this.focusFirstOrLastCell(e);
    }
  }
  isQuickNavigationToFirstCell() {
    var _this$_focusedCellPos2;
    const firstColumnIndex = this.getFirstOrLastColumnIndex(true);
    return (null === (_this$_focusedCellPos2 = this._focusedCellPosition) || void 0 === _this$_focusedCellPos2 ? void 0 : _this$_focusedCellPos2.columnIndex) === firstColumnIndex;
  }
  _pointerEventHandler(e) {
    var _this$_rowsView6;
    const event = e.event || e;
    let $target = renderer_default(event.currentTarget);
    const focusedViewElement = null === (_this$_rowsView6 = this._rowsView) || void 0 === _this$_rowsView6 ? void 0 : _this$_rowsView6.element();
    const $parent = $target.parent();
    const isInteractiveElement = renderer_default(event.target).is(INTERACTIVE_ELEMENTS_SELECTOR);
    const isRevertButton = !!renderer_default(event.target).closest(`.${REVERT_BUTTON_CLASS}`).length;
    const isExpandCommandCell = $target.hasClass(COMMAND_EXPAND_CLASS);
    if (!this._isEventInCurrentGrid(event)) {
      return;
    }
    if (!isRevertButton && (this._isCellValid($target, !isInteractiveElement) || isExpandCommandCell)) {
      $target = this._isInsideEditForm($target) ? renderer_default(event.target) : $target;
      this._focusView();
      renderer_default(focusedViewElement).removeClass(FOCUS_STATE_CLASS);
      if ($parent.hasClass(FREESPACE_ROW_CLASS)) {
        this._updateFocusedCellPosition($target);
        this._applyTabIndexToElement(this._focusedView.element());
        this._focusedView.focus(true);
      } else if (!this.getMasterDetailCell($target)) {
        this._clickTargetCellHandler(event, $target);
      } else {
        this._updateFocusedCellPosition($target);
      }
    } else if ($target.is("td")) {
      this._resetFocusedCell();
    }
  }
  _clickTargetCellHandler(event, $cell) {
    const column = this._getColumnByCellElement($cell);
    const isCellEditMode = this._isCellEditMode();
    this.setCellFocusType();
    const args = this._fireFocusChangingEvents(event, $cell, true);
    $cell = args.$newCellElement;
    if (!args.cancel) {
      if (args.resetFocusedRow) {
        this._focusController._resetFocusedRow();
        return;
      }
      if (args.rowIndexChanged) {
        $cell = this._getFocusedCell();
      }
      if (!args.isHighlighted && !isCellEditMode) {
        this.setRowFocusType();
      }
      this._updateFocusedCellPosition($cell);
      if (this._allowRowUpdating() && isCellEditMode && column && column.allowEditing) {
        this._isNeedFocus = false;
        this._isHiddenFocus = false;
      } else {
        $cell = this._getFocusedCell();
        const $target = event && renderer_default(event.target).closest(`${NON_FOCUSABLE_ELEMENTS_SELECTOR}, td`);
        const skipFocusEvent = $target && $target.not($cell).is(NON_FOCUSABLE_ELEMENTS_SELECTOR);
        const isEditor = !!column && !column.command && $cell.hasClass(EDITOR_CELL_CLASS);
        const isDisabled = !isEditor && (!args.isHighlighted || skipFocusEvent);
        this._focus($cell, isDisabled, skipFocusEvent);
      }
    } else {
      this.setRowFocusType();
      this.setFocusedRowIndex(args.prevRowIndex);
      if (this._editingController.isEditing() && isCellEditMode) {
        this._closeEditCell();
      }
    }
  }
  _allowRowUpdating() {
    const rowIndex = this.getVisibleRowIndex();
    const row = this._dataController.items()[rowIndex];
    return this._editingController.allowUpdating({
      row
    }, "click");
  }
  focus(element) {
    let activeElementSelector;
    const focusedRowEnabled = this.option("focusedRowEnabled");
    const isHighlighted = this._isCellElement(renderer_default(element));
    if (!element) {
      activeElementSelector = ".dx-datagrid-rowsview .dx-row[tabindex]";
      if (!focusedRowEnabled) {
        activeElementSelector += ", .dx-datagrid-rowsview .dx-row > td[tabindex]";
      }
      element = this.component.$element().find(activeElementSelector).first();
    }
    element && this._focusElement(renderer_default(element), isHighlighted);
  }
  getFocusedView() {
    return this.getView("rowsView");
  }
  setupFocusedView() {
    if (this.isKeyboardEnabled() && !isDefined(this._focusedView)) {
      this._focusView();
    }
  }
  _focusElement($element, isHighlighted, event) {
    const rowsViewElement = renderer_default(this._getRowsViewElement());
    const $focusedView = $element.closest(rowsViewElement);
    const isRowFocusType = this.isRowFocusType();
    let args = {};
    if (!$focusedView.length || this._isCellElement($element) && !this._isCellValid($element)) {
      return;
    }
    this._focusView();
    this._isNeedFocus = true;
    this._isNeedScroll = true;
    if (this._isCellElement($element) || isGroupRow2($element)) {
      this.setCellFocusType();
      args = this._fireFocusChangingEvents(event, $element, true, isHighlighted);
      $element = args.$newCellElement;
      if (isRowFocusType && !args.isHighlighted) {
        this.setRowFocusType();
      }
    }
    if (!args.cancel) {
      this._focus($element, !args.isHighlighted);
      this._focusInteractiveElement($element);
    }
  }
  isInsideFocusedView($element) {
    var _this$_focusedView2;
    return 0 !== $element.closest(null === (_this$_focusedView2 = this._focusedView) || void 0 === _this$_focusedView2 ? void 0 : _this$_focusedView2.element()).length;
  }
  _focusView() {
    this._focusedView = this._rowsView;
  }
  _resetFocusedView() {
    this.setRowFocusType();
    this._focusedView = null;
  }
  _focusInteractiveElement($cell, isLast) {
    if (!$cell) {
      return;
    }
    const $focusedElement = this._getInteractiveElement($cell, isLast);
    m_utils_default.focusAndSelectElement(this, $focusedElement);
  }
  _focus($cell, disableFocus, skipFocusEvent) {
    const $row = $cell && !$cell.hasClass(ROW_CLASS) ? $cell.closest(`.${ROW_CLASS}`) : $cell;
    if ($row && isNotFocusedRow($row)) {
      return;
    }
    const focusedView = this._focusedView;
    const $focusViewElement = focusedView && focusedView.element();
    let $focusElement;
    this._isHiddenFocus = disableFocus;
    const isRowFocus = isGroupRow2($row) || isGroupFooterRow($row) || this.isRowFocusType();
    if (isRowFocus) {
      $focusElement = $row;
      if (focusedView) {
        this.setFocusedRowIndex(this._getRowIndex($row));
      }
    } else if (this._isCellElement($cell)) {
      $focusElement = $cell;
      this._updateFocusedCellPosition($cell);
    }
    if ($focusElement) {
      if ($focusViewElement) {
        $focusViewElement.find(".dx-row[tabindex], .dx-row > td[tabindex]").filter((i, node) => m_utils_default.isElementInCurrentGrid(this, renderer_default(node))).not($focusElement).removeClass(CELL_FOCUS_DISABLED_CLASS).removeClass(FOCUSED_CLASS).removeAttr("tabindex");
      }
      m_events_engine_default.one($focusElement, "blur", (e) => {
        if (e.relatedTarget) {
          $focusElement.removeClass(CELL_FOCUS_DISABLED_CLASS).removeClass(FOCUSED_CLASS);
        }
      });
      if (!skipFocusEvent) {
        this._applyTabIndexToElement($focusElement);
        m_events_engine_default.trigger($focusElement, "focus");
      }
      if (disableFocus) {
        $focusElement.addClass(CELL_FOCUS_DISABLED_CLASS);
        if (isRowFocus) {
          $cell.addClass(CELL_FOCUS_DISABLED_CLASS);
        }
      } else {
        this._editorFactory.focus($focusElement);
      }
    }
  }
  _updateFocus(isRenderView) {
    let skipFocusEvent = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : false;
    this._updateFocusTimeout = setTimeout(() => {
      if (this._needFocusEditingCell()) {
        this._editingController._focusEditingCell();
        return;
      }
      let $cell = this._getFocusedCell();
      const isEditing = this._editingController.isEditing();
      if (!this.getMasterDetailCell($cell) || this._isRowEditMode()) {
        if (this._hasSkipRow($cell.parent())) {
          const direction = this._focusedCellPosition && this._focusedCellPosition.rowIndex > 0 ? "upArrow" : "downArrow";
          $cell = this._getNextCell(direction);
        }
        if (isElementDefined($cell)) {
          if ($cell.is("td") || $cell.hasClass(this.addWidgetPrefix(EDIT_FORM_ITEM_CLASS))) {
            const isCommandCell = $cell.is(COMMAND_CELL_SELECTOR);
            const $focusedElementInsideCell = $cell.find(":focus");
            const isFocusedElementDefined = isElementDefined($focusedElementInsideCell);
            const column = this._getColumnByCellElement($cell);
            if ((isRenderView || !isCommandCell) && this._editorFactory.focus()) {
              if (isCommandCell && isFocusedElementDefined) {
                m_utils_default.focusAndSelectElement(this, $focusedElementInsideCell);
                return;
              }
              !isFocusedElementDefined && this._focus($cell, false, skipFocusEvent);
            } else if (!isFocusedElementDefined && (this._isNeedFocus || this._isHiddenFocus)) {
              this._focus($cell, this._isHiddenFocus, skipFocusEvent);
            }
            if (isEditing && !(null !== column && void 0 !== column && column.showEditorAlways)) {
              this._focusInteractiveElement.bind(this)($cell);
            }
          } else {
            m_events_engine_default.trigger($cell, "focus");
          }
        }
      }
    });
  }
  _needFocusEditingCell() {
    const isCellEditMode = this._editingController.getEditMode() === EDIT_MODE_CELL;
    const isBatchEditMode = this._editingController.getEditMode() === EDIT_MODE_BATCH;
    const cellEditModeHasChanges = isCellEditMode && this._editingController.hasChanges();
    const isNewRowBatchEditMode = isBatchEditMode && this._editingController.isNewRowInEditMode();
    const $cell = this._getFocusedCell();
    return (0 === $cell.children().length || $cell.find(FOCUSABLE_ELEMENT_SELECTOR).length > 0) && (cellEditModeHasChanges || isNewRowBatchEditMode);
  }
  _updateFocusedCellPositionByTarget(target) {
    var _this$_focusedCellPos3;
    const elementType = this._getElementType(target);
    if ("row" === elementType && isDefined(null === (_this$_focusedCellPos3 = this._focusedCellPosition) || void 0 === _this$_focusedCellPos3 ? void 0 : _this$_focusedCellPos3.columnIndex)) {
      const $row = renderer_default(target);
      this._focusedView && isGroupRow2($row) && this.setFocusedRowIndex(this._getRowIndex($row));
    } else {
      this._updateFocusedCellPosition(this._getCellElementFromTarget(target));
    }
  }
  _focusCell($cell, isDisabled) {
    if (this._isCellValid($cell)) {
      this._focus($cell, isDisabled);
      return true;
    }
    return;
  }
  _focusEditFormCell($cell) {
    if ($cell.hasClass(MASTER_DETAIL_CELL_CLASS)) {
      this._editorFactory.focus($cell, true);
    }
  }
  _resetFocusedCell(preventScroll) {
    var _this$_focusedView3;
    const $cell = this._getFocusedCell();
    isElementDefined($cell) && $cell.removeAttr("tabindex").removeClass(CELL_FOCUS_DISABLED_CLASS);
    this._isNeedFocus = false;
    this._isNeedScroll = false;
    this._focusedCellPosition = {};
    clearTimeout(this._updateFocusTimeout);
    null === (_this$_focusedView3 = this._focusedView) || void 0 === _this$_focusedView3 || _this$_focusedView3.renderFocusState({
      preventScroll
    });
  }
  restoreFocusableElement(rowIndex, $event) {
    const that = this;
    let args;
    let $rowElement;
    const isUpArrow = isDefined(rowIndex);
    const $rowsViewElement = this._rowsView.element();
    const {
      columnIndex
    } = that._focusedCellPosition;
    const rowIndexOffset = that._dataController.getRowIndexOffset();
    rowIndex = isUpArrow ? rowIndex : this._rowsView.getTopVisibleItemIndex() + rowIndexOffset;
    if (!isUpArrow) {
      that._editorFactory.loseFocus();
      that._applyTabIndexToElement($rowsViewElement);
      m_events_engine_default.trigger($rowsViewElement, "focus");
    } else {
      $rowElement = this._rowsView.getRow(rowIndex - rowIndexOffset);
      args = that._fireFocusedRowChanging($event, $rowElement);
      if (!args.cancel && args.rowIndexChanged) {
        rowIndex = args.newRowIndex;
      }
    }
    if (!isUpArrow || !args.cancel) {
      that.setFocusedCellPosition(rowIndex, columnIndex);
    }
    isUpArrow && that._updateFocus();
  }
  silentUpdateFocusedCellPosition(newFocusedCellPosition) {
    this._focusedCellPosition = _extends({}, this._focusedCellPosition ?? {}, newFocusedCellPosition);
  }
  _getNewPositionByCode(cellPosition, elementType, code) {
    let {
      columnIndex
    } = cellPosition;
    let {
      rowIndex
    } = cellPosition;
    let visibleColumnsCount;
    if (void 0 === cellPosition.rowIndex && "next" === code) {
      return {
        columnIndex: 0,
        rowIndex: 0
      };
    }
    switch (code) {
      case "nextInRow":
      case "next":
        visibleColumnsCount = this._getVisibleColumnCount();
        if (columnIndex < visibleColumnsCount - 1 && "row" !== elementType && this._hasValidCellAfterPosition({
          columnIndex,
          rowIndex
        })) {
          columnIndex++;
        } else if (!this._isLastRow(rowIndex) && "next" === code) {
          columnIndex = 0;
          rowIndex++;
        }
        break;
      case "previousInRow":
      case "previous":
        if (columnIndex > 0 && "row" !== elementType && this._hasValidCellBeforePosition({
          columnIndex,
          rowIndex
        })) {
          columnIndex--;
        } else if (rowIndex > 0 && "previous" === code) {
          rowIndex--;
          visibleColumnsCount = this._getVisibleColumnCount();
          columnIndex = visibleColumnsCount - 1;
        }
        break;
      case "upArrow":
        rowIndex = rowIndex > 0 ? rowIndex - 1 : rowIndex;
        break;
      case "downArrow":
        rowIndex = !this._isLastRow(rowIndex) ? rowIndex + 1 : rowIndex;
    }
    return {
      columnIndex,
      rowIndex
    };
  }
  getRowIndex() {
    return this._focusedCellPosition ? this._focusedCellPosition.rowIndex : -1;
  }
  getColumnIndex() {
    return this._focusedCellPosition ? this._focusedCellPosition.columnIndex : -1;
  }
  getVisibleRowIndex() {
    var _this$_focusedCellPos4;
    const rowIndex = null === (_this$_focusedCellPos4 = this._focusedCellPosition) || void 0 === _this$_focusedCellPos4 ? void 0 : _this$_focusedCellPos4.rowIndex;
    return !isDefined(rowIndex) || rowIndex < 0 ? -1 : rowIndex - this._dataController.getRowIndexOffset();
  }
  getVisibleColumnIndex() {
    var _this$_focusedCellPos5;
    const columnIndex = null === (_this$_focusedCellPos5 = this._focusedCellPosition) || void 0 === _this$_focusedCellPos5 ? void 0 : _this$_focusedCellPos5.columnIndex;
    return !isDefined(columnIndex) ? -1 : columnIndex - this._columnsController.getColumnIndexOffset();
  }
  _isCellByPositionValid(cellPosition) {
    const $cell = renderer_default(this._getCell(cellPosition));
    return this._isCellValid($cell);
  }
  _isLastRow(rowIndex) {
    const dataController2 = this._dataController;
    if (this._isVirtualRowRender()) {
      return rowIndex >= dataController2.getMaxRowIndex();
    }
    const lastVisibleIndex = Math.max(...dataController2.items().map((item, index2) => false !== item.visible ? index2 : -1));
    return rowIndex === lastVisibleIndex;
  }
  _isFirstValidCell(cellPosition) {
    let isFirstValidCell = false;
    if (0 === cellPosition.rowIndex && cellPosition.columnIndex >= 0) {
      isFirstValidCell = isFirstValidCell || !this._hasValidCellBeforePosition(cellPosition);
    }
    return isFirstValidCell;
  }
  _hasValidCellBeforePosition(cellPosition) {
    let {
      columnIndex
    } = cellPosition;
    let hasValidCells = false;
    while (columnIndex > 0 && !hasValidCells) {
      const checkingPosition = {
        columnIndex: --columnIndex,
        rowIndex: cellPosition.rowIndex
      };
      hasValidCells = this._isCellByPositionValid(checkingPosition);
    }
    return hasValidCells;
  }
  _hasValidCellAfterPosition(cellPosition) {
    let {
      columnIndex
    } = cellPosition;
    let hasValidCells = false;
    const visibleColumnCount = this._getVisibleColumnCount();
    while (columnIndex < visibleColumnCount - 1 && !hasValidCells) {
      const checkingPosition = {
        columnIndex: ++columnIndex,
        rowIndex: cellPosition.rowIndex
      };
      hasValidCells = this._isCellByPositionValid(checkingPosition);
    }
    return hasValidCells;
  }
  _isLastValidCell(cellPosition) {
    const nextColumnIndex = cellPosition.columnIndex >= 0 ? cellPosition.columnIndex + 1 : 0;
    const {
      rowIndex
    } = cellPosition;
    const checkingPosition = {
      columnIndex: nextColumnIndex,
      rowIndex
    };
    const visibleRows = this._dataController.getVisibleRows();
    const row = visibleRows && visibleRows[rowIndex];
    const isLastRow = this._isLastRow(rowIndex);
    if (!isLastRow) {
      return false;
    }
    const isFullRowFocus = "group" === (null === row || void 0 === row ? void 0 : row.rowType) || "groupFooter" === (null === row || void 0 === row ? void 0 : row.rowType);
    if (isFullRowFocus && cellPosition.columnIndex > 0) {
      return true;
    }
    if (cellPosition.columnIndex === this._getVisibleColumnCount() - 1) {
      return true;
    }
    if (this._isCellByPositionValid(checkingPosition)) {
      return false;
    }
    return this._isLastValidCell(checkingPosition);
  }
  _isCellValid($cell, isClick) {
    if (isElementDefined($cell)) {
      const $row = $cell.parent();
      const columnIndex = this._rowsView.getCellIndex($cell) + this._columnsController.getColumnIndexOffset();
      const column = this._getColumnByCellElement($cell);
      const visibleColumnCount = this._getVisibleColumnCount();
      const editingController = this._editingController;
      const isMasterDetailRow = isDetailRow($row);
      const isShowWhenGrouped = column && column.showWhenGrouped;
      const isDataCell = column && !$cell.hasClass(COMMAND_EXPAND_CLASS) && isDataRow($row);
      const isValidGroupSpaceColumn = function() {
        return !isMasterDetailRow && column && (!isDefined(column.groupIndex) || isShowWhenGrouped && isDataCell) || parseInt($cell.attr("colspan"), 10) > 1;
      };
      const isDragCell2 = GridCoreKeyboardNavigationDom.isDragCell($cell);
      if (isDragCell2) {
        return false;
      }
      if (this.getMasterDetailCell($cell)) {
        return true;
      }
      if (visibleColumnCount > columnIndex && isValidGroupSpaceColumn()) {
        const rowItems = this._dataController.items();
        const visibleRowIndex = this._rowsView.getRowIndex($row);
        const row = rowItems[visibleRowIndex];
        const isCellEditing = editingController && this._isCellEditMode() && editingController.isEditing();
        const isRowEditingInCurrentRow = editingController && editingController.isEditRow(visibleRowIndex);
        const isEditing = isRowEditingInCurrentRow || isCellEditing;
        if (column.command) {
          if (this._isLegacyNavigation()) {
            return !isEditing && "expand" === column.command;
          }
          if (isCellEditing) {
            return false;
          }
          if (isRowEditingInCurrentRow) {
            return "select" !== column.command;
          }
          return !isEditing;
        }
        if (isCellEditing && row && "data" !== row.rowType) {
          return false;
        }
        return !isEditing || column.allowEditing || isClick;
      }
    }
  }
  getFirstValidCellInRow($row, columnIndex) {
    const that = this;
    const $cells = $row.find("> td");
    let $cell;
    let $result;
    columnIndex = columnIndex || 0;
    for (let i = columnIndex; i < $cells.length; ++i) {
      $cell = $cells.eq(i);
      if (that._isCellValid($cell)) {
        $result = $cell;
        break;
      }
    }
    return $result;
  }
  _getNextCell(keyCode, elementType, cellPosition) {
    const focusedCellPosition = cellPosition || this._focusedCellPosition;
    const isRowFocusType = this.isRowFocusType();
    const includeCommandCells = isRowFocusType || ["next", "previous"].includes(keyCode);
    let $cell;
    let $row;
    if (this._focusedView && focusedCellPosition) {
      const newFocusedCellPosition = this._getNewPositionByCode(focusedCellPosition, elementType, keyCode);
      $cell = renderer_default(this._getCell(newFocusedCellPosition));
      const isLastCellOnDirection = "previous" === keyCode ? this._isFirstValidCell(newFocusedCellPosition) : this._isLastValidCell(newFocusedCellPosition);
      if (isElementDefined($cell) && !this._isCellValid($cell) && this._isCellInRow(newFocusedCellPosition, includeCommandCells) && !isLastCellOnDirection) {
        if (isRowFocusType) {
          $cell = this.getFirstValidCellInRow($cell.parent(), newFocusedCellPosition.columnIndex);
        } else {
          $cell = this._getNextCell(keyCode, "cell", newFocusedCellPosition);
        }
      }
      $row = isElementDefined($cell) && $cell.parent();
      if (this._hasSkipRow($row)) {
        const rowIndex = this._getRowIndex($row);
        if (!this._isLastRow(rowIndex)) {
          $cell = this._getNextCell(keyCode, "row", {
            columnIndex: focusedCellPosition.columnIndex,
            rowIndex
          });
        } else {
          return null;
        }
      }
      return isElementDefined($cell) ? $cell : null;
    }
    return null;
  }
  _startEditing(eventArgs, fastEditingKey) {
    const focusedCellPosition = this._focusedCellPosition;
    const visibleRowIndex = this.getVisibleRowIndex();
    const visibleColumnIndex = this.getVisibleColumnIndex();
    const row = this._dataController.items()[visibleRowIndex];
    const column = this._columnsController.getVisibleColumns()[visibleColumnIndex];
    if (this._isAllowEditing(row, column)) {
      if (this._isRowEditMode()) {
        this._editingController.editRow(visibleRowIndex);
      } else if (focusedCellPosition) {
        this._startEditCell(eventArgs, fastEditingKey);
      }
    }
  }
  _isAllowEditing(row, column) {
    return this._editingController.allowUpdating({
      row
    }) && column && column.allowEditing;
  }
  _editFocusedCell() {
    const rowIndex = this.getVisibleRowIndex();
    const colIndex = this.getVisibleColumnIndex();
    return this._editingController.editCell(rowIndex, colIndex);
  }
  _startEditCell(eventArgs, fastEditingKey) {
    this._fastEditingStarted = isDefined(fastEditingKey);
    const editResult = this._editFocusedCell();
    const isEditResultDeferred = isDeferred(editResult);
    const isFastEditingStarted = this._isFastEditingStarted();
    if (!isFastEditingStarted || !isEditResultDeferred && !editResult) {
      return;
    }
    const editorValue = isEditResultDeferred && fastEditingKey === FAST_EDITING_DELETE_KEY ? "" : fastEditingKey;
    const editResultDeferred = isEditResultDeferred ? editResult : Deferred().resolve();
    const waitTemplatesDeferred = this._rowsView.waitAsyncTemplates(true);
    when(editResultDeferred, waitTemplatesDeferred).done(() => {
      this._editingCellHandler(eventArgs, editorValue);
    });
  }
  _editingCellHandler(eventArgs, editorValue) {
    var _$inputElement$select;
    const $input = this._getFocusedCell().find(INTERACTIVE_ELEMENTS_SELECTOR).eq(0);
    const $inputElement = $input.get(0);
    if (!$inputElement) {
      return;
    }
    const keyDownEvent = createEvent(eventArgs, {
      type: "keydown",
      target: $inputElement
    });
    const keyPressEvent = createEvent(eventArgs, {
      type: "keypress",
      target: $inputElement
    });
    const inputEvent = createEvent(eventArgs, {
      type: "input",
      target: $inputElement
    });
    if (inputEvent.originalEvent) {
      inputEvent.originalEvent = createEvent(inputEvent.originalEvent, {
        data: editorValue
      });
    }
    null === (_$inputElement$select = $inputElement.select) || void 0 === _$inputElement$select || _$inputElement$select.call($inputElement);
    m_events_engine_default.trigger($input, keyDownEvent);
    if (!keyDownEvent.isDefaultPrevented()) {
      m_events_engine_default.trigger($input, keyPressEvent);
      if (!keyPressEvent.isDefaultPrevented()) {
        const timeout = browser_default.mozilla ? 25 : 0;
        setTimeout(() => {
          const inputValue = this._getKeyPressInputValue($input, editorValue);
          $input.val(inputValue);
          const $widgetContainer = $input.closest(`.${WIDGET_CLASS}`);
          m_events_engine_default.off($widgetContainer, "focusout");
          m_events_engine_default.one($widgetContainer, "focusout", () => {
            m_events_engine_default.trigger($input, "change");
          });
          m_events_engine_default.trigger($input, inputEvent);
        }, timeout);
      }
    }
  }
  _getKeyPressInputValue($input, editorValue) {
    const inputCurrentValue = $input.val();
    return "-" === editorValue && "-0" === inputCurrentValue ? "-0" : editorValue;
  }
  _fireFocusChangingEvents($event, $cell, fireRowEvent, isHighlighted) {
    let args = {};
    const cellPosition = this._getCellPosition($cell) ?? {};
    if (this.isCellFocusType()) {
      args = this._fireFocusedCellChanging($event, $cell, isHighlighted);
      if (!args.cancel) {
        cellPosition.columnIndex = args.newColumnIndex;
        cellPosition.rowIndex = args.newRowIndex;
        isHighlighted = args.isHighlighted;
        $cell = renderer_default(this._getCell(cellPosition));
      }
    }
    if (!args.cancel && fireRowEvent && $cell) {
      args = this._fireFocusedRowChanging($event, $cell.parent());
      if (!args.cancel) {
        cellPosition.rowIndex = args.newRowIndex;
        args.isHighlighted = isHighlighted;
      }
    }
    args.$newCellElement = renderer_default(this._getCell(cellPosition));
    if (!args.$newCellElement.length) {
      args.$newCellElement = $cell;
    }
    return args;
  }
  _fireFocusedCellChanging($event, $cellElement, isHighlighted) {
    const prevColumnIndex = this.option("focusedColumnIndex");
    const prevRowIndex = this.option("focusedRowIndex");
    const cellPosition = this._getCellPosition($cellElement);
    const columnIndex = cellPosition ? cellPosition.columnIndex : -1;
    const rowIndex = cellPosition ? cellPosition.rowIndex : -1;
    const visibleRows = this._dataController.getVisibleRows();
    const visibleColumns = this._columnsController.getVisibleColumns();
    const args = {
      cellElement: $cellElement,
      prevColumnIndex,
      prevRowIndex,
      newColumnIndex: columnIndex,
      newRowIndex: rowIndex,
      rows: visibleRows,
      columns: visibleColumns,
      event: $event,
      isHighlighted: isHighlighted || false,
      cancel: false
    };
    this._canceledCellPosition = null;
    this.executeAction("onFocusedCellChanging", args);
    if (args.newColumnIndex !== columnIndex || args.newRowIndex !== rowIndex) {
      args.$newCellElement = renderer_default(this._getCell({
        columnIndex: args.newColumnIndex,
        rowIndex: args.newRowIndex
      }));
    }
    if (args.cancel) {
      this._canceledCellPosition = {
        rowIndex,
        columnIndex
      };
    }
    return args;
  }
  _fireFocusedCellChanged($cell) {
    const columnIndex = this._rowsView.getCellIndex($cell);
    const rowOptions = null === $cell || void 0 === $cell ? void 0 : $cell.parent().data("options");
    const focusedRowKey = null === rowOptions || void 0 === rowOptions ? void 0 : rowOptions.key;
    this._memoFireFocusedCellChanged(focusedRowKey, columnIndex);
  }
  _memoFireFocusedCellChanged(rowKey, columnIndex) {
    const $cell = this._getFocusedCell();
    const rowIndex = this._getRowIndex(null === $cell || void 0 === $cell ? void 0 : $cell.parent());
    const localRowIndex = Math.min(rowIndex - this._dataController.getRowIndexOffset(), this._dataController.items().length - 1);
    const isEditingCell2 = this._editingController.isEditCell(localRowIndex, columnIndex);
    if (isEditingCell2) {
      return;
    }
    const row = this._dataController.items()[localRowIndex];
    const column = this._columnsController.getVisibleColumns()[columnIndex];
    this.executeAction("onFocusedCellChanged", {
      cellElement: $cell ? getPublicElement($cell) : void 0,
      columnIndex,
      rowIndex,
      row,
      column
    });
  }
  _fireFocusedRowChanging(eventArgs, $newFocusedRow) {
    const newRowIndex = this._getRowIndex($newFocusedRow);
    const prevFocusedRowIndex = this.option("focusedRowIndex");
    const loadingOperationTypes = this._dataController.loadingOperationTypes();
    const args = {
      rowElement: $newFocusedRow,
      prevRowIndex: prevFocusedRowIndex,
      newRowIndex,
      event: eventArgs,
      rows: this._dataController.getVisibleRows(),
      cancel: false
    };
    const loadingOperations = loadingOperationTypes.sorting || loadingOperationTypes.grouping || loadingOperationTypes.filtering || loadingOperationTypes.paging;
    if (!this._dataController || this._dataController.isLoading() && loadingOperations) {
      args.cancel = true;
      return args;
    }
    if (this.option("focusedRowEnabled")) {
      this.executeAction("onFocusedRowChanging", args);
      if (!args.cancel && args.newRowIndex !== newRowIndex) {
        args.resetFocusedRow = args.newRowIndex < 0;
        if (!args.resetFocusedRow) {
          this.setFocusedRowIndex(args.newRowIndex);
        }
        args.rowIndexChanged = true;
      }
    }
    return args;
  }
  _fireFocusedRowChanged() {
    var _this$_focusControlle;
    const focusedRowEnabled = this.option("focusedRowEnabled");
    const focusedRowKey = this.option("focusedRowKey");
    const focusedRowIndex = null === (_this$_focusControlle = this._focusController) || void 0 === _this$_focusControlle ? void 0 : _this$_focusControlle.getFocusedRowIndexByKey(focusedRowKey);
    if (!focusedRowEnabled || isDefined(focusedRowKey) && focusedRowIndex < 0) {
      return;
    }
    this._memoFireFocusedRowChanged(focusedRowKey, focusedRowIndex);
  }
  _memoFireFocusedRowChanged(focusedRowKey, focusedRowIndex) {
    const localRowIndex = focusedRowIndex - this._dataController.getRowIndexOffset();
    this.executeAction("onFocusedRowChanged", {
      rowElement: focusedRowIndex < 0 ? void 0 : this._rowsView.getRowElement(localRowIndex),
      rowIndex: focusedRowIndex,
      row: focusedRowIndex < 0 ? void 0 : this._dataController.getVisibleRows()[localRowIndex]
    });
  }
  _isEventInCurrentGrid(event) {
    return m_utils_default.isElementInCurrentGrid(this, renderer_default(event.target));
  }
  _isRowEditMode() {
    const editMode = this._editingController.getEditMode();
    return editMode === EDIT_MODE_ROW || editMode === EDIT_MODE_FORM;
  }
  _isCellEditMode() {
    const editMode = this._editingController.getEditMode();
    return editMode === EDIT_MODE_CELL || editMode === EDIT_MODE_BATCH;
  }
  _isFastEditingAllowed() {
    return this._isCellEditMode() && this.option("keyboardNavigation.editOnKeyPress");
  }
  _getInteractiveElement($cell, isLast) {
    const $focusedElement = $cell.find(INTERACTIVE_ELEMENTS_SELECTOR).filter(":visible");
    return isLast ? $focusedElement.last() : $focusedElement.first();
  }
  _applyTabIndexToElement($element) {
    const tabIndex = this.option("tabIndex") ?? 0;
    $element.attr("tabindex", tabIndex);
  }
  _getCell(cellPosition) {
    if (this._focusedView && cellPosition) {
      const rowIndexOffset = this._dataController.getRowIndexOffset();
      const column = this._columnsController.getVisibleColumns(null, true)[cellPosition.columnIndex];
      const columnIndexOffset = column && column.fixed ? this._getFixedColumnIndexOffset(column) : this._columnsController.getColumnIndexOffset();
      const rowIndex = cellPosition.rowIndex >= 0 ? cellPosition.rowIndex - rowIndexOffset : -1;
      const columnIndex = cellPosition.columnIndex >= 0 ? cellPosition.columnIndex - columnIndexOffset : -1;
      return this._focusedView.getCell({
        rowIndex,
        columnIndex
      });
    }
  }
  _getRowIndex($row) {
    let rowIndex = this._rowsView.getRowIndex($row);
    if (rowIndex >= 0) {
      rowIndex += this._dataController.getRowIndexOffset();
    }
    return rowIndex;
  }
  getCellIndex($cell, rowIndex) {
    return this._rowsView.getCellIndex($cell, rowIndex);
  }
  _hasSkipRow($row) {
    const row = $row && $row.get(0);
    return row && "none" === row.style.display;
  }
  _allowEditingOnEnterKey() {
    return "startEdit" === this.option("keyboardNavigation.enterKeyAction");
  }
  _isLegacyNavigation() {
    return this.option("useLegacyKeyboardNavigation");
  }
  _getDirectionCodeByKey(key) {
    let directionCode;
    switch (key) {
      case "upArrow":
        directionCode = "prevRow";
        break;
      case "downArrow":
        directionCode = "nextRow";
        break;
      case "leftArrow":
        directionCode = this.option("rtlEnabled") ? "nextInRow" : "previousInRow";
        break;
      case "rightArrow":
        directionCode = this.option("rtlEnabled") ? "previousInRow" : "nextInRow";
    }
    return directionCode;
  }
  _isVirtualScrolling() {
    const scrollingMode = this.option("scrolling.mode");
    return "virtual" === scrollingMode || "infinite" === scrollingMode;
  }
  _isVirtualRowRender() {
    return this._isVirtualScrolling() || m_utils_default.isVirtualRowRendering(this);
  }
  _isVirtualColumnRender() {
    return "virtual" === this.option("scrolling.columnRenderingMode");
  }
  _scrollBy(left, top, rowIndex, $event) {
    const that = this;
    const scrollable = this._rowsView.getScrollable();
    if (that._focusedCellPosition) {
      const scrollHandler = function() {
        scrollable.off("scroll", scrollHandler);
        setTimeout(that.restoreFocusableElement.bind(that, rowIndex, $event));
      };
      scrollable.on("scroll", scrollHandler);
    }
    return scrollable.scrollBy({
      left,
      top
    });
  }
  _isInsideEditForm(element) {
    const $editForm = renderer_default(element).closest(`.${this.addWidgetPrefix(EDIT_FORM_CLASS2)}`);
    return $editForm.length && this.elementIsInsideGrid($editForm);
  }
  getMasterDetailCell(element) {
    const $masterDetailCell = renderer_default(element).closest(`.${MASTER_DETAIL_CELL_CLASS}`);
    if ($masterDetailCell.length && this.elementIsInsideGrid($masterDetailCell)) {
      return $masterDetailCell;
    }
    return null;
  }
  _processNextCellInMasterDetail($nextCell, _$cell) {
    if (!this._isInsideEditForm($nextCell) && $nextCell) {
      this._applyTabIndexToElement($nextCell);
    }
  }
  _handleTabKeyOnMasterDetailCell(target, direction) {
    if (this.getMasterDetailCell(target)) {
      this._updateFocusedCellPosition(renderer_default(target), direction);
      const $nextCell = this._getNextCell(direction, "row");
      this._processNextCellInMasterDetail($nextCell, renderer_default(target));
      return true;
    }
    return false;
  }
  _getElementType(target) {
    return renderer_default(target).is("tr") ? "row" : "cell";
  }
  _isFastEditingStarted() {
    return this._isFastEditingAllowed() && this._fastEditingStarted;
  }
  _getVisibleColumnCount() {
    return this._columnsController.getVisibleColumns(null, true).length;
  }
  _isCellInRow(cellPosition, includeCommandCells) {
    const {
      columnIndex
    } = cellPosition;
    const visibleColumnsCount = this._getVisibleColumnCount();
    return includeCommandCells ? columnIndex >= 0 && columnIndex <= visibleColumnsCount - 1 : columnIndex > 0 && columnIndex < visibleColumnsCount - 1;
  }
  _isCellElement($element) {
    return $element.length && "TD" === $element[0].tagName;
  }
  _getCellElementFromTarget(target) {
    const elementType = this._getElementType(target);
    const $targetElement = renderer_default(target);
    let $cell;
    if ("cell" === elementType) {
      $cell = $targetElement.closest(`.${ROW_CLASS} > td`);
    } else {
      $cell = $targetElement.children().not(`.${COMMAND_EXPAND_CLASS}`).first();
    }
    return $cell;
  }
  _getRowsViewElement() {
    var _this$_rowsView7;
    return null === (_this$_rowsView7 = this._rowsView) || void 0 === _this$_rowsView7 ? void 0 : _this$_rowsView7.element();
  }
  _processCanceledEditCellPosition(rowIndex, columnIndex) {
    if (this._canceledCellPosition) {
      const isCanceled = this._canceledCellPosition.rowIndex === rowIndex && this._canceledCellPosition.columnIndex === columnIndex;
      this._canceledCellPosition = null;
      return isCanceled;
    }
    return;
  }
  updateFocusedRowIndex() {
    const dataController2 = this._dataController;
    const visibleRowIndex = this.getVisibleRowIndex();
    const visibleItems = dataController2.items();
    const lastVisibleIndex = visibleItems.length ? visibleItems.length - 1 : -1;
    const rowIndexOffset = dataController2.getRowIndexOffset();
    if (lastVisibleIndex >= 0 && visibleRowIndex > lastVisibleIndex) {
      this.setFocusedRowIndex(lastVisibleIndex + rowIndexOffset);
    }
  }
  needNavigationToCell() {
    return this._needNavigationToCell;
  }
  navigationToCellInProgress() {
    return this.needToRestoreFocus || this.needNavigationToCell();
  }
};
var rowsView10 = (Base) => class extends Base {
  _rowClick(e) {
    const editRowIndex = this._editingController.getEditRowIndex();
    const isKeyboardEnabled = this._keyboardNavigationController.isKeyboardEnabled();
    if (editRowIndex === e.rowIndex) {
      this._keyboardNavigationController.setCellFocusType();
    }
    const needTriggerPointerEventHandler = (isMobile() || !isKeyboardEnabled) && this.option("focusedRowEnabled");
    if (needTriggerPointerEventHandler) {
      this._triggerPointerDownEventHandler(e, !isKeyboardEnabled);
    }
    super._rowClick.apply(this, arguments);
  }
  _triggerPointerDownEventHandler(e, force) {
    const {
      originalEvent
    } = e.event;
    if (originalEvent) {
      const $cell = renderer_default(originalEvent.target);
      const columnIndex = this.getCellIndex($cell);
      const column = this._columnsController.getVisibleColumns()[columnIndex];
      const row = this._dataController.items()[e.rowIndex];
      if (this._keyboardNavigationController._isAllowEditing(row, column) || force) {
        const eventArgs = createEvent(originalEvent, {
          currentTarget: originalEvent.target
        });
        this._keyboardNavigationController._pointerEventHandler(eventArgs);
      }
    }
  }
  renderFocusState(params) {
    super.renderFocusState(params);
    if (this._keyboardNavigationController.navigationToCellInProgress()) {
      return;
    }
    const {
      preventScroll,
      pageSizeChanged
    } = params ?? {};
    const $rowsViewElement = this.element();
    if ($rowsViewElement && !focused($rowsViewElement)) {
      $rowsViewElement.attr("tabindex", null);
    }
    pageSizeChanged && this._keyboardNavigationController.updateFocusedRowIndex();
    let rowIndex = this._keyboardNavigationController.getVisibleRowIndex();
    if (!isDefined(rowIndex) || rowIndex < 0) {
      rowIndex = 0;
    }
    const cellElements = this.getCellElements(rowIndex);
    if (this._keyboardNavigationController.isKeyboardEnabled() && null !== cellElements && void 0 !== cellElements && cellElements.length) {
      this.updateFocusElementTabIndex(cellElements, preventScroll);
    }
  }
  updateFocusElementTabIndex(cellElements, preventScroll) {
    const $row = cellElements.eq(0).parent();
    if (isGroupRow2($row)) {
      this._keyboardNavigationController._applyTabIndexToElement($row);
    } else {
      let columnIndex = this._keyboardNavigationController.getColumnIndex();
      if (!isDefined(columnIndex) || columnIndex < 0) {
        columnIndex = 0;
      }
      this._updateFocusedCellTabIndex(cellElements, columnIndex);
    }
  }
  _updateFocusedCellTabIndex(cellElements, columnIndex) {
    const keyboardController = this._keyboardNavigationController;
    const cellElementsLength = cellElements ? cellElements.length : -1;
    const updateCellTabIndex = function($cell2) {
      const isMasterDetailCell = !!keyboardController.getMasterDetailCell($cell2);
      const isValidCell = keyboardController._isCellValid($cell2);
      if (!isMasterDetailCell && isValidCell && keyboardController._isCellElement($cell2)) {
        keyboardController._applyTabIndexToElement($cell2);
        keyboardController.setCellFocusType();
        return true;
      }
      return;
    };
    const $cell = GridCoreKeyboardNavigationDom.getCellToFocus(cellElements, columnIndex);
    if ($cell.length) {
      updateCellTabIndex($cell);
    } else {
      if (cellElementsLength <= columnIndex) {
        columnIndex = cellElementsLength - 1;
      }
      for (let i = columnIndex; i < cellElementsLength; ++i) {
        if (updateCellTabIndex(renderer_default(cellElements[i]))) {
          break;
        }
      }
    }
  }
  renderDelayedTemplates(change) {
    super.renderDelayedTemplates.apply(this, arguments);
    this.waitAsyncTemplates().done(() => {
      this._renderFocusByChange(change);
    });
  }
  _renderFocusByChange(change) {
    var _change$changeTypes;
    const {
      operationTypes,
      repaintChangesOnly
    } = change ?? {};
    const {
      fullReload,
      pageSize
    } = operationTypes ?? {};
    const hasInsertsOrRemoves = !!(null !== change && void 0 !== change && null !== (_change$changeTypes = change.changeTypes) && void 0 !== _change$changeTypes && _change$changeTypes.find((changeType) => "insert" === changeType || "remove" === changeType));
    if (!change || !repaintChangesOnly || fullReload || pageSize || hasInsertsOrRemoves) {
      const preventScroll = shouldPreventScroll(this);
      this.renderFocusState({
        preventScroll,
        pageSizeChanged: pageSize
      });
    }
  }
  _renderCore(change) {
    const deferred = super._renderCore.apply(this, arguments);
    this._renderFocusByChange(change);
    return deferred;
  }
  _editCellPrepared($cell) {
    var _this$_keyboardNaviga;
    const editorInstance = this._getEditorInstance($cell);
    const isEditingNavigationMode = null === (_this$_keyboardNaviga = this._keyboardNavigationController) || void 0 === _this$_keyboardNaviga ? void 0 : _this$_keyboardNaviga._isFastEditingStarted();
    if (editorInstance && isEditingNavigationMode) {
      this._handleEditingNavigationMode(editorInstance);
    }
    super._editCellPrepared.apply(this, arguments);
  }
  _handleEditingNavigationMode(editorInstance) {
    ["downArrow", "upArrow"].forEach((keyName) => {
      const originalKeyHandler = editorInstance._supportedKeys()[keyName];
      editorInstance.registerKeyHandler(keyName, (e) => {
        const isDropDownOpened = "true" === editorInstance._input().attr("aria-expanded");
        if (isDropDownOpened) {
          return originalKeyHandler && originalKeyHandler.call(editorInstance, e);
        }
      });
    });
    editorInstance.registerKeyHandler("leftArrow", noop2);
    editorInstance.registerKeyHandler("rightArrow", noop2);
    const isDateBoxWithMask = editorInstance.NAME === DATEBOX_WIDGET_NAME && editorInstance.option("useMaskBehavior");
    if (isDateBoxWithMask) {
      editorInstance.registerKeyHandler("enter", noop2);
    }
  }
  _getEditorInstance($cell) {
    const $editor = $cell.find(".dx-texteditor").eq(0);
    return m_utils_default.getWidgetInstance($editor);
  }
  _handleScroll(e) {
    super._handleScroll(e);
    if (this._keyboardNavigationController.needNavigationToCell()) {
      this._keyboardNavigationController.navigateToFirstOrLastCell(this._keyboardNavigationController.isQuickNavigationToFirstCell());
    }
  }
  init() {
    super.init();
    this._resizeController = this.getController("resizing");
  }
};
var editing2 = (Base) => class extends Base {
  editCell(rowIndex, columnIndex) {
    if (this._keyboardNavigationController._processCanceledEditCellPosition(rowIndex, columnIndex)) {
      return false;
    }
    const isCellEditing = super.editCell(rowIndex, columnIndex);
    if (isCellEditing) {
      this._keyboardNavigationController.setupFocusedView();
    }
    return isCellEditing;
  }
  editRow(rowIndex) {
    const visibleColumnIndex = this._keyboardNavigationController.getVisibleColumnIndex();
    const column = this._columnsController.getVisibleColumns()[visibleColumnIndex];
    if (column && column.type || this.option("editing.mode") === EDIT_MODE_FORM) {
      this._keyboardNavigationController._resetFocusedCell();
    }
    super.editRow(rowIndex);
    return;
  }
  addRow(parentKey) {
    this._keyboardNavigationController.setupFocusedView();
    this._keyboardNavigationController.setCellFocusType();
    return super.addRow.apply(this, arguments);
  }
  getFocusedCellInRow(rowIndex) {
    let $cell = super.getFocusedCellInRow(rowIndex);
    const rowIndexOffset = this._dataController.getRowIndexOffset();
    const focusedRowIndex = this._keyboardNavigationController._focusedCellPosition.rowIndex - rowIndexOffset;
    if (this._keyboardNavigationController.isKeyboardEnabled() && focusedRowIndex === rowIndex) {
      const $focusedCell = this._keyboardNavigationController._getFocusedCell();
      if (isElementDefined($focusedCell) && !$focusedCell.hasClass(COMMAND_EDIT_CLASS)) {
        $cell = $focusedCell;
      }
    }
    return $cell;
  }
  _processCanceledEditingCell() {
    this.closeEditCell().done(() => {
      this._keyboardNavigationController._updateFocus();
    });
  }
  closeEditCell() {
    const keyboardNavigation4 = this._keyboardNavigationController;
    keyboardNavigation4._fastEditingStarted = false;
    const result2 = super.closeEditCell.apply(this, arguments);
    const $focusedElement = this._getFocusedElement();
    const isFilterCell = !!$focusedElement.closest(`.${this.addWidgetPrefix(FILTER_ROW_CLASS)}`).length;
    if (!isFilterCell) {
      keyboardNavigation4._updateFocus();
    }
    return result2;
  }
  _getFocusedElement() {
    var _this$component$eleme, _this$component;
    const $element = renderer_default(null === (_this$component$eleme = (_this$component = this.component).element) || void 0 === _this$component$eleme ? void 0 : _this$component$eleme.call(_this$component));
    const $focusedElement = $element.find(":focus");
    return $focusedElement;
  }
  _delayedInputFocus() {
    this._keyboardNavigationController._isNeedScroll = true;
    super._delayedInputFocus.apply(this, arguments);
  }
  _isEditingStart() {
    const cancel2 = super._isEditingStart.apply(this, arguments);
    if (cancel2 && !this._keyboardNavigationController._isNeedFocus) {
      const $cell = this._keyboardNavigationController._getFocusedCell();
      this._keyboardNavigationController._focus($cell, true);
    }
    return cancel2;
  }
};
var data12 = (Base) => class extends Base {
  _correctRowIndices(getRowIndexCorrection) {
    const focusedCellPosition = this._keyboardNavigationController._focusedCellPosition;
    super._correctRowIndices.apply(this, arguments);
    if (focusedCellPosition && focusedCellPosition.rowIndex >= 0) {
      const focusedRowIndexCorrection = getRowIndexCorrection(focusedCellPosition.rowIndex);
      if (focusedRowIndexCorrection) {
        focusedCellPosition.rowIndex += focusedRowIndexCorrection;
        this._editorFactoryController.refocus();
      }
    }
  }
  getMaxRowIndex() {
    let result2 = this.items().length - 1;
    const virtualItemsCount = this.virtualItemsCount();
    if (virtualItemsCount) {
      const rowIndexOffset = this.getRowIndexOffset();
      result2 += rowIndexOffset + virtualItemsCount.end;
    }
    return result2;
  }
};
var adaptiveColumns = (Base) => class extends Base {
  _showHiddenCellsInView(_ref) {
    let {
      viewName: viewName2,
      $cells,
      isCommandColumn
    } = _ref;
    super._showHiddenCellsInView.apply(this, arguments);
    viewName2 === COLUMN_HEADERS_VIEW && !isCommandColumn && $cells.each((_, cellElement) => {
      const $cell = renderer_default(cellElement);
      isCellInHeaderRow($cell) && $cell.attr("tabindex", 0);
    });
  }
  _hideVisibleCellInView(_ref2) {
    let {
      viewName: viewName2,
      $cell,
      isCommandColumn
    } = _ref2;
    super._hideVisibleCellInView.apply(this, arguments);
    if (viewName2 === COLUMN_HEADERS_VIEW && !isCommandColumn && isCellInHeaderRow($cell)) {
      $cell.removeAttr("tabindex");
    }
  }
  _hideVisibleColumnInView(_ref3) {
    let {
      view,
      isCommandColumn,
      visibleIndex
    } = _ref3;
    super._hideVisibleColumnInView({
      view,
      isCommandColumn,
      visibleIndex
    });
    if (view.name === ROWS_VIEW) {
      this._rowsView.renderFocusState(null);
    }
  }
};
var keyboardNavigationModule = {
  defaultOptions: () => ({
    useLegacyKeyboardNavigation: false,
    keyboardNavigation: {
      enabled: true,
      enterKeyAction: "startEdit",
      enterKeyDirection: "none",
      editOnKeyPress: false
    }
  }),
  controllers: {
    keyboardNavigation: KeyboardNavigationController2
  },
  extenders: {
    views: {
      rowsView: rowsView10
    },
    controllers: {
      editing: editing2,
      data: data12,
      adaptiveColumns,
      keyboardNavigation: keyboardNavigationScrollableA11yExtender
    }
  }
};

// node_modules/devextreme/esm/__internal/grids/data_grid/module_not_extended/keyboard_navigation.js
m_core_default.registerModule("keyboardNavigation", keyboardNavigationModule);

// node_modules/devextreme/esm/__internal/grids/grid_core/sticky_columns/dom.js
var addStickyColumnBorderLeftClass = ($cell, addWidgetPrefix) => {
  $cell.addClass(addWidgetPrefix(CLASSES3.stickyColumnBorderLeft));
};
var addStickyColumnBorderRightClass = ($cell, addWidgetPrefix) => {
  $cell.addClass(addWidgetPrefix(CLASSES3.stickyColumnBorderRight));
};
var addStickyColumnClass = ($cell, fixedPosition, addWidgetPrefix) => {
  switch (fixedPosition) {
    case StickyPosition.Right:
      $cell.addClass(addWidgetPrefix(CLASSES3.stickyColumnRight));
      break;
    case StickyPosition.Sticky:
      $cell.addClass(addWidgetPrefix(CLASSES3.stickyColumn));
      break;
    default:
      $cell.addClass(addWidgetPrefix(CLASSES3.stickyColumnLeft));
  }
};
var toggleFirstHeaderClass = ($cell, value2, addWidgetPrefix) => {
  $cell.toggleClass(addWidgetPrefix(CLASSES3.firstHeader), value2);
};
var toggleColumnNoBorderClass = ($cell, value2, addWidgetPrefix) => {
  $cell.toggleClass(addWidgetPrefix(CLASSES3.columnNoBorder), value2);
};
var toggleStickyColumnsClass = ($element, hasStickyColumns, addWidgetPrefix) => {
  $element.toggleClass(addWidgetPrefix(CLASSES3.stickyColumns), hasStickyColumns);
};
var isStickyCellPinnedToLeft = ($cell, $container, addWidgetPrefix) => {
  const isStickyCell2 = $cell.hasClass(addWidgetPrefix(CLASSES3.stickyColumn));
  if (!isStickyCell2) {
    return false;
  }
  const cellLeft = parseFloat($cell[0].style.left);
  const cellRect = getBoundingRect($cell[0]);
  const containerRect = getBoundingRect($container[0]);
  const calculatedCellLeft = cellRect.left - containerRect.left;
  return Math.round(cellLeft) >= Math.round(calculatedCellLeft);
};
var isStickyCellPinnedToRight = ($cell, $container, addWidgetPrefix) => {
  const isStickyCell2 = $cell.hasClass(addWidgetPrefix(CLASSES3.stickyColumn));
  if (!isStickyCell2) {
    return false;
  }
  const cellRight = parseFloat($cell[0].style.right);
  const cellRect = getBoundingRect($cell[0]);
  const containerRect = getBoundingRect($container[0]);
  const calculatedCellRight = containerRect.right - cellRect.right;
  return Math.round(cellRight) >= Math.round(calculatedCellRight);
};
var isStickyCellPinned = ($cell, $container, addWidgetPrefix) => isStickyCellPinnedToLeft($cell, $container, addWidgetPrefix) || isStickyCellPinnedToRight($cell, $container, addWidgetPrefix);
var isFixedCellPinnedToRight = ($cell, $container, addWidgetPrefix) => $cell.hasClass(addWidgetPrefix(CLASSES3.stickyColumnRight)) || isStickyCellPinnedToRight($cell, $container, addWidgetPrefix);
var isLastLeftFixedCell = ($cell, addWidgetPrefix) => $cell.hasClass(addWidgetPrefix(CLASSES3.stickyColumnLeft)) && $cell.hasClass(addWidgetPrefix(CLASSES3.stickyColumnBorderRight));
var isFirstRightFixedCell = ($cell, addWidgetPrefix) => $cell.hasClass(addWidgetPrefix(CLASSES3.stickyColumnRight)) && $cell.hasClass(addWidgetPrefix(CLASSES3.stickyColumnBorderLeft));
var isStickyCell = ($cell, addWidgetPrefix) => $cell.hasClass(addWidgetPrefix(CLASSES3.stickyColumn));
var isFixedCell = ($cell, addWidgetPrefix) => $cell.hasClass(addWidgetPrefix(CLASSES3.stickyColumnLeft)) || $cell.hasClass(addWidgetPrefix(CLASSES3.stickyColumnRight)) || $cell.hasClass(addWidgetPrefix(CLASSES3.stickyColumn));
var getLeftFixedCells = ($cells, addWidgetPrefix) => $cells.filter((_, cell) => renderer_default(cell).hasClass(addWidgetPrefix(CLASSES3.stickyColumnLeft)));
var getRightFixedCells = ($cells, addWidgetPrefix) => $cells.filter((_, cell) => renderer_default(cell).hasClass(addWidgetPrefix(CLASSES3.stickyColumnRight)));
var getNonFixedAndStickyCells = ($cells, addWidgetPrefix) => $cells.filter((_, cell) => renderer_default(cell).hasClass(addWidgetPrefix(CLASSES3.stickyColumn)) || !isFixedCell(renderer_default(cell), addWidgetPrefix));
var getLastLeftFixedCell = ($cells, $container, addWidgetPrefix) => {
  const rtlEnabled = "rtl" === $container.css("direction");
  const processedCells = rtlEnabled ? $cells.toArray() : $cells.toArray().reverse();
  const lastLeftFixedCell = processedCells.find((cell) => isStickyCellPinnedToLeft(renderer_default(cell), $container, addWidgetPrefix) || isLastLeftFixedCell(renderer_default(cell), addWidgetPrefix));
  return renderer_default(lastLeftFixedCell ?? "");
};
var getFirstRightFixedCell = ($cells, $container, addWidgetPrefix) => {
  const rtlEnabled = "rtl" === $container.css("direction");
  const processedCells = rtlEnabled ? $cells.toArray().reverse() : $cells.toArray();
  const firstRightFixedCell = processedCells.find((cell) => isStickyCellPinnedToRight(renderer_default(cell), $container, addWidgetPrefix) || isFirstRightFixedCell(renderer_default(cell), addWidgetPrefix));
  return renderer_default(firstRightFixedCell ?? "");
};
var getNonFixedAreaBoundingRect = ($cells, $container, addWidgetPrefix) => {
  const containerRect = getBoundingRect($container.get(0));
  const result2 = {
    left: containerRect.left,
    right: containerRect.right
  };
  if (null !== $cells && void 0 !== $cells && $cells.length) {
    const $lastLeftFixedCell = getLastLeftFixedCell($cells, $container, addWidgetPrefix);
    const $firstRightFixedCell = getFirstRightFixedCell($cells, $container, addWidgetPrefix);
    if (null !== $lastLeftFixedCell && void 0 !== $lastLeftFixedCell && $lastLeftFixedCell.length) {
      result2.left = Math.round(getBoundingRect($lastLeftFixedCell[0]).right);
    }
    if (null !== $firstRightFixedCell && void 0 !== $firstRightFixedCell && $firstRightFixedCell.length) {
      result2.right = Math.round(getBoundingRect($firstRightFixedCell[0]).left);
    }
  }
  return result2;
};
var noNeedToCreateResizingPoint = (that, _ref, addWidgetPrefix) => {
  let {
    point,
    column,
    nextColumn
  } = _ref;
  const {
    item,
    isLeftBoundary,
    isRightBoundary
  } = point;
  const $item = renderer_default(item);
  const offsetX = Math.round(point.x);
  const rtlEnabled = that.option("rtlEnabled");
  const isSplitPoint = isDefined(isLeftBoundary) || isDefined(isRightBoundary);
  const $cells = renderer_default(that.getColumnElements() ?? "");
  const $container = renderer_default(that.getContent());
  const isFixedPoint = (null === column || void 0 === column ? void 0 : column.fixed) && (null === nextColumn || void 0 === nextColumn ? void 0 : nextColumn.fixed);
  const nonFixedAreaBoundingRect = getNonFixedAreaBoundingRect($cells, $container, addWidgetPrefix);
  if (isFixedPoint || isFixedEdge(point, column, nextColumn)) {
    return false;
  }
  if (isSplitPoint) {
    if (isLastLeftFixedCell($item, addWidgetPrefix) || isStickyCellPinnedToLeft($item, $container, addWidgetPrefix)) {
      return isLeftBoundary;
    }
    if (isFirstRightFixedCell($item, addWidgetPrefix) || isStickyCellPinnedToRight($item, $container, addWidgetPrefix)) {
      return isRightBoundary;
    }
  }
  const isOutsideVisibleArea2 = offsetX < nonFixedAreaBoundingRect.left || offsetX > nonFixedAreaBoundingRect.right;
  const isPointBoundary = offsetX === nonFixedAreaBoundingRect.left || offsetX === nonFixedAreaBoundingRect.right;
  const isLastOrFirstPoint = rtlEnabled ? 0 === point.index : point.index === $cells.length;
  return isOutsideVisibleArea2 || !isLastOrFirstPoint && isPointBoundary;
};
var noNeedToCreateReorderingPoint = (point, $cells, $container, addWidgetPrefix) => {
  const {
    item,
    isLeftBoundary,
    isRightBoundary
  } = point;
  const $item = renderer_default(item);
  const pointX = Math.round(point.x);
  const isSplitPoint = isDefined(isLeftBoundary) || isDefined(isRightBoundary);
  const nonFixedAreaBoundingRect = getNonFixedAreaBoundingRect($cells, $container, addWidgetPrefix);
  if (isStickyCellPinnedToLeft($item, $container, addWidgetPrefix)) {
    return isSplitPoint && !isLeftBoundary;
  }
  if (isStickyCellPinnedToRight($item, $container, addWidgetPrefix)) {
    return isSplitPoint && !isRightBoundary;
  }
  return pointX < nonFixedAreaBoundingRect.left || pointX > nonFixedAreaBoundingRect.right;
};
var doesGroupCellEndInFirstColumn = ($groupCell) => {
  const $groupRow = $groupCell.parent();
  const commandColumns = $groupRow.children().filter((i) => i < $groupCell.index());
  const groupColSpanWithoutCommand = $groupCell.attr("colspan") - commandColumns.length;
  return 1 === groupColSpanWithoutCommand;
};
var getScrollPadding = ($cells, $container, addWidgetPrefix) => {
  const containerRect = getBoundingRect($container.get(0));
  const nonFixedAreaBoundingRect = getNonFixedAreaBoundingRect($cells, $container, addWidgetPrefix);
  return {
    left: nonFixedAreaBoundingRect.left - containerRect.left,
    right: containerRect.right - nonFixedAreaBoundingRect.right
  };
};
var isOutsideVisibleArea = ($element, $cells, $container, addWidgetPrefix) => {
  const elementRect = getBoundingRect($element.get(0));
  const elementRectLeft = Math.round(elementRect.left);
  const elementRectRight = Math.round(elementRect.right);
  const nonFixedAreaBoundingRect = getNonFixedAreaBoundingRect($cells, $container, addWidgetPrefix);
  return elementRectLeft < nonFixedAreaBoundingRect.left || elementRectRight > nonFixedAreaBoundingRect.right;
};
var isLastCell = ($cell) => {
  if (!$cell.is("td")) {
    return false;
  }
  const $lastCell = $cell.parent().children().last();
  return $cell[0] === $lastCell[0];
};
var needToSkipHeaderCell = ($cell) => !$cell.is("[tabindex]");
var getNextHeaderCell = function($cell) {
  let direction = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "next";
  let $nextCell = $cell;
  let $nextRow = $cell.parent();
  do {
    $nextCell = "next" === direction ? $nextCell.next() : $nextCell.prev();
    if (!$nextCell.length) {
      $nextRow = "next" === direction ? $nextRow.next() : $nextRow.prev();
      if ($nextRow.length) {
        $nextCell = "next" === direction ? $nextRow.children().first() : $nextRow.children().last();
      }
    }
  } while ($nextCell.length && needToSkipHeaderCell($nextCell));
  return $nextCell;
};
var GridCoreStickyColumnsDom = {
  toggleFirstHeaderClass,
  toggleColumnNoBorderClass,
  addStickyColumnClass,
  addStickyColumnBorderLeftClass,
  addStickyColumnBorderRightClass,
  doesGroupCellEndInFirstColumn,
  toggleStickyColumnsClass,
  getLeftFixedCells,
  getRightFixedCells,
  getNonFixedAndStickyCells,
  getNonFixedAreaBoundingRect,
  getScrollPadding,
  getNextHeaderCell,
  noNeedToCreateResizingPoint,
  isFixedCellPinnedToRight,
  noNeedToCreateReorderingPoint,
  isFixedCell,
  isStickyCell,
  isStickyCellPinned,
  isOutsideVisibleArea,
  isLastCell
};

// node_modules/devextreme/esm/__internal/grids/grid_core/keyboard_navigation/m_column_focus_dispatcher.js
var ColumnFocusDispatcher = class extends Controller {
  constructor() {
    super(...arguments);
    this.keyboardNavigationControllers = [];
  }
  registerKeyboardNavigationController(keyboardNavigationController) {
    this.keyboardNavigationControllers.push(keyboardNavigationController);
  }
  updateFocusPosition(keyboardNavigationController, cellPosition) {
    if (isDefined(cellPosition)) {
      keyboardNavigationController.updateFocusPosition(cellPosition);
    } else {
      this.keyboardNavigationControllers.forEach((keyboardController) => {
        if (keyboardController === keyboardNavigationController) {
          return;
        }
        keyboardController.updateFocusPosition();
      });
    }
  }
  restoreFocus(keyboardNavigationController) {
    if (keyboardNavigationController.getFirstFocusableVisibleIndex() >= 0) {
      keyboardNavigationController.restoreFocus();
    } else {
      this.keyboardNavigationControllers.forEach((keyboardController) => {
        if (keyboardController === keyboardNavigationController) {
          return;
        }
        const firstFocusableVisibleIndex = keyboardController.getFirstFocusableVisibleIndex();
        if (firstFocusableVisibleIndex >= 0) {
          keyboardController.restoreFocus();
        }
      });
    }
  }
};

// node_modules/devextreme/esm/__internal/grids/grid_core/keyboard_navigation/m_column_keyboard_navigation_core.js
var ColumnKeyboardNavigationController = class extends KeyboardNavigationController {
  keyDownHandler(e) {
    return this.processOnKeyDown(e);
  }
  getVisibleIndex(column, rowIndex) {
    const visibleIndex = this._columnsController.getVisibleIndex(column.index, rowIndex);
    const columnIndexOffset = this.getColumnIndexOffset(visibleIndex);
    return visibleIndex >= 0 ? visibleIndex + columnIndexOffset : -1;
  }
  getNewVisibleIndex(visibleIndex, rowIndex, direction) {
    return "previous" === direction ? visibleIndex - 1 : visibleIndex + 2;
  }
  getNewFocusedColumnIndex(newVisibleIndex, direction) {
    return direction === Direction.Next ? newVisibleIndex - 1 : newVisibleIndex;
  }
  resizeCompleted() {
    if (this.needToRestoreFocus) {
      this.restoreFocus();
    }
  }
  resetFocusedCellPosition() {
    this._focusedCellPosition = {};
  }
  canReorderColumn(column, direction, rowIndex) {
    return false;
  }
  init() {
    var _this$columnFocusDisp;
    super.init();
    this.columnFocusDispatcher = this.getController("columnFocusDispatcher");
    null === (_this$columnFocusDisp = this.columnFocusDispatcher) || void 0 === _this$columnFocusDisp || _this$columnFocusDisp.registerKeyboardNavigationController(this);
  }
  moveColumn(column) {
    let direction = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : Direction.Next;
    let rowIndex = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
    const viewName2 = this.getFocusedView().getName();
    const visibleIndex = this.getVisibleIndex(column, rowIndex);
    const newVisibleIndex = this.getNewVisibleIndex(visibleIndex, rowIndex, direction);
    const newFocusedColumnIndex = this.getNewFocusedColumnIndex(newVisibleIndex, direction);
    this.updateViewFocusPosition({
      rowIndex,
      columnIndex: newFocusedColumnIndex
    });
    this._columnsController.moveColumn({
      columnIndex: visibleIndex,
      rowIndex
    }, {
      columnIndex: newVisibleIndex,
      rowIndex
    }, viewName2, viewName2);
  }
  getFirstFocusableVisibleIndex() {
    return -1;
  }
  updateViewFocusPosition(cellPosition) {
    var _this$columnFocusDisp2;
    null === (_this$columnFocusDisp2 = this.columnFocusDispatcher) || void 0 === _this$columnFocusDisp2 || _this$columnFocusDisp2.updateFocusPosition(this, cellPosition);
  }
  updateFocusPosition(cellPosition) {
    this.needToRestoreFocus = true;
    if (isDefined(cellPosition)) {
      this.setFocusedCellPosition(cellPosition.rowIndex, cellPosition.columnIndex);
    } else {
      this.resetFocusedCellPosition();
    }
  }
  restoreViewFocus() {
    var _this$columnFocusDisp3;
    null === (_this$columnFocusDisp3 = this.columnFocusDispatcher) || void 0 === _this$columnFocusDisp3 || _this$columnFocusDisp3.restoreFocus(this);
  }
  restoreFocus() {
    var _$focusedCell$;
    this.needToRestoreFocus = false;
    if (isEmptyObject(this._focusedCellPosition)) {
      this.setFocusedCellPosition(0, this.getFirstFocusableVisibleIndex());
    }
    const $focusedCell = this._getFocusedCell();
    null === $focusedCell || void 0 === $focusedCell || null === (_$focusedCell$ = $focusedCell[0]) || void 0 === _$focusedCell$ || _$focusedCell$.focus({
      preventScroll: true
    });
  }
};

// node_modules/devextreme/esm/__internal/grids/grid_core/keyboard_navigation/m_headers_keyboard_navigation.js
var HeadersKeyboardNavigationController = class extends ColumnKeyboardNavigationController {
  constructor() {
    super(...arguments);
    this.isOutsideVisibleArea = ($element, $container) => {
      const elementRect = getBoundingRect($element.get(0));
      const elementRectLeft = Math.round(elementRect.left);
      const elementRectRight = Math.round(elementRect.right);
      const containerBoundingRect = this.getContainerBoundingRect($container);
      return elementRectLeft < containerBoundingRect.left || elementRectRight > containerBoundingRect.right;
    };
  }
  leftRightKeysHandler(e) {
    const {
      originalEvent
    } = e;
    if (isCommandKeyPressed(originalEvent)) {
      const $cell = renderer_default(originalEvent.target).closest("td");
      const direction = this.getDirectionByKeyName(e.keyName);
      const rowIndex = this._getRowIndex($cell.parent());
      const column = this._getColumnByCellElement($cell, rowIndex);
      if (this.canReorderColumn(column, direction, rowIndex)) {
        this.moveColumn(column, direction, rowIndex);
      }
      null === originalEvent || void 0 === originalEvent || originalEvent.preventDefault();
    }
  }
  getColumnVisibleIndexCorrection(visibleColumnIndex, rowIndex, direction) {
    return 0;
  }
  getNewVisibleIndex(visibleIndex, rowIndex, direction) {
    const newVisibleIndex = super.getNewVisibleIndex(visibleIndex, rowIndex, direction);
    const indexCorrection = this.getColumnVisibleIndexCorrection(visibleIndex, rowIndex, direction);
    return newVisibleIndex + indexCorrection;
  }
  getDraggableColumns(column, rowIndex) {
    var _columnsController$ge;
    const columnsController = this._columnsController;
    const visibleColumns = null === (_columnsController$ge = columnsController.getVisibleColumns(rowIndex, true)) || void 0 === _columnsController$ge ? void 0 : _columnsController$ge.filter((col) => col.ownerBand === (null === column || void 0 === column ? void 0 : column.ownerBand) && (!isDefined(col.type) || columnsController.isCustomCommandColumn(col)));
    if (null !== column && void 0 !== column && column.fixed) {
      const fixedPosition = getColumnFixedPosition(columnsController, column);
      if (fixedPosition !== StickyPosition.Sticky) {
        return visibleColumns.filter((col) => col.fixed && getColumnFixedPosition(columnsController, col) === fixedPosition);
      }
    }
    return visibleColumns.filter((column2) => !column2.fixed || column2.fixedPosition === StickyPosition.Sticky);
  }
  keyDownHandler(e) {
    let isHandled = super.keyDownHandler(e);
    if (isHandled) {
      return true;
    }
    switch (e.keyName) {
      case "tab":
        this.tabKeyHandler(e);
        isHandled = true;
        break;
      case "leftArrow":
      case "rightArrow":
        this.leftRightKeysHandler(e);
        isHandled = true;
    }
    return isHandled;
  }
  tabKeyHandler(e) {
  }
  getCellIndex($cell) {
    return this._columnHeadersView.getCellIndex($cell);
  }
  _getCell(cellPosition) {
    var _this$_columnHeadersV;
    const columnIndexOffset = this.getColumnIndexOffset(cellPosition.columnIndex);
    const columnIndex = cellPosition.columnIndex >= 0 ? cellPosition.columnIndex - columnIndexOffset : -1;
    return null === (_this$_columnHeadersV = this._columnHeadersView) || void 0 === _this$_columnHeadersV ? void 0 : _this$_columnHeadersV.getCell({
      rowIndex: cellPosition.rowIndex,
      columnIndex
    });
  }
  getFocusedView() {
    return this.getView("columnHeadersView");
  }
  focusinHandler(e) {
    this._updateFocusedCellPosition(renderer_default(e.target));
  }
  getFocusinSelector() {
    return ".dx-header-row > td";
  }
  getFocusableColumns(rowIndex, bandColumnId) {
    const visibleColumns = this._columnsController.getVisibleColumns(rowIndex);
    const result2 = visibleColumns.filter((column) => !isDefined(column.type) || this._columnsController.isCustomCommandColumn(column));
    if (isDefined(bandColumnId)) {
      return result2.filter((column) => column.ownerBand === bandColumnId);
    }
    return result2;
  }
  getContainerBoundingRect($container) {
    const containerRect = getBoundingRect($container.get(0));
    return {
      left: containerRect.left,
      right: containerRect.right
    };
  }
  getScrollPadding($container) {
    const containerRect = getBoundingRect($container.get(0));
    const containerBoundingRect = this.getContainerBoundingRect($container);
    return {
      left: containerBoundingRect.left - containerRect.left,
      right: containerRect.right - containerBoundingRect.right
    };
  }
  scrollToColumn($cell) {
    var _this$getView;
    const scrollable = null === (_this$getView = this.getView("rowsView")) || void 0 === _this$getView ? void 0 : _this$getView.getScrollable();
    if (!scrollable) {
      return;
    }
    const scrollPadding = this.getScrollPadding(renderer_default(scrollable.container()));
    const scrollPosition = getElementLocationInternal($cell[0], "horizontal", renderer_default(this._columnHeadersView.getContent())[0], scrollable.scrollOffset(), scrollPadding, this.addWidgetPrefix("table"));
    scrollable.scrollTo({
      x: scrollPosition
    });
  }
  init() {
    super.init();
    this._columnHeadersView = this.getView("columnHeadersView");
  }
  canReorderColumn(column, direction, rowIndex) {
    const allowReordering2 = this._columnHeadersView.isColumnReorderingEnabled(column);
    if (!allowReordering2) {
      return false;
    }
    const draggableColumns = this.getDraggableColumns(column, rowIndex);
    const isFirstColumn = column.index === draggableColumns[0].index;
    const isLastColumn = column.index === draggableColumns[draggableColumns.length - 1].index;
    return direction === Direction.Next ? !isLastColumn : !isFirstColumn;
  }
  getFirstFocusableVisibleIndex() {
    const focusableColumns = this.getFocusableColumns();
    if (null !== focusableColumns && void 0 !== focusableColumns && focusableColumns.length) {
      return this._columnsController.getVisibleIndex(focusableColumns[0].index);
    }
    return -1;
  }
  restoreFocus() {
    const $focusedCell = this._getFocusedCell();
    const isFixedCell2 = GridCoreStickyColumnsDom.isFixedCell($focusedCell, this.addWidgetPrefix.bind(this));
    if (isFixedCell2) {
      super.restoreFocus();
      return;
    }
    const focusedCellIsOutsideVisibleArea = $focusedCell.length && this.isOutsideVisibleArea($focusedCell, renderer_default(this._columnHeadersView.getContent()));
    if (focusedCellIsOutsideVisibleArea) {
      this.scrollToColumn($focusedCell);
    } else {
      super.restoreFocus();
    }
  }
  needToFocus() {
    return this.needToRestoreFocus;
  }
};
var columnHeadersView6 = (Base) => class extends Base {
  handleScroll(e) {
    var _this$_headersKeyboar, _this$_columnsControl;
    super.handleScroll(e);
    if (!(null !== (_this$_headersKeyboar = this._headersKeyboardNavigation) && void 0 !== _this$_headersKeyboar && _this$_headersKeyboar.needToFocus())) {
      return;
    }
    const isNeedToRenderVirtualColumns = null === (_this$_columnsControl = this._columnsController) || void 0 === _this$_columnsControl ? void 0 : _this$_columnsControl.isNeedToRenderVirtualColumns(e.target.scrollLeft);
    if (!isNeedToRenderVirtualColumns) {
      this._headersKeyboardNavigation.restoreFocus();
    }
  }
};
var headersKeyboardNavigationModule = {
  controllers: {
    headersKeyboardNavigation: HeadersKeyboardNavigationController,
    columnFocusDispatcher: ColumnFocusDispatcher
  },
  extenders: {
    views: {
      columnHeadersView: columnHeadersView6
    }
  }
};

// node_modules/devextreme/esm/__internal/grids/data_grid/keyboard_navigation/m_column_keyboard_navigation_mixin.js
var ColumnKeyboardNavigationMixin = (Base) => class extends Base {
  ungroupColumnByPressingKey(e) {
    var _e$originalEvent;
    const column = this.getColumnFromEvent(e);
    const rowIndex = this.getRowIndexFromEvent(e);
    this.ungroupColumn(column, rowIndex);
    null === (_e$originalEvent = e.originalEvent) || void 0 === _e$originalEvent || _e$originalEvent.preventDefault();
  }
  getFocusedCellPositionByColumn(column) {
    if (!column) {
      return;
    }
    const newRowIndex = this._columnsController.getRowIndex(column.index, true);
    return {
      rowIndex: newRowIndex,
      columnIndex: this.getVisibleIndex(column, newRowIndex)
    };
  }
  getRowIndexFromEvent(e) {
    return 0;
  }
  getColumnFromEvent(e) {
  }
  getNewFocusedColumnBeforeUngrouping(column, rowIndex) {
    return column;
  }
  keyDownHandler(e) {
    let isHandled = super.keyDownHandler(e);
    if (isHandled) {
      return true;
    }
    if (this.canUngroupColumnByPressingKey(e)) {
      this.ungroupColumnByPressingKey(e);
      isHandled = true;
    } else if (this.canUngroupAllColumnByPressingKey(e)) {
      this.ungroupAllColumns();
      isHandled = true;
    }
    return isHandled;
  }
  changeGroupColumnIndex(groupIndex, column, newFocusedColumn) {
    this._columnsController.beginUpdate();
    this._columnsController.columnOption(column.dataField, "groupIndex", groupIndex);
    const newFocusedCellPosition = this.getFocusedCellPositionByColumn(newFocusedColumn);
    this.updateViewFocusPosition(newFocusedCellPosition);
    this._columnsController.endUpdate();
  }
  canUngroupColumnByPressingKey(e) {
    return e.which === KEY_CODES.G && e.shift && isCommandKeyPressed(e.originalEvent);
  }
  canUngroupAllColumnByPressingKey(e) {
    return e.which === KEY_CODES.G && e.shift && e.alt;
  }
  ungroupColumn(column) {
    let rowIndex = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
    if (isDefined(null === column || void 0 === column ? void 0 : column.groupIndex)) {
      const newFocusedColumn = this.getNewFocusedColumnBeforeUngrouping(column, rowIndex);
      this.changeGroupColumnIndex(-1, column, newFocusedColumn);
    }
  }
  ungroupAllColumns() {
    this._columnsController.clearGrouping();
  }
};

// node_modules/devextreme/esm/__internal/grids/data_grid/keyboard_navigation/m_headers_keyboard_navigation.js
var headersKeyboardNavigation = (Base) => class extends ColumnKeyboardNavigationMixin(Base) {
  getNewFocusedColumnBeforeGrouping(column, rowIndex) {
    if (column.showWhenGrouped) {
      return column;
    }
    const focusableColumns = this.getFocusableColumns(rowIndex, column.ownerBand);
    if (1 === focusableColumns.length && isDefined(column.ownerBand)) {
      return this._columnsController.getParentColumn(column, true);
    }
    if (1 === focusableColumns.length) {
      return;
    }
    const visibleColumnIndex = focusableColumns.findIndex((col) => col.index === column.index);
    return visibleColumnIndex === focusableColumns.length - 1 ? focusableColumns[visibleColumnIndex - 1] : focusableColumns[visibleColumnIndex + 1];
  }
  groupColumnByPressingKey(e) {
    var _e$originalEvent;
    const $cell = renderer_default(e.originalEvent.target).closest("td");
    const rowIndex = this._getRowIndex($cell.parent());
    const column = this._getColumnByCellElement($cell, rowIndex);
    this.groupColumn(column, rowIndex);
    null === (_e$originalEvent = e.originalEvent) || void 0 === _e$originalEvent || _e$originalEvent.preventDefault();
  }
  canGroupColumnByPressingKey(e) {
    return e.which === KEY_CODES.G && isCommandKeyPressed(e.originalEvent);
  }
  getRowIndexFromEvent(e) {
    const $cell = renderer_default(e.originalEvent.target).closest("td");
    return this._getRowIndex($cell.parent());
  }
  getColumnFromEvent(e) {
    const $cell = renderer_default(e.originalEvent.target).closest("td");
    const rowIndex = this._getRowIndex($cell.parent());
    return this._getColumnByCellElement($cell, rowIndex);
  }
  keyDownHandler(e) {
    let isHandled = super.keyDownHandler(e);
    if (isHandled) {
      return true;
    }
    if (this.canGroupColumnByPressingKey(e)) {
      this.groupColumnByPressingKey(e);
      isHandled = true;
    }
    return isHandled;
  }
  groupColumn(column) {
    let rowIndex = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
    if (!isDefined(column.groupIndex) && null !== column && void 0 !== column && column.allowGrouping) {
      var _this$_columnsControl;
      const newGroupIndex = (null === (_this$_columnsControl = this._columnsController.getGroupColumns()) || void 0 === _this$_columnsControl ? void 0 : _this$_columnsControl.length) ?? 0;
      const newFocusedColumn = this.getNewFocusedColumnBeforeGrouping(column, rowIndex);
      this.changeGroupColumnIndex(newGroupIndex, column, newFocusedColumn);
    }
  }
  ungroupAllColumns() {
    const $focusedCell = this._getFocusedCell();
    const focusedColumn = this._getColumnByCellElement($focusedCell);
    this._columnsController.beginUpdate();
    super.ungroupAllColumns();
    const rowIndex = this._columnsController.getRowIndex(focusedColumn.index, true);
    const newVisibleIndex = this.getVisibleIndex(focusedColumn);
    this.updateFocusPosition({
      rowIndex,
      columnIndex: newVisibleIndex
    });
    this._columnsController.endUpdate();
  }
};
m_core_default.registerModule("headersKeyboardNavigation", _extends({}, headersKeyboardNavigationModule, {
  extenders: {
    controllers: {
      headersKeyboardNavigation
    },
    views: _extends({}, headersKeyboardNavigationModule.extenders.views)
  }
}));

// node_modules/devextreme/esm/__internal/grids/data_grid/keyboard_navigation/m_group_panel_keyboard_navigation.js
var GroupPanelKeyboardNavigationController = class extends ColumnKeyboardNavigationMixin(ColumnKeyboardNavigationController) {
  constructor() {
    super(...arguments);
    this.isNeedToHiddenFocusAfterClick = false;
  }
  groupItemClickHandler(e) {
    var _this$_columnsControl;
    const $groupedColumnElement = renderer_default(e.originalEvent.target);
    const groupColumn = this._columnsController.columnOption(`groupIndex:${$groupedColumnElement.index()}`);
    this.isNeedToHiddenFocusAfterClick = null === (_this$_columnsControl = this._columnsController) || void 0 === _this$_columnsControl ? void 0 : _this$_columnsControl.allowColumnSorting(groupColumn);
  }
  unsubscribeFromGroupItemClick() {
    const $focusedView = this.getFocusedViewElement();
    if ($focusedView) {
      m_events_engine_default.off($focusedView, CLICK_EVENT_NAME, this.groupItemClickHandlerContext);
    }
  }
  subscribeToGroupItemClick() {
    const $focusedView = this.getFocusedViewElement();
    if ($focusedView) {
      m_events_engine_default.on($focusedView, CLICK_EVENT_NAME, `.${CLASSES5.groupPanelItem}`, this.groupItemClickHandlerContext);
    }
  }
  leftRightKeysHandler(e) {
    const {
      originalEvent
    } = e;
    if (isCommandKeyPressed(originalEvent)) {
      const $groupedColumnElement = renderer_default(originalEvent.target);
      const column = this._columnsController.columnOption(`groupIndex:${$groupedColumnElement.index()}`);
      const direction = this.getDirectionByKeyName(e.keyName);
      if (this.canReorderColumn(column, direction)) {
        this.moveColumn(column, direction);
      }
      null === originalEvent || void 0 === originalEvent || originalEvent.preventDefault();
    }
  }
  getVisibleIndex(column) {
    return column.groupIndex;
  }
  getColumnFromEvent(e) {
    const $groupedColumnElement = renderer_default(e.originalEvent.target);
    return this._columnsController.columnOption(`groupIndex:${$groupedColumnElement.index()}`);
  }
  getNewFocusedColumnBeforeUngrouping(column) {
    const visibleColumnIndex = column.groupIndex;
    const groupColumns = this._columnsController.getGroupColumns();
    return visibleColumnIndex === groupColumns.length - 1 ? groupColumns[visibleColumnIndex - 1] : groupColumns[visibleColumnIndex + 1];
  }
  _getCell(cellPosition) {
    var _this$headerPanel;
    const $groupColumnElements = null === (_this$headerPanel = this.headerPanel) || void 0 === _this$headerPanel ? void 0 : _this$headerPanel.getColumnElements();
    return null === $groupColumnElements || void 0 === $groupColumnElements ? void 0 : $groupColumnElements.eq(cellPosition.columnIndex);
  }
  getFocusedView() {
    return this.getView("headerPanel");
  }
  getFocusedViewElement() {
    var _this$headerPanel2;
    return null === (_this$headerPanel2 = this.headerPanel) || void 0 === _this$headerPanel2 || null === (_this$headerPanel2 = _this$headerPanel2.element()) || void 0 === _this$headerPanel2 ? void 0 : _this$headerPanel2.find(`.${CLASSES5.groupPanel}`);
  }
  getFocusinSelector() {
    return `.${CLASSES5.groupPanelItem}`;
  }
  focusinHandler(e) {
    this.setFocusedCellPosition(0, renderer_default(e.target).index());
  }
  keyDownHandler(e) {
    let isHandled = super.keyDownHandler(e);
    if (isHandled) {
      return true;
    }
    if ("leftArrow" === e.keyName || "rightArrow" === e.keyName) {
      this.leftRightKeysHandler(e);
      isHandled = true;
    }
    return isHandled;
  }
  renderCompleted(e) {
    const {
      needToRestoreFocus
    } = this;
    super.renderCompleted(e);
    this.unsubscribeFromGroupItemClick();
    this.subscribeToGroupItemClick();
    if (!needToRestoreFocus && this.isNeedToHiddenFocusAfterClick) {
      const $focusElement = this._getFocusedCell();
      if (null !== $focusElement && void 0 !== $focusElement && $focusElement.length) {
        hiddenFocus($focusElement.get(0));
      }
      this.isNeedToHiddenFocusAfterClick = false;
    }
  }
  canUngroupColumnByPressingKey(e) {
    return super.canUngroupColumnByPressingKey(e) || "backspace" === e.keyName || "del" === e.keyName;
  }
  getFirstFocusableVisibleIndex() {
    var _this$headerPanel3;
    const columns7 = null === (_this$headerPanel3 = this.headerPanel) || void 0 === _this$headerPanel3 ? void 0 : _this$headerPanel3.getColumns();
    return null !== columns7 && void 0 !== columns7 && columns7.length ? 0 : -1;
  }
  init() {
    this.headerPanel = this.getView("headerPanel");
    this.groupItemClickHandlerContext = this.groupItemClickHandlerContext ?? this.groupItemClickHandler.bind(this);
    super.init();
  }
  canReorderColumn(groupColumn, direction) {
    const allowDragging2 = this.headerPanel.allowDragging(groupColumn);
    if (!allowDragging2) {
      return false;
    }
    const groupedColumns = this._columnsController.getGroupColumns();
    return direction === Direction.Next ? groupColumn.groupIndex !== groupedColumns.length - 1 : 0 !== groupColumn.groupIndex;
  }
  ungroupAllColumns() {
    this.updateViewFocusPosition();
    super.ungroupAllColumns();
  }
};
m_core_default.registerModule("groupPanelKeyboardNavigation", {
  controllers: {
    groupPanelKeyboardNavigation: GroupPanelKeyboardNavigationController
  }
});

// node_modules/devextreme/esm/__internal/grids/data_grid/m_aggregate_calculator.js
function depthFirstSearch(i, depth, root, callback) {
  let j = 0;
  if (i < depth) {
    for (; j < root.items.length; j++) {
      depthFirstSearch(i + 1, depth, root.items[j], callback);
    }
  }
  if (i === depth) {
    callback(root);
  }
}
function map2(array, callback) {
  let i;
  if ("map" in array) {
    return array.map(callback);
  }
  const result2 = new Array(array.length);
  for (i in array) {
    result2[i] = callback(array[i], i);
  }
  return result2;
}
function isEmpty2(x) {
  return x !== x || "" === x || null === x || void 0 === x;
}
function isCount(aggregator) {
  return aggregator === aggregators.count;
}
function normalizeAggregate(aggregate) {
  const selector = compileGetter(aggregate.selector);
  const skipEmptyValues = "skipEmptyValues" in aggregate ? aggregate.skipEmptyValues : true;
  let {
    aggregator
  } = aggregate;
  if ("string" === typeof aggregator) {
    aggregator = aggregators[aggregator];
    if (!aggregator) {
      throw errors.Error("E4001", aggregate.aggregator);
    }
  }
  return {
    selector,
    aggregator,
    skipEmptyValues
  };
}
var AggregateCalculator = class {
  constructor(options2) {
    this._data = options2.data;
    this._groupLevel = options2.groupLevel || 0;
    this._totalAggregates = map2(options2.totalAggregates || [], normalizeAggregate);
    this._groupAggregates = map2(options2.groupAggregates || [], normalizeAggregate);
    this._totals = [];
  }
  calculate() {
    if (this._totalAggregates.length) {
      this._calculateTotals(0, {
        items: this._data
      });
    }
    if (this._groupAggregates.length && this._groupLevel > 0) {
      this._calculateGroups({
        items: this._data
      });
    }
  }
  totalAggregates() {
    return this._totals;
  }
  _aggregate(aggregates, data17, container) {
    const length = data17.items ? data17.items.length : 0;
    for (let i = 0; i < aggregates.length; i++) {
      if (isCount(aggregates[i].aggregator)) {
        container[i] = (container[i] || 0) + length;
        continue;
      }
      for (let j = 0; j < length; j++) {
        this._accumulate(i, aggregates[i], container, data17.items[j]);
      }
    }
  }
  _calculateTotals(level, data17) {
    if (0 === level) {
      this._totals = this._seed(this._totalAggregates);
    }
    if (level === this._groupLevel) {
      this._aggregate(this._totalAggregates, data17, this._totals);
    } else {
      for (let i = 0; i < data17.items.length; i++) {
        this._calculateTotals(level + 1, data17.items[i]);
      }
    }
    if (0 === level) {
      this._totals = this._finalize(this._totalAggregates, this._totals);
    }
  }
  _calculateGroups(root) {
    const maxLevel = this._groupLevel;
    let currentLevel = maxLevel + 1;
    const seedFn = this._seed.bind(this, this._groupAggregates);
    const stepFn = this._aggregate.bind(this, this._groupAggregates);
    const finalizeFn = this._finalize.bind(this, this._groupAggregates);
    function aggregator(node) {
      node.aggregates = seedFn(currentLevel - 1);
      if (currentLevel === maxLevel) {
        stepFn(node, node.aggregates);
      } else {
        depthFirstSearch(currentLevel, maxLevel, node, (innerNode) => {
          stepFn(innerNode, node.aggregates);
        });
      }
      node.aggregates = finalizeFn(node.aggregates);
    }
    while (--currentLevel > 0) {
      depthFirstSearch(0, currentLevel, root, aggregator);
    }
  }
  _seed(aggregates, groupIndex) {
    return map2(aggregates, (aggregate) => {
      const {
        aggregator
      } = aggregate;
      const seed = "seed" in aggregator ? isFunction(aggregator.seed) ? aggregator.seed(groupIndex) : aggregator.seed : NaN;
      return seed;
    });
  }
  _accumulate(aggregateIndex, aggregate, results, item) {
    const value2 = aggregate.selector(item);
    const {
      aggregator
    } = aggregate;
    const {
      skipEmptyValues
    } = aggregate;
    if (skipEmptyValues && isEmpty2(value2)) {
      return;
    }
    if (results[aggregateIndex] !== results[aggregateIndex]) {
      results[aggregateIndex] = value2;
    } else {
      results[aggregateIndex] = aggregator.step(results[aggregateIndex], value2);
    }
  }
  _finalize(aggregates, results) {
    return map2(aggregates, (aggregate, index2) => {
      const fin = aggregate.aggregator.finalize;
      return fin ? fin(results[index2]) : results[index2];
    });
  }
};

// node_modules/devextreme/esm/__internal/grids/data_grid/summary/m_summary.js
var DATAGRID_CELL_DISABLED = "dx-cell-focus-disabled";
var renderSummaryCell = function(cell, options2) {
  const $cell = renderer_default(cell);
  const {
    column
  } = options2;
  const {
    summaryItems
  } = options2;
  const $summaryItems = [];
  if (!column.command && summaryItems) {
    for (let i = 0; i < summaryItems.length; i++) {
      const summaryItem = summaryItems[i];
      const text = m_core_default.getSummaryText(summaryItem, options2.summaryTexts);
      $summaryItems.push(renderer_default("<div>").css("textAlign", summaryItem.alignment || column.alignment).addClass("dx-datagrid-summary-item").addClass("dx-datagrid-text-content").addClass(summaryItem.cssClass).toggleClass("dx-datagrid-group-text-content", "group" === options2.rowType).text(text).attr("aria-label", `${column.caption} ${text}`));
    }
    $cell.append($summaryItems);
  }
};
var getSummaryCellOptions = function(that, options2) {
  const summaryTexts = that.option("summary.texts") || {};
  return {
    totalItem: options2.row,
    summaryItems: options2.row.summaryCells[options2.columnIndex],
    summaryTexts
  };
};
var getGroupAggregates = function(data17) {
  return data17.summary || data17.aggregates || [];
};
var recalculateWhileEditing = function(that) {
  return that.option("summary.recalculateWhileEditing");
};
var forEachGroup = function(groups, groupCount, callback, path) {
  path = path || [];
  for (let i = 0; i < groups.length; i++) {
    path.push(groups[i].key);
    if (1 === groupCount) {
      callback(path, groups[i].items);
    } else {
      forEachGroup(groups[i].items, groupCount - 1, callback, path);
    }
    path.pop();
  }
};
var applyAddedData = function(data17, insertedData, groupLevel) {
  if (groupLevel) {
    return applyAddedData(data17, insertedData.map((item) => ({
      items: [item]
    }), groupLevel - 1));
  }
  return data17.concat(insertedData);
};
var applyRemovedData = function(data17, removedData, groupLevel) {
  if (groupLevel) {
    return data17.map((data18) => {
      const updatedData = {};
      const updatedItems = applyRemovedData(data18.items || [], removedData, groupLevel - 1);
      Object.defineProperty(updatedData, "aggregates", {
        get: () => data18.aggregates,
        set: (value2) => {
          data18.aggregates = value2;
        }
      });
      return extend(updatedData, data18, {
        items: updatedItems
      });
    });
  }
  return data17.filter((data18) => removedData.indexOf(data18) < 0);
};
var sortGroupsBySummaryCore = function(items, groups, sortByGroups) {
  if (!items || !groups.length) {
    return items;
  }
  const group = groups[0];
  const sorts = sortByGroups[0];
  let query2;
  if (group && sorts && sorts.length) {
    query2 = m_query_default(items);
    each(sorts, function(index2) {
      if (0 === index2) {
        query2 = query2.sortBy(this.selector, this.desc);
      } else {
        query2 = query2.thenBy(this.selector, this.desc);
      }
    });
    query2.enumerate().done((sortedItems) => {
      items = sortedItems;
    });
  }
  groups = groups.slice(1);
  sortByGroups = sortByGroups.slice(1);
  if (groups.length && sortByGroups.length) {
    each(items, function() {
      this.items = sortGroupsBySummaryCore(this.items, groups, sortByGroups);
    });
  }
  return items;
};
var sortGroupsBySummary = function(data17, group, summary) {
  const sortByGroups = summary && summary.sortByGroups && summary.sortByGroups();
  if (sortByGroups && sortByGroups.length) {
    return sortGroupsBySummaryCore(data17, group, sortByGroups);
  }
  return data17;
};
var calculateAggregates = function(that, summary, data17, groupLevel) {
  let calculator;
  if (recalculateWhileEditing(that)) {
    const editingController = that._editingController;
    if (editingController) {
      const insertedData = editingController.getInsertedData();
      if (insertedData.length) {
        data17 = applyAddedData(data17, insertedData, groupLevel);
      }
      const removedData = editingController.getRemovedData();
      if (removedData.length) {
        data17 = applyRemovedData(data17, removedData, groupLevel);
      }
    }
  }
  if (summary) {
    calculator = new AggregateCalculator({
      totalAggregates: summary.totalAggregates,
      groupAggregates: summary.groupAggregates,
      data: data17,
      groupLevel
    });
    calculator.calculate();
  }
  return calculator ? calculator.totalAggregates() : [];
};
var FooterView = class extends ColumnsView {
  _getRows() {
    return this._dataController.footerItems();
  }
  _getCellOptions(options2) {
    return extend(super._getCellOptions(options2), getSummaryCellOptions(this, options2));
  }
  _renderCellContent($cell, options2) {
    renderSummaryCell($cell, options2);
    super._renderCellContent.apply(this, arguments);
  }
  _renderCore(change) {
    let needUpdateScrollLeft = false;
    const totalItem = this._dataController.footerItems()[0];
    if (!change || !change.columnIndices) {
      this.element().empty().addClass("dx-datagrid-total-footer").toggleClass("dx-datagrid-nowrap", !this.option("wordWrapEnabled"));
      needUpdateScrollLeft = true;
    }
    if (totalItem && totalItem.summaryCells && totalItem.summaryCells.length) {
      this._updateContent(this._renderTable({
        change
      }), change);
      needUpdateScrollLeft && this._updateScrollLeftPosition();
    }
    return super._renderCore(change);
  }
  _updateContent($newTable, change) {
    if (change && "update" === change.changeType && change.columnIndices) {
      return this.waitAsyncTemplates().done(() => {
        const $row = this.getTableElement().find(".dx-row");
        const $newRow = $newTable.find(".dx-row");
        this._updateCells($row, $newRow, change.columnIndices[0]);
      });
    }
    return super._updateContent.apply(this, arguments);
  }
  _rowClick(e) {
    const item = this._dataController.footerItems()[e.rowIndex] || {};
    this.executeAction("onRowClick", extend({}, e, item));
  }
  _columnOptionChanged(e) {
    const {
      optionNames
    } = e;
    if (e.changeTypes.grouping) {
      return;
    }
    if (optionNames.width || optionNames.visibleWidth) {
      super._columnOptionChanged(e);
    }
  }
  _handleDataChanged(e) {
    const {
      changeType
    } = e;
    if ("update" === e.changeType && e.repaintChangesOnly) {
      if (!e.totalColumnIndices) {
        this.render();
      } else if (e.totalColumnIndices.length) {
        this.render(null, {
          changeType: "update",
          columnIndices: [e.totalColumnIndices]
        });
      }
    } else if ("refresh" === changeType || "append" === changeType || "prepend" === changeType) {
      this.render();
    }
  }
  _createRow(row) {
    const $row = super._createRow.apply(this, arguments);
    if ("totalFooter" === row.rowType) {
      $row.addClass("dx-footer-row");
      $row.addClass(DATAGRID_CELL_DISABLED);
      $row.attr("tabindex", 0);
    }
    return $row;
  }
  getHeight() {
    return this.getElementHeight();
  }
  isVisible() {
    return !!this._dataController.footerItems().length;
  }
};
var dataSourceAdapterExtender3 = (Base) => class extends Base {
  init() {
    super.init.apply(this, arguments);
    this._editingController = this.getController("editing");
    this._totalAggregates = [];
    this._summaryGetter = noop2;
  }
  summaryGetter(summaryGetter) {
    if (!arguments.length) {
      return this._summaryGetter;
    }
    if (isFunction(summaryGetter)) {
      this._summaryGetter = summaryGetter;
    }
  }
  summary(summary) {
    if (!arguments.length) {
      return this._summaryGetter();
    }
    this._summaryGetter = function() {
      return summary;
    };
  }
  totalAggregates() {
    return this._totalAggregates;
  }
  isLastLevelGroupItemsPagingLocal() {
    const summary = this.summary();
    const sortByGroupsInfo = null === summary || void 0 === summary ? void 0 : summary.sortByGroups();
    return null === sortByGroupsInfo || void 0 === sortByGroupsInfo ? void 0 : sortByGroupsInfo.length;
  }
  sortLastLevelGroupItems(items, groups, paths) {
    const groupedItems = m_store_helper_default.multiLevelGroup(m_query_default(items), groups).toArray();
    let result2 = [];
    paths.forEach((path) => {
      forEachGroup(groupedItems, groups.length, (itemsPath, items2) => {
        if (path.toString() === itemsPath.toString()) {
          result2 = result2.concat(items2);
        }
      });
    });
    return result2;
  }
  _customizeRemoteOperations(options2) {
    const summary = this.summary();
    if (summary) {
      if (options2.remoteOperations.summary) {
        if (!options2.isCustomLoading || options2.storeLoadOptions.isLoadingAll) {
          if (options2.storeLoadOptions.group) {
            if (options2.remoteOperations.grouping) {
              options2.storeLoadOptions.groupSummary = summary.groupAggregates;
            } else if (summary.groupAggregates.length) {
              options2.remoteOperations.paging = false;
            }
          }
          options2.storeLoadOptions.totalSummary = summary.totalAggregates;
        }
      } else if (summary.totalAggregates.length || summary.groupAggregates.length && options2.storeLoadOptions.group) {
        options2.remoteOperations.paging = false;
      }
    }
    super._customizeRemoteOperations.apply(this, arguments);
    const cachedExtra = options2.cachedData.extra;
    if (null !== cachedExtra && void 0 !== cachedExtra && cachedExtra.summary && !options2.isCustomLoading) {
      options2.storeLoadOptions.totalSummary = void 0;
    }
  }
  _handleDataLoadedCore(options2) {
    const groups = normalizeSortingInfo(options2.storeLoadOptions.group || options2.loadOptions.group || []);
    const remoteOperations = options2.remoteOperations || {};
    const summary = this.summaryGetter()(remoteOperations);
    if (!options2.isCustomLoading || options2.storeLoadOptions.isLoadingAll) {
      if (remoteOperations.summary) {
        if (!remoteOperations.paging && groups.length && summary) {
          if (!remoteOperations.grouping) {
            calculateAggregates(this, {
              groupAggregates: summary.groupAggregates
            }, options2.data, groups.length);
          }
          options2.data = sortGroupsBySummary(options2.data, groups, summary);
        }
      } else if (!remoteOperations.paging && summary) {
        var _options$cachedData;
        const operationTypes = options2.operationTypes || {};
        const hasOperations = Object.keys(operationTypes).some((type2) => operationTypes[type2]);
        if (!hasOperations || !(null !== (_options$cachedData = options2.cachedData) && void 0 !== _options$cachedData && null !== (_options$cachedData = _options$cachedData.extra) && void 0 !== _options$cachedData && _options$cachedData.summary) || groups.length && summary.groupAggregates.length) {
          const totalAggregates = calculateAggregates(this, summary, options2.data, groups.length);
          options2.extra = isPlainObject(options2.extra) ? options2.extra : {};
          options2.extra.summary = totalAggregates;
          if (options2.cachedData) {
            options2.cachedData.extra = options2.extra;
          }
        }
        options2.data = sortGroupsBySummary(options2.data, groups, summary);
      }
    }
    if (!options2.isCustomLoading) {
      this._totalAggregates = options2.extra && options2.extra.summary || this._totalAggregates;
    }
    super._handleDataLoadedCore(options2);
  }
};
m_data_source_adapter_default.extend(dataSourceAdapterExtender3);
var data13 = (Base) => class extends Base {
  _isDataColumn(column) {
    return column && (!isDefined(column.groupIndex) || column.showWhenGrouped);
  }
  _isGroupFooterVisible() {
    const groupItems = this.option("summary.groupItems") || [];
    for (let i = 0; i < groupItems.length; i++) {
      const groupItem = groupItems[i];
      const column = this._columnsController.columnOption(groupItem.showInColumn || groupItem.column);
      if (groupItem.showInGroupFooter && this._isDataColumn(column)) {
        return true;
      }
    }
    return false;
  }
  _processGroupItems(items, groupCount, options2) {
    const data17 = options2 && options2.data;
    const result2 = super._processGroupItems.apply(this, arguments);
    if (options2) {
      if (void 0 === options2.isGroupFooterVisible) {
        options2.isGroupFooterVisible = this._isGroupFooterVisible();
      }
      if (data17 && data17.items && options2.isGroupFooterVisible && (options2.collectContinuationItems || !data17.isContinuationOnNextPage)) {
        result2.push({
          rowType: "groupFooter",
          key: options2.path.slice(),
          data: data17,
          groupIndex: options2.path.length - 1,
          values: []
        });
      }
    }
    return result2;
  }
  _processGroupItem(groupItem, options2) {
    const that = this;
    if (!options2.summaryGroupItems) {
      options2.summaryGroupItems = that.option("summary.groupItems") || [];
    }
    if ("group" === groupItem.rowType) {
      let groupColumnIndex = -1;
      let afterGroupColumnIndex = -1;
      each(options2.visibleColumns, function(visibleIndex) {
        const prevColumn = options2.visibleColumns[visibleIndex - 1];
        if (groupItem.groupIndex === this.groupIndex) {
          groupColumnIndex = this.index;
        }
        if (visibleIndex > 0 && "expand" === prevColumn.command && "expand" !== this.command) {
          afterGroupColumnIndex = this.index;
        }
      });
      groupItem.summaryCells = this._calculateSummaryCells(options2.summaryGroupItems, getGroupAggregates(groupItem.data), options2.visibleColumns, (summaryItem, column) => {
        if (summaryItem.showInGroupFooter) {
          return -1;
        }
        if (summaryItem.alignByColumn && column && !isDefined(column.groupIndex) && column.index !== afterGroupColumnIndex) {
          return column.index;
        }
        return groupColumnIndex;
      }, true);
    }
    if ("groupFooter" === groupItem.rowType) {
      groupItem.summaryCells = this._calculateSummaryCells(options2.summaryGroupItems, getGroupAggregates(groupItem.data), options2.visibleColumns, (summaryItem, column) => summaryItem.showInGroupFooter && that._isDataColumn(column) ? column.index : -1);
    }
    return groupItem;
  }
  _calculateSummaryCells(summaryItems, aggregates, visibleColumns, calculateTargetColumnIndex, isGroupRow3) {
    const that = this;
    const summaryCells = [];
    const summaryCellsByColumns = {};
    each(summaryItems, (summaryIndex, summaryItem) => {
      const column = that._columnsController.columnOption(summaryItem.column);
      const showInColumn = summaryItem.showInColumn && that._columnsController.columnOption(summaryItem.showInColumn) || column;
      const columnIndex = calculateTargetColumnIndex(summaryItem, showInColumn);
      if (columnIndex >= 0) {
        if (!summaryCellsByColumns[columnIndex]) {
          summaryCellsByColumns[columnIndex] = [];
        }
        const aggregate = aggregates[summaryIndex];
        if (aggregate === aggregate) {
          let valueFormat;
          if (isDefined(summaryItem.valueFormat)) {
            valueFormat = summaryItem.valueFormat;
          } else if ("count" !== summaryItem.summaryType) {
            valueFormat = m_core_default.getFormatByDataType(column && column.dataType);
          }
          summaryCellsByColumns[columnIndex].push(extend({}, summaryItem, {
            value: isString(aggregate) && column && column.deserializeValue ? column.deserializeValue(aggregate) : aggregate,
            valueFormat,
            columnCaption: column && column.index !== columnIndex ? column.caption : void 0
          }));
        }
      }
    });
    if (!isEmptyObject(summaryCellsByColumns)) {
      visibleColumns.forEach((column, visibleIndex) => {
        const prevColumn = visibleColumns[visibleIndex - 1];
        const columnIndex = isGroupRow3 && ("expand" === (null === prevColumn || void 0 === prevColumn ? void 0 : prevColumn.command) || "expand" === column.command) ? null === prevColumn || void 0 === prevColumn ? void 0 : prevColumn.index : column.index;
        summaryCells.push(summaryCellsByColumns[columnIndex] || []);
      });
    }
    return summaryCells;
  }
  _getSummaryCells(summaryTotalItems, totalAggregates) {
    const that = this;
    const columnsController = that._columnsController;
    return that._calculateSummaryCells(summaryTotalItems, totalAggregates, columnsController.getVisibleColumns(), (summaryItem, column) => that._isDataColumn(column) ? column.index : -1);
  }
  _updateItemsCore(change) {
    const that = this;
    let summaryCells;
    const dataSource = that._dataSource;
    const footerItems = that._footerItems;
    const oldSummaryCells = footerItems && footerItems[0] && footerItems[0].summaryCells;
    const summaryTotalItems = that.option("summary.totalItems");
    that._footerItems = [];
    if (dataSource && summaryTotalItems && summaryTotalItems.length) {
      const totalAggregates = dataSource.totalAggregates();
      summaryCells = that._getSummaryCells(summaryTotalItems, totalAggregates);
      if (change && change.repaintChangesOnly && oldSummaryCells) {
        change.totalColumnIndices = summaryCells.map((summaryCell, index2) => {
          if (JSON.stringify(summaryCell) !== JSON.stringify(oldSummaryCells[index2])) {
            return index2;
          }
          return -1;
        }).filter((index2) => index2 >= 0);
      }
      if (summaryCells.length) {
        that._footerItems.push({
          rowType: "totalFooter",
          summaryCells
        });
      }
    }
    super._updateItemsCore(change);
  }
  _prepareUnsavedDataSelector(selector) {
    if (recalculateWhileEditing(this)) {
      const editingController = this._editingController;
      if (editingController) {
        return function(data17) {
          data17 = editingController.getUpdatedData(data17);
          return selector(data17);
        };
      }
    }
    return selector;
  }
  _prepareAggregateSelector(selector, aggregator) {
    selector = this._prepareUnsavedDataSelector(selector);
    if ("avg" === aggregator || "sum" === aggregator) {
      return function(data17) {
        const value2 = selector(data17);
        return isDefined(value2) ? Number(value2) : value2;
      };
    }
    return selector;
  }
  _getAggregates(summaryItems, remoteOperations) {
    const that = this;
    let calculateCustomSummary = that.option("summary.calculateCustomSummary");
    const commonSkipEmptyValues = that.option("summary.skipEmptyValues");
    return map(summaryItems || [], (summaryItem) => {
      const column = this._columnsController.columnOption(summaryItem.column);
      const calculateCellValue = column && column.calculateCellValue ? column.calculateCellValue.bind(column) : compileGetter(column ? column.dataField : summaryItem.column);
      let aggregator = summaryItem.summaryType || "count";
      const skipEmptyValues = isDefined(summaryItem.skipEmptyValues) ? summaryItem.skipEmptyValues : commonSkipEmptyValues;
      if (remoteOperations) {
        return {
          selector: summaryItem.column,
          summaryType: aggregator
        };
      }
      const selector = that._prepareAggregateSelector(calculateCellValue, aggregator);
      if ("custom" === aggregator) {
        if (!calculateCustomSummary) {
          ui_errors_default.log("E1026");
          calculateCustomSummary = function() {
          };
        }
        const options2 = {
          component: that.component,
          name: summaryItem.name
        };
        calculateCustomSummary(options2);
        options2.summaryProcess = "calculate";
        aggregator = {
          seed(groupIndex) {
            options2.summaryProcess = "start";
            options2.totalValue = void 0;
            options2.groupIndex = groupIndex;
            delete options2.value;
            calculateCustomSummary(options2);
            return options2.totalValue;
          },
          step(totalValue, value2) {
            options2.summaryProcess = "calculate";
            options2.totalValue = totalValue;
            options2.value = value2;
            calculateCustomSummary(options2);
            return options2.totalValue;
          },
          finalize(totalValue) {
            options2.summaryProcess = "finalize";
            options2.totalValue = totalValue;
            delete options2.value;
            calculateCustomSummary(options2);
            return options2.totalValue;
          }
        };
      }
      return {
        selector,
        aggregator,
        skipEmptyValues
      };
    });
  }
  _addSortInfo(sortByGroups, groupColumn, selector, sortOrder) {
    if (groupColumn) {
      const {
        groupIndex
      } = groupColumn;
      sortOrder = sortOrder || groupColumn.sortOrder;
      if (isDefined(groupIndex)) {
        sortByGroups[groupIndex] = sortByGroups[groupIndex] || [];
        sortByGroups[groupIndex].push({
          selector,
          desc: "desc" === sortOrder
        });
      }
    }
  }
  _findSummaryItem(summaryItems, name2) {
    let summaryItemIndex = -1;
    if (isDefined(name2)) {
      each(summaryItems || [], function(index2) {
        if (this.name === name2 || index2 === name2 || this.summaryType === name2 || this.column === name2 || function(summaryItem) {
          const {
            summaryType
          } = summaryItem;
          const {
            column
          } = summaryItem;
          return summaryType && column && `${summaryType}_${column}`;
        }(this) === name2) {
          summaryItemIndex = index2;
          return false;
        }
      });
    }
    return summaryItemIndex;
  }
  _getSummarySortByGroups(sortByGroupSummaryInfo, groupSummaryItems) {
    const that = this;
    const columnsController = that._columnsController;
    const groupColumns = columnsController.getGroupColumns();
    const sortByGroups = [];
    if (!groupSummaryItems || !groupSummaryItems.length) {
      return;
    }
    each(sortByGroupSummaryInfo || [], function() {
      const {
        sortOrder
      } = this;
      let {
        groupColumn
      } = this;
      const summaryItemIndex = that._findSummaryItem(groupSummaryItems, this.summaryItem);
      if (summaryItemIndex < 0) {
        return;
      }
      const selector = function(data17) {
        return getGroupAggregates(data17)[summaryItemIndex];
      };
      if (isDefined(groupColumn)) {
        groupColumn = columnsController.columnOption(groupColumn);
        that._addSortInfo(sortByGroups, groupColumn, selector, sortOrder);
      } else {
        each(groupColumns, (groupIndex, groupColumn2) => {
          that._addSortInfo(sortByGroups, groupColumn2, selector, sortOrder);
        });
      }
    });
    return sortByGroups;
  }
  _createDataSourceAdapterCore(dataSource, remoteOperations) {
    const that = this;
    const dataSourceAdapter = super._createDataSourceAdapterCore(dataSource, remoteOperations);
    dataSourceAdapter.summaryGetter((currentRemoteOperations) => that._getSummaryOptions(currentRemoteOperations || remoteOperations));
    return dataSourceAdapter;
  }
  _getSummaryOptions(remoteOperations) {
    const that = this;
    const groupSummaryItems = that.option("summary.groupItems");
    const totalSummaryItems = that.option("summary.totalItems");
    const sortByGroupSummaryInfo = that.option("sortByGroupSummaryInfo");
    const groupAggregates = that._getAggregates(groupSummaryItems, remoteOperations && remoteOperations.grouping && remoteOperations.summary);
    const totalAggregates = that._getAggregates(totalSummaryItems, remoteOperations && remoteOperations.summary);
    const sortByGroups = function() {
      return that._getSummarySortByGroups(sortByGroupSummaryInfo, groupSummaryItems);
    };
    if (groupAggregates.length || totalAggregates.length) {
      return {
        groupAggregates,
        totalAggregates,
        sortByGroups
      };
    }
    return;
  }
  publicMethods() {
    const methods = super.publicMethods();
    methods.push("getTotalSummaryValue");
    return methods;
  }
  getTotalSummaryValue(summaryItemName) {
    const summaryItemIndex = this._findSummaryItem(this.option("summary.totalItems"), summaryItemName);
    const aggregates = this._dataSource.totalAggregates();
    if (aggregates.length && summaryItemIndex > -1) {
      return aggregates[summaryItemIndex];
    }
  }
  optionChanged(args) {
    if ("summary" === args.name || "sortByGroupSummaryInfo" === args.name) {
      args.name = "dataSource";
    }
    super.optionChanged(args);
  }
  init() {
    this._footerItems = [];
    super.init();
  }
  footerItems() {
    return this._footerItems;
  }
};
var editing3 = (Base) => class extends Base {
  _refreshSummary() {
    if (recalculateWhileEditing(this) && !this.isSaving()) {
      this._dataController.refresh({
        load: true,
        changesOnly: true
      });
    }
  }
  _addChange(params) {
    const result2 = super._addChange.apply(this, arguments);
    if (params.type) {
      this._refreshSummary();
    }
    return result2;
  }
  _removeChange() {
    const result2 = super._removeChange.apply(this, arguments);
    this._refreshSummary();
    return result2;
  }
  cancelEditData() {
    const result2 = super.cancelEditData.apply(this, arguments);
    this._refreshSummary();
    return result2;
  }
};
var rowsView11 = (Base) => class extends Base {
  _createRow(row) {
    const $row = super._createRow.apply(this, arguments);
    row && $row.addClass("groupFooter" === row.rowType ? "dx-datagrid-group-footer" : "");
    return $row;
  }
  _renderCells($row, options2) {
    super._renderCells.apply(this, arguments);
    if ("group" === options2.row.rowType && options2.row.summaryCells && options2.row.summaryCells.length) {
      this._renderGroupSummaryCells($row, options2);
    }
  }
  _hasAlignByColumnSummaryItems(columnIndex, options2) {
    return !isDefined(options2.columns[columnIndex].groupIndex) && options2.row.summaryCells[columnIndex].length;
  }
  _getAlignByColumnCellCount(groupCellColSpan, options2) {
    let alignByColumnCellCount = 0;
    for (let i = 1; i < groupCellColSpan; i++) {
      const columnIndex = options2.row.summaryCells.length - i;
      alignByColumnCellCount = this._hasAlignByColumnSummaryItems(columnIndex, options2) ? i : alignByColumnCellCount;
    }
    return alignByColumnCellCount;
  }
  _renderGroupSummaryCells($row, options2) {
    const $groupCell = $row.children().last();
    const groupCellColSpan = Number($groupCell.attr("colSpan")) || 1;
    const alignByColumnCellCount = this._getAlignByColumnCellCount(groupCellColSpan, options2);
    this._renderGroupSummaryCellsCore($groupCell, options2, groupCellColSpan, alignByColumnCellCount);
  }
  _renderGroupSummaryCellsCore($groupCell, options2, groupCellColSpan, alignByColumnCellCount) {
    if (alignByColumnCellCount > 0) {
      $groupCell.attr("colSpan", groupCellColSpan - alignByColumnCellCount);
      for (let i = 0; i < alignByColumnCellCount; i++) {
        const columnIndex = options2.columns.length - alignByColumnCellCount + i;
        this._renderCell($groupCell.parent(), extend({
          column: options2.columns[columnIndex],
          columnIndex: this._getSummaryCellIndex(columnIndex, options2.columns)
        }, options2));
      }
    }
  }
  _getSummaryCellIndex(columnIndex, columns7) {
    return columnIndex;
  }
  _getCellTemplate(options2) {
    if (!options2.column.command && !isDefined(options2.column.groupIndex) && options2.summaryItems && options2.summaryItems.length) {
      return renderSummaryCell;
    }
    return super._getCellTemplate(options2);
  }
  _getCellOptions(options2) {
    const that = this;
    const parameters = super._getCellOptions(options2);
    if (options2.row.summaryCells) {
      return extend(parameters, getSummaryCellOptions(that, options2));
    }
    return parameters;
  }
};
m_core_default.registerModule("summary", {
  defaultOptions: () => ({
    summary: {
      groupItems: void 0,
      totalItems: void 0,
      calculateCustomSummary: void 0,
      skipEmptyValues: true,
      recalculateWhileEditing: false,
      texts: {
        sum: message_default.format("dxDataGrid-summarySum"),
        sumOtherColumn: message_default.format("dxDataGrid-summarySumOtherColumn"),
        min: message_default.format("dxDataGrid-summaryMin"),
        minOtherColumn: message_default.format("dxDataGrid-summaryMinOtherColumn"),
        max: message_default.format("dxDataGrid-summaryMax"),
        maxOtherColumn: message_default.format("dxDataGrid-summaryMaxOtherColumn"),
        avg: message_default.format("dxDataGrid-summaryAvg"),
        avgOtherColumn: message_default.format("dxDataGrid-summaryAvgOtherColumn"),
        count: message_default.format("dxDataGrid-summaryCount")
      }
    },
    sortByGroupSummaryInfo: void 0
  }),
  views: {
    footerView: FooterView
  },
  extenders: {
    controllers: {
      data: data13,
      editing: editing3
    },
    views: {
      rowsView: rowsView11
    }
  }
});

// node_modules/devextreme/esm/__internal/grids/grid_core/master_detail/const.js
var CLASSES6 = {
  detailRow: "dx-master-detail-row"
};

// node_modules/devextreme/esm/__internal/grids/grid_core/sticky_columns/m_sticky_columns.js
var baseStickyColumns = (Base) => class extends Base {
  _addStickyColumnBorderLeftClass($cell, column, rowIndex) {
    let onlyWithinBandColumn = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : false;
    let fixedPosition = arguments.length > 4 ? arguments[4] : void 0;
    const isFirstFixedCell = isFirstFixedColumn(this._columnsController, column, rowIndex, onlyWithinBandColumn, fixedPosition);
    if (isFirstFixedCell) {
      GridCoreStickyColumnsDom.addStickyColumnBorderLeftClass($cell, this.addWidgetPrefix.bind(this));
    }
  }
  _addStickyColumnBorderRightClass($cell, column, rowIndex) {
    let onlyWithinBandColumn = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : false;
    let fixedPosition = arguments.length > 4 ? arguments[4] : void 0;
    const isLastFixedCell = isLastFixedColumn(this._columnsController, column, rowIndex, onlyWithinBandColumn, fixedPosition);
    if (isLastFixedCell) {
      GridCoreStickyColumnsDom.addStickyColumnBorderRightClass($cell, this.addWidgetPrefix.bind(this));
    }
  }
  updateBorderCellClasses($cell, column, rowIndex) {
    const columnsController = this._columnsController;
    const isRowsView = "rowsView" === this.name;
    const needToRemoveBorder = needToRemoveColumnBorder(columnsController, column, rowIndex, isRowsView);
    const isFirstColumn = null === columnsController || void 0 === columnsController ? void 0 : columnsController.isFirstColumn(column, rowIndex);
    GridCoreStickyColumnsDom.toggleColumnNoBorderClass($cell, needToRemoveBorder, this.addWidgetPrefix.bind(this));
    GridCoreStickyColumnsDom.toggleFirstHeaderClass($cell, isFirstColumn, this.addWidgetPrefix.bind(this));
  }
  _updateBorderClasses() {
    const isColumnHeadersView = "columnHeadersView" === this.name;
    const $rows = this._getRowElementsCore().not(`.${CLASSES6.detailRow}`).toArray();
    $rows.forEach((row, index2) => {
      const rowIndex = isColumnHeadersView ? index2 : null;
      const $cells = renderer_default(row).children("td").toArray();
      let columns7 = this.getColumns(rowIndex);
      columns7 = processFixedColumns(this._columnsController, columns7);
      $cells.forEach((cell, cellIndex) => {
        const $cell = renderer_default(cell);
        const column = columns7[cellIndex];
        if (column.visibleWidth !== HIDDEN_COLUMNS_WIDTH) {
          this.updateBorderCellClasses($cell, column, rowIndex);
        }
      });
    });
  }
  _renderCore(options2) {
    const deferred = super._renderCore(options2);
    const $element = this.element();
    const hasStickyColumns = this.hasStickyColumns();
    GridCoreStickyColumnsDom.toggleStickyColumnsClass($element, hasStickyColumns, this.addWidgetPrefix.bind(this));
    if (hasStickyColumns) {
      return deferred.done(() => {
        this.setStickyOffsets();
      });
    }
    return deferred;
  }
  _createCell(options2) {
    const {
      column
    } = options2;
    const {
      rowType
    } = options2;
    const $cell = super._createCell(options2);
    const hasStickyColumns = this.hasStickyColumns();
    const rowIndex = "header" === rowType ? options2.rowIndex : null;
    const isSummary = "groupFooter" === rowType || "totalFooter" === rowType || "group" === rowType;
    const isExpandColumn = column.command && "expand" === column.command;
    if (hasStickyColumns && !needToDisableStickyColumn(this._columnsController, column)) {
      this.updateBorderCellClasses($cell, column, rowIndex);
      if (column.fixed) {
        const fixedPosition = getColumnFixedPosition(this._columnsController, column);
        GridCoreStickyColumnsDom.addStickyColumnClass($cell, fixedPosition, this.addWidgetPrefix.bind(this));
        if (!isSummary && !isExpandColumn) {
          switch (fixedPosition) {
            case StickyPosition.Right:
              this._addStickyColumnBorderLeftClass($cell, column, rowIndex, false, StickyPosition.Right);
              break;
            case StickyPosition.Sticky:
              this._addStickyColumnBorderLeftClass($cell, column, rowIndex, true);
              this._addStickyColumnBorderRightClass($cell, column, rowIndex, true);
              break;
            default:
              this._addStickyColumnBorderRightClass($cell, column, rowIndex, false, StickyPosition.Left);
          }
        }
      }
    }
    return $cell;
  }
  setStickyOffsets(rowIndex, offsets) {
    const columnsController = this._columnsController;
    const rtlEnabled = this.option("rtlEnabled");
    const showColumnHeaders = this.option("showColumnHeaders");
    let widths = this.getColumnWidths(void 0, rowIndex);
    let columns7 = this.getColumns(showColumnHeaders ? rowIndex : void 0);
    columns7 = processFixedColumns(this._columnsController, columns7);
    if (rtlEnabled) {
      columns7 = rtlEnabled ? [...columns7].reverse() : columns7;
      widths = rtlEnabled ? [...widths].reverse() : widths;
    }
    columns7.forEach((column, columnIndex) => {
      if (column.fixed) {
        const visibleColumnIndex = rtlEnabled ? columns7.length - columnIndex - 1 : columnIndex;
        const offset2 = getStickyOffset(columnsController, columns7, widths, columnIndex, offsets);
        if (offsets) {
          offsets[column.index] = offset2;
        }
        const styleProps = normalizeOffset2(offset2);
        this.setCellProperties(styleProps, visibleColumnIndex, rowIndex);
      }
    });
  }
  setColumnWidths(options2) {
    const hasStickyColumns = this.hasStickyColumns();
    const columnsResizerController = this.getController("columnsResizer");
    const isColumnResizing = null === columnsResizerController || void 0 === columnsResizerController ? void 0 : columnsResizerController.isResizing();
    super.setColumnWidths(options2);
    if (hasStickyColumns && isColumnResizing) {
      this.setStickyOffsets();
    }
  }
  _resizeCore() {
    const hasStickyColumns = this.hasStickyColumns();
    const adaptiveColumns2 = this.getController("adaptiveColumns");
    const hidingColumnsQueue = null === adaptiveColumns2 || void 0 === adaptiveColumns2 ? void 0 : adaptiveColumns2.getHidingColumnsQueue();
    super._resizeCore.apply(this, arguments);
    if (hasStickyColumns) {
      this.setStickyOffsets();
      if (null !== hidingColumnsQueue && void 0 !== hidingColumnsQueue && hidingColumnsQueue.length) {
        this._updateBorderClasses();
      }
    }
  }
  hasStickyColumns() {
    var _this$_columnsControl;
    const stickyColumns = null === (_this$_columnsControl = this._columnsController) || void 0 === _this$_columnsControl ? void 0 : _this$_columnsControl.getStickyColumns();
    return true !== this.option("columnFixing.legacyMode") && !!stickyColumns.length;
  }
};
var columnHeadersView7 = (Base) => class extends baseStickyColumns(Base) {
  setStickyOffsets() {
    const offsets = {};
    const rows = this._getRows();
    for (let rowIndex = 0; rowIndex < rows.length; rowIndex++) {
      var _rows$rowIndex;
      const isFilterRow = "filter" === (null === rows || void 0 === rows || null === (_rows$rowIndex = rows[rowIndex]) || void 0 === _rows$rowIndex ? void 0 : _rows$rowIndex.rowType);
      super.setStickyOffsets(rowIndex, isFilterRow ? void 0 : offsets);
    }
  }
  getContextMenuItems(options2) {
    const {
      column
    } = options2;
    const columnsController = this._columnsController;
    const columnFixingOptions = this.option("columnFixing");
    let items = super.getContextMenuItems(options2);
    if (options2.row && "header" === options2.row.rowType) {
      if (true === columnFixingOptions.enabled && column && column.allowFixing) {
        const onItemClick = (params) => {
          switch (params.itemData.value) {
            case "none":
              this._columnsController.columnOption(column.index, "fixed", false);
              break;
            case "left":
              this._columnsController.columnOption(column.index, {
                fixed: true,
                fixedPosition: "left"
              });
              break;
            case "right":
              this._columnsController.columnOption(column.index, {
                fixed: true,
                fixedPosition: "right"
              });
              break;
            case "sticky":
              this._columnsController.columnOption(column.index, {
                fixed: true,
                fixedPosition: "sticky"
              });
          }
        };
        const fixedPositionItems = [{
          text: columnFixingOptions.texts.leftPosition,
          icon: columnFixingOptions.icons.leftPosition,
          value: "left",
          disabled: column.fixed && (!column.fixedPosition || "left" === column.fixedPosition),
          onItemClick
        }, {
          text: columnFixingOptions.texts.rightPosition,
          icon: columnFixingOptions.icons.rightPosition,
          value: "right",
          disabled: column.fixed && "right" === column.fixedPosition,
          onItemClick
        }];
        if (true !== this.option("columnFixing.legacyMode") && !columnsController.isVirtualMode()) {
          fixedPositionItems.push({
            text: columnFixingOptions.texts.stickyPosition,
            icon: columnFixingOptions.icons.stickyPosition,
            value: "sticky",
            disabled: column.fixed && column.fixedPosition === StickyPosition.Sticky,
            onItemClick
          });
        }
        items = items || [];
        items.push({
          text: columnFixingOptions.texts.fix,
          icon: columnFixingOptions.icons.fix,
          beginGroup: true,
          items: fixedPositionItems
        }, {
          text: columnFixingOptions.texts.unfix,
          icon: columnFixingOptions.icons.unfix,
          value: "none",
          disabled: !column.fixed,
          onItemClick
        });
      }
    }
    return items;
  }
};
var rowsView12 = (Base) => class extends baseStickyColumns(Base) {
  _getMasterDetailWidth() {
    const componentWidth = getWidth(this.component.$element()) ?? 0;
    const borderWidth = m_utils_default.getComponentBorderWidth(this, this._$element);
    return componentWidth - borderWidth - this.getScrollbarWidth();
  }
  _renderMasterDetailCell($row, row, options2) {
    const $detailCell = super._renderMasterDetailCell($row, row, options2);
    if (this.hasStickyColumns()) {
      $detailCell.addClass(this.addWidgetPrefix(CLASSES3.stickyColumnLeft));
      setWidth($detailCell, this._getMasterDetailWidth());
    }
    return $detailCell;
  }
  _updateMasterDetailWidths() {
    const width = this._getMasterDetailWidth();
    const $masterDetailCells = this._getRowElements().children(".dx-master-detail-cell");
    setWidth($masterDetailCells, `${width}px`);
  }
  setStickyOffsets(rowIndex, offsets) {
    super.setStickyOffsets(rowIndex, offsets);
    this.setStickyOffsetsForGroupCells();
  }
  setStickyOffsetsForGroupCells() {
    const groupColumns = this._columnsController.getGroupColumns();
    let columns7 = this.getColumns();
    let widths = this.getColumnWidths();
    const columnsCountBeforeGroups = this._getColumnsCountBeforeGroups(columns7);
    const rtlEnabled = this.option("rtlEnabled");
    if (rtlEnabled) {
      columns7 = rtlEnabled ? [...columns7].reverse() : columns7;
      widths = rtlEnabled ? [...widths].reverse() : widths;
    }
    const $tableElement = this.getTableElement();
    groupColumns.forEach((column) => {
      const columnIndex = columnsCountBeforeGroups + column.groupIndex + 1;
      const visibleColumnIndex = rtlEnabled ? columns7.length - columnIndex - 1 : columnIndex;
      const offset2 = getStickyOffset(this._columnsController, columns7, widths, visibleColumnIndex);
      const styleProps = normalizeOffset2(offset2);
      const $cells = $tableElement.children().children(".dx-group-row").find(`.dx-group-cell[aria-colindex='${columnIndex + 1}']`);
      for (let i = 0; i < $cells.length; i += 1) {
        const cell = $cells.get(i);
        const container = renderer_default(cell).find(".dx-datagrid-group-row-container").get(0);
        Object.assign(cell.style, styleProps);
        Object.assign(container.style, styleProps);
      }
    });
  }
  _resizeCore() {
    const hasStickyColumns = this.hasStickyColumns();
    super._resizeCore.apply(this, arguments);
    if (hasStickyColumns) {
      this._updateMasterDetailWidths();
    }
  }
  _renderCellContent($cell, options2, renderOptions) {
    if (!isGroupRow(options2) || !this.hasStickyColumns()) {
      return super._renderCellContent($cell, options2, renderOptions);
    }
    const $container = renderer_default("<div>").addClass(this.addWidgetPrefix(CLASSES3.groupRowContainer)).appendTo($cell);
    return super._renderCellContent($container, options2, renderOptions);
  }
  _renderGroupSummaryCellsCore($groupCell, options2, groupCellColSpan, alignByColumnCellCount) {
    super._renderGroupSummaryCellsCore($groupCell, options2, groupCellColSpan, alignByColumnCellCount);
    const stickySummarySelector = `.${this.addWidgetPrefix(CLASSES3.stickyColumn)}`;
    if ($groupCell.parent().find(stickySummarySelector).length && GridCoreStickyColumnsDom.doesGroupCellEndInFirstColumn($groupCell)) {
      GridCoreStickyColumnsDom.addStickyColumnBorderRightClass($groupCell, this.addWidgetPrefix.bind(this));
    }
  }
  _handleScroll(e) {
    const hasStickyColumns = this.hasStickyColumns();
    super._handleScroll(e);
    if (hasStickyColumns) {
      const editorFactoryController = this.getController("editorFactory");
      const hasOverlayElements = editorFactoryController.hasOverlayElements();
      if (hasOverlayElements) {
        const $focusedElement = editorFactoryController.focus();
        editorFactoryController.focus($focusedElement);
      }
    }
  }
  _scrollToElement($element, offset2) {
    let scrollOffset = offset2;
    const scrollable = this.getScrollable();
    const hasStickyColumns = this.hasStickyColumns();
    if (hasStickyColumns && scrollable) {
      const isFixedCell2 = GridCoreStickyColumnsDom.isFixedCell($element, this.addWidgetPrefix.bind(this));
      if (!$element.is("td") || isFixedCell2) {
        return;
      }
      const $row = null === $element || void 0 === $element ? void 0 : $element.closest("tr");
      const $cells = null === $row || void 0 === $row ? void 0 : $row.children();
      scrollOffset = GridCoreStickyColumnsDom.getScrollPadding($cells, renderer_default(scrollable.container()), this.addWidgetPrefix.bind(this));
    }
    super._scrollToElement($element, scrollOffset);
  }
};
var footerView = (Base) => class extends baseStickyColumns(Base) {
};
var columnsResizer2 = (Base) => class extends Base {
  getSeparatorOffsetX($cell) {
    var _this$_columnHeadersV;
    const hasStickyColumns = null === (_this$_columnHeadersV = this._columnHeadersView) || void 0 === _this$_columnHeadersV ? void 0 : _this$_columnHeadersV.hasStickyColumns();
    if (hasStickyColumns) {
      const $container = renderer_default(this._columnHeadersView.getContent());
      const isFixedCellPinnedToRight2 = GridCoreStickyColumnsDom.isFixedCellPinnedToRight($cell, $container, this.addWidgetPrefix.bind(this));
      const isWidgetResizingMode = "widget" === this.option("columnResizingMode");
      if (isWidgetResizingMode && isFixedCellPinnedToRight2) {
        var _$cell$offset;
        return (null === (_$cell$offset = $cell.offset()) || void 0 === _$cell$offset ? void 0 : _$cell$offset.left) ?? 0;
      }
    }
    return super.getSeparatorOffsetX($cell);
  }
  _correctColumnIndexForPoint(point, correctionValue, columns7) {
    const rtlEnabled = this.option("rtlEnabled");
    const isWidgetResizingMode = "widget" === this.option("columnResizingMode");
    const columnIndex = Math.max(point.index - 1, 0);
    const column = columns7[columnIndex];
    const nextColumnIndex = this._getNextColumnIndex(columnIndex);
    const nextColumn = columns7[nextColumnIndex];
    if (isWidgetResizingMode && !isFixedEdge(point, column, nextColumn)) {
      const $container = renderer_default(this._columnHeadersView.getContent());
      const isFixedCellPinnedToRight2 = GridCoreStickyColumnsDom.isFixedCellPinnedToRight(renderer_default(point.item), $container, this.addWidgetPrefix.bind(this));
      if (isFixedCellPinnedToRight2) {
        point.columnIndex -= rtlEnabled ? 1 : 0;
        return;
      }
    }
    super._correctColumnIndexForPoint(point, correctionValue, columns7);
  }
  _needToInvertResizing($cell) {
    const result2 = super._needToInvertResizing($cell);
    const isWidgetResizingMode = "widget" === this.option("columnResizingMode");
    if (!result2 && isWidgetResizingMode) {
      const $container = renderer_default(this._columnHeadersView.getContent());
      return GridCoreStickyColumnsDom.isFixedCellPinnedToRight($cell, $container, this.addWidgetPrefix.bind(this));
    }
    return result2;
  }
  _generatePointsByColumns() {
    var _this$_columnHeadersV2;
    const hasStickyColumns = null === (_this$_columnHeadersV2 = this._columnHeadersView) || void 0 === _this$_columnHeadersV2 ? void 0 : _this$_columnHeadersV2.hasStickyColumns();
    super._generatePointsByColumns(hasStickyColumns);
  }
  _pointCreated(point, cellsLength, columns7) {
    var _this$_columnHeadersV3;
    const hasStickyColumns = null === (_this$_columnHeadersV3 = this._columnHeadersView) || void 0 === _this$_columnHeadersV3 ? void 0 : _this$_columnHeadersV3.hasStickyColumns();
    const result2 = super._pointCreated(point, cellsLength, columns7);
    const needToCheckPoint = hasStickyColumns && cellsLength > 0;
    if (needToCheckPoint && !result2) {
      const column = columns7[point.index - 1];
      const nextColumnIndex = this._getNextColumnIndex(point.index - 1);
      const nextColumn = columns7[nextColumnIndex];
      return GridCoreStickyColumnsDom.noNeedToCreateResizingPoint(this._columnHeadersView, {
        point,
        column,
        nextColumn
      }, this.addWidgetPrefix.bind(this));
    }
    return result2;
  }
};
var draggingHeader = (Base) => class extends Base {
  _generatePointsByColumns(options2) {
    var _this$_columnHeadersV4;
    const hasStickyColumns = null === (_this$_columnHeadersV4 = this._columnHeadersView) || void 0 === _this$_columnHeadersV4 ? void 0 : _this$_columnHeadersV4.hasStickyColumns();
    const {
      sourceLocation,
      sourceColumn,
      targetDraggingPanel
    } = options2;
    const isDraggingBetweenHeaders = "headers" === sourceLocation && "headers" === (null === targetDraggingPanel || void 0 === targetDraggingPanel ? void 0 : targetDraggingPanel.getName());
    if (hasStickyColumns && isDraggingBetweenHeaders) {
      const columnFixedPosition = getColumnFixedPosition(this._columnsController, sourceColumn);
      switch (true) {
        case (sourceColumn.fixed && columnFixedPosition === StickyPosition.Left):
          options2.columnElements = GridCoreStickyColumnsDom.getLeftFixedCells(options2.columnElements, this.addWidgetPrefix.bind(this));
          options2.startColumnIndex = options2.columnElements.eq(0).index();
          break;
        case (sourceColumn.fixed && columnFixedPosition === StickyPosition.Right):
          options2.columnElements = GridCoreStickyColumnsDom.getRightFixedCells(options2.columnElements, this.addWidgetPrefix.bind(this));
          options2.startColumnIndex = options2.columnElements.eq(0).index();
          break;
        default:
          options2.columnElements = GridCoreStickyColumnsDom.getNonFixedAndStickyCells(options2.columnElements, this.addWidgetPrefix.bind(this));
          options2.startColumnIndex = options2.columnElements.eq(0).index();
      }
    }
    return super._generatePointsByColumns(options2, hasStickyColumns);
  }
  _pointCreated(point, columns7, location, sourceColumn) {
    const hasStickyColumns = this._columnHeadersView.hasStickyColumns();
    const $cells = this._columnHeadersView.getColumnElements();
    const needToCheckPoint = hasStickyColumns && "headers" === location && (null === $cells || void 0 === $cells ? void 0 : $cells.length) && (!sourceColumn.fixed || sourceColumn.fixedPosition === StickyPosition.Sticky);
    const result2 = super._pointCreated(point, columns7, location, sourceColumn);
    if (needToCheckPoint && !result2) {
      return GridCoreStickyColumnsDom.noNeedToCreateReorderingPoint(point, $cells, renderer_default(this._columnHeadersView.getContent()), this.addWidgetPrefix.bind(this));
    }
    return result2;
  }
};
var editorFactory2 = (Base) => class extends Base {
  getOverlayContainerIfNeeded($cell) {
    const hasFixedColumns = this._rowsView.hasStickyColumns();
    const isFixedCell2 = GridCoreStickyColumnsDom.isFixedCell($cell, this.addWidgetPrefix.bind(this));
    if (hasFixedColumns && isFixedCell2) {
      return $cell.closest(`.${this.addWidgetPrefix(CLASSES3.stickyColumns)}`);
    }
    return;
  }
  updateFocusOverlaySize($element, position3) {
    const hasFixedColumns = this._rowsView.hasStickyColumns();
    if (!hasFixedColumns) {
      super.updateFocusOverlaySize($element, position3);
    }
  }
  getFocusOverlaySize($element) {
    const hasFixedColumns = this._rowsView.hasStickyColumns();
    if (hasFixedColumns) {
      const elementRect = getBoundingRect($element.get(0));
      const isLastCell2 = GridCoreStickyColumnsDom.isLastCell($element);
      const isFixedCell2 = GridCoreStickyColumnsDom.isFixedCell($element, this.addWidgetPrefix.bind(this));
      return {
        width: elementRect.right - elementRect.left + (isLastCell2 || isFixedCell2 ? 0 : 1),
        height: elementRect.bottom - elementRect.top
      };
    }
    return super.getFocusOverlaySize($element);
  }
  getValidationMessageContainer($cell) {
    return this.getOverlayContainerIfNeeded($cell) ?? super.getValidationMessageContainer($cell);
  }
  getRevertButtonContainer($cell) {
    return this.getOverlayContainerIfNeeded($cell) ?? super.getRevertButtonContainer($cell);
  }
  getFocusOverlayContainer($focusedElement) {
    return this.getOverlayContainerIfNeeded($focusedElement) ?? super.getFocusOverlayContainer($focusedElement);
  }
  overlayPositionedHandler(e, isOverlayVisible) {
    const columnHeaders = this.getView("columnHeadersView");
    const hasStickyColumns = columnHeaders.hasStickyColumns();
    super.overlayPositionedHandler(e, isOverlayVisible);
    if (hasStickyColumns) {
      const $cell = renderer_default(e.element).closest("td");
      if (!GridCoreStickyColumnsDom.isFixedCell($cell, this.addWidgetPrefix.bind(this))) {
        const $wrapper = e.component.$wrapper();
        const $overlayContent = e.component.$content();
        const isOutsideVisibleArea2 = GridCoreStickyColumnsDom.isOutsideVisibleArea($overlayContent, renderer_default(columnHeaders.getColumnElements()), renderer_default(columnHeaders.getContent()), this.addWidgetPrefix.bind(this));
        $wrapper.css("zIndex", isOutsideVisibleArea2 ? 1 : (null === this || void 0 === this ? void 0 : this.getOverlayBaseZIndex()) ?? 0);
      }
    }
  }
  updateFocusOverlay($element) {
    let isHideBorder = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : false;
    if (!isHideBorder) {
      const isFixedCell2 = GridCoreStickyColumnsDom.isFixedCell($element, this.addWidgetPrefix.bind(this));
      this._$focusOverlay.toggleClass(CLASSES3.focusedFixedElement, isFixedCell2);
      const isGroupElement = isGroupRow2($element);
      const isGroupFooterRowElement = isGroupFooterRow($element);
      const isAdaptiveElement = isAdaptiveItem($element);
      if (isFixedCell2 || isGroupElement || isGroupFooterRowElement || isAdaptiveElement) {
        this._$focusOverlay.toggleClass(CLASSES3.focusedFixedElement, true);
      }
    }
    super.updateFocusOverlay($element, isHideBorder);
  }
};
var resizing4 = (Base) => class extends Base {
  resize() {
    const result2 = super.resize();
    const hasStickyColumns = this._columnHeadersView.hasStickyColumns();
    if (hasStickyColumns && null !== this && void 0 !== this && this.hasResizeTimeout()) {
      this._rowsView.setStickyOffsets();
    }
    return result2;
  }
};
var headersKeyboardNavigation2 = (Base) => class extends Base {
  getContainerBoundingRect($container) {
    var _this$_columnHeadersV5;
    const hasStickyColumns = null === (_this$_columnHeadersV5 = this._columnHeadersView) || void 0 === _this$_columnHeadersV5 ? void 0 : _this$_columnHeadersV5.hasStickyColumns();
    if (hasStickyColumns) {
      const $cells = renderer_default(this._columnHeadersView.getColumnElements());
      return GridCoreStickyColumnsDom.getNonFixedAreaBoundingRect($cells, $container, this.addWidgetPrefix.bind(this));
    }
    return super.getContainerBoundingRect($container);
  }
  tabKeyHandler(_ref) {
    var _this$_columnHeadersV6, _this$getView;
    let {
      originalEvent,
      shift
    } = _ref;
    const hasStickyColumns = null === (_this$_columnHeadersV6 = this._columnHeadersView) || void 0 === _this$_columnHeadersV6 ? void 0 : _this$_columnHeadersV6.hasStickyColumns();
    const scrollable = null === (_this$getView = this.getView("rowsView")) || void 0 === _this$getView ? void 0 : _this$getView.getScrollable();
    if (!hasStickyColumns || !scrollable) {
      return;
    }
    const $cell = renderer_default(originalEvent.target).closest("td");
    const $nextCell = GridCoreStickyColumnsDom.getNextHeaderCell($cell, shift ? "previous" : "next");
    const isFixedCell2 = GridCoreStickyColumnsDom.isFixedCell($nextCell, this.addWidgetPrefix.bind(this));
    if (isFixedCell2) {
      return;
    }
    const nextCellIsOutsideVisibleArea = $nextCell.length && this.isOutsideVisibleArea($nextCell, renderer_default(this._columnHeadersView.getContent()));
    if (nextCellIsOutsideVisibleArea) {
      this.scrollToColumn($nextCell);
    }
  }
};
var stickyColumnsModule = {
  extenders: {
    views: {
      columnHeadersView: columnHeadersView7,
      rowsView: rowsView12,
      footerView
    },
    controllers: {
      columnsResizer: columnsResizer2,
      draggingHeader,
      editorFactory: editorFactory2,
      resizing: resizing4,
      headersKeyboardNavigation: headersKeyboardNavigation2
    }
  }
};

// node_modules/devextreme/esm/__internal/grids/data_grid/module_not_extended/sticky_columns.js
m_core_default.registerModule("stickyColumns", stickyColumnsModule);

// node_modules/devextreme/esm/__internal/grids/grid_core/column_fixing/m_column_fixing.js
var DETAIL_ROW_CLASS2 = "dx-master-detail-row";
var getTransparentColumnIndex = function(fixedColumns) {
  let transparentColumnIndex = -1;
  each(fixedColumns, (index2, column) => {
    if ("transparent" === column.command) {
      transparentColumnIndex = index2;
      return false;
    }
    return;
  });
  return transparentColumnIndex;
};
var normalizeColumnWidths = function(fixedColumns, widths, fixedWidths) {
  let fixedColumnIndex = 0;
  if (fixedColumns && widths && fixedWidths) {
    for (let i = 0; i < fixedColumns.length; i++) {
      if ("transparent" === fixedColumns[i].command) {
        fixedColumnIndex += fixedColumns[i].colspan;
      } else {
        if (widths[fixedColumnIndex] < fixedWidths[i]) {
          widths[fixedColumnIndex] = fixedWidths[i];
        }
        fixedColumnIndex++;
      }
    }
  }
  return widths;
};
var baseFixedColumns = (Base) => class extends Base {
  init() {
    super.init();
    this._isFixedTableRendering = false;
    this._isFixedColumns = false;
  }
  _createCol(column) {
    return super._createCol(column).toggleClass("dx-col-fixed", !!(this._isFixedTableRendering && (column.fixed || column.command && "transparent" !== column.command)));
  }
  isIndicesArray(arr) {
    return Array.isArray(arr) && arr.length > 0;
  }
  _correctColumnIndicesForFixedColumns(fixedColumns, change) {
    var _change$items;
    const columnIndicesArray = null === change || void 0 === change ? void 0 : change.columnIndices;
    if (!this.isIndicesArray(columnIndicesArray)) {
      return;
    }
    const transparentColumnIndex = getTransparentColumnIndex(fixedColumns);
    const transparentColspan = fixedColumns[transparentColumnIndex].colspan;
    const transparentOffset = transparentColumnIndex + transparentColspan;
    const rowTypes = null === change || void 0 === change || null === (_change$items = change.items) || void 0 === _change$items ? void 0 : _change$items.map((_ref) => {
      let {
        rowType
      } = _ref;
      return rowType;
    });
    change.columnIndices = columnIndicesArray.map((columnIndices, idx) => {
      if (!this.isIndicesArray(columnIndices)) {
        return columnIndices;
      }
      const isGroupRow3 = rowTypes && "group" === rowTypes[idx];
      if (isGroupRow3) {
        return [...columnIndices];
      }
      return columnIndices.reduce((result2, colIdx) => {
        switch (true) {
          case colIdx < transparentColumnIndex:
            result2.push(colIdx);
            break;
          case colIdx >= transparentOffset:
            result2.push(colIdx - transparentColspan + 1);
        }
        return result2;
      }, []);
    });
  }
  _partialUpdateFixedTable(fixedColumns, rows) {
    const fixedTableElement = this._fixedTableElement;
    const $rows = this._getRowElementsCore(fixedTableElement);
    const $colgroup = fixedTableElement.children("colgroup");
    $colgroup.replaceWith(this._createColGroup(fixedColumns));
    for (let i = 0; i < rows.length; i++) {
      this._partialUpdateFixedRow(renderer_default($rows[i]), fixedColumns, rows[i]);
    }
  }
  _partialUpdateFixedRow($row, fixedColumns, row) {
    const cellElements = $row.get(0).childNodes;
    const transparentColumnIndex = getTransparentColumnIndex(fixedColumns);
    const transparentColumn = fixedColumns[transparentColumnIndex];
    const columnIndexOffset = this._columnsController.getColumnIndexOffset();
    let groupCellOptions;
    let colIndex = columnIndexOffset + 1;
    let {
      colspan
    } = transparentColumn;
    if ($row.hasClass(DETAIL_ROW_CLASS2)) {
      var _this$_columnsControl;
      cellElements[0].setAttribute("colspan", null === (_this$_columnsControl = this._columnsController.getVisibleColumns()) || void 0 === _this$_columnsControl ? void 0 : _this$_columnsControl.length);
      return;
    }
    if ($row.hasClass("dx-group-row")) {
      groupCellOptions = this._getGroupCellOptions({
        row,
        columns: this._columnsController.getVisibleColumns()
      });
      const hasSummary = row.summaryCells.length > 0;
      if (hasSummary) {
        const alignByColumnCellCount = this._getAlignByColumnCellCount(groupCellOptions.colspan, {
          columns: this._columnsController.getVisibleColumns(),
          row,
          isFixed: true
        });
        colspan = groupCellOptions.colspan - alignByColumnCellCount;
      } else {
        colspan = groupCellOptions.colspan - Math.max(0, cellElements.length - (groupCellOptions.columnIndex + 2));
      }
    }
    for (let j = 0; j < cellElements.length; j++) {
      const needUpdateColspan = groupCellOptions ? j === groupCellOptions.columnIndex + 1 : j === transparentColumnIndex;
      cellElements[j].setAttribute("aria-colindex", colIndex);
      if (needUpdateColspan) {
        cellElements[j].setAttribute("colspan", colspan);
        colIndex += colspan;
      } else {
        colIndex++;
      }
    }
  }
  _renderTable(options2) {
    let $fixedTable;
    const fixedColumns = this.getFixedColumns();
    this._isFixedColumns = this.isFixedColumns();
    const $table = super._renderTable(options2);
    if (this._isFixedColumns) {
      var _change$items2;
      const change = null === options2 || void 0 === options2 ? void 0 : options2.change;
      const $fixedDataRows = this._getRowElements(this._fixedTableElement);
      const needPartialUpdate = (null === change || void 0 === change ? void 0 : change.virtualColumnsScrolling) && $fixedDataRows.length === (null === change || void 0 === change || null === (_change$items2 = change.items) || void 0 === _change$items2 ? void 0 : _change$items2.length);
      this._isFixedTableRendering = true;
      if (needPartialUpdate && true !== this.option("scrolling.legacyMode")) {
        var _options$change;
        this._partialUpdateFixedTable(fixedColumns, null === options2 || void 0 === options2 || null === (_options$change = options2.change) || void 0 === _options$change ? void 0 : _options$change.items);
        this._isFixedTableRendering = false;
      } else {
        const columnIndices = null === change || void 0 === change ? void 0 : change.columnIndices;
        this._correctColumnIndicesForFixedColumns(fixedColumns, change);
        $fixedTable = this._createTable(fixedColumns);
        this._renderRows($fixedTable, extend({}, options2, {
          columns: fixedColumns
        }));
        this._updateContent($fixedTable, change, true);
        if (columnIndices) {
          change.columnIndices = columnIndices;
        }
        this._isFixedTableRendering = false;
      }
    } else {
      this._fixedTableElement && this._fixedTableElement.parent().remove();
      this._fixedTableElement = null;
    }
    return $table;
  }
  _renderRow($table, options2) {
    let fixedCorrection;
    let {
      cells
    } = options2.row;
    super._renderRow.apply(this, arguments);
    if (this._isFixedTableRendering && cells && cells.length) {
      fixedCorrection = 0;
      const fixedCells = options2.row.cells || [];
      cells = cells.slice();
      options2.row.cells = cells;
      for (let i = 0; i < fixedCells.length; i++) {
        if (fixedCells[i].column && "transparent" === fixedCells[i].column.command) {
          fixedCorrection = (fixedCells[i].column.colspan || 1) - 1;
          continue;
        }
        cells[i + fixedCorrection] = fixedCells[i];
      }
    }
  }
  _createCell(options2) {
    const that = this;
    const {
      column
    } = options2;
    const columnCommand = column && column.command;
    const {
      rowType
    } = options2;
    const $cell = super._createCell.apply(that, arguments);
    let fixedColumns;
    let prevFixedColumn;
    let transparentColumnIndex;
    if (that._isFixedTableRendering || "filter" === rowType) {
      fixedColumns = that.getFixedColumns();
      transparentColumnIndex = getTransparentColumnIndex(fixedColumns);
      prevFixedColumn = fixedColumns[transparentColumnIndex - 1];
    }
    if (that._isFixedTableRendering) {
      if ("transparent" === columnCommand) {
        $cell.addClass("dx-pointer-events-none").toggleClass("dx-first-cell", 0 === transparentColumnIndex || prevFixedColumn && "expand" === prevFixedColumn.command).toggleClass("dx-last-cell", fixedColumns.length && transparentColumnIndex === fixedColumns.length - 1);
        if ("freeSpace" !== rowType) {
          m_utils_default.setEmptyText($cell);
        }
      }
    } else if ("filter" === rowType) {
      $cell.toggleClass("dx-first-cell", options2.columnIndex === transparentColumnIndex);
    }
    const isRowAltStyle = that.option("rowAlternationEnabled") && options2.isAltRow;
    const isSelectAllCell = "multiple" === that.option("selection.mode") && 0 === options2.columnIndex && "header" === options2.rowType;
    if (browser_default.mozilla && options2.column.fixed && "group" !== options2.rowType && !isRowAltStyle && !isSelectAllCell) {
      $cell.addClass("dx-col-fixed");
    }
    return $cell;
  }
  _wrapTableInScrollContainer($table, isFixedTableRendering) {
    const $scrollContainer = super._wrapTableInScrollContainer.apply(this, arguments);
    if (this._isFixedTableRendering || isFixedTableRendering) {
      $scrollContainer.addClass(this.addWidgetPrefix("content-fixed"));
    }
    return $scrollContainer;
  }
  _renderCellContent($cell, options2) {
    let isEmptyCell;
    const {
      column
    } = options2;
    const isFixedTableRendering = this._isFixedTableRendering;
    const isGroupCell = "group" === options2.rowType && isDefined(column.groupIndex);
    if (isFixedTableRendering && isGroupCell && !column.command && !column.groupCellTemplate) {
      $cell.css("pointerEvents", "none");
    }
    if (!isFixedTableRendering && this._isFixedColumns) {
      isEmptyCell = column.fixed || column.command && false !== column.fixed;
      if (isGroupCell) {
        isEmptyCell = false;
        if (options2.row.summaryCells && options2.row.summaryCells.length) {
          var _this$_getAlignByColu;
          const columns7 = this._columnsController.getVisibleColumns();
          const alignByFixedColumnCellCount = (null === (_this$_getAlignByColu = this._getAlignByColumnCellCount) || void 0 === _this$_getAlignByColu ? void 0 : _this$_getAlignByColu.call(this, column.colspan, {
            columns: columns7,
            row: options2.row,
            isFixed: true
          })) ?? 0;
          if (alignByFixedColumnCellCount > 0) {
            const transparentColumnIndex = getTransparentColumnIndex(this._columnsController.getFixedColumns());
            isEmptyCell = columns7.length - alignByFixedColumnCellCount < transparentColumnIndex;
          }
        }
      }
      if (isEmptyCell) {
        if (column.command && "buttons" !== column.type || "group" === options2.rowType) {
          $cell.html("&nbsp;").addClass(column.cssClass);
          return;
        }
        $cell.addClass("dx-hidden-cell");
      }
    }
    if ("transparent" !== column.command) {
      super._renderCellContent.apply(this, arguments);
    }
  }
  getContent(isFixedTableRendering) {
    var _this$_fixedTableElem;
    return isFixedTableRendering ? null === (_this$_fixedTableElem = this._fixedTableElement) || void 0 === _this$_fixedTableElem ? void 0 : _this$_fixedTableElem.parent() : super.getContent.apply(this, arguments);
  }
  _getCellElementsCore(rowIndex) {
    const cellElements = super._getCellElementsCore.apply(this, arguments);
    const isGroupRow3 = null === cellElements || void 0 === cellElements ? void 0 : cellElements.parent().hasClass("dx-group-row");
    const headerRowIndex = "columnHeadersView" === this.name ? rowIndex : void 0;
    if (this._fixedTableElement && cellElements) {
      const fixedColumns = this.getFixedColumns(headerRowIndex);
      const fixedCellElements = this._getRowElements(this._fixedTableElement).eq(rowIndex).children("td");
      each(fixedCellElements, (columnIndex, cell) => {
        if (isGroupRow3) {
          if (cellElements[columnIndex] && "hidden" !== cell.style.visibility) {
            cellElements[columnIndex] = cell;
          }
        } else {
          const fixedColumn = fixedColumns[columnIndex];
          if (fixedColumn) {
            if ("transparent" === fixedColumn.command) {
              if (fixedCellElements.eq(columnIndex).hasClass("dx-master-detail-cell")) {
                cellElements[columnIndex] = cell || cellElements[columnIndex];
              }
            } else {
              const fixedColumnIndex = this._columnsController.getVisibleIndexByColumn(fixedColumn, headerRowIndex);
              cellElements[fixedColumnIndex] = cell || cellElements[fixedColumnIndex];
            }
          }
        }
      });
    }
    return cellElements;
  }
  getColumnWidths(fixedTableElement, rowIndex) {
    const result2 = super.getColumnWidths(fixedTableElement, rowIndex);
    const fixedColumns = this.getFixedColumns();
    const fixedWidths = this._fixedTableElement && result2.length ? super.getColumnWidths(this._fixedTableElement) : void 0;
    return normalizeColumnWidths(fixedColumns, result2, fixedWidths);
  }
  getTableElement(isFixedTableRendering) {
    isFixedTableRendering = this._isFixedTableRendering || isFixedTableRendering;
    const tableElement = isFixedTableRendering ? this._fixedTableElement : super.getTableElement();
    return tableElement;
  }
  setTableElement(tableElement, isFixedTableRendering) {
    if (this._isFixedTableRendering || isFixedTableRendering) {
      this._fixedTableElement = tableElement.addClass("dx-pointer-events-none");
    } else {
      super.setTableElement(tableElement);
    }
  }
  getColumns(rowIndex) {
    const $tableElement = this.getTableElement();
    if (this._isFixedTableRendering) {
      return this.getFixedColumns(rowIndex);
    }
    return super.getColumns(rowIndex, $tableElement);
  }
  getRowIndex($row) {
    const $fixedTable = this._fixedTableElement;
    if ($fixedTable && $fixedTable.find($row).length) {
      return this._getRowElements($fixedTable).index($row);
    }
    return super.getRowIndex($row);
  }
  getTableElements() {
    let result2 = super.getTableElements.apply(this, arguments);
    if (this._fixedTableElement) {
      result2 = renderer_default([result2.get(0), this._fixedTableElement.get(0)]);
    }
    return result2;
  }
  getFixedColumns(rowIndex) {
    return this._columnsController.getFixedColumns(rowIndex);
  }
  getFixedColumnsOffset() {
    let offset2 = {
      left: 0,
      right: 0
    };
    let $transparentColumn;
    if (this._fixedTableElement) {
      $transparentColumn = this.getTransparentColumnElement();
      const positionTransparentColumn = $transparentColumn.position();
      offset2 = {
        left: positionTransparentColumn.left,
        right: getOuterWidth(this.element(), true) - (getOuterWidth($transparentColumn, true) + positionTransparentColumn.left)
      };
    }
    return offset2;
  }
  getTransparentColumnElement() {
    return this._fixedTableElement && this._fixedTableElement.find(".dx-pointer-events-none").first();
  }
  getFixedTableElement() {
    return this._fixedTableElement;
  }
  _resizeCore() {
    super._resizeCore();
    this.synchronizeRows();
  }
  setColumnWidths(options2) {
    var _options$optionNames;
    const {
      widths
    } = options2;
    const visibleColumns = this._columnsController.getVisibleColumns();
    const isColumnWidthsSynced = (null === widths || void 0 === widths ? void 0 : widths.length) && visibleColumns.some((column) => isDefined(column.visibleWidth));
    const isColumnWidthChanged = null === (_options$optionNames = options2.optionNames) || void 0 === _options$optionNames ? void 0 : _options$optionNames.width;
    super.setColumnWidths(options2);
    if (this._fixedTableElement) {
      const hasAutoWidth = null === widths || void 0 === widths ? void 0 : widths.some((width) => "auto" === width || !isDefined(width));
      const needVisibleColumns = hasAutoWidth && (!isColumnWidthsSynced || !this.isScrollbarVisible(true));
      const columns7 = needVisibleColumns ? visibleColumns : this.getFixedColumns();
      this.setFixedTableColumnWidths(columns7, widths);
    }
    const wordWrapEnabled = this.option("wordWrapEnabled");
    const needSynchronizeRows = isColumnWidthsSynced || isColumnWidthChanged && wordWrapEnabled;
    if (needSynchronizeRows) {
      this.synchronizeRows();
    }
  }
  setFixedTableColumnWidths(columns7, widths) {
    if (!this._fixedTableElement || !widths) {
      return;
    }
    const $cols = this._fixedTableElement.children("colgroup").children("col");
    $cols.toArray().forEach((col) => col.removeAttribute("style"));
    let columnIndex = 0;
    columns7.forEach((column) => {
      if (column.colspan) {
        columnIndex += column.colspan;
        return;
      }
      const colWidth = normalizeWidth(widths[columnIndex]);
      if (isDefined(colWidth)) {
        setWidth2($cols.eq(columnIndex), colWidth);
      }
      columnIndex += 1;
    });
  }
  _getClientHeight(element) {
    const boundingClientRectElement = element.getBoundingClientRect && getBoundingRect(element);
    return boundingClientRectElement && boundingClientRectElement.height ? boundingClientRectElement.height : element.clientHeight;
  }
  synchronizeRows() {
    const rowHeights = [];
    const fixedRowHeights = [];
    let rowIndex;
    let $rowElements;
    let $fixedRowElements;
    let $contentElement;
    this.waitAsyncTemplates(true).done(() => {
      if (this._isFixedColumns && this._tableElement && this._fixedTableElement) {
        const heightTable = this._getClientHeight(this._tableElement.get(0));
        const heightFixedTable = this._getClientHeight(this._fixedTableElement.get(0));
        $rowElements = this._getRowElements(this._tableElement);
        $fixedRowElements = this._getRowElements(this._fixedTableElement);
        $contentElement = this._findContentElement();
        if (heightTable !== heightFixedTable) {
          $contentElement && $contentElement.css("height", heightTable);
          $rowElements.css("height", "");
          $fixedRowElements.css("height", "");
          for (rowIndex = 0; rowIndex < $rowElements.length; rowIndex++) {
            rowHeights.push(this._getClientHeight($rowElements.get(rowIndex)));
            fixedRowHeights.push(this._getClientHeight($fixedRowElements.get(rowIndex)));
          }
          for (rowIndex = 0; rowIndex < $rowElements.length; rowIndex++) {
            const rowHeight = rowHeights[rowIndex];
            const fixedRowHeight = fixedRowHeights[rowIndex];
            if (rowHeight > fixedRowHeight) {
              $fixedRowElements.eq(rowIndex).css("height", rowHeight);
            } else if (rowHeight < fixedRowHeight) {
              $rowElements.eq(rowIndex).css("height", fixedRowHeight);
            }
          }
          $contentElement && $contentElement.css("height", "");
        }
      }
    });
  }
  setScrollerSpacing(width, hWidth) {
    const rtlEnabled = this.option("rtlEnabled");
    super.setScrollerSpacing(width);
    this.element().children(`.${this.addWidgetPrefix("content-fixed")}`).css({
      paddingLeft: rtlEnabled ? width : "",
      paddingRight: !rtlEnabled ? width : ""
    });
  }
  isFixedColumns() {
    const fixedColumns = this.getFixedColumns();
    const legacyMode = this.option("columnFixing.legacyMode");
    return true === legacyMode && !!fixedColumns.length;
  }
};
var columnHeadersView8 = (Base) => class extends baseFixedColumns(Base) {
  _getRowVisibleColumns(rowIndex) {
    if (this._isFixedTableRendering) {
      return this.getFixedColumns(rowIndex);
    }
    return super._getRowVisibleColumns(rowIndex);
  }
  getFixedColumnElements(rowIndex) {
    const that = this;
    if (!this._isFixedColumns) {
      return;
    }
    if (isDefined(rowIndex)) {
      return this._fixedTableElement && this._getRowElements(this._fixedTableElement).eq(rowIndex).children();
    }
    const columnElements = that.getColumnElements();
    const $transparentColumnElement = that.getTransparentColumnElement();
    if (columnElements && $transparentColumnElement && $transparentColumnElement.length) {
      var _$transparentColumnEl;
      const transparentColumnIndex = getTransparentColumnIndex(that.getFixedColumns());
      [].splice.apply(columnElements, [transparentColumnIndex, null === (_$transparentColumnEl = $transparentColumnElement.get(0)) || void 0 === _$transparentColumnEl ? void 0 : _$transparentColumnEl.colSpan, $transparentColumnElement.get(0)]);
    }
    return columnElements;
  }
  getColumnWidths(fixedTableElement, rowIndex) {
    const that = this;
    let fixedWidths;
    const result2 = super.getColumnWidths(fixedTableElement, rowIndex);
    const $fixedColumnElements = that.getFixedColumnElements();
    const fixedColumns = that.getFixedColumns();
    if (that._fixedTableElement) {
      if ($fixedColumnElements && $fixedColumnElements.length) {
        fixedWidths = that._getWidths($fixedColumnElements);
      } else {
        fixedWidths = super.getColumnWidths(that._fixedTableElement);
      }
    }
    return normalizeColumnWidths(fixedColumns, result2, fixedWidths);
  }
};
var rowsView13 = (Base) => class extends baseFixedColumns(Base) {
  dispose() {
    super.dispose.apply(this, arguments);
    clearTimeout(this._fixedScrollTimeout);
  }
  optionChanged(args) {
    super.optionChanged(args);
    if ("hoverStateEnabled" === args.name && this._isFixedColumns) {
      args.value ? this._attachHoverEvents() : this._detachHoverEvents();
    }
  }
  _detachHoverEvents() {
    const element = this.element();
    if (this._fixedTableElement && this._tableElement) {
      m_events_engine_default.off(element, "mouseover mouseout", ".dx-data-row");
    }
  }
  _attachHoverEvents() {
    if (this._fixedTableElement && this._tableElement) {
      m_events_engine_default.on(this.element(), "mouseover mouseout", ".dx-data-row", this.createAction((args) => {
        const {
          event
        } = args;
        const rowIndex = this.getRowIndex(renderer_default(event.target).closest(".dx-row"));
        const isHover = "mouseover" === event.type;
        if (rowIndex >= 0) {
          this._tableElement && this._getRowElements(this._tableElement).eq(rowIndex).toggleClass("dx-state-hover", isHover);
          this._fixedTableElement && this._getRowElements(this._fixedTableElement).eq(rowIndex).toggleClass("dx-state-hover", isHover);
        }
      }));
    }
  }
  _getScrollDelay() {
    var _this$_resizingContro;
    const hasResizeTimeout = null === (_this$_resizingContro = this._resizingController) || void 0 === _this$_resizingContro ? void 0 : _this$_resizingContro.hasResizeTimeout();
    if (hasResizeTimeout) {
      return this.option("scrolling.updateTimeout");
    }
    return browser_default.mozilla ? 60 : 0;
  }
  _findContentElement(isFixedTableRendering) {
    let $content;
    let scrollTop;
    const contentClass = this.addWidgetPrefix("content");
    const element = this.element();
    isFixedTableRendering = this._isFixedTableRendering || isFixedTableRendering;
    if (element && isFixedTableRendering) {
      $content = element.children(`.${contentClass}`);
      const scrollable = this.getScrollable();
      if (!$content.length && scrollable) {
        $content = renderer_default("<div>").addClass(contentClass);
        m_events_engine_default.on($content, "scroll", (e) => {
          const {
            target
          } = e;
          const scrollDelay = this._getScrollDelay();
          clearTimeout(this._fixedScrollTimeout);
          this._fixedScrollTimeout = setTimeout(() => {
            scrollTop = renderer_default(target).scrollTop();
            scrollable.scrollTo({
              y: scrollTop
            });
          }, scrollDelay);
        });
        m_events_engine_default.on($content, EVENT_NAME, (e) => {
          const $nearestScrollable = renderer_default(e.target).closest(".dx-scrollable");
          let shouldScroll = false;
          if (scrollable && scrollable.$element().is($nearestScrollable)) {
            shouldScroll = true;
          } else {
            const nearestScrollableInstance = $nearestScrollable.length && ui_scrollable_default.getInstance($nearestScrollable.get(0));
            const nearestScrollableHasVerticalScrollbar = nearestScrollableInstance && nearestScrollableInstance.scrollHeight() - nearestScrollableInstance.clientHeight() > 0;
            shouldScroll = nearestScrollableInstance && !nearestScrollableHasVerticalScrollbar;
          }
          if (shouldScroll) {
            scrollTop = scrollable.scrollTop();
            scrollable.scrollTo({
              y: scrollTop - e.delta
            });
            const scrollableTop = scrollable.scrollTop() + scrollable.clientHeight();
            const scrollableHeight = scrollable.scrollHeight() + this.getScrollbarWidth();
            const isPreventDefault = scrollable.scrollTop() > 0 && scrollableTop < scrollableHeight;
            if (isPreventDefault) {
              return false;
            }
          }
          return;
        });
        $content.appendTo(element);
      }
      return $content;
    }
    return super._findContentElement();
  }
  _updateScrollable() {
    super._updateScrollable();
    const scrollable = this.getScrollable();
    if (null !== scrollable && void 0 !== scrollable && scrollable._disposed) {
      return;
    }
    const scrollTop = scrollable && scrollable.scrollOffset().top;
    this._updateFixedTablePosition(scrollTop);
  }
  _renderContent(contentElement, tableElement, isFixedTableRendering) {
    if (this._isFixedTableRendering || isFixedTableRendering) {
      return contentElement.empty().addClass(`${this.addWidgetPrefix("content")} ${this.addWidgetPrefix("content-fixed")}`).append(tableElement);
    }
    return super._renderContent(contentElement, tableElement);
  }
  _getGroupCellOptions(options2) {
    if (this._isFixedTableRendering) {
      return super._getGroupCellOptions(extend({}, options2, {
        columns: this._columnsController.getVisibleColumns()
      }));
    }
    return super._getGroupCellOptions(options2);
  }
  _renderGroupedCells($row, options2) {
    return super._renderGroupedCells($row, extend({}, options2, {
      columns: this._columnsController.getVisibleColumns()
    }));
  }
  _renderGroupSummaryCells($row, options2) {
    if (this._isFixedTableRendering) {
      super._renderGroupSummaryCells($row, extend({}, options2, {
        columns: this._columnsController.getVisibleColumns()
      }));
    } else {
      super._renderGroupSummaryCells($row, options2);
    }
  }
  _hasAlignByColumnSummaryItems(columnIndex, options2) {
    const result2 = super._hasAlignByColumnSummaryItems.apply(this, arguments);
    const column = options2.columns[columnIndex];
    if (options2.isFixed) {
      return column.fixed && (result2 || "right" === column.fixedPosition);
    }
    return result2 && (!this._isFixedColumns || !column.fixed);
  }
  _renderGroupSummaryCellsCore($groupCell, options2, groupCellColSpan, alignByColumnCellCount) {
    let alignByFixedColumnCellCount;
    if (this._isFixedTableRendering) {
      options2.isFixed = true;
      alignByFixedColumnCellCount = this._getAlignByColumnCellCount(groupCellColSpan, options2);
      options2.isFixed = false;
      const startColumnIndex = options2.columns.length - alignByFixedColumnCellCount;
      options2 = extend({}, options2, {
        columns: this.getFixedColumns()
      });
      const transparentColumnIndex = getTransparentColumnIndex(options2.columns);
      if (startColumnIndex < transparentColumnIndex) {
        alignByFixedColumnCellCount -= options2.columns[transparentColumnIndex].colspan - 1 || 0;
        groupCellColSpan -= options2.columns[transparentColumnIndex].colspan - 1 || 0;
      } else if (alignByColumnCellCount > 0) {
        $groupCell.css("visibility", "hidden");
      }
      alignByColumnCellCount = alignByFixedColumnCellCount;
    }
    super._renderGroupSummaryCellsCore($groupCell, options2, groupCellColSpan, alignByColumnCellCount);
  }
  _getSummaryCellIndex(columnIndex, columns7) {
    if (this._isFixedTableRendering) {
      const transparentColumnIndex = getTransparentColumnIndex(columns7);
      if (columnIndex > transparentColumnIndex) {
        columnIndex += columns7[transparentColumnIndex].colspan - 1;
      }
      return columnIndex;
    }
    return super._getSummaryCellIndex.apply(this, arguments);
  }
  _renderCore(change) {
    this._detachHoverEvents();
    const deferred = super._renderCore(change);
    const isFixedColumns = this._isFixedColumns;
    this.element().toggleClass("dx-fixed-columns", isFixedColumns);
    if (this.option("hoverStateEnabled") && isFixedColumns) {
      this._attachHoverEvents();
    }
    return deferred;
  }
  setAriaOwns(headerTableId, footerTableId, isFixed) {
    if (isFixed) {
      var _this$element;
      const contentFixedClass = this.addWidgetPrefix("content-fixed");
      const $contentFixedElement = null === (_this$element = this.element()) || void 0 === _this$element ? void 0 : _this$element.children(`.${contentFixedClass}`);
      const $fixedTableElement = this.getFixedTableElement();
      if ($contentFixedElement.length && null !== $fixedTableElement && void 0 !== $fixedTableElement && $fixedTableElement.length) {
        this.setAria("owns", `${headerTableId ?? ""} ${$fixedTableElement.attr("id") ?? ""} ${footerTableId ?? ""}`.trim(), $contentFixedElement);
      }
    } else {
      super.setAriaOwns.apply(this, arguments);
    }
  }
  toggleDraggableColumnClass(columnIndex, value2) {
    super.toggleDraggableColumnClass(columnIndex, value2);
    if (this.isFixedColumns()) {
      const $rows = this._getRowElements(this._fixedTableElement);
      this._toggleDraggableSourceColumnClass($rows, this.getFixedColumns(), columnIndex, value2);
    }
  }
  getCellIndex($cell) {
    const $fixedTable = this._fixedTableElement;
    let cellIndex = 0;
    if ($fixedTable && $cell.is("td") && $cell.closest($fixedTable).length) {
      const columns7 = this.getFixedColumns();
      each(columns7, (index2, column) => {
        if (index2 === $cell[0].cellIndex) {
          return false;
        }
        if (column.colspan) {
          cellIndex += column.colspan;
          return;
        }
        cellIndex++;
        return;
      });
      return cellIndex;
    }
    return super.getCellIndex.apply(this, arguments);
  }
  _updateFixedTablePosition(scrollTop, needFocus) {
    if (this._fixedTableElement && this._tableElement) {
      let $focusedElement;
      this._fixedTableElement.parent().scrollTop(scrollTop);
      if (needFocus && this._editorFactoryController) {
        $focusedElement = this._editorFactoryController.focus();
        $focusedElement && this._editorFactoryController.focus($focusedElement);
      }
    }
  }
  setScrollerSpacing(vWidth, hWidth) {
    const that = this;
    const styles = {
      marginBottom: 0
    };
    const $fixedContent = that.element().children(`.${this.addWidgetPrefix("content-fixed")}`);
    if ($fixedContent.length && that._fixedTableElement) {
      $fixedContent.css(styles);
      that._fixedTableElement.css(styles);
      styles[that.option("rtlEnabled") ? "marginLeft" : "marginRight"] = vWidth;
      styles.marginBottom = hWidth;
      const useNativeScrolling = that._scrollable && that._scrollable.option("useNative");
      (useNativeScrolling ? $fixedContent : that._fixedTableElement).css(styles);
    }
  }
  _getElasticScrollTop(e) {
    let elasticScrollTop = 0;
    if (e.scrollOffset.top < 0) {
      elasticScrollTop = -e.scrollOffset.top;
    } else if (e.reachedBottom) {
      const $scrollableContent = renderer_default(e.component.content());
      const $scrollableContainer = renderer_default(e.component.container());
      const maxScrollTop = Math.max($scrollableContent.get(0).clientHeight - $scrollableContainer.get(0).clientHeight, 0);
      elasticScrollTop = Math.min(maxScrollTop - e.scrollOffset.top, 0);
    }
    return Math.floor(elasticScrollTop);
  }
  _applyElasticScrolling(e) {
    if (this._fixedTableElement) {
      const elasticScrollTop = this._getElasticScrollTop(e);
      if (0 !== Math.ceil(elasticScrollTop)) {
        move(this._fixedTableElement, {
          top: elasticScrollTop
        });
      } else {
        this._fixedTableElement.css("transform", "");
      }
    }
  }
  _handleScroll(e) {
    this._updateFixedTablePosition(e.scrollOffset.top, true);
    this._applyElasticScrolling(e);
    super._handleScroll(e);
  }
  _updateContentPosition(isRender) {
    super._updateContentPosition.apply(this, arguments);
    if (!isRender) {
      this._updateFixedTablePosition(this._scrollTop);
    }
  }
  _afterRowPrepared(e) {
    if (this._isFixedTableRendering) {
      return;
    }
    super._afterRowPrepared(e);
  }
  _scrollToElement($element, offset2) {
    const scrollOffset = this.isFixedColumns() ? this.getFixedColumnsOffset() : offset2;
    super._scrollToElement($element, scrollOffset);
  }
};
var footerView2 = (Base) => class extends baseFixedColumns(Base) {
};
var normalizeColumnIndicesByPoints = function(columns7, fixedColumns, pointsByColumns) {
  const transparentColumnIndex = getTransparentColumnIndex(fixedColumns);
  const correctIndex = columns7.length - fixedColumns.length;
  each(pointsByColumns, (_, point) => {
    if (point.index > transparentColumnIndex) {
      point.columnIndex += correctIndex;
      point.index += correctIndex;
    }
  });
  return pointsByColumns;
};
var draggingHeader2 = (Base) => class extends Base {
  _generatePointsByColumns(options2, needToCheckPrevPoint) {
    const visibleColumns = options2.columns;
    const {
      targetDraggingPanel
    } = options2;
    if (targetDraggingPanel && "headers" === targetDraggingPanel.getName() && targetDraggingPanel.isFixedColumns()) {
      if (options2.sourceColumn.fixed) {
        if (!options2.rowIndex) {
          options2.columnElements = targetDraggingPanel.getFixedColumnElements(0);
        }
        options2.columns = targetDraggingPanel.getFixedColumns(options2.rowIndex);
        const pointsByColumns = super._generatePointsByColumns(options2, needToCheckPrevPoint);
        normalizeColumnIndicesByPoints(visibleColumns, options2.columns, pointsByColumns);
        return pointsByColumns;
      }
    }
    return super._generatePointsByColumns(options2, needToCheckPrevPoint);
  }
  _pointCreated(point, columns7, location, sourceColumn) {
    const result2 = super._pointCreated.apply(this, arguments);
    const targetColumn = columns7[point.columnIndex];
    const $transparentColumn = this._columnHeadersView.getTransparentColumnElement();
    if (!result2 && "headers" === location && $transparentColumn && $transparentColumn.length) {
      const boundingRect = getBoundingRect($transparentColumn.get(0));
      if (sourceColumn && sourceColumn.fixed) {
        return "right" === sourceColumn.fixedPosition ? point.x < boundingRect.right : point.x > boundingRect.left;
      }
      if (targetColumn && targetColumn.fixed && "right" !== targetColumn.fixedPosition) {
        return true;
      }
      return point.x < boundingRect.left || point.x > boundingRect.right;
    }
    return result2;
  }
};
var columnsResizer3 = (Base) => class extends Base {
  _generatePointsByColumns(needToCheckPrevPoint) {
    const that = this;
    const columnsController = that._columnsController;
    const columns7 = columnsController && that._columnsController.getVisibleColumns();
    const fixedColumns = columnsController && that._columnsController.getFixedColumns();
    const transparentColumnIndex = getTransparentColumnIndex(fixedColumns);
    const correctIndex = columns7.length - fixedColumns.length;
    const cells = that._columnHeadersView.getFixedColumnElements();
    super._generatePointsByColumns(needToCheckPrevPoint);
    if (cells && cells.length > 0) {
      that._pointsByFixedColumns = m_utils_default.getPointsByColumns(cells, (point) => {
        if (point.index > transparentColumnIndex) {
          point.columnIndex += correctIndex;
          point.index += correctIndex;
        }
        return that._pointCreated(point, columns7.length, columns7);
      });
    }
  }
  _getTargetPoint(pointsByColumns, currentX, deltaX) {
    const $transparentColumn = this._columnHeadersView.getTransparentColumnElement();
    if ($transparentColumn && $transparentColumn.length) {
      const boundingRect = getBoundingRect($transparentColumn.get(0));
      if (currentX <= boundingRect.left || currentX >= boundingRect.right) {
        return super._getTargetPoint(this._pointsByFixedColumns, currentX, deltaX);
      }
    }
    return super._getTargetPoint(pointsByColumns, currentX, deltaX);
  }
};
var resizing5 = (Base) => class extends Base {
  _setAriaOwns() {
    var _this$_columnHeadersV, _this$_footerView, _this$_rowsView;
    super._setAriaOwns.apply(this, arguments);
    const headerFixedTable = null === (_this$_columnHeadersV = this._columnHeadersView) || void 0 === _this$_columnHeadersV ? void 0 : _this$_columnHeadersV.getFixedTableElement();
    const footerFixedTable = null === (_this$_footerView = this._footerView) || void 0 === _this$_footerView ? void 0 : _this$_footerView.getFixedTableElement();
    null === (_this$_rowsView = this._rowsView) || void 0 === _this$_rowsView || _this$_rowsView.setAriaOwns(null === headerFixedTable || void 0 === headerFixedTable ? void 0 : headerFixedTable.attr("id"), null === footerFixedTable || void 0 === footerFixedTable ? void 0 : footerFixedTable.attr("id"), true);
  }
};
var keyboardNavigation = (Base) => class extends Base {
  _toggleInertAttr(value2) {
    var _this$_rowsView2;
    const $fixedContent = null === (_this$_rowsView2 = this._rowsView) || void 0 === _this$_rowsView2 ? void 0 : _this$_rowsView2.getFixedContentElement();
    if (value2) {
      null === $fixedContent || void 0 === $fixedContent || $fixedContent.attr("inert", true);
    } else {
      null === $fixedContent || void 0 === $fixedContent || $fixedContent.removeAttr("inert");
    }
  }
};
var editorFactory3 = (Base) => class extends Base {
  getValidationMessageContainer($cell) {
    const isFixedColumns = this._rowsView.isFixedColumns();
    if (isFixedColumns) {
      return this._rowsView.element();
    }
    return super.getValidationMessageContainer($cell);
  }
};
var columnFixingModule = {
  defaultOptions: () => ({
    columnFixing: {
      enabled: false,
      legacyMode: false,
      texts: {
        fix: message_default.format("dxDataGrid-columnFixingFix"),
        unfix: message_default.format("dxDataGrid-columnFixingUnfix"),
        leftPosition: message_default.format("dxDataGrid-columnFixingLeftPosition"),
        rightPosition: message_default.format("dxDataGrid-columnFixingRightPosition"),
        stickyPosition: message_default.format("dxDataGrid-columnFixingStickyPosition")
      },
      icons: {
        fix: "fix-column",
        unfix: "unfix-column",
        leftPosition: "fix-column-left",
        rightPosition: "fix-column-right",
        stickyPosition: "stick-column"
      }
    }
  }),
  extenders: {
    views: {
      columnHeadersView: columnHeadersView8,
      rowsView: rowsView13,
      footerView: footerView2
    },
    controllers: {
      draggingHeader: draggingHeader2,
      columnsResizer: columnsResizer3,
      resizing: resizing5,
      keyboardNavigation,
      editorFactory: editorFactory3
    }
  }
};

// node_modules/devextreme/esm/__internal/grids/data_grid/module_not_extended/column_fixing.js
m_core_default.registerModule("columnFixing", columnFixingModule);

// node_modules/devextreme/esm/__internal/grids/grid_core/adaptivity/m_adaptivity.js
var ROWS_VIEW2 = "rowsView";
var FOOTER_VIEW = "footerView";
var COLUMN_VIEWS = ["columnHeadersView", ROWS_VIEW2, FOOTER_VIEW];
var ADAPTIVE_NAMESPACE = "dxDataGridAdaptivity";
var EXPAND_ARIA_NAME = "dxDataGrid-ariaAdaptiveExpand";
var COLLAPSE_ARIA_NAME = "dxDataGrid-ariaAdaptiveCollapse";
var LEGACY_SCROLLING_MODE5 = "scrolling.legacyMode";
function getColumnId(that, column) {
  return that._columnsController.getColumnId(column);
}
function getDataCellElements($row) {
  return $row.find("td:not(.dx-datagrid-hidden-column):not([class*='dx-command-'])");
}
function adaptiveCellTemplate(container, options2) {
  let $adaptiveColumnButton;
  const $container = renderer_default(container);
  const adaptiveColumnsController = options2.component.getController("adaptiveColumns");
  if ("data" === options2.rowType) {
    $adaptiveColumnButton = renderer_default("<span>").addClass(adaptiveColumnsController.addWidgetPrefix("adaptive-more"));
    m_events_engine_default.on($adaptiveColumnButton, addNamespace2(CLICK_EVENT_NAME, ADAPTIVE_NAMESPACE), adaptiveColumnsController.createAction(() => {
      adaptiveColumnsController.toggleExpandAdaptiveDetailRow(options2.key);
    }));
    $adaptiveColumnButton.appendTo($container);
  } else {
    m_utils_default.setEmptyText($container);
  }
}
function focusCellHandler(e) {
  var _e$data;
  const $nextCell = null === (_e$data = e.data) || void 0 === _e$data ? void 0 : _e$data.$nextCell;
  m_events_engine_default.off($nextCell, "focus", focusCellHandler);
  m_events_engine_default.trigger($nextCell, "dxclick");
}
var AdaptiveColumnsController = class extends m_modules_default.ViewController {
  init() {
    this._columnsController = this.getController("columns");
    this._dataController = this.getController("data");
    this._editingController = this.getController("editing");
    this._keyboardNavigationController = this.getController("keyboardNavigation");
    this._rowsView = this.getView("rowsView");
    this._columnsController.addCommandColumn({
      type: "adaptive",
      command: "adaptive",
      visible: true,
      adaptiveHidden: true,
      cssClass: "dx-command-adaptive",
      alignment: "center",
      width: "auto",
      cellTemplate: adaptiveCellTemplate,
      fixedPosition: "right"
    });
    this._columnsController.columnsChanged.add(() => {
      const isAdaptiveVisible = !!this.updateHidingQueue(this._columnsController.getColumns()).length;
      this._columnsController.columnOption("command:adaptive", "adaptiveHidden", !isAdaptiveVisible, true);
    });
    this._hidingColumnsQueue = [];
    this._hiddenColumns = [];
    this.createAction("onAdaptiveDetailRowPreparing");
    super.init();
  }
  optionChanged(args) {
    if ("columnHidingEnabled" === args.name) {
      this._columnsController.columnOption("command:adaptive", "adaptiveHidden", !args.value);
    }
    super.optionChanged(args);
  }
  publicMethods() {
    return ["isAdaptiveDetailRowExpanded", "expandAdaptiveDetailRow", "collapseAdaptiveDetailRow"];
  }
  _isRowEditMode() {
    const editMode = this._getEditMode();
    return "row" === editMode;
  }
  _isItemModified(item, cellOptions) {
    const columnIndex = this._columnsController.getVisibleIndex(item.column.index);
    const rowIndex = this._dataController.getRowIndexByKey(cellOptions.key);
    const row = this._dataController.items()[rowIndex + 1];
    return row && row.modifiedValues && isDefined(row.modifiedValues[columnIndex]);
  }
  _renderFormViewTemplate(item, cellOptions, $container) {
    const that = this;
    const {
      column
    } = item;
    const focusAction = that.createAction(() => {
      if (that._editingController.isEditing()) {
        m_events_engine_default.trigger($container, CLICK_EVENT_NAME);
      }
    });
    const rowData = cellOptions.row.data;
    const value2 = column.calculateCellValue(rowData);
    const displayValue = m_utils_default.getDisplayValue(column, value2, rowData, cellOptions.rowType);
    const text = m_utils_default.formatValue(displayValue, column);
    const isCellOrBatchEditMode = this._editingController.isCellOrBatchEditMode();
    const rowsView18 = that._rowsView;
    if (column.allowEditing && this._keyboardNavigationController.isKeyboardEnabled()) {
      $container.attr("tabIndex", that.option("tabIndex"));
      if (isCellOrBatchEditMode) {
        m_events_engine_default.off($container, "focus", focusAction);
        m_events_engine_default.on($container, "focus", focusAction);
      }
    }
    if (column.cellTemplate) {
      const templateOptions = extend({}, cellOptions, {
        value: value2,
        displayValue,
        text,
        column
      });
      rowsView18.renderTemplate($container, column.cellTemplate, templateOptions, isElementInDom($container)).done(() => {
        rowsView18._cellPrepared($container, cellOptions);
      });
    } else {
      const container = $container.get(0);
      if (column.encodeHtml) {
        container.textContent = text;
      } else {
        container.innerHTML = text;
      }
      $container.addClass("dx-adaptive-item-text");
      if (!isDefined(text) || "" === text) {
        $container.html("&nbsp;");
      }
      if (!that._isRowEditMode()) {
        if (that._isItemModified(item, cellOptions)) {
          $container.addClass("dx-item-modified");
        }
      }
      rowsView18._cellPrepared($container, cellOptions);
    }
  }
  _getTemplate(item, cellOptions, updateForm) {
    const that = this;
    const {
      column
    } = item;
    const editingController = this._editingController;
    return function(options2, container) {
      const $container = renderer_default(container);
      const columnIndex = that._columnsController.getVisibleIndex(column.index);
      const templateOptions = extend({}, cellOptions);
      const renderFormTemplate = function() {
        const isItemEdited = that._isItemEdited(item);
        templateOptions.value = cellOptions.row.values[columnIndex];
        if (isItemEdited || column.showEditorAlways) {
          editingController.renderFormEditorTemplate(templateOptions, item, options2, $container, !isItemEdited);
        } else {
          templateOptions.column = column;
          templateOptions.columnIndex = columnIndex;
          that._renderFormViewTemplate(item, templateOptions, $container);
        }
      };
      renderFormTemplate();
      if (templateOptions.watch) {
        const dispose2 = templateOptions.watch(() => ({
          isItemEdited: that._isItemEdited(item),
          value: cellOptions.row.values[columnIndex]
        }), () => {
          $container.contents().remove();
          $container.removeClass("dx-adaptive-item-text");
          renderFormTemplate();
        });
        m_events_engine_default.on($container, removeEvent, dispose2);
      }
    };
  }
  _isVisibleColumnsValid(visibleColumns) {
    if (visibleColumns < 2) {
      return false;
    }
    if (visibleColumns.length - function() {
      let result2 = 0;
      for (let j = 0; j < visibleColumns.length; j++) {
        const visibleColumn = visibleColumns[j];
        if (visibleColumn.command) {
          result2++;
        }
      }
      return result2;
    }() <= 1) {
      return false;
    }
    return true;
  }
  _calculatePercentWidths(widths, visibleColumns) {
    const that = this;
    let percentWidths = 0;
    visibleColumns.forEach((item, index2) => {
      if ("adaptiveHidden" !== widths[index2]) {
        percentWidths += that._getItemPercentWidth(item);
      }
    });
    return percentWidths;
  }
  _isPercentWidth(width) {
    return isString(width) && width.endsWith("%");
  }
  _isColumnHidden(column) {
    return this._hiddenColumns.filter((hiddenColumn) => hiddenColumn.index === column.index).length > 0;
  }
  _getAverageColumnsWidth(containerWidth, columns7, columnsCanFit) {
    const that = this;
    let fixedColumnsWidth = 0;
    let columnsWithoutFixedWidthCount = 0;
    columns7.forEach((column) => {
      if (!that._isColumnHidden(column)) {
        const {
          width
        } = column;
        if (isDefined(width) && !isNaN(parseFloat(width))) {
          fixedColumnsWidth += that._isPercentWidth(width) ? that._calculatePercentWidth({
            visibleIndex: column.visibleIndex,
            columnsCount: columns7.length,
            columnsCanFit,
            bestFitWidth: column.bestFitWidth,
            columnWidth: width,
            containerWidth
          }) : parseFloat(width);
        } else {
          columnsWithoutFixedWidthCount++;
        }
      }
    });
    return (containerWidth - fixedColumnsWidth) / columnsWithoutFixedWidthCount;
  }
  _calculateColumnWidth(column, containerWidth, contentColumns, columnsCanFit) {
    const columnId = getColumnId(this, column);
    const widthOption = this._columnsController.columnOption(columnId, "width");
    const bestFitWidth = this._columnsController.columnOption(columnId, "bestFitWidth");
    const columnsCount = contentColumns.length;
    let colWidth;
    if (widthOption && "auto" !== widthOption) {
      if (this._isPercentWidth(widthOption)) {
        colWidth = this._calculatePercentWidth({
          visibleIndex: column.visibleIndex,
          columnsCount,
          columnsCanFit,
          bestFitWidth,
          columnWidth: widthOption,
          containerWidth
        });
      } else {
        return parseFloat(widthOption);
      }
    } else {
      const columnAutoWidth = this.option("columnAutoWidth");
      colWidth = columnAutoWidth || !!column.command ? bestFitWidth : this._getAverageColumnsWidth(containerWidth, contentColumns, columnsCanFit);
    }
    return colWidth;
  }
  _calculatePercentWidth(options2) {
    const columnFitted = options2.visibleIndex < options2.columnsCount - 1 && options2.columnsCanFit;
    const partialWidth = options2.containerWidth * parseFloat(options2.columnWidth) / 100;
    const resultWidth = options2.columnsCanFit && partialWidth < options2.bestFitWidth ? options2.bestFitWidth : partialWidth;
    return columnFitted ? options2.containerWidth * parseFloat(options2.columnWidth) / 100 : resultWidth;
  }
  _getNotTruncatedColumnWidth(column, containerWidth, contentColumns, columnsCanFit) {
    const columnId = getColumnId(this, column);
    const widthOption = this._columnsController.columnOption(columnId, "width");
    const bestFitWidth = this._columnsController.columnOption(columnId, "bestFitWidth");
    if (widthOption && "auto" !== widthOption && !this._isPercentWidth(widthOption)) {
      return parseFloat(widthOption);
    }
    const colWidth = this._calculateColumnWidth(column, containerWidth, contentColumns, columnsCanFit);
    return colWidth < bestFitWidth ? null : colWidth;
  }
  _getItemPercentWidth(item) {
    let result2 = 0;
    if (item.width && this._isPercentWidth(item.width)) {
      result2 = parseFloat(item.width);
    }
    return result2;
  }
  _getCommandColumnsWidth() {
    const that = this;
    const columns7 = that._columnsController.getVisibleColumns();
    let colWidth = 0;
    each(columns7, (index2, column) => {
      if (column.index < 0 || column.command) {
        colWidth += that._columnsController.columnOption(getColumnId(that, column), "bestFitWidth") || 0;
      }
    });
    return colWidth;
  }
  _isItemEdited(item) {
    if (this.isFormOrPopupEditMode()) {
      return false;
    }
    if (this._isRowEditMode()) {
      const editRowKey = this.option("editing.editRowKey");
      if (equalByValue(editRowKey, this._dataController.adaptiveExpandedKey())) {
        return true;
      }
    } else {
      const rowIndex = this._dataController.getRowIndexByKey(this._dataController.adaptiveExpandedKey()) + 1;
      const columnIndex = this._columnsController.getVisibleIndex(item.column.index);
      return this._editingController.isEditCell(rowIndex, columnIndex);
    }
    return;
  }
  _getFormItemsByHiddenColumns(hiddenColumns) {
    const items = [];
    each(hiddenColumns, (_, column) => {
      items.push({
        column,
        name: column.name,
        dataField: column.dataField,
        visibleIndex: column.visibleIndex
      });
    });
    return items;
  }
  _getAdaptiveColumnVisibleIndex(visibleColumns) {
    for (let i = 0; i < visibleColumns.length; i++) {
      const column = visibleColumns[i];
      if ("adaptive" === column.command) {
        return i;
      }
    }
    return;
  }
  _hideAdaptiveColumn(resultWidths, visibleColumns) {
    const visibleIndex = this._getAdaptiveColumnVisibleIndex(visibleColumns);
    if (isDefined(visibleIndex)) {
      resultWidths[visibleIndex] = "adaptiveHidden";
      this._hideVisibleColumn({
        isCommandColumn: true,
        visibleIndex
      });
    }
  }
  _showHiddenCellsInView(_ref) {
    let {
      $cells,
      isCommandColumn
    } = _ref;
    let cssClassNameToRemove = this.addWidgetPrefix("hidden-column");
    if (isCommandColumn) {
      cssClassNameToRemove = "dx-command-adaptive-hidden";
      $cells.attr({
        tabIndex: 0,
        "aria-hidden": null
      }).removeClass(cssClassNameToRemove);
    } else {
      $cells.removeClass(cssClassNameToRemove);
    }
  }
  _showHiddenColumns() {
    for (let i = 0; i < COLUMN_VIEWS.length; i++) {
      const view = this.getView(COLUMN_VIEWS[i]);
      if (view && view.isVisible() && view.element()) {
        const viewName2 = view.name;
        const $hiddenCommandCells = view.element().find(".dx-command-adaptive-hidden");
        this._showHiddenCellsInView({
          viewName: viewName2,
          $cells: $hiddenCommandCells,
          isCommandColumn: true
        });
        const $hiddenCells = view.element().find(`.${this.addWidgetPrefix("hidden-column")}`);
        this._showHiddenCellsInView({
          viewName: viewName2,
          $cells: $hiddenCells
        });
      }
    }
  }
  _isCellValid($cell) {
    return $cell && $cell.length && !$cell.hasClass("dx-master-detail-cell") && !$cell.hasClass("dx-group-cell");
  }
  _hideVisibleColumn(_ref2) {
    let {
      isCommandColumn,
      visibleIndex
    } = _ref2;
    const that = this;
    COLUMN_VIEWS.forEach((viewName2) => {
      const view = that.getView(viewName2);
      view && that._hideVisibleColumnInView({
        view,
        isCommandColumn,
        visibleIndex
      });
    });
  }
  _hideVisibleColumnInView(_ref3) {
    let {
      view,
      isCommandColumn,
      visibleIndex
    } = _ref3;
    const viewName2 = view.name;
    let $cellElement;
    const column = this._columnsController.getVisibleColumns()[visibleIndex];
    const editFormRowIndex = this._editingController && this._editingController.getEditFormRowIndex();
    if (view && view.isVisible() && column) {
      const rowsCount = view.getRowsCount();
      const $rowElements = view._getRowElements();
      for (let rowIndex = 0; rowIndex < rowsCount; rowIndex++) {
        const cancelClassAdding = rowIndex === editFormRowIndex && viewName2 === ROWS_VIEW2 && "popup" !== this.option("editing.mode");
        if (!cancelClassAdding) {
          const currentVisibleIndex = "columnHeadersView" === viewName2 ? this._columnsController.getVisibleIndex(column.index, rowIndex) : visibleIndex;
          if (currentVisibleIndex >= 0) {
            const $rowElement = $rowElements.eq(rowIndex);
            $cellElement = this._findCellElementInRow($rowElement, currentVisibleIndex);
            this._isCellValid($cellElement) && this._hideVisibleCellInView({
              viewName: viewName2,
              isCommandColumn,
              $cell: $cellElement
            });
          }
        }
      }
    }
  }
  _findCellElementInRow($rowElement, visibleColumnIndex) {
    const $rowCells = $rowElement.children();
    let visibleIndex = visibleColumnIndex;
    let cellIsInsideGroup = false;
    if ($rowElement.hasClass("dx-group-row")) {
      const $groupCell = $rowElement.find(".dx-group-cell");
      const colSpan = $groupCell.attr("colspan");
      if ($groupCell.length && isDefined(colSpan)) {
        const groupCellLength = parseInt(colSpan);
        const endGroupIndex = $groupCell.index() + groupCellLength - 1;
        if (visibleColumnIndex > endGroupIndex) {
          visibleIndex = visibleColumnIndex - groupCellLength + 1;
        } else {
          cellIsInsideGroup = true;
        }
      }
    }
    const $cellElement = !cellIsInsideGroup ? $rowCells.eq(visibleIndex) : void 0;
    return $cellElement;
  }
  _hideVisibleCellInView(_ref4) {
    let {
      $cell,
      isCommandColumn
    } = _ref4;
    const cssClassNameToAdd = isCommandColumn ? "dx-command-adaptive-hidden" : this.addWidgetPrefix("hidden-column");
    $cell.attr({
      tabIndex: -1,
      "aria-hidden": true
    }).addClass(cssClassNameToAdd);
  }
  _getEditMode() {
    return this._editingController.getEditMode();
  }
  isFormOrPopupEditMode() {
    const editMode = this._getEditMode();
    return "form" === editMode || "popup" === editMode;
  }
  hideRedundantColumns(resultWidths, visibleColumns, hiddenQueue) {
    const that = this;
    this._hiddenColumns = [];
    if (that._isVisibleColumnsValid(visibleColumns) && hiddenQueue.length) {
      let totalWidth = 0;
      const $rootElement = that.component.$element();
      let rootElementWidth = getWidth($rootElement) - that._getCommandColumnsWidth();
      const getVisibleContentColumns = function() {
        return visibleColumns.filter((item) => !item.command && 0 === this._hiddenColumns.filter((i2) => i2.index === item.index).length);
      }.bind(this);
      let visibleContentColumns = getVisibleContentColumns();
      const contentColumnsCount = visibleContentColumns.length;
      let i;
      let hasHiddenColumns;
      let needHideColumn;
      do {
        needHideColumn = false;
        totalWidth = 0;
        const percentWidths = that._calculatePercentWidths(resultWidths, visibleColumns);
        const columnsCanFit = percentWidths < 100 && 0 !== percentWidths;
        for (i = 0; i < visibleColumns.length; i++) {
          const visibleColumn = visibleColumns[i];
          let columnWidth = that._getNotTruncatedColumnWidth(visibleColumn, rootElementWidth, visibleContentColumns, columnsCanFit);
          const columnId = getColumnId(that, visibleColumn);
          const widthOption = that._columnsController.columnOption(columnId, "width");
          const minWidth = that._columnsController.columnOption(columnId, "minWidth");
          const columnBestFitWidth = that._columnsController.columnOption(columnId, "bestFitWidth");
          if ("adaptiveHidden" === resultWidths[i]) {
            hasHiddenColumns = true;
            continue;
          }
          if (!columnWidth && !visibleColumn.command && !visibleColumn.fixed) {
            needHideColumn = true;
            break;
          }
          if (!widthOption || "auto" === widthOption) {
            columnWidth = Math.max(columnBestFitWidth || 0, minWidth || 0);
          }
          if ("adaptive" !== visibleColumn.command || hasHiddenColumns) {
            totalWidth += columnWidth;
          }
        }
        needHideColumn = needHideColumn || totalWidth > getWidth($rootElement);
        if (needHideColumn) {
          const column = hiddenQueue.pop();
          const visibleIndex = that._columnsController.getVisibleIndex(column.index);
          rootElementWidth += that._calculateColumnWidth(column, rootElementWidth, visibleContentColumns, columnsCanFit);
          that._hideVisibleColumn({
            visibleIndex
          });
          resultWidths[visibleIndex] = "adaptiveHidden";
          this._hiddenColumns.push(column);
          visibleContentColumns = getVisibleContentColumns();
        }
      } while (needHideColumn && visibleContentColumns.length > 1 && hiddenQueue.length);
      if (contentColumnsCount === visibleContentColumns.length) {
        that._hideAdaptiveColumn(resultWidths, visibleColumns);
      }
    } else {
      that._hideAdaptiveColumn(resultWidths, visibleColumns);
    }
  }
  getAdaptiveDetailItems() {
    return this._$itemContents;
  }
  getItemContentByColumnIndex(visibleColumnIndex) {
    let $itemContent;
    for (let i = 0; i < this._$itemContents.length; i++) {
      $itemContent = this._$itemContents.eq(i);
      const item = $itemContent.data("dx-form-item");
      if (item && item.column && this._columnsController.getVisibleIndex(item.column.index) === visibleColumnIndex) {
        return $itemContent;
      }
    }
  }
  toggleExpandAdaptiveDetailRow(key, alwaysExpanded) {
    if (!(this.isFormOrPopupEditMode() && this._editingController.isEditing())) {
      this._dataController.toggleExpandAdaptiveDetailRow(key, alwaysExpanded);
    }
  }
  createFormByHiddenColumns(container, options2) {
    const that = this;
    const $container = renderer_default(container);
    const userFormOptions = {
      items: that._getFormItemsByHiddenColumns(that._hiddenColumns),
      formID: `dx-${new guid_default2()}`
    };
    const defaultFormOptions = isMaterial() ? {
      colCount: 2
    } : {};
    this.executeAction("onAdaptiveDetailRowPreparing", {
      formOptions: userFormOptions
    });
    that._$itemContents = null;
    that._form = that._createComponent(renderer_default("<div>").appendTo($container), form_default, extend(defaultFormOptions, userFormOptions, {
      customizeItem(item) {
        const column = item.column || that._columnsController.columnOption(item.name || item.dataField);
        if (column) {
          item.label = item.label || {};
          item.label.text = item.label.text || column.caption;
          item.column = column;
          item.template = that._getTemplate(item, options2, that.updateForm.bind(that));
        }
        userFormOptions.customizeItem && userFormOptions.customizeItem.call(this, item);
      },
      onContentReady(e) {
        userFormOptions.onContentReady && userFormOptions.onContentReady.call(this, e);
        that._$itemContents = $container.find(".dx-field-item-content");
      }
    }));
  }
  hasAdaptiveDetailRowExpanded() {
    return isDefined(this._dataController.adaptiveExpandedKey());
  }
  updateForm(hiddenColumns) {
    if (this.hasAdaptiveDetailRowExpanded()) {
      if (this._form && isDefined(this._form._contentReadyAction)) {
        if (hiddenColumns && hiddenColumns.length) {
          this._form.option("items", this._getFormItemsByHiddenColumns(hiddenColumns));
        } else {
          this._form.repaint();
        }
      }
    }
  }
  updateHidingQueue(columns7) {
    const that = this;
    const hideableColumns = columns7.filter((column) => column.visible && !column.type && !column.fixed && !(isDefined(column.groupIndex) && column.groupIndex >= 0));
    let columnsHasHidingPriority;
    let i;
    that._hidingColumnsQueue = [];
    if (that.option("allowColumnResizing") && "widget" === that.option("columnResizingMode")) {
      return that._hidingColumnsQueue;
    }
    for (i = 0; i < hideableColumns.length; i++) {
      if (isDefined(hideableColumns[i].hidingPriority) && hideableColumns[i].hidingPriority >= 0) {
        columnsHasHidingPriority = true;
        that._hidingColumnsQueue[hideableColumns[i].hidingPriority] = hideableColumns[i];
      }
    }
    if (columnsHasHidingPriority) {
      that._hidingColumnsQueue.reverse();
    } else if (that.option("columnHidingEnabled")) {
      for (i = 0; i < hideableColumns.length; i++) {
        const visibleIndex = that._columnsController.getVisibleIndex(hideableColumns[i].index);
        that._hidingColumnsQueue[visibleIndex] = hideableColumns[i];
      }
    }
    that._hidingColumnsQueue = that._hidingColumnsQueue.filter(Object);
    return that._hidingColumnsQueue;
  }
  getHiddenColumns() {
    return this._hiddenColumns;
  }
  hasHiddenColumns() {
    return this._hiddenColumns.length > 0;
  }
  getHidingColumnsQueue() {
    return this._hidingColumnsQueue;
  }
  isAdaptiveDetailRowExpanded(key) {
    const dataController2 = this._dataController;
    return dataController2.adaptiveExpandedKey() && equalByValue(dataController2.adaptiveExpandedKey(), key);
  }
  expandAdaptiveDetailRow(key) {
    if (!this.hasAdaptiveDetailRowExpanded()) {
      this.toggleExpandAdaptiveDetailRow(key);
    }
  }
  collapseAdaptiveDetailRow() {
    if (this.hasAdaptiveDetailRowExpanded()) {
      this.toggleExpandAdaptiveDetailRow();
    }
  }
  updateCommandAdaptiveAriaLabel(key, label) {
    const rowIndex = this._dataController.getRowIndexByKey(key);
    if (-1 === rowIndex) {
      return;
    }
    const $row = renderer_default(this.component.getRowElement(rowIndex));
    this.setCommandAdaptiveAriaLabel($row, label);
  }
  setCommandAdaptiveAriaLabel($row, labelName) {
    const $adaptiveCommand = $row.find(".dx-command-adaptive");
    $adaptiveCommand.attr("aria-label", message_default.format(labelName));
  }
};
var keyboardNavigation2 = (Base) => class extends Base {
  _isCellValid($cell, isClick) {
    return super._isCellValid($cell, isClick) && !$cell.hasClass(this.addWidgetPrefix("hidden-column")) && !$cell.hasClass("dx-command-adaptive-hidden");
  }
  _processNextCellInMasterDetail($nextCell, $cell) {
    super._processNextCellInMasterDetail($nextCell, $cell);
    const isCellOrBatchMode = this._editingController.isCellOrBatchEditMode();
    const isEditing = this._editingController.isEditing();
    if (isEditing && $nextCell && isCellOrBatchMode && !this._isInsideEditForm($nextCell)) {
      m_events_engine_default.off($nextCell, "focus", focusCellHandler);
      m_events_engine_default.on($nextCell, "focus", {
        $nextCell
      }, focusCellHandler);
      m_events_engine_default.trigger($cell, "focus");
    }
  }
  isFocusableColumn(column) {
    return super.isFocusableColumn(column) && "adaptiveHidden" !== column.visibleWidth;
  }
  _isCellElement($cell) {
    return super._isCellElement($cell) || $cell.hasClass("dx-adaptive-item-text");
  }
};
var rowsView14 = (Base) => class extends Base {
  _getCellTemplate(options2) {
    const that = this;
    const {
      column
    } = options2;
    if ("detailAdaptive" === options2.rowType && "detail" === column.command) {
      return function(container, options3) {
        that._adaptiveColumnsController.createFormByHiddenColumns(renderer_default(container), options3);
      };
    }
    return super._getCellTemplate(options2);
  }
  _createRow(row) {
    const $row = super._createRow.apply(this, arguments);
    if (row && "detailAdaptive" === row.rowType && row.key === this._dataController.adaptiveExpandedKey()) {
      $row.addClass("dx-adaptive-detail-row");
    }
    return $row;
  }
  _renderCells($row, options2) {
    super._renderCells($row, options2);
    const adaptiveColumnsController = this._adaptiveColumnsController;
    const hidingColumnsQueueLength = adaptiveColumnsController.getHidingColumnsQueue().length;
    const hiddenColumnsLength = adaptiveColumnsController.getHiddenColumns().length;
    if (hidingColumnsQueueLength && !hiddenColumnsLength) {
      getDataCellElements($row).last().addClass("dx-last-data-cell");
    }
    if ("data" === options2.row.rowType) {
      adaptiveColumnsController.setCommandAdaptiveAriaLabel($row, EXPAND_ARIA_NAME);
    }
  }
  _getColumnIndexByElementCore($element) {
    const $itemContent = $element.closest(".dx-field-item-content");
    if ($itemContent.length && $itemContent.closest(this.component.$element()).length) {
      const formItem = $itemContent.length ? $itemContent.first().data("dx-form-item") : null;
      return formItem && formItem.column && this._columnsController.getVisibleIndex(formItem.column.index);
    }
    return super._getColumnIndexByElementCore($element);
  }
  _cellPrepared($cell, options2) {
    super._cellPrepared.apply(this, arguments);
    if ("detailAdaptive" !== options2.row.rowType && "adaptiveHidden" === options2.column.visibleWidth) {
      $cell.addClass(this.addWidgetPrefix("hidden-column"));
    }
  }
  getCell(cellPosition, rows) {
    const item = this._dataController.items()[null === cellPosition || void 0 === cellPosition ? void 0 : cellPosition.rowIndex];
    if ("detailAdaptive" === (null === item || void 0 === item ? void 0 : item.rowType)) {
      const $adaptiveDetailItems = this._adaptiveColumnsController.getAdaptiveDetailItems();
      return super.getCell(cellPosition, rows, $adaptiveDetailItems);
    }
    return super.getCell.apply(this, arguments);
  }
  _getCellElement(rowIndex, columnIdentifier) {
    const item = this._dataController.items()[rowIndex];
    if (item && "detailAdaptive" === item.rowType) {
      return this._adaptiveColumnsController.getItemContentByColumnIndex(columnIdentifier);
    }
    return super._getCellElement.apply(this, arguments);
  }
  getContextMenuItems(options2) {
    var _super$getContextMenu;
    if (options2.row && "detailAdaptive" === options2.row.rowType) {
      const view = this._columnHeadersView;
      const formItem = renderer_default(options2.targetElement).closest(".dx-field-item-label").next().data("dx-form-item");
      options2.column = formItem ? formItem.column : options2.column;
      return view.getContextMenuItems && view.getContextMenuItems(options2);
    }
    return null === (_super$getContextMenu = super.getContextMenuItems) || void 0 === _super$getContextMenu ? void 0 : _super$getContextMenu.call(this, options2);
  }
  isClickableElement($target) {
    var _super$isClickableEle;
    const isClickable = (null === (_super$isClickableEle = super.isClickableElement) || void 0 === _super$isClickableEle ? void 0 : _super$isClickableEle.call(this, $target)) ?? false;
    return isClickable || !!$target.closest(".dx-command-adaptive").length;
  }
};
var exportExtender = (Base) => class extends Base {
  _updateColumnWidth(column, width) {
    super._updateColumnWidth(column, "adaptiveHidden" === column.visibleWidth ? column.bestFitWidth : width);
  }
};
var columnsResizer4 = (Base) => class extends Base {
  _pointCreated(point, cellsLength, columns7) {
    const result2 = super._pointCreated(point, cellsLength, columns7);
    const currentColumn = columns7[point.columnIndex] || {};
    const nextColumnIndex = this._getNextColumnIndex(point.columnIndex);
    const nextColumn = columns7[nextColumnIndex] || {};
    const hasHiddenColumnsOnly = nextColumnIndex !== point.columnIndex + 1 && nextColumn.command;
    const hasAdaptiveHiddenWidth = "adaptiveHidden" === currentColumn.visibleWidth || hasHiddenColumnsOnly;
    return result2 || hasAdaptiveHiddenWidth;
  }
  _getNextColumnIndex(currentColumnIndex) {
    const visibleColumns = this._columnsController.getVisibleColumns();
    let index2 = super._getNextColumnIndex(currentColumnIndex);
    while (visibleColumns[index2] && "adaptiveHidden" === visibleColumns[index2].visibleWidth) {
      index2++;
    }
    return index2;
  }
};
var draggingHeader3 = (Base) => class extends Base {
  _pointCreated(point, columns7, location, sourceColumn) {
    const result2 = super._pointCreated(point, columns7, location, sourceColumn);
    const column = columns7[point.columnIndex - 1] || {};
    const hasAdaptiveHiddenWidth = "adaptiveHidden" === column.visibleWidth;
    return result2 || hasAdaptiveHiddenWidth;
  }
};
var editing4 = (Base) => class extends Base {
  _isRowEditMode() {
    return "row" === this.getEditMode();
  }
  _getFormEditItemTemplate(cellOptions, column) {
    if ("row" !== this.getEditMode() && "detailAdaptive" === cellOptions.rowType) {
      cellOptions.columnIndex = this._columnsController.getVisibleIndex(column.index);
      return this.getColumnTemplate(cellOptions);
    }
    return super._getFormEditItemTemplate(cellOptions, column);
  }
  _closeEditItem($targetElement) {
    const $itemContents = $targetElement.closest(".dx-field-item-content");
    const rowIndex = this._dataController.getRowIndexByKey(this._dataController.adaptiveExpandedKey()) + 1;
    const formItem = $itemContents.length ? $itemContents.first().data("dx-form-item") : null;
    const columnIndex = formItem && formItem.column && this._columnsController.getVisibleIndex(formItem.column.index);
    if (!this.isEditCell(rowIndex, columnIndex)) {
      super._closeEditItem($targetElement);
    }
  }
  _beforeUpdateItems(rowIndices, rowIndex) {
    if (!this._adaptiveColumnsController.isFormOrPopupEditMode() && this._adaptiveColumnsController.hasHiddenColumns()) {
      const items = this._dataController.items();
      const item = items[rowIndex];
      const oldExpandRowIndex = m_utils_default.getIndexByKey(this._dataController.adaptiveExpandedKey(), items);
      this._isForceRowAdaptiveExpand = !this._adaptiveColumnsController.hasAdaptiveDetailRowExpanded();
      if (oldExpandRowIndex >= 0) {
        rowIndices.push(oldExpandRowIndex + 1);
      }
      rowIndices.push(rowIndex + 1);
      this._dataController.adaptiveExpandedKey(item.key);
    }
  }
  _afterInsertRow(key) {
    super._afterInsertRow.apply(this, arguments);
    if (this._adaptiveColumnsController.hasHiddenColumns()) {
      this._adaptiveColumnsController.toggleExpandAdaptiveDetailRow(key, this.isRowEditMode());
      this._isForceRowAdaptiveExpand = true;
    }
  }
  _collapseAdaptiveDetailRow() {
    if (this._isRowEditMode() && this._isForceRowAdaptiveExpand) {
      this._adaptiveColumnsController.collapseAdaptiveDetailRow();
      this._isForceRowAdaptiveExpand = false;
    }
  }
  _cancelEditAdaptiveDetailRow() {
    if (this._adaptiveColumnsController.hasHiddenColumns()) {
      this._collapseAdaptiveDetailRow();
    }
  }
  _afterSaveEditData() {
    super._afterSaveEditData.apply(this, arguments);
    const deferred = new Deferred();
    if (this._isRowEditMode() && this._adaptiveColumnsController.hasHiddenColumns()) {
      when(this._validatingController.validate(true)).done((isValid) => {
        if (isValid) {
          this._cancelEditAdaptiveDetailRow();
        }
        deferred.resolve();
      });
    } else {
      deferred.resolve();
    }
    return deferred.promise();
  }
  _beforeCancelEditData() {
    super._beforeCancelEditData();
    this._cancelEditAdaptiveDetailRow();
  }
  _getRowIndicesForCascadeUpdating(row) {
    const rowIndices = super._getRowIndicesForCascadeUpdating.apply(this, arguments);
    if (this._adaptiveColumnsController.isAdaptiveDetailRowExpanded(row.key)) {
      rowIndices.push("detailAdaptive" === row.rowType ? row.rowIndex - 1 : row.rowIndex + 1);
    }
    return rowIndices;
  }
  _beforeCloseEditCellInBatchMode(rowIndices) {
    const expandedKey = this._dataController._adaptiveExpandedKey;
    if (expandedKey) {
      const rowIndex = m_utils_default.getIndexByKey(expandedKey, this._dataController.items());
      if (rowIndex > -1) {
        rowIndices.unshift(rowIndex);
      }
    }
  }
  editRow(rowIndex) {
    if (this._adaptiveColumnsController.isFormOrPopupEditMode()) {
      this._adaptiveColumnsController.collapseAdaptiveDetailRow();
    }
    return super.editRow(rowIndex);
  }
  deleteRow(rowIndex) {
    const rowKey = this._dataController.getKeyByRowIndex(rowIndex);
    if ("batch" === this.getEditMode() && this._adaptiveColumnsController.isAdaptiveDetailRowExpanded(rowKey)) {
      this._adaptiveColumnsController.collapseAdaptiveDetailRow();
    }
    super.deleteRow(rowIndex);
  }
};
var data14 = (Base) => class extends Base {
  init() {
    super.init();
    this._adaptiveExpandedKey = void 0;
  }
  _processItems(items, change) {
    const {
      changeType
    } = change;
    items = super._processItems.apply(this, arguments);
    if ("loadingAll" === changeType || !isDefined(this._adaptiveExpandedKey)) {
      return items;
    }
    const expandRowIndex = m_utils_default.getIndexByKey(this._adaptiveExpandedKey, items);
    const newMode = false === this.option(LEGACY_SCROLLING_MODE5);
    if (expandRowIndex >= 0) {
      const item = items[expandRowIndex];
      items.splice(expandRowIndex + 1, 0, {
        visible: true,
        rowType: "detailAdaptive",
        key: item.key,
        data: item.data,
        node: item.node,
        modifiedValues: item.modifiedValues,
        isNewRow: item.isNewRow,
        values: item.values
      });
    } else if ("refresh" === changeType && !(newMode && change.repaintChangesOnly)) {
      this._adaptiveExpandedKey = void 0;
    }
    return items;
  }
  _getRowIndicesForExpand(key) {
    const rowIndices = super._getRowIndicesForExpand.apply(this, arguments);
    if (this._adaptiveColumnsController.isAdaptiveDetailRowExpanded(key)) {
      const lastRowIndex = rowIndices[rowIndices.length - 1];
      rowIndices.push(lastRowIndex + 1);
    }
    return rowIndices;
  }
  adaptiveExpandedKey(value2) {
    if (isDefined(value2)) {
      this._adaptiveExpandedKey = value2;
    } else {
      return this._adaptiveExpandedKey;
    }
  }
  toggleExpandAdaptiveDetailRow(key, alwaysExpanded) {
    let oldExpandLoadedRowIndex = m_utils_default.getIndexByKey(this._adaptiveExpandedKey, this._items);
    let newExpandLoadedRowIndex = m_utils_default.getIndexByKey(key, this._items);
    if (oldExpandLoadedRowIndex >= 0 && oldExpandLoadedRowIndex === newExpandLoadedRowIndex && !alwaysExpanded) {
      key = void 0;
      newExpandLoadedRowIndex = -1;
    }
    const oldKey = this._adaptiveExpandedKey;
    this._adaptiveExpandedKey = key;
    if (oldExpandLoadedRowIndex >= 0) {
      oldExpandLoadedRowIndex++;
    }
    if (newExpandLoadedRowIndex >= 0) {
      newExpandLoadedRowIndex++;
    }
    const rowIndexDelta = this.getRowIndexDelta();
    this.updateItems({
      allowInvisibleRowIndices: true,
      changeType: "update",
      rowIndices: [oldExpandLoadedRowIndex - rowIndexDelta, newExpandLoadedRowIndex - rowIndexDelta]
    });
    this._adaptiveColumnsController.updateCommandAdaptiveAriaLabel(key, COLLAPSE_ARIA_NAME);
    this._adaptiveColumnsController.updateCommandAdaptiveAriaLabel(oldKey, EXPAND_ARIA_NAME);
  }
};
var editorFactory4 = (Base) => class extends Base {
  _needHideBorder($element) {
    return super._needHideBorder($element) || (null === $element || void 0 === $element ? void 0 : $element.hasClass("dx-field-item-content")) && (null === $element || void 0 === $element ? void 0 : $element.find(".dx-checkbox").length);
  }
  _getFocusCellSelector() {
    return `${super._getFocusCellSelector()}, .dx-adaptive-detail-row .dx-field-item > .dx-field-item-content`;
  }
  _getRevertTooltipsSelector() {
    return `${super._getRevertTooltipsSelector()}, .dx-field-item-content .${this.addWidgetPrefix("revert-tooltip")}`;
  }
};
var columns4 = (Base) => class extends Base {
  _isColumnVisible(column) {
    return super._isColumnVisible(column) && !column.adaptiveHidden;
  }
  getVisibleDataColumnsByBandColumn(bandColumnIndex) {
    return super.getVisibleDataColumnsByBandColumn(bandColumnIndex).filter((column) => "adaptiveHidden" !== column.visibleWidth);
  }
};
var resizing6 = (Base) => class extends Base {
  dispose() {
    super.dispose.apply(this, arguments);
    clearTimeout(this._updateScrollableTimeoutID);
  }
  _needBestFit() {
    return super._needBestFit() || !!this._adaptiveColumnsController.getHidingColumnsQueue().length;
  }
  _correctColumnWidths(resultWidths, visibleColumns) {
    const adaptiveController = this._adaptiveColumnsController;
    const oldHiddenColumns = adaptiveController.getHiddenColumns();
    const hidingColumnsQueue = adaptiveController.updateHidingQueue(this._columnsController.getColumns());
    adaptiveController.hideRedundantColumns(resultWidths, visibleColumns, hidingColumnsQueue);
    const hiddenColumns = adaptiveController.getHiddenColumns();
    if (adaptiveController.hasAdaptiveDetailRowExpanded()) {
      if (oldHiddenColumns.length !== hiddenColumns.length) {
        adaptiveController.updateForm(hiddenColumns);
      }
    }
    !hiddenColumns.length && adaptiveController.collapseAdaptiveDetailRow();
    return super._correctColumnWidths.apply(this, arguments);
  }
  _toggleBestFitMode(isBestFit) {
    isBestFit && this._adaptiveColumnsController._showHiddenColumns();
    super._toggleBestFitMode(isBestFit);
  }
  _needStretch() {
    const adaptiveColumnsController = this._adaptiveColumnsController;
    return super._needStretch.apply(this, arguments) || adaptiveColumnsController.getHidingColumnsQueue().length || adaptiveColumnsController.hasHiddenColumns();
  }
};
var headersKeyboardNavigation3 = (Base) => class extends Base {
  getColumnVisibleIndexCorrection(visibleIndex, rowIndex, direction) {
    let indexCorrection = super.getColumnVisibleIndexCorrection(visibleIndex, rowIndex, direction);
    let visibleColumns = this._columnsController.getVisibleColumns(rowIndex);
    visibleColumns = "next" === direction ? visibleColumns.slice(visibleIndex + 1) : visibleColumns.slice(0, visibleIndex).reverse();
    while ("adaptiveHidden" === (null === (_visibleColumns = visibleColumns) || void 0 === _visibleColumns || null === (_visibleColumns = _visibleColumns.shift()) || void 0 === _visibleColumns ? void 0 : _visibleColumns.visibleWidth)) {
      var _visibleColumns;
      indexCorrection += "next" === direction ? 1 : -1;
    }
    return indexCorrection;
  }
  getFocusableColumns(rowIndex, bandColumnId) {
    return super.getFocusableColumns(rowIndex, bandColumnId).filter((col) => "adaptiveHidden" !== col.visibleWidth);
  }
  getDraggableColumns(column, rowIndex) {
    return super.getDraggableColumns(column, rowIndex).filter((col) => "adaptiveHidden" !== col.visibleWidth);
  }
};
var adaptivityModule = {
  defaultOptions: () => ({
    columnHidingEnabled: false,
    onAdaptiveDetailRowPreparing: null
  }),
  controllers: {
    adaptiveColumns: AdaptiveColumnsController
  },
  extenders: {
    views: {
      rowsView: rowsView14
    },
    controllers: {
      export: exportExtender,
      columnsResizer: columnsResizer4,
      draggingHeader: draggingHeader3,
      editing: editing4,
      resizing: resizing6,
      data: data14,
      editorFactory: editorFactory4,
      columns: columns4,
      keyboardNavigation: keyboardNavigation2,
      headersKeyboardNavigation: headersKeyboardNavigation3
    }
  }
};

// node_modules/devextreme/esm/__internal/grids/data_grid/module_not_extended/adaptivity.js
m_core_default.registerModule("adaptivity", adaptivityModule);

// node_modules/devextreme/esm/__internal/grids/grid_core/virtual_columns/m_virtual_columns_core.js
function foreachColumnInfo(info, callback, rowIndex, offsets, columnCount, lastProcessedIndexes) {
  rowIndex = rowIndex || 0;
  offsets = offsets || [];
  lastProcessedIndexes = lastProcessedIndexes || [];
  offsets[rowIndex] = offsets[rowIndex] || 0;
  const row = info[rowIndex];
  const startIndex = lastProcessedIndexes[rowIndex] + 1 || 0;
  let processedColumnCount = 0;
  let colIndex;
  if (!row) {
    return;
  }
  for (colIndex = startIndex; colIndex < row.length; colIndex++) {
    const cell = row[colIndex];
    const visibleIndex = colIndex + offsets[rowIndex];
    const colspan = cell.colspan || 1;
    foreachColumnInfo(info, callback, rowIndex + (cell.rowspan || 1), offsets, colspan, lastProcessedIndexes);
    offsets[rowIndex] += colspan - 1;
    processedColumnCount += colspan;
    if (cell.rowspan) {
      for (let i = rowIndex + 1; i < rowIndex + cell.rowspan; i++) {
        offsets[i] = offsets[i] || 0;
        offsets[i] += cell.colspan || 1;
      }
    }
    if (false === callback(cell, visibleIndex, rowIndex, colIndex)) {
      break;
    }
    if (void 0 !== columnCount && processedColumnCount >= columnCount) {
      break;
    }
  }
  lastProcessedIndexes[rowIndex] = colIndex;
}
function createColumnsInfo(info, startIndex, endIndex) {
  const newInfo = [];
  foreachColumnInfo(info, (columnInfo, visibleIndex, rowIndex) => {
    let cell = columnInfo;
    let colspan;
    const cellColspan = cell.colspan || 1;
    const isVisible2 = visibleIndex + cellColspan - 1 >= startIndex && visibleIndex < endIndex;
    newInfo[rowIndex] = newInfo[rowIndex] || [];
    if (isVisible2) {
      if (visibleIndex < startIndex) {
        colspan = cellColspan - (startIndex - visibleIndex);
        visibleIndex = startIndex;
      } else {
        colspan = cellColspan;
      }
      if (visibleIndex + colspan > endIndex) {
        colspan = endIndex - visibleIndex;
      }
      if (colspan !== cellColspan) {
        cell = extend({}, cell, {
          colspan
        });
      }
      newInfo[rowIndex].push(cell);
    } else if (visibleIndex > endIndex) {
      return false;
    }
    return;
  });
  for (let i = 0; i < newInfo.length; i++) {
    newInfo[i] = newInfo[i] || [];
  }
  return newInfo;
}

// node_modules/devextreme/esm/__internal/grids/grid_core/virtual_columns/m_virtual_columns.js
var baseView = (Base) => class extends Base {
  _needToSetCellWidths() {
    let result2 = super._needToSetCellWidths();
    if (!result2 && this._columnsController.isVirtualMode()) {
      const columns7 = this._columnsController.getColumns();
      result2 = columns7.some((column) => "auto" === column.width);
    }
    return result2;
  }
};
var rowsView15 = (Base) => class extends baseView(Base) {
  _resizeCore() {
    super._resizeCore.apply(this, arguments);
    this._columnsController.resize();
  }
  _handleScroll(e) {
    const scrollable = this.getScrollable();
    let {
      left
    } = e.scrollOffset;
    this._scrollLeft = left;
    super._handleScroll.apply(this, arguments);
    if (this.option("rtlEnabled") && scrollable) {
      left = getWidth(scrollable.$content()) - getWidth(scrollable.$element()) - left;
    }
    this._columnsController.setScrollPosition(left, e.event);
  }
  _renderCore(e) {
    if (null !== e && void 0 !== e && e.virtualColumnsScrolling) {
      var _this$_columnsControl, _this$_scrollable;
      const $contentElement = this._findContentElement();
      const fixedColumns = null === (_this$_columnsControl = this._columnsController) || void 0 === _this$_columnsControl ? void 0 : _this$_columnsControl.getFixedColumns();
      const useNativeScrolling = null === (_this$_scrollable = this._scrollable) || void 0 === _this$_scrollable ? void 0 : _this$_scrollable.option("useNative");
      const legacyMode = this.option("columnFixing.legacyMode");
      if (null !== fixedColumns && void 0 !== fixedColumns && fixedColumns.length) {
        if (legacyMode && !useNativeScrolling) {
          $contentElement.css({
            minHeight: m_utils_default.getContentHeightLimit(browser_default)
          });
        } else {
          $contentElement.css({
            minHeight: getHeight($contentElement)
          });
        }
        const resizeCompletedHandler = () => {
          this.resizeCompleted.remove(resizeCompletedHandler);
          $contentElement.css({
            minHeight: ""
          });
        };
        this.resizeCompleted.add(resizeCompletedHandler);
      }
    }
    return super._renderCore.apply(this, arguments);
  }
};
var columnHeadersView9 = (Base) => class extends baseView(Base) {
  _renderCore() {
    const deferred = super._renderCore.apply(this, arguments);
    if (this._columnsController.isVirtualMode()) {
      this._updateScrollLeftPosition();
    }
    return deferred;
  }
};
var getWidths = function(columns7) {
  return columns7.map((column) => column.visibleWidth || parseFloat(column.width) || 50);
};
var columns5 = (Base) => class extends Base {
  init() {
    super.init.apply(this, arguments);
    this._resizingController = this.getController("resizing");
    this._beginPageIndex = null;
    this._endPageIndex = null;
    this._position ?? (this._position = 0);
    this._virtualVisibleColumns = {};
  }
  dispose() {
    clearTimeout(this._changedTimeout);
    super.dispose.apply(this, arguments);
  }
  resetColumnsCache() {
    super.resetColumnsCache();
    this._virtualVisibleColumns = {};
  }
  getBeginPageIndex(position3) {
    const visibleColumns = this.getVisibleColumns(void 0, true);
    const widths = getWidths(visibleColumns);
    let currentPosition = 0;
    for (let index2 = 0; index2 < widths.length; index2++) {
      if (currentPosition >= position3) {
        return Math.floor(index2 / this.getColumnPageSize());
      }
      currentPosition += widths[index2];
    }
    return 0;
  }
  getTotalWidth() {
    const width = this.option("width");
    if ("number" === typeof width) {
      return width;
    }
    return this._resizingController._lastWidth || getOuterWidth(this.component.$element());
  }
  getEndPageIndex(position3) {
    const visibleColumns = this.getVisibleColumns(void 0, true);
    const widths = getWidths(visibleColumns);
    let currentPosition = 0;
    position3 += this.getTotalWidth();
    for (let index2 = 0; index2 < widths.length; index2++) {
      if (currentPosition >= position3) {
        return Math.ceil(index2 / this.getColumnPageSize());
      }
      currentPosition += widths[index2];
    }
    return Math.ceil(widths.length / this.getColumnPageSize());
  }
  getColumnPageSize() {
    return this.option("scrolling.columnPageSize");
  }
  _fireColumnsChanged(event) {
    const date = /* @__PURE__ */ new Date();
    this.columnsChanged.fire({
      optionNames: {
        all: true,
        length: 1
      },
      changeTypes: {
        columns: true,
        virtualColumnsScrolling: true,
        length: 2,
        event
      }
    });
    this._renderTime = /* @__PURE__ */ new Date() - date;
  }
  getScrollingTimeout() {
    const renderingThreshold = this.option("scrolling.columnRenderingThreshold");
    const renderAsync = this.option("scrolling.renderAsync");
    let scrollingTimeout = 0;
    if (!isDefined(renderAsync) && this._renderTime > renderingThreshold || renderAsync) {
      scrollingTimeout = this.option("scrolling.timeout");
    }
    return scrollingTimeout;
  }
  setScrollPosition(position3, event) {
    const scrollingTimeout = this.getScrollingTimeout();
    if (scrollingTimeout > 0) {
      clearTimeout(this._changedTimeout);
      this._changedTimeout = setTimeout(() => {
        this._setScrollPositionCore(position3, event);
      }, scrollingTimeout);
    } else {
      this._setScrollPositionCore(position3, event);
    }
  }
  resize() {
    this._setScrollPositionCore(this._position);
  }
  _setScrollPositionCore(position3, event) {
    const needColumnsChanged = this.isNeedToRenderVirtualColumns(position3);
    if (needColumnsChanged) {
      this._position = position3;
      this._beginPageIndex = this.getBeginPageIndex(position3);
      this._endPageIndex = this.getEndPageIndex(position3);
      this._fireColumnsChanged(event);
    }
  }
  isNeedToRenderVirtualColumns(scrollPosition) {
    if (this.isVirtualMode()) {
      if (scrollPosition < this._position) {
        return this._beginPageIndex > this.getBeginPageIndex(scrollPosition);
      }
      return this._endPageIndex < this.getEndPageIndex(scrollPosition);
    }
    return false;
  }
  getFixedColumns(rowIndex, isBase) {
    const fixedColumns = super.getFixedColumns(rowIndex);
    if (this.isVirtualMode() && !isBase && fixedColumns.length) {
      const transparentColumnIndex = fixedColumns.map((c) => c.command).indexOf("transparent");
      fixedColumns[transparentColumnIndex].colspan = this.getVisibleColumns().length - super.getFixedColumns().length + 1;
      return fixedColumns;
    }
    return fixedColumns;
  }
  _compileVisibleColumns(rowIndex, isBase) {
    var _this$_columns;
    if (isBase || !this.isVirtualMode() || !this._shouldReturnVisibleColumns()) {
      return super._compileVisibleColumns(rowIndex);
    }
    if (null !== (_this$_columns = this._columns) && void 0 !== _this$_columns && _this$_columns.length && !isDefined(this._beginPageIndex) && !isDefined(this._endPageIndex)) {
      this._beginPageIndex = this.getBeginPageIndex(this._position);
      this._endPageIndex = this.getEndPageIndex(this._position);
    }
    const beginPageIndex = this._beginPageIndex;
    const endPageIndex = this._endPageIndex;
    const visibleColumnsHash = `${rowIndex}-${beginPageIndex}-${endPageIndex}`;
    if (this._virtualVisibleColumns[visibleColumnsHash]) {
      return this._virtualVisibleColumns[visibleColumnsHash];
    }
    let visibleColumns = super._compileVisibleColumns();
    const rowCount = this.getRowCount();
    const pageSize = this.getColumnPageSize();
    let startIndex = beginPageIndex * pageSize;
    let endIndex = endPageIndex * pageSize;
    const fixedColumns = this.getFixedColumns(void 0, true);
    const transparentColumnIndex = fixedColumns.map((c) => c.command).indexOf("transparent");
    const beginFixedColumnCount = fixedColumns.length ? transparentColumnIndex : 0;
    let beginFixedColumns = visibleColumns.slice(0, beginFixedColumnCount);
    const beginColumns = visibleColumns.slice(beginFixedColumnCount, startIndex);
    const beginWidth = getWidths(beginColumns).reduce((a, b) => a + b, 0);
    if (!beginWidth) {
      startIndex = 0;
    }
    const endFixedColumnCount = fixedColumns.length ? fixedColumns.length - transparentColumnIndex - 1 : 0;
    let endFixedColumns = visibleColumns.slice(visibleColumns.length - endFixedColumnCount);
    const endColumns = visibleColumns.slice(endIndex, visibleColumns.length - endFixedColumnCount);
    const endWidth = getWidths(endColumns).reduce((a, b) => a + b, 0);
    if (!endWidth) {
      endIndex = visibleColumns.length;
    }
    if (rowCount > 1 && "number" === typeof rowIndex) {
      const columnsInfo = [];
      for (let i = 0; i <= rowCount; i++) {
        columnsInfo.push(super._compileVisibleColumns(i));
      }
      beginFixedColumns = createColumnsInfo(columnsInfo, 0, beginFixedColumns.length)[rowIndex] || [];
      endFixedColumns = createColumnsInfo(columnsInfo, visibleColumns.length - endFixedColumns.length, visibleColumns.length)[rowIndex] || [];
      visibleColumns = createColumnsInfo(columnsInfo, startIndex, endIndex)[rowIndex] || [];
    } else {
      visibleColumns = visibleColumns.slice(startIndex, endIndex);
    }
    if (beginWidth) {
      visibleColumns.unshift({
        command: "virtual",
        type: "virtual",
        width: beginWidth
      });
      visibleColumns = beginFixedColumns.concat(visibleColumns);
    }
    if (endWidth) {
      visibleColumns.push({
        command: "virtual",
        type: "virtual",
        width: endWidth
      });
      visibleColumns = visibleColumns.concat(endFixedColumns);
    }
    this._virtualVisibleColumns[visibleColumnsHash] = visibleColumns;
    return visibleColumns;
  }
  getColumnIndexOffset() {
    let offset2 = 0;
    if (this._beginPageIndex > 0) {
      const fixedColumns = this.getFixedColumns();
      const transparentColumnIndex = fixedColumns.map((c) => c.command).indexOf("transparent");
      const leftFixedColumnCount = transparentColumnIndex >= 0 ? transparentColumnIndex : 0;
      offset2 = this._beginPageIndex * this.getColumnPageSize() - leftFixedColumnCount - 1;
    }
    return offset2 > 0 ? offset2 : 0;
  }
  isVirtualMode() {
    return hasWindow() && "virtual" === this.option("scrolling.columnRenderingMode");
  }
};
var virtualColumnsModule = {
  defaultOptions: () => ({
    scrolling: {
      columnRenderingMode: "standard",
      columnPageSize: 5,
      columnRenderingThreshold: 300
    }
  }),
  extenders: {
    controllers: {
      columns: columns5
    },
    views: {
      columnHeadersView: columnHeadersView9,
      rowsView: rowsView15
    }
  }
};

// node_modules/devextreme/esm/__internal/grids/data_grid/module_not_extended/virtual_columns.js
m_core_default.registerModule("virtualColumns", virtualColumnsModule);

// node_modules/devextreme/esm/__internal/data/data_controller/data_controller.js
var DataController3 = class {
  constructor(dataSourceOptions, _ref) {
    let {
      key
    } = _ref;
    this._isSharedDataSource = false;
    this._keyExpr = key;
    this.updateDataSource(dataSourceOptions);
  }
  _updateDataSource(dataSourceOptions) {
    if (!dataSourceOptions) {
      return;
    }
    if (dataSourceOptions instanceof DataSource) {
      this._isSharedDataSource = true;
      this._dataSource = dataSourceOptions;
    } else {
      const normalizedDataSourceOptions = normalizeDataSourceOptions(dataSourceOptions);
      this._dataSource = new DataSource(extend(true, {}, {}, normalizedDataSourceOptions));
    }
  }
  _updateDataSourceByItems(items) {
    this._dataSource = new DataSource({
      store: new m_array_store_default({
        key: this.key(),
        data: items
      }),
      pageSize: 0
    });
  }
  _disposeDataSource() {
    if (this._dataSource) {
      if (this._isSharedDataSource) {
        this._isSharedDataSource = false;
      } else {
        this._dataSource.dispose();
      }
      delete this._dataSource;
    }
  }
  load() {
    return this._dataSource.load();
  }
  loadSingle(propName, propValue) {
    if (!this._dataSource) {
      return new Deferred().reject();
    }
    let pName = propName;
    let pValue = propValue;
    if (arguments.length < 2) {
      pValue = propName;
      pName = this.key();
    }
    return this._dataSource.loadSingle(pName, pValue);
  }
  loadFromStore(loadOptions) {
    return this.store().load(loadOptions);
  }
  loadNextPage() {
    this.pageIndex(1 + this.pageIndex());
    return this.load();
  }
  loadOptions() {
    return this._dataSource.loadOptions();
  }
  userData() {
    return this._dataSource._userData;
  }
  cancel(operationId) {
    this._dataSource.cancel(operationId);
  }
  cancelAll() {
    this._dataSource.cancelAll();
  }
  filter(filter) {
    return this._dataSource.filter(filter);
  }
  addSearchFilter(storeLoadOptions) {
    this._dataSource._addSearchFilter(storeLoadOptions);
  }
  group(group) {
    return this._dataSource.group(group);
  }
  paginate() {
    return this._dataSource.paginate();
  }
  pageSize() {
    return this._dataSource._pageSize;
  }
  pageIndex(pageIndex) {
    if (void 0 === pageIndex) {
      return this._dataSource.pageIndex(void 0);
    }
    return this._dataSource.pageIndex(pageIndex);
  }
  resetDataSource() {
    this._disposeDataSource();
  }
  resetDataSourcePageIndex() {
    if (this.pageIndex()) {
      this.pageIndex(0);
      this.load();
    }
  }
  updateDataSource(items, key) {
    const dataSourceOptions = items ?? this.items();
    if (key) {
      this._keyExpr = key;
    }
    this._disposeDataSource();
    if (Array.isArray(dataSourceOptions)) {
      this._updateDataSourceByItems(dataSourceOptions);
    } else {
      this._updateDataSource(dataSourceOptions);
    }
  }
  totalCount() {
    return this._dataSource.totalCount();
  }
  isLastPage() {
    return this._dataSource.isLastPage() || !this._dataSource._pageSize;
  }
  isLoading() {
    return this._dataSource.isLoading();
  }
  isLoaded() {
    return this._dataSource.isLoaded();
  }
  searchValue(value2) {
    return this._dataSource.searchValue(value2);
  }
  searchOperation(operation) {
    return this._dataSource.searchOperation(operation);
  }
  searchExpr(expr) {
    return this._dataSource.searchExpr(expr);
  }
  select() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return this._dataSource.select(args);
  }
  key() {
    var _this$_dataSource;
    const storeKey = null === (_this$_dataSource = this._dataSource) || void 0 === _this$_dataSource ? void 0 : _this$_dataSource.key();
    return isDefined(storeKey) && "this" === this._keyExpr ? storeKey : this._keyExpr;
  }
  keyOf(item) {
    return this.store().keyOf(item);
  }
  store() {
    return this._dataSource.store();
  }
  items() {
    var _this$_dataSource2;
    return null === (_this$_dataSource2 = this._dataSource) || void 0 === _this$_dataSource2 ? void 0 : _this$_dataSource2.items();
  }
  applyMapFunction(data17) {
    return this._dataSource._applyMapFunction(data17);
  }
  getDataSource() {
    return this._dataSource ?? null;
  }
  reload() {
    return this._dataSource.reload();
  }
  on(event, handler) {
    this._dataSource.on(event, handler);
  }
  off(event, handler) {
    this._dataSource.off(event, handler);
  }
};
var data_controller_default = DataController3;

// node_modules/devextreme/esm/data_controller.js
var data_controller_default2 = data_controller_default;

// node_modules/devextreme/esm/__internal/ui/m_button_group.js
var BUTTON_GROUP_ITEM_HAS_WIDTH = "dx-buttongroup-item-has-width";
var BUTTON_GROUP_STYLING_MODE_CLASS = {
  contained: "dx-buttongroup-mode-contained",
  outlined: "dx-buttongroup-mode-outlined",
  text: "dx-buttongroup-mode-text"
};
var ButtonCollection = class extends ui_collection_widget_edit_default {
  _initTemplates() {
    super._initTemplates();
    this._templateManager.addDefaultTemplates({
      item: new BindableTemplate(($container, data17, model) => {
        this._prepareItemStyles($container);
        const template = this.option("buttonTemplate");
        this._createComponent($container, button_default2, extend({}, model, data17, this._getBasicButtonOptions(), {
          _templateData: this._hasCustomTemplate(template) ? model : {},
          template: model.template || template
        }));
      }, ["text", "type", "icon", "disabled", "visible", "hint"], this.option("integrationOptions.watchMethod"))
    });
  }
  _getBasicButtonOptions() {
    const {
      hoverStateEnabled,
      activeStateEnabled,
      stylingMode
    } = this.option();
    return {
      focusStateEnabled: false,
      onClick: null,
      hoverStateEnabled,
      activeStateEnabled,
      stylingMode
    };
  }
  _getDefaultOptions() {
    return _extends({}, super._getDefaultOptions(), {
      itemTemplateProperty: null
    });
  }
  _hasCustomTemplate(template) {
    return isFunction(template) || this.option("integrationOptions.templates")[template];
  }
  _selectedItemClass() {
    return "dx-item-selected dx-state-selected";
  }
  _prepareItemStyles($item) {
    const itemIndex = $item.data("dxItemIndex");
    if (0 === itemIndex) {
      $item.addClass("dx-buttongroup-first-item");
    }
    const {
      items
    } = this.option();
    items && itemIndex === items.length - 1 && $item.addClass("dx-buttongroup-last-item");
    $item.addClass("dx-shape-standard");
  }
  _renderItemContent(args) {
    args.container = renderer_default(args.container).parent();
    return super._renderItemContent(args);
  }
  _setAriaSelectionAttribute($target, value2) {
    this.setAria("pressed", value2, $target);
  }
  _renderItemContentByNode(args, $node) {
    args.container = renderer_default(args.container.children().first());
    return super._renderItemContentByNode(args, $node);
  }
  _focusTarget() {
    return this.$element().parent();
  }
  _keyboardEventBindingTarget() {
    return this._focusTarget();
  }
  _enterKeyHandler(e) {
    e.preventDefault();
    super._enterKeyHandler(e);
  }
  _refreshContent() {
    this._prepareContent();
    this._renderContent();
  }
  _itemClass() {
    return "dx-buttongroup-item";
  }
  _itemSelectHandler(e) {
    const {
      selectionMode
    } = this.option();
    if ("single" === selectionMode && this.isItemSelected(e.currentTarget)) {
      return;
    }
    super._itemSelectHandler(e);
  }
};
var ButtonGroup = class extends widget_default {
  _getDefaultOptions() {
    return _extends({}, super._getDefaultOptions(), {
      hoverStateEnabled: true,
      focusStateEnabled: true,
      selectionMode: "single",
      selectedItems: [],
      selectedItemKeys: [],
      stylingMode: "contained",
      keyExpr: "text",
      items: [],
      buttonTemplate: "content",
      onSelectionChanged: null,
      onItemClick: null
    });
  }
  _init() {
    super._init();
    this._createItemClickAction();
  }
  _createItemClickAction() {
    this._itemClickAction = this._createActionByOption("onItemClick");
  }
  _initMarkup() {
    this.setAria("role", "group");
    this.$element().addClass("dx-buttongroup");
    this._renderStylingMode();
    this._renderButtons();
    this._syncSelectionOptions();
    super._initMarkup();
  }
  _renderStylingMode() {
    const {
      stylingMode
    } = this.option();
    for (const key in BUTTON_GROUP_STYLING_MODE_CLASS) {
      this.$element().removeClass(BUTTON_GROUP_STYLING_MODE_CLASS[key]);
    }
    this.$element().addClass(BUTTON_GROUP_STYLING_MODE_CLASS[stylingMode ?? "contained"]);
  }
  _fireSelectionChangeEvent(addedItems, removedItems) {
    this._createActionByOption("onSelectionChanged", {
      excludeValidators: ["disabled", "readOnly"]
    })({
      addedItems,
      removedItems
    });
  }
  _renderButtons() {
    const $buttons = renderer_default("<div>").addClass("dx-buttongroup-wrapper").appendTo(this.$element());
    const {
      selectedItems
    } = this.option();
    const options2 = {
      selectionMode: this.option("selectionMode"),
      items: this.option("items"),
      keyExpr: this.option("keyExpr"),
      buttonTemplate: this.option("buttonTemplate"),
      scrollingEnabled: false,
      selectedItemKeys: this.option("selectedItemKeys"),
      focusStateEnabled: this.option("focusStateEnabled"),
      hoverStateEnabled: this.option("hoverStateEnabled"),
      activeStateEnabled: this.option("activeStateEnabled"),
      stylingMode: this.option("stylingMode"),
      accessKey: this.option("accessKey"),
      tabIndex: this.option("tabIndex"),
      noDataText: "",
      selectionRequired: false,
      onItemRendered: (e) => {
        const width = this.option("width");
        if (isDefined(width)) {
          renderer_default(e.itemElement).addClass(BUTTON_GROUP_ITEM_HAS_WIDTH);
        }
      },
      onSelectionChanged: (e) => {
        this._syncSelectionOptions();
        this._fireSelectionChangeEvent(e.addedItems, e.removedItems);
      },
      onItemClick: (e) => {
        this._itemClickAction(e);
      }
    };
    if (isDefined(selectedItems) && selectedItems.length) {
      options2.selectedItems = selectedItems;
    }
    this._buttonsCollection = this._createComponent($buttons, ButtonCollection, options2);
  }
  _syncSelectionOptions() {
    this._setOptionWithoutOptionChange("selectedItems", this._buttonsCollection.option("selectedItems"));
    this._setOptionWithoutOptionChange("selectedItemKeys", this._buttonsCollection.option("selectedItemKeys"));
  }
  _optionChanged(args) {
    switch (args.name) {
      case "stylingMode":
      case "selectionMode":
      case "keyExpr":
      case "buttonTemplate":
      case "items":
      case "activeStateEnabled":
      case "focusStateEnabled":
      case "hoverStateEnabled":
      case "tabIndex":
        this._invalidate();
        break;
      case "selectedItemKeys":
      case "selectedItems":
        this._buttonsCollection.option(args.name, args.value);
        break;
      case "onItemClick":
        this._createItemClickAction();
        break;
      case "onSelectionChanged":
        break;
      case "width":
        super._optionChanged(args);
        this._buttonsCollection.itemElements().toggleClass(BUTTON_GROUP_ITEM_HAS_WIDTH, !!args.value);
        break;
      default:
        super._optionChanged(args);
    }
  }
};
component_registrator_default("dxButtonGroup", ButtonGroup);
var m_button_group_default = ButtonGroup;

// node_modules/devextreme/esm/ui/button_group.js
var button_group_default = m_button_group_default;

// node_modules/devextreme/esm/__internal/ui/m_drop_down_button.js
var DROP_DOWN_BUTTON_CONTENT = "dx-dropdownbutton-content";
var DropDownButton2 = class extends widget_default {
  _getDefaultOptions() {
    return _extends({}, super._getDefaultOptions(), {
      itemTemplate: "item",
      keyExpr: "this",
      selectedItem: null,
      selectedItemKey: null,
      stylingMode: "outlined",
      deferRendering: true,
      noDataText: message_default.format("dxCollectionWidget-noDataText"),
      useSelectMode: false,
      splitButton: false,
      showArrowIcon: true,
      template: null,
      text: "",
      type: "normal",
      onButtonClick: null,
      onSelectionChanged: null,
      onItemClick: null,
      opened: false,
      items: null,
      dataSource: null,
      focusStateEnabled: true,
      hoverStateEnabled: true,
      dropDownOptions: {},
      dropDownContentTemplate: "content",
      wrapItemText: false,
      useItemTextAsTitle: true,
      grouped: false,
      groupTemplate: "group",
      buttonGroupOptions: {}
    });
  }
  _setOptionsByReference() {
    super._setOptionsByReference();
    extend(this._optionsByReference, {
      selectedItem: true
    });
  }
  _init() {
    super._init();
    this._createItemClickAction();
    this._createActionClickAction();
    this._createSelectionChangedAction();
    this._initDataController();
    this._compileKeyGetter();
    this._compileDisplayGetter();
    this._options.cache("buttonGroupOptions", this.option("buttonGroupOptions"));
    this._options.cache("dropDownOptions", this.option("dropDownOptions"));
  }
  _initDataController() {
    const dataSource = this.option("dataSource");
    this._dataController = new data_controller_default2(dataSource ?? this.option("items"), {
      key: this.option("keyExpr")
    });
  }
  _initTemplates() {
    this._templateManager.addDefaultTemplates({
      content: new FunctionTemplate((options2) => {
        const $popupContent = renderer_default(options2.container);
        const $listContainer = renderer_default("<div>").appendTo($popupContent);
        this._list = this._createComponent($listContainer, list_light_default, this._listOptions());
        this._list.registerKeyHandler("escape", this._escHandler.bind(this));
        this._list.registerKeyHandler("tab", this._escHandler.bind(this));
        this._list.registerKeyHandler("leftArrow", this._escHandler.bind(this));
        this._list.registerKeyHandler("rightArrow", this._escHandler.bind(this));
      })
    });
    super._initTemplates();
  }
  _compileKeyGetter() {
    this._keyGetter = compileGetter(this._dataController.key());
  }
  _compileDisplayGetter() {
    const {
      displayExpr
    } = this.option();
    this._displayGetter = compileGetter(displayExpr);
  }
  _initMarkup() {
    super._initMarkup();
    this.$element().addClass("dx-dropdownbutton");
    this._renderButtonGroup();
    this._updateArrowClass();
    if (isDefined(this.option("selectedItemKey"))) {
      this._loadSelectedItem().done(this._updateActionButton.bind(this));
    }
  }
  _renderFocusTarget() {
  }
  _render() {
    if (!this.option("deferRendering") || this.option("opened")) {
      this._renderPopup();
    }
    super._render();
  }
  _renderContentImpl() {
    if (this._popup) {
      this._renderPopupContent();
    }
    return super._renderContentImpl();
  }
  _loadSelectedItem() {
    var _this$_loadSingleDefe;
    null === (_this$_loadSingleDefe = this._loadSingleDeferred) || void 0 === _this$_loadSingleDefe || _this$_loadSingleDefe.reject();
    const d = Deferred();
    if (this._list && void 0 !== this._lastSelectedItemData) {
      const cachedResult = this.option("useSelectMode") ? this._list.option("selectedItem") : this._lastSelectedItemData;
      return d.resolve(cachedResult);
    }
    this._lastSelectedItemData = void 0;
    const selectedItemKey = this.option("selectedItemKey");
    this._dataController.loadSingle(selectedItemKey).done(d.resolve).fail(() => {
      d.reject(null);
    });
    this._loadSingleDeferred = d;
    return d.promise();
  }
  _createActionClickAction() {
    this._actionClickAction = this._createActionByOption("onButtonClick");
  }
  _createSelectionChangedAction() {
    this._selectionChangedAction = this._createActionByOption("onSelectionChanged");
  }
  _createItemClickAction() {
    this._itemClickAction = this._createActionByOption("onItemClick");
  }
  _fireSelectionChangedAction(_ref) {
    let {
      previousValue,
      value: value2
    } = _ref;
    this._selectionChangedAction({
      item: value2,
      previousItem: previousValue
    });
  }
  _fireItemClickAction(_ref2) {
    let {
      event,
      itemElement,
      itemData
    } = _ref2;
    return this._itemClickAction({
      event,
      itemElement,
      itemData: this._actionItem || itemData
    });
  }
  _getButtonTemplate() {
    const {
      template,
      splitButton,
      showArrowIcon
    } = this.option();
    if (template) {
      return template;
    }
    return splitButton || !showArrowIcon ? "content" : (_ref3, buttonContent) => {
      let {
        text,
        icon
      } = _ref3;
      const $firstIcon = getImageContainer(icon);
      const $textContainer = text ? renderer_default("<span>").text(text).addClass("dx-button-text") : void 0;
      const $secondIcon = getImageContainer("spindown").addClass("dx-icon-right");
      renderer_default(buttonContent).append($firstIcon, $textContainer, $secondIcon);
    };
  }
  _getActionButtonConfig() {
    const {
      icon,
      text,
      type: type2,
      splitButton
    } = this.option();
    const actionButtonConfig = {
      text,
      icon,
      type: type2,
      template: this._getButtonTemplate(),
      elementAttr: {
        class: "dx-dropdownbutton-action"
      }
    };
    if (splitButton) {
      actionButtonConfig.elementAttr.role = "menuitem";
    }
    return actionButtonConfig;
  }
  _getSpinButtonConfig() {
    const {
      type: type2
    } = this.option();
    const config3 = {
      type: type2,
      icon: "spindown",
      elementAttr: {
        class: "dx-dropdownbutton-toggle",
        role: "menuitem"
      }
    };
    return config3;
  }
  _getButtonGroupItems() {
    const {
      splitButton
    } = this.option();
    const items = [this._getActionButtonConfig()];
    if (splitButton) {
      items.push(this._getSpinButtonConfig());
    }
    return items;
  }
  _buttonGroupItemClick(_ref4) {
    let {
      event,
      itemData
    } = _ref4;
    const isActionButton = "dx-dropdownbutton-action" === itemData.elementAttr.class;
    const isToggleButton = "dx-dropdownbutton-toggle" === itemData.elementAttr.class;
    if (isToggleButton) {
      this.toggle();
    } else if (isActionButton) {
      this._actionClickAction({
        event,
        selectedItem: this.option("selectedItem")
      });
      if (!this.option("splitButton")) {
        this.toggle();
      }
    }
  }
  _getButtonGroupOptions() {
    const {
      accessKey,
      focusStateEnabled,
      hoverStateEnabled,
      splitButton,
      stylingMode,
      tabIndex
    } = this.option();
    const buttonGroupOptions = _extends({
      items: this._getButtonGroupItems(),
      width: "100%",
      height: "100%",
      selectionMode: "none",
      focusStateEnabled,
      hoverStateEnabled,
      stylingMode,
      accessKey,
      tabIndex,
      elementAttr: {
        role: splitButton ? "menu" : "group"
      },
      onItemClick: this._buttonGroupItemClick.bind(this),
      onKeyboardHandled: (e) => this._keyboardHandler(e)
    }, this._options.cache("buttonGroupOptions"));
    return buttonGroupOptions;
  }
  _renderPopupContent() {
    const $content = this._popup.$content();
    const template = this._getTemplateByOption("dropDownContentTemplate");
    $content.empty();
    this._popupContentId = `dx-${new guid_default2()}`;
    this.setAria("id", this._popupContentId, $content);
    const result2 = template.render({
      container: getPublicElement($content),
      model: this.option("items") || this._dataController.getDataSource()
    });
    return result2;
  }
  _popupOptions() {
    const horizontalAlignment = this.option("rtlEnabled") ? "right" : "left";
    return extend({
      dragEnabled: false,
      focusStateEnabled: false,
      deferRendering: this.option("deferRendering"),
      hideOnOutsideClick: (e) => {
        const $element = this.$element();
        const $buttonClicked = renderer_default(e.target).closest(".dx-dropdownbutton");
        return !$buttonClicked.is($element);
      },
      showTitle: false,
      animation: {
        show: {
          type: "fade",
          duration: 0,
          from: 0,
          to: 1
        },
        hide: {
          type: "fade",
          duration: 400,
          from: 1,
          to: 0
        }
      },
      _ignoreFunctionValueDeprecation: true,
      width: () => getElementWidth(this.$element()),
      height: "auto",
      shading: false,
      position: {
        of: this.$element(),
        collision: "flipfit",
        my: `${horizontalAlignment} top`,
        at: `${horizontalAlignment} bottom`
      },
      _wrapperClassExternal: "dx-dropdowneditor-overlay",
      contentTemplate: null
    }, this._options.cache("dropDownOptions"), {
      visible: this.option("opened")
    });
  }
  _listOptions() {
    const selectedItemKey = this.option("selectedItemKey");
    const useSelectMode = this.option("useSelectMode");
    return {
      selectionMode: useSelectMode ? "single" : "none",
      wrapItemText: this.option("wrapItemText"),
      focusStateEnabled: this.option("focusStateEnabled"),
      hoverStateEnabled: this.option("hoverStateEnabled"),
      useItemTextAsTitle: this.option("useItemTextAsTitle"),
      onContentReady: () => this._fireContentReadyAction(),
      selectedItemKeys: isDefined(selectedItemKey) && useSelectMode ? [selectedItemKey] : [],
      grouped: this.option("grouped"),
      groupTemplate: this.option("groupTemplate"),
      keyExpr: this._dataController.key(),
      noDataText: this.option("noDataText"),
      displayExpr: this.option("displayExpr"),
      itemTemplate: this.option("itemTemplate"),
      items: this.option("items"),
      dataSource: this._dataController.getDataSource(),
      onItemClick: (e) => {
        if (!this.option("useSelectMode")) {
          this._lastSelectedItemData = e.itemData;
        }
        this.option("selectedItemKey", this._keyGetter(e.itemData));
        const actionResult = this._fireItemClickAction(e);
        if (false !== actionResult) {
          this.toggle(false);
          this._buttonGroup.focus();
        }
      }
    };
  }
  _upDownKeyHandler() {
    var _this$_popup;
    if (null !== (_this$_popup = this._popup) && void 0 !== _this$_popup && _this$_popup.option("visible") && this._list) {
      this._list.focus();
    } else {
      this.open();
    }
    return true;
  }
  _escHandler() {
    this.close();
    this._buttonGroup.focus();
    return true;
  }
  _tabHandler() {
    this.close();
    return true;
  }
  _renderPopup() {
    const $popup = renderer_default("<div>");
    this.$element().append($popup);
    this._popup = this._createComponent($popup, m_popup_default, this._popupOptions());
    this._popup.$content().addClass(DROP_DOWN_BUTTON_CONTENT);
    this._popup.$wrapper().addClass("dx-dropdownbutton-popup-wrapper");
    this._popup.$overlayContent().attr("aria-label", "Dropdown");
    this._popup.on("hiding", this._popupHidingHandler.bind(this));
    this._popup.on("showing", this._popupShowingHandler.bind(this));
    this._bindInnerWidgetOptions(this._popup, "dropDownOptions");
  }
  _popupHidingHandler() {
    this.option("opened", false);
    this._updateAriaAttributes(false);
  }
  _popupOptionChanged(args) {
    const options2 = widget_default.getOptionsFromContainer(args);
    this._setPopupOption(options2);
    const optionsKeys = Object.keys(options2);
    if (optionsKeys.includes("width") || optionsKeys.includes("height")) {
      this._dimensionChanged();
    }
  }
  _dimensionChanged() {
    const popupWidth = getSizeValue(this.option("dropDownOptions.width"));
    if (void 0 === popupWidth) {
      this._setPopupOption("width", () => getElementWidth(this.$element()));
    }
  }
  _setPopupOption(optionName, value2) {
    this._setWidgetOption("_popup", arguments);
  }
  _popupShowingHandler() {
    this.option("opened", true);
    this._updateAriaAttributes(true);
  }
  _setElementAria(value2) {
    const elementAria = {
      owns: value2 ? this._popupContentId : void 0
    };
    this.setAria(elementAria, this.$element());
  }
  _setButtonsAria(value2) {
    const commonButtonAria = {
      expanded: value2,
      haspopup: "listbox"
    };
    const firstButtonAria = {};
    if (!this.option("text")) {
      firstButtonAria.label = "dropdownbutton";
    }
    this._getButtons().each((index2, $button) => {
      if (0 === index2) {
        this.setAria(_extends({}, firstButtonAria, commonButtonAria), renderer_default($button));
      } else {
        this.setAria(commonButtonAria, renderer_default($button));
      }
    });
  }
  _updateAriaAttributes(value2) {
    this._setElementAria(value2);
    this._setButtonsAria(value2);
  }
  _getButtons() {
    return this._buttonGroup.$element().find(".dx-button");
  }
  _renderButtonGroup() {
    var _this$_buttonGroup;
    const $buttonGroup = (null === (_this$_buttonGroup = this._buttonGroup) || void 0 === _this$_buttonGroup ? void 0 : _this$_buttonGroup.$element()) || renderer_default("<div>");
    if (!this._buttonGroup) {
      this.$element().append($buttonGroup);
    }
    this._buttonGroup = this._createComponent($buttonGroup, button_group_default, this._getButtonGroupOptions());
    this._buttonGroup.registerKeyHandler("downArrow", this._upDownKeyHandler.bind(this));
    this._buttonGroup.registerKeyHandler("tab", this._tabHandler.bind(this));
    this._buttonGroup.registerKeyHandler("upArrow", this._upDownKeyHandler.bind(this));
    this._buttonGroup.registerKeyHandler("escape", this._escHandler.bind(this));
    this._bindInnerWidgetOptions(this._buttonGroup, "buttonGroupOptions");
    this._updateAriaAttributes(this.option("opened"));
  }
  _updateArrowClass() {
    const hasArrow = this.option("splitButton") || this.option("showArrowIcon");
    this.$element().toggleClass("dx-dropdownbutton-has-arrow", hasArrow);
  }
  toggle(visible2) {
    var _this$_popup2;
    if (!this._popup) {
      this._renderPopup();
      this._renderContent();
    }
    return null === (_this$_popup2 = this._popup) || void 0 === _this$_popup2 ? void 0 : _this$_popup2.toggle(visible2);
  }
  open() {
    return this.toggle(true);
  }
  close() {
    return this.toggle(false);
  }
  _setListOption(name2, value2) {
    var _this$_list;
    null === (_this$_list = this._list) || void 0 === _this$_list || _this$_list.option(name2, value2);
  }
  _getDisplayValue(item) {
    const isPrimitiveItem = !isObject(item);
    const displayValue = isPrimitiveItem ? item : this._displayGetter(item);
    return !isObject(displayValue) ? String(ensureDefined(displayValue, "")) : "";
  }
  _updateActionButton(selectedItem) {
    if (this.option("useSelectMode")) {
      this.option({
        text: this._getDisplayValue(selectedItem),
        icon: isPlainObject(selectedItem) ? selectedItem.icon : void 0
      });
    }
    this._setOptionWithoutOptionChange("selectedItem", selectedItem);
    this._setOptionWithoutOptionChange("selectedItemKey", this._keyGetter(selectedItem));
  }
  _clean() {
    var _this$_list2, _this$_popup3;
    null === (_this$_list2 = this._list) || void 0 === _this$_list2 || _this$_list2.$element().remove();
    null === (_this$_popup3 = this._popup) || void 0 === _this$_popup3 || _this$_popup3.$element().remove();
  }
  _selectedItemKeyChanged(value2) {
    this._setListOption("selectedItemKeys", this.option("useSelectMode") && isDefined(value2) ? [value2] : []);
    const previousItem = this.option("selectedItem");
    this._loadSelectedItem().always((selectedItem) => {
      this._updateActionButton(selectedItem);
      if (this._displayGetter(previousItem) !== this._displayGetter(selectedItem)) {
        this._fireSelectionChangedAction({
          previousValue: previousItem,
          value: selectedItem
        });
      }
    });
  }
  _updateButtonGroup(name2, value2) {
    this._buttonGroup.option(name2, value2);
    this._updateAriaAttributes(this.option("opened"));
  }
  _actionButtonOptionChanged(_ref5) {
    let {
      name: name2,
      value: value2
    } = _ref5;
    const newConfig = {};
    newConfig[name2] = value2;
    this._updateButtonGroup("items[0]", extend({}, this._getActionButtonConfig(), newConfig));
    this._popup && this._popup.repaint();
  }
  _selectModeChanged(value2) {
    if (value2) {
      this._setListOption("selectionMode", "single");
      const selectedItemKey = this.option("selectedItemKey");
      this._setListOption("selectedItemKeys", isDefined(selectedItemKey) ? [selectedItemKey] : []);
      this._selectedItemKeyChanged(this.option("selectedItemKey"));
    } else {
      this._setListOption("selectionMode", "none");
      this.option({
        selectedItemKey: void 0,
        selectedItem: void 0
      });
      this._actionButtonOptionChanged({
        text: this.option("text")
      });
    }
  }
  _updateItemCollection(optionName) {
    const selectedItemKey = this.option("selectedItemKey");
    this._setListOption("selectedItem", null);
    this._setWidgetOption("_list", [optionName]);
    if (isDefined(selectedItemKey)) {
      this._loadSelectedItem().done((selectedItem) => {
        this._setListOption("selectedItemKeys", [selectedItemKey]);
        this._setListOption("selectedItem", selectedItem);
      }).fail((error2) => {
        this._setListOption("selectedItemKeys", []);
      }).always(this._updateActionButton.bind(this));
    }
  }
  _updateDataController(items) {
    this._dataController.updateDataSource(items, this.option("keyExpr"));
    this._updateKeyExpr();
  }
  _updateKeyExpr() {
    this._compileKeyGetter();
    this._setListOption("keyExpr", this._dataController.key());
  }
  focus() {
    this._buttonGroup.focus();
  }
  _optionChanged(args) {
    var _this$_popup4;
    const {
      name: name2,
      value: value2
    } = args;
    switch (name2) {
      case "useSelectMode":
        this._selectModeChanged(value2);
        break;
      case "splitButton":
        this._updateArrowClass();
        this._renderButtonGroup();
        break;
      case "displayExpr":
        this._compileDisplayGetter();
        this._setListOption(name2, value2);
        this._updateActionButton(this.option("selectedItem"));
        break;
      case "keyExpr":
        this._updateDataController();
        break;
      case "buttonGroupOptions":
        this._innerWidgetOptionChanged(this._buttonGroup, args);
        break;
      case "dropDownOptions":
        if ("dropDownOptions.visible" === args.fullName) {
          break;
        }
        if (void 0 !== args.value.visible) {
          delete args.value.visible;
        }
        this._popupOptionChanged(args);
        this._innerWidgetOptionChanged(this._popup, args);
        break;
      case "opened":
        this.toggle(value2);
        break;
      case "focusStateEnabled":
      case "hoverStateEnabled":
        this._setListOption(name2, value2);
        this._updateButtonGroup(name2, value2);
        super._optionChanged(args);
        break;
      case "items":
        this._updateDataController(this.option("items"));
        this._updateItemCollection(name2);
        break;
      case "dataSource":
        this._dataController.updateDataSource(value2);
        this._updateKeyExpr();
        this._updateItemCollection(name2);
        break;
      case "icon":
      case "text":
        this._actionButtonOptionChanged(args);
        break;
      case "showArrowIcon":
        this._updateArrowClass();
        this._renderButtonGroup();
        this._popup && this._popup.repaint();
        break;
      case "width":
      case "height":
        super._optionChanged(args);
        null === (_this$_popup4 = this._popup) || void 0 === _this$_popup4 || _this$_popup4.repaint();
        break;
      case "stylingMode":
      case "tabIndex":
        this._updateButtonGroup(name2, value2);
        break;
      case "type":
        this._updateButtonGroup("items", this._getButtonGroupItems());
        break;
      case "itemTemplate":
      case "grouped":
      case "noDataText":
      case "groupTemplate":
      case "wrapItemText":
      case "useItemTextAsTitle":
        this._setListOption(name2, value2);
        break;
      case "dropDownContentTemplate":
        this._renderContent();
        break;
      case "selectedItemKey":
        this._selectedItemKeyChanged(value2);
        break;
      case "selectedItem":
        break;
      case "onItemClick":
        this._createItemClickAction();
        break;
      case "onButtonClick":
        this._createActionClickAction();
        break;
      case "onSelectionChanged":
        this._createSelectionChangedAction();
        break;
      case "deferRendering": {
        const {
          opened
        } = this.option();
        this.toggle(opened);
        break;
      }
      case "template":
        this._renderButtonGroup();
        break;
      default:
        super._optionChanged(args);
    }
  }
  getDataSource() {
    return this._dataController.getDataSource();
  }
};
component_registrator_default("dxDropDownButton", DropDownButton2);

// node_modules/devextreme/esm/__internal/grids/grid_core/m_export.js
function prepareItems(items, emptyCell) {
  const defaultSetter = (value2) => !value2 ? 1 : value2;
  const resultItems = [];
  const cols = (items[0] || []).reduce((sum, item2) => sum + defaultSetter(item2.colspan), 0);
  const getItem = /* @__PURE__ */ ((items2) => {
    let rowIndex2 = 0;
    let cellIndex = 0;
    return () => {
      const row = items2[rowIndex2] || [];
      const item2 = row[cellIndex++];
      if (cellIndex >= row.length) {
        rowIndex2++;
        cellIndex = 0;
      }
      if (item2) {
        item2.colspan = defaultSetter(item2.colspan);
        item2.rowspan = defaultSetter(item2.rowspan);
      }
      return item2;
    };
  })(items);
  const addItem2 = (rowIndex2, cellIndex, item2) => {
    const row = resultItems[rowIndex2] = resultItems[rowIndex2] || [];
    row[cellIndex] = item2;
    if (item2.colspan > 1 || item2.rowspan > 1) {
      const clone2 = ((item3) => extend({}, item3, emptyCell))(item2);
      for (let c = 1; c < item2.colspan; c++) {
        addItem2(rowIndex2, cellIndex + c, clone2);
      }
      for (let r = 1; r < item2.rowspan; r++) {
        for (let c = 0; c < item2.colspan; c++) {
          addItem2(rowIndex2 + r, cellIndex + c, clone2);
        }
      }
    }
  };
  let item = getItem();
  let rowIndex = 0;
  while (item) {
    for (let cellIndex = 0; cellIndex < cols; cellIndex++) {
      if (!item) {
        break;
      }
      if (resultItems[rowIndex] && resultItems[rowIndex][cellIndex]) {
        continue;
      }
      addItem2(rowIndex, cellIndex, item);
      cellIndex += item.colspan - 1;
      item = getItem();
    }
    rowIndex++;
  }
  return resultItems;
}

// node_modules/devextreme/esm/__internal/grids/data_grid/export/m_export.js
var DataProvider = class {
  constructor(exportController, initialColumnWidthsByColumnIndex, selectedRowsOnly) {
    this._exportController = exportController;
    this._initialColumnWidthsByColumnIndex = initialColumnWidthsByColumnIndex;
    this._selectedRowsOnly = selectedRowsOnly;
  }
  _getGroupValue(item) {
    const {
      key,
      data: data17,
      rowType,
      groupIndex,
      summaryCells
    } = item;
    const groupColumn = this._options.groupColumns[groupIndex];
    const value2 = m_core_default.getDisplayValue(groupColumn, groupColumn.deserializeValue ? groupColumn.deserializeValue(key[groupIndex]) : key[groupIndex], data17, rowType);
    let result2 = `${groupColumn.caption}: ${m_core_default.formatValue(value2, groupColumn)}`;
    if (summaryCells && summaryCells[0] && summaryCells[0].length) {
      result2 += ` ${m_core_default.getGroupRowSummaryText(summaryCells[0], this._options.summaryTexts)}`;
    }
    return result2;
  }
  _correctCellIndex(cellIndex) {
    return cellIndex;
  }
  _initOptions() {
    const exportController = this._exportController;
    const groupColumns = exportController._columnsController.getGroupColumns();
    this._options = {
      columns: exportController._getColumns(this._initialColumnWidthsByColumnIndex),
      groupColumns,
      items: this._selectedRowsOnly || exportController._selectionOnly ? exportController._getSelectedItems() : exportController._getAllItems(),
      isHeadersVisible: exportController.option("showColumnHeaders"),
      summaryTexts: exportController.option("summary.texts"),
      rtlEnabled: exportController.option("rtlEnabled")
    };
  }
  getHeaderStyles() {
    return [{
      bold: true,
      alignment: "center"
    }, {
      bold: true,
      alignment: "left"
    }, {
      bold: true,
      alignment: "right"
    }];
  }
  getGroupRowStyle() {
    return {
      bold: true,
      alignment: getDefaultAlignment(this._options.rtlEnabled)
    };
  }
  getColumnStyles() {
    const columnStyles = [];
    this.getColumns().forEach((column) => {
      columnStyles.push({
        alignment: column.alignment || "left",
        format: column.format,
        dataType: column.dataType
      });
    });
    return columnStyles;
  }
  getStyles() {
    return [...this.getHeaderStyles(), ...this.getColumnStyles(), this.getGroupRowStyle()];
  }
  _getTotalCellStyleId(cellIndex) {
    var _this$getColumns$cell;
    const alignment = (null === (_this$getColumns$cell = this.getColumns()[cellIndex]) || void 0 === _this$getColumns$cell ? void 0 : _this$getColumns$cell.alignment) || "right";
    return this.getHeaderStyles().map((style) => style.alignment).indexOf(alignment);
  }
  getStyleId(rowIndex, cellIndex) {
    if (rowIndex < this.getHeaderRowCount()) {
      return 0;
    }
    if (this.isTotalCell(rowIndex - this.getHeaderRowCount(), cellIndex)) {
      return this._getTotalCellStyleId(cellIndex);
    }
    if (this.isGroupRow(rowIndex - this.getHeaderRowCount())) {
      return this.getHeaderStyles().length + this.getColumns().length;
    }
    return cellIndex + this.getHeaderStyles().length;
  }
  getColumns(getColumnsByAllRows) {
    const {
      columns: columns7
    } = this._options;
    return getColumnsByAllRows ? columns7 : columns7[columns7.length - 1];
  }
  getColumnsWidths() {
    const columns7 = this.getColumns();
    return isDefined(columns7) ? columns7.map((c) => c.width) : void 0;
  }
  getRowsCount() {
    return this._options.items.length + this.getHeaderRowCount();
  }
  getHeaderRowCount() {
    if (this.isHeadersVisible()) {
      return this._options.columns.length - 1;
    }
    return 0;
  }
  isGroupRow(rowIndex) {
    return rowIndex < this._options.items.length && "group" === this._options.items[rowIndex].rowType;
  }
  getGroupLevel(rowIndex) {
    const item = this._options.items[rowIndex - this.getHeaderRowCount()];
    const groupIndex = item && item.groupIndex;
    if (item && "totalFooter" === item.rowType) {
      return 0;
    }
    return isDefined(groupIndex) ? groupIndex : this._options.groupColumns.length;
  }
  getCellType(rowIndex, cellIndex) {
    const columns7 = this.getColumns();
    if (rowIndex < this.getHeaderRowCount()) {
      return "string";
    }
    rowIndex -= this.getHeaderRowCount();
    if (cellIndex < columns7.length) {
      const item = this._options.items.length && this._options.items[rowIndex];
      const column = columns7[cellIndex];
      if (item && "data" === item.rowType) {
        if (isFinite(item.values[this._correctCellIndex(cellIndex)]) && !isDefined(column.customizeText)) {
          return isDefined(column.lookup) ? column.lookup.dataType : column.dataType;
        }
      }
      return "string";
    }
  }
  ready() {
    this._initOptions();
    const options2 = this._options;
    return when(options2.items).done((items) => {
      options2.items = items;
    }).fail(() => {
      options2.items = [];
    });
  }
  _convertFromGridGroupSummaryItems(gridGroupSummaryItems) {
    if (isDefined(gridGroupSummaryItems) && gridGroupSummaryItems.length > 0) {
      return gridGroupSummaryItems.map((item) => ({
        value: item.value,
        name: item.name
      }));
    }
  }
  getCellData(rowIndex, cellIndex, isExcelJS) {
    let value2;
    let column;
    const result2 = {
      cellSourceData: {},
      value: value2
    };
    const columns7 = this.getColumns();
    const correctedCellIndex = this._correctCellIndex(cellIndex);
    if (rowIndex < this.getHeaderRowCount()) {
      const columnsRow = this.getColumns(true)[rowIndex];
      column = columnsRow[cellIndex];
      result2.cellSourceData.rowType = "header";
      result2.cellSourceData.column = column && column.gridColumn;
      result2.value = column && column.caption;
    } else {
      rowIndex -= this.getHeaderRowCount();
      const item = this._options.items.length && this._options.items[rowIndex];
      if (item) {
        const itemValues = item.values;
        result2.cellSourceData.rowType = item.rowType;
        result2.cellSourceData.column = columns7[cellIndex] && columns7[cellIndex].gridColumn;
        switch (item.rowType) {
          case "groupFooter":
          case "totalFooter":
            if (correctedCellIndex < itemValues.length) {
              value2 = itemValues[correctedCellIndex];
              if (isDefined(value2)) {
                result2.cellSourceData.value = value2.value;
                result2.cellSourceData.totalSummaryItemName = value2.name;
                result2.value = m_core_default.getSummaryText(value2, this._options.summaryTexts);
              } else {
                result2.cellSourceData.value = void 0;
              }
            }
            break;
          case "group":
            result2.cellSourceData.groupIndex = item.groupIndex;
            if (cellIndex < 1) {
              result2.cellSourceData.column = this._options.groupColumns[item.groupIndex];
              result2.cellSourceData.value = item.key[item.groupIndex];
              result2.cellSourceData.groupSummaryItems = this._convertFromGridGroupSummaryItems(item.summaryCells[0]);
              result2.value = this._getGroupValue(item);
            } else {
              const summaryItems = item.values[correctedCellIndex];
              if (Array.isArray(summaryItems)) {
                result2.cellSourceData.groupSummaryItems = this._convertFromGridGroupSummaryItems(summaryItems);
                value2 = "";
                for (let i = 0; i < summaryItems.length; i++) {
                  value2 += (i > 0 ? isExcelJS ? "\n" : " \n " : "") + m_core_default.getSummaryText(summaryItems[i], this._options.summaryTexts);
                }
                result2.value = value2;
              } else {
                result2.cellSourceData.value = void 0;
              }
            }
            break;
          default:
            column = columns7[cellIndex];
            if (column) {
              const value3 = itemValues[correctedCellIndex];
              const displayValue = m_core_default.getDisplayValue(column, value3, item.data, item.rowType);
              if (!isFinite(displayValue) || isDefined(column.customizeText)) {
                if (isExcelJS && isDefined(column.customizeText) && column.customizeText === this._exportController._columnsController.getCustomizeTextByDataType("boolean")) {
                  result2.value = displayValue;
                } else {
                  result2.value = m_core_default.formatValue(displayValue, column);
                }
              } else {
                result2.value = displayValue;
              }
              result2.cellSourceData.value = value3;
            }
            result2.cellSourceData.data = item.data;
        }
      }
    }
    return result2;
  }
  isHeadersVisible() {
    return this._options.isHeadersVisible;
  }
  isTotalCell(rowIndex, cellIndex) {
    const {
      items
    } = this._options;
    const item = items[rowIndex];
    const correctCellIndex = this._correctCellIndex(cellIndex);
    const isSummaryAlignByColumn = item.summaryCells && item.summaryCells[correctCellIndex] && item.summaryCells[correctCellIndex].length > 0 && item.summaryCells[correctCellIndex][0].alignByColumn;
    return item && "groupFooter" === item.rowType || "totalFooter" === item.rowType || isSummaryAlignByColumn;
  }
  getCellMerging(rowIndex, cellIndex) {
    const {
      columns: columns7
    } = this._options;
    const column = columns7[rowIndex] && columns7[rowIndex][cellIndex];
    return column ? {
      colspan: (column.exportColspan || 1) - 1,
      rowspan: (column.rowspan || 1) - 1
    } : {
      colspan: 0,
      rowspan: 0
    };
  }
  getFrozenArea() {
    return {
      x: 0,
      y: this.getHeaderRowCount()
    };
  }
};
var ExportController = class extends m_core_default.ViewController {
  init() {
    this.throwWarningIfNoOnExportingEvent();
    this._columnsController = this.getController("columns");
    this._dataController = this.getController("data");
    this._selectionController = this.getController("selection");
    this._rowsView = this.getView("rowsView");
    this._headersView = this.getView("columnHeadersView");
    this.createAction("onExporting", {
      excludeValidators: ["disabled", "readOnly"]
    });
  }
  _getEmptyCell() {
    return {
      caption: "",
      colspan: 1,
      rowspan: 1
    };
  }
  _updateColumnWidth(column, width) {
    column.width = width;
  }
  _getColumns(initialColumnWidthsByColumnIndex) {
    let result2 = [];
    let i;
    let columns7;
    const columnsController = this._columnsController;
    const rowCount = columnsController.getRowCount();
    for (i = 0; i <= rowCount; i++) {
      const currentHeaderRow = [];
      columns7 = columnsController.getVisibleColumns(i, true);
      let columnWidthsByColumnIndex;
      if (i === rowCount) {
        if (this._updateLockCount) {
          columnWidthsByColumnIndex = initialColumnWidthsByColumnIndex;
        } else {
          const columnWidths = this._getColumnWidths(this._headersView, this._rowsView);
          if (columnWidths && columnWidths.length) {
            columnWidthsByColumnIndex = {};
            for (let i2 = 0; i2 < columns7.length; i2++) {
              columnWidthsByColumnIndex[columns7[i2].index] = columnWidths[i2];
            }
          }
        }
      }
      for (let j = 0; j < columns7.length; j++) {
        const column = extend({}, columns7[j], {
          dataType: "datetime" === columns7[j].dataType ? "date" : columns7[j].dataType,
          gridColumn: columns7[j]
        });
        if (this._needColumnExporting(column)) {
          const currentColspan = this._calculateExportColspan(column);
          if (isDefined(currentColspan)) {
            column.exportColspan = currentColspan;
          }
          if (columnWidthsByColumnIndex) {
            this._updateColumnWidth(column, columnWidthsByColumnIndex[column.index]);
          }
          currentHeaderRow.push(column);
        }
      }
      result2.push(currentHeaderRow);
    }
    columns7 = result2[rowCount];
    result2 = prepareItems(result2.slice(0, -1), this._getEmptyCell());
    result2.push(columns7);
    return result2;
  }
  _calculateExportColspan(column) {
    if (!column.isBand) {
      return;
    }
    const childColumns = this._columnsController.getChildrenByBandColumn(column.index, true);
    if (!isDefined(childColumns)) {
      return;
    }
    return childColumns.reduce((result2, childColumn) => {
      if (this._needColumnExporting(childColumn)) {
        return result2 + (this._calculateExportColspan(childColumn) || 1);
      }
      return result2;
    }, 0);
  }
  _needColumnExporting(column) {
    return !column.command && (column.allowExporting || void 0 === column.allowExporting);
  }
  _getFooterSummaryItems(summaryCells, isTotal) {
    const result2 = [];
    let estimatedItemsCount = 1;
    let i = 0;
    do {
      const values = [];
      for (let j = 0; j < summaryCells.length; j++) {
        const summaryCell = summaryCells[j];
        const itemsLength = summaryCell.length;
        if (estimatedItemsCount < itemsLength) {
          estimatedItemsCount = itemsLength;
        }
        values.push(summaryCell[i]);
      }
      result2.push({
        values,
        rowType: isTotal ? "totalFooter" : "groupFooter"
      });
    } while (i++ < estimatedItemsCount - 1);
    return result2;
  }
  _hasSummaryGroupFooters() {
    const groupItems = this.option("summary.groupItems");
    if (isDefined(groupItems)) {
      for (let i = 0; i < groupItems.length; i++) {
        if (groupItems[i].showInGroupFooter) {
          return true;
        }
      }
    }
    return false;
  }
  _getItemsWithSummaryGroupFooters(sourceItems) {
    let result2 = [];
    let beforeGroupFooterItems = [];
    let groupFooterItems = [];
    for (let i = 0; i < sourceItems.length; i++) {
      const item = sourceItems[i];
      if ("groupFooter" === item.rowType) {
        groupFooterItems = this._getFooterSummaryItems(item.summaryCells);
        result2 = result2.concat(beforeGroupFooterItems, groupFooterItems);
        beforeGroupFooterItems = [];
      } else {
        beforeGroupFooterItems.push(item);
      }
    }
    return result2.length ? result2 : beforeGroupFooterItems;
  }
  _updateGroupValuesWithSummaryByColumn(sourceItems) {
    let summaryValues = [];
    for (let i = 0; i < sourceItems.length; i++) {
      const item = sourceItems[i];
      const {
        summaryCells
      } = item;
      if ("group" === item.rowType && summaryCells && summaryCells.length > 1) {
        const groupColumnCount = item.values.length;
        for (let j = 1; j < summaryCells.length; j++) {
          for (let k = 0; k < summaryCells[j].length; k++) {
            const summaryItem = summaryCells[j][k];
            if (summaryItem && summaryItem.alignByColumn) {
              if (!Array.isArray(summaryValues[j - groupColumnCount])) {
                summaryValues[j - groupColumnCount] = [];
              }
              summaryValues[j - groupColumnCount].push(summaryItem);
            }
          }
        }
        if (summaryValues.length > 0) {
          item.values.push(...summaryValues);
          summaryValues = [];
        }
      }
    }
  }
  _processUnExportedItems(items) {
    const columns7 = this._columnsController.getVisibleColumns(null, true);
    const groupColumns = this._columnsController.getGroupColumns();
    let values;
    let summaryCells;
    for (let i = 0; i < items.length; i++) {
      const item = items[i];
      let isCommand = false;
      values = [];
      summaryCells = [];
      for (let j = 0; j < columns7.length; j++) {
        const column = columns7[j];
        isCommand || (isCommand = ["detailExpand", "buttons"].includes(column.type));
        if (this._needColumnExporting(column)) {
          if (item.values) {
            if ("group" === item.rowType && !values.length) {
              values.push(item.key[item.groupIndex]);
            } else {
              values.push(item.values[j]);
            }
          }
          if (item.summaryCells) {
            if ("group" === item.rowType && !summaryCells.length) {
              const index2 = j - groupColumns.length + item.groupIndex;
              summaryCells.push(item.summaryCells[isCommand ? index2 : index2 + 1]);
            } else {
              summaryCells.push(item.summaryCells[j]);
            }
          }
        }
      }
      if (values.length) {
        item.values = values;
      }
      if (summaryCells.length) {
        item.summaryCells = summaryCells;
      }
    }
  }
  _getAllItems(data17) {
    let skipFilter = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : false;
    const that = this;
    const d = new Deferred();
    const footerItems = this._dataController.footerItems();
    const totalItem = footerItems.length && footerItems[0];
    const summaryTotalItems = that.option("summary.totalItems");
    let summaryCells;
    when(data17).done((data18) => {
      this._dataController.loadAll(data18, skipFilter).done((sourceItems, totalAggregates) => {
        that._updateGroupValuesWithSummaryByColumn(sourceItems);
        if (that._hasSummaryGroupFooters()) {
          sourceItems = that._getItemsWithSummaryGroupFooters(sourceItems);
        }
        summaryCells = totalItem && totalItem.summaryCells;
        if (isDefined(totalAggregates) && summaryTotalItems) {
          summaryCells = that._getSummaryCells(summaryTotalItems, totalAggregates);
        }
        const summaryItems = totalItem && that._getFooterSummaryItems(summaryCells, true);
        if (summaryItems) {
          sourceItems = sourceItems.concat(summaryItems);
        }
        that._processUnExportedItems(sourceItems);
        d.resolve(sourceItems);
      }).fail(d.reject);
    }).fail(d.reject);
    return d;
  }
  _getSummaryCells(summaryTotalItems, totalAggregates) {
    return this._dataController._calculateSummaryCells(summaryTotalItems, totalAggregates, this._columnsController.getVisibleColumns(null, true), (summaryItem, column) => this._dataController._isDataColumn(column) ? column.index : -1);
  }
  _getSelectedItems() {
    if (this.needLoadItemsOnExportingSelectedItems()) {
      return this._getAllItems(this._selectionController.loadSelectedItemsWithFilter(), true);
    }
    return this._getAllItems(this._selectionController.getSelectedRowsData());
  }
  _getColumnWidths(headersView, rowsView18) {
    return headersView && headersView.isVisible() ? headersView.getColumnWidths() : rowsView18.getColumnWidths();
  }
  throwWarningIfNoOnExportingEvent() {
    var _this$component$hasAc, _this$component;
    const hasOnExporting = null === (_this$component$hasAc = (_this$component = this.component).hasActionSubscription) || void 0 === _this$component$hasAc ? void 0 : _this$component$hasAc.call(_this$component, "onExporting");
    if (this.option("export.enabled") && !hasOnExporting) {
      ui_errors_default.log("W1024");
    }
  }
  callbackNames() {
    return ["selectionOnlyChanged"];
  }
  getDataProvider(selectedRowsOnly) {
    const columnWidths = this._getColumnWidths(this._headersView, this._rowsView);
    let initialColumnWidthsByColumnIndex;
    if (columnWidths && columnWidths.length) {
      initialColumnWidthsByColumnIndex = {};
      const columnsLastRowVisibleColumns = this._columnsController.getVisibleColumns(this._columnsController.getRowCount(), true);
      for (let i = 0; i < columnsLastRowVisibleColumns.length; i++) {
        initialColumnWidthsByColumnIndex[columnsLastRowVisibleColumns[i].index] = columnWidths[i];
      }
    }
    return new DataProvider(this, initialColumnWidthsByColumnIndex, selectedRowsOnly);
  }
  exportTo(selectedRowsOnly, format2) {
    this._selectionOnly = selectedRowsOnly;
    const onExporting = this.getAction("onExporting");
    const eventArgs = {
      rtlEnabled: this.option("rtlEnabled"),
      selectedRowsOnly: !!selectedRowsOnly,
      format: format2,
      fileName: "DataGrid",
      cancel: false
    };
    isFunction(onExporting) && onExporting(eventArgs);
  }
  publicMethods() {
    return ["getDataProvider"];
  }
  selectionOnly(value2) {
    if (isDefined(value2)) {
      this._isSelectedRows = value2;
      this.selectionOnlyChanged.fire();
    } else {
      return this._isSelectedRows;
    }
  }
  optionChanged(args) {
    super.optionChanged(args);
    if ("export" === args.name) {
      this.throwWarningIfNoOnExportingEvent();
    }
  }
  needLoadItemsOnExportingSelectedItems() {
    return this.option("loadItemsOnExportingSelectedItems") ?? this._dataController._dataSource.remoteOperations().filtering;
  }
};
var editing5 = (Base) => class extends Base {
  callbackNames() {
    const callbackList = super.callbackNames();
    return isDefined(callbackList) ? callbackList.push("editingButtonsUpdated") : ["editingButtonsUpdated"];
  }
  _updateEditButtons() {
    super._updateEditButtons();
    this.editingButtonsUpdated.fire();
  }
};
var headerPanel7 = (Base) => class extends Base {
  _getToolbarItems() {
    const items = super._getToolbarItems();
    const exportButton = this._getExportToolbarButton();
    if (exportButton) {
      items.push(exportButton);
      this._correctItemsPosition(items);
    }
    return items;
  }
  _getExportToolbarButton() {
    const items = this._getExportToolbarItems();
    if (0 === items.length) {
      return null;
    }
    const disabled = this._needDisableExportButton();
    const toolbarButtonOptions = {
      name: "exportButton",
      location: "after",
      locateInMenu: "auto",
      sortIndex: 30,
      options: {
        items
      },
      disabled
    };
    if (1 === items.length) {
      const widgetOptions = _extends({}, items[0], {
        hint: items[0].text,
        elementAttr: {
          class: "dx-datagrid-export-button"
        }
      });
      toolbarButtonOptions.widget = "dxButton";
      toolbarButtonOptions.showText = "inMenu";
      toolbarButtonOptions.options = widgetOptions;
    } else {
      const widgetOptions = {
        icon: "export",
        displayExpr: "text",
        items,
        hint: this.option("export.texts.exportTo"),
        elementAttr: {
          class: "dx-datagrid-export-button"
        },
        dropDownOptions: {
          width: "auto",
          _wrapperClassExternal: "dx-datagrid-export-menu"
        }
      };
      toolbarButtonOptions.options = widgetOptions;
      toolbarButtonOptions.widget = "dxDropDownButton";
      toolbarButtonOptions.menuItemTemplate = (_data, _index, container) => {
        this._createComponent(renderer_default(container), list_light_default, {
          items
        });
      };
    }
    return toolbarButtonOptions;
  }
  _getExportToolbarItems() {
    const exportOptions = this.option("export");
    const texts = this.option("export.texts");
    const formats = this.option("export.formats") ?? [];
    if (!exportOptions.enabled) {
      return [];
    }
    const items = [];
    formats.forEach((formatType) => {
      let formatName = formatType.toUpperCase();
      let exportAllIcon = "export";
      if ("xlsx" === formatType) {
        formatName = "Excel";
        exportAllIcon = "xlsxfile";
      }
      if ("pdf" === formatType) {
        exportAllIcon = "pdffile";
      }
      items.push({
        text: format(texts.exportAll, formatName),
        icon: exportAllIcon,
        onClick: () => {
          this._exportController.exportTo(false, formatType);
        }
      });
      if (exportOptions.allowExportSelectedData) {
        items.push({
          text: format(texts.exportSelectedRows, formatName),
          icon: "exportselected",
          onClick: () => {
            this._exportController.exportTo(true, formatType);
          }
        });
      }
    });
    return items;
  }
  _correctItemsPosition(items) {
    items.sort((itemA, itemB) => itemA.sortIndex - itemB.sortIndex);
  }
  _isExportButtonVisible() {
    return this.option("export.enabled");
  }
  optionChanged(args) {
    super.optionChanged(args);
    if ("export" === args.name) {
      args.handled = true;
      this._invalidate();
    }
  }
  _needDisableExportButton() {
    const isDataColumnsInvisible = !this._columnsController.hasVisibleDataColumns();
    const hasUnsavedChanges = this._editingController.hasChanges();
    return isDataColumnsInvisible || hasUnsavedChanges;
  }
  _columnOptionChanged(e) {
    super._columnOptionChanged(e);
    const isColumnLocationChanged = m_core_default.checkChanges(e.optionNames, ["groupIndex", "visible", "all"]);
    if (isColumnLocationChanged) {
      const disabled = this._needDisableExportButton();
      this.setToolbarItemDisabled("exportButton", disabled);
    }
  }
  init() {
    super.init();
    this._exportController = this.getController("export");
    this._editingController.editingButtonsUpdated.add(() => {
      const disabled = this._needDisableExportButton();
      this.setToolbarItemDisabled("exportButton", disabled);
    });
  }
};
m_core_default.registerModule("export", {
  defaultOptions: () => ({
    export: {
      enabled: false,
      fileName: "DataGrid",
      formats: ["xlsx"],
      allowExportSelectedData: false,
      texts: {
        exportTo: message_default.format("dxDataGrid-exportTo"),
        exportAll: message_default.format("dxDataGrid-exportAll"),
        exportSelectedRows: message_default.format("dxDataGrid-exportSelectedRows")
      }
    }
  }),
  controllers: {
    export: ExportController
  },
  extenders: {
    controllers: {
      editing: editing5
    },
    views: {
      headerPanel: headerPanel7
    }
  }
});

// node_modules/devextreme/esm/__internal/grids/grid_core/focus/m_focus_utils.js
var getSortFilterValue = (sortInfo, rowData, _ref) => {
  let {
    isRemoteFiltering,
    dateSerializationFormat,
    getSelector
  } = _ref;
  const {
    selector
  } = sortInfo;
  const getter = isFunction(selector) ? selector : getSelector(selector);
  const rawValue = getter ? getter(rowData) : rowData[selector];
  const safeValue = isRemoteFiltering && isDate(rawValue) ? date_serialization_default.serializeDate(rawValue, dateSerializationFormat) : rawValue;
  return {
    getter,
    rawValue,
    safeValue
  };
};
var UiGridCoreFocusUtils = {
  getSortFilterValue
};

// node_modules/devextreme/esm/__internal/grids/grid_core/focus/m_focus.js
var FOCUSED_ROW_SELECTOR = ".dx-row.dx-row-focused";
var FocusController = class extends m_modules_default.ViewController {
  getKeyboardController() {
    return this.getController("keyboardNavigation");
  }
  getDataController() {
    return this.getController("data");
  }
  init() {
    this.component._optionsByReference.focusedRowKey = true;
  }
  optionChanged(args) {
    const {
      name: name2,
      value: value2,
      previousValue
    } = args;
    switch (name2) {
      case "focusedRowIndex":
        this._focusRowByIndex(value2);
        this.getKeyboardController()._fireFocusedRowChanged();
        args.handled = true;
        break;
      case "focusedRowKey":
        if (Array.isArray(value2) && JSON.stringify(value2) === JSON.stringify(previousValue)) {
          return;
        }
        this._focusRowByKey(value2);
        this.getKeyboardController()._fireFocusedRowChanged();
        args.handled = true;
        break;
      case "focusedColumnIndex":
      case "focusedRowEnabled":
      case "autoNavigateToFocusedRow":
        args.handled = true;
        break;
      default:
        super.optionChanged(args);
    }
  }
  publicMethods() {
    return ["navigateToRow", "isRowFocused"];
  }
  isAutoNavigateToFocusedRow() {
    return "infinite" !== this.option("scrolling.mode") && this.option("autoNavigateToFocusedRow");
  }
  _focusRowByIndex(index2, operationTypes) {
    if (!this.option("focusedRowEnabled")) {
      return;
    }
    const isEmptyData = this.getDataController().isEmpty();
    const currentIndex = this._getCurrentFocusRowIndex(isEmptyData, index2);
    if (currentIndex < 0) {
      if (isEmptyData || this.isAutoNavigateToFocusedRow()) {
        this._resetFocusedRow();
      }
    } else {
      this._focusRowByIndexCore(currentIndex, operationTypes);
    }
  }
  _getCurrentFocusRowIndex(isEmptyData, index2) {
    let currentIndex = index2;
    if (void 0 === currentIndex) {
      if (isEmptyData) {
        currentIndex = -1;
      } else {
        currentIndex = this.option("focusedRowIndex");
      }
    }
    return currentIndex;
  }
  _focusRowByIndexCore(index2, operationTypes) {
    const pageSize = this.getDataController().pageSize();
    const setKeyByIndex = () => {
      if (this._isValidFocusedRowIndex(index2)) {
        let rowIndex = index2 - this.getDataController().getRowIndexOffset(true);
        if (!operationTypes || operationTypes.paging && !operationTypes.filtering) {
          const lastItemIndex = this.getDataController()._getLastItemIndex();
          rowIndex = Math.min(rowIndex, lastItemIndex);
        }
        const focusedRowKey = this.getDataController().getKeyByRowIndex(rowIndex, true);
        if (isDefined(focusedRowKey) && !this.isRowFocused(focusedRowKey)) {
          this.option("focusedRowKey", focusedRowKey);
        }
      }
    };
    if (pageSize >= 0) {
      if (!this._isLocalRowIndex(index2)) {
        const pageIndex = Math.floor(index2 / this.getDataController().pageSize());
        when(this.getDataController().pageIndex(pageIndex), this.getDataController().waitReady()).done(() => {
          setKeyByIndex();
        });
      } else {
        setKeyByIndex();
      }
    }
  }
  _isLocalRowIndex(index2) {
    const isVirtualScrolling = this.getKeyboardController()._isVirtualScrolling();
    if (isVirtualScrolling) {
      const pageIndex = Math.floor(index2 / this.getDataController().pageSize());
      const virtualItems = this.getDataController().virtualItemsCount();
      const virtualItemsBegin = virtualItems ? virtualItems.begin : -1;
      const visibleRowsCount = this.getDataController().getVisibleRows().length + this.getDataController().getRowIndexOffset();
      const visiblePagesCount = Math.ceil(visibleRowsCount / this.getDataController().pageSize());
      return virtualItemsBegin <= index2 && visiblePagesCount > pageIndex;
    }
    return true;
  }
  _setFocusedRowKeyByIndex(index2) {
    if (this._isValidFocusedRowIndex(index2)) {
      const rowIndex = Math.min(index2 - this.getDataController().getRowIndexOffset(), this.getDataController().items().length - 1);
      const focusedRowKey = this.getDataController().getKeyByRowIndex(rowIndex);
      if (isDefined(focusedRowKey) && !this.isRowFocused(focusedRowKey)) {
        this.option("focusedRowKey", focusedRowKey);
      }
    }
  }
  _focusRowByKey(key) {
    if (!isDefined(key)) {
      this._resetFocusedRow();
    } else {
      this._navigateToRow(key, true);
    }
  }
  _resetFocusedRow() {
    const focusedRowKey = this.option("focusedRowKey");
    const isFocusedRowKeyDefined = isDefined(focusedRowKey);
    if (!isFocusedRowKeyDefined && this.option("focusedRowIndex") < 0) {
      return;
    }
    if (isFocusedRowKeyDefined) {
      this.option("focusedRowKey", null);
    }
    this.getKeyboardController().setFocusedRowIndex(-1);
    this.option("focusedRowIndex", -1);
    this.getDataController().updateItems({
      changeType: "updateFocusedRow",
      focusedRowKey: null
    });
    this.getKeyboardController()._fireFocusedRowChanged();
  }
  _isValidFocusedRowIndex(rowIndex) {
    const row = this.getDataController().getVisibleRows()[rowIndex];
    return !row || "data" === row.rowType || "group" === row.rowType;
  }
  navigateToRow(key) {
    if (!this.isAutoNavigateToFocusedRow()) {
      this.option("focusedRowIndex", -1);
    }
    return this._navigateToRow(key);
  }
  _navigateToRow(key, needFocusRow) {
    const that = this;
    const isAutoNavigate = that.isAutoNavigateToFocusedRow();
    const d = new Deferred();
    const rowsView18 = this.getView("rowsView");
    if (void 0 === key || !this.getDataController().dataSource()) {
      return d.reject().promise();
    }
    const rowIndexByKey = that.getFocusedRowIndexByKey(key);
    if (!isAutoNavigate && needFocusRow || rowIndexByKey >= 0) {
      that._navigateTo(key, d, needFocusRow);
    } else {
      this.getDataController().getPageIndexByKey(key).done((pageIndex) => {
        if (pageIndex < 0) {
          d.resolve(-1);
          return;
        }
        if (pageIndex === this.getDataController().pageIndex()) {
          this.getDataController().reload().done(() => {
            if (that.isRowFocused(key) && this.getDataController().getRowIndexByKey(key) >= 0) {
              d.resolve(that.getFocusedRowIndexByKey(key));
            } else {
              that._navigateTo(key, d, needFocusRow);
            }
          }).fail(d.reject);
        } else {
          this.getDataController().pageIndex(pageIndex).done(() => {
            rowsView18.waitAsyncTemplates(true).done(() => {
              that._navigateTo(key, d, needFocusRow);
            });
          }).fail(d.reject);
        }
      }).fail(d.reject);
    }
    return d.promise();
  }
  _navigateTo(key, deferred, needFocusRow) {
    const visibleRowIndex = this.getDataController().getRowIndexByKey(key);
    const isVirtualRowRenderingMode = m_utils_default.isVirtualRowRendering(this);
    const isAutoNavigate = this.isAutoNavigateToFocusedRow();
    if (isAutoNavigate && isVirtualRowRenderingMode && visibleRowIndex < 0) {
      this._navigateToVirtualRow(key, deferred, needFocusRow);
    } else {
      this._navigateToVisibleRow(key, deferred, needFocusRow);
    }
  }
  _navigateToVisibleRow(key, deferred, needFocusRow) {
    if (needFocusRow) {
      this._triggerUpdateFocusedRow(key, deferred);
    } else {
      const focusedRowIndex = this.getFocusedRowIndexByKey(key);
      this.getView("rowsView").scrollToRowElement(key, deferred).done(() => {
        deferred.resolve(focusedRowIndex);
      });
    }
  }
  _navigateToVirtualRow(key, deferred, needFocusRow) {
    const rowsScrollController = this.getDataController()._rowsScrollController;
    const rowIndex = m_utils_default.getIndexByKey(key, this.getDataController().items(true));
    const scrollable = this.getView("rowsView").getScrollable();
    if (rowsScrollController && scrollable && rowIndex >= 0) {
      const focusedRowIndex = rowIndex + this.getDataController().getRowIndexOffset(true);
      const offset2 = rowsScrollController.getItemOffset(focusedRowIndex);
      const triggerUpdateFocusedRow = () => {
        if (this.getDataController().totalCount() && !this.getDataController().items().length) {
          return;
        }
        this.component.off("contentReady", triggerUpdateFocusedRow);
        if (needFocusRow) {
          this._triggerUpdateFocusedRow(key, deferred);
        } else {
          deferred.resolve(focusedRowIndex);
        }
      };
      this.component.on("contentReady", triggerUpdateFocusedRow);
      this.getView("rowsView").scrollTopPosition(offset2);
    } else {
      deferred.resolve(-1);
    }
  }
  _triggerUpdateFocusedRow(key, deferred) {
    const focusedRowIndex = this.getFocusedRowIndexByKey(key);
    if (this._isValidFocusedRowIndex(focusedRowIndex)) {
      let d;
      if (this.option("focusedRowEnabled")) {
        this.getDataController().updateItems({
          changeType: "updateFocusedRow",
          focusedRowKey: key
        });
      } else {
        d = this.getView("rowsView").scrollToRowElement(key);
      }
      when(d).done(() => {
        this.getKeyboardController().setFocusedRowIndex(focusedRowIndex);
        deferred && deferred.resolve(focusedRowIndex);
      });
    } else {
      deferred && deferred.resolve(-1);
    }
  }
  getFocusedRowIndexByKey(key) {
    const loadedRowIndex = this.getDataController().getRowIndexByKey(key, true);
    return loadedRowIndex >= 0 ? loadedRowIndex + this.getDataController().getRowIndexOffset(true) : -1;
  }
  _focusRowByKeyOrIndex() {
    const focusedRowKey = this.option("focusedRowKey");
    let currentFocusedRowIndex = this.option("focusedRowIndex");
    if (isDefined(focusedRowKey)) {
      const visibleRowIndex = this.getDataController().getRowIndexByKey(focusedRowKey);
      if (visibleRowIndex >= 0) {
        if (this.getKeyboardController()._isVirtualScrolling()) {
          currentFocusedRowIndex = visibleRowIndex + this.getDataController().getRowIndexOffset();
        }
        this.getKeyboardController().setFocusedRowIndex(currentFocusedRowIndex);
        this._triggerUpdateFocusedRow(focusedRowKey);
      } else {
        this._navigateToRow(focusedRowKey, true).done((focusedRowIndex) => {
          if (currentFocusedRowIndex >= 0 && focusedRowIndex < 0) {
            this._focusRowByIndex();
          } else if (currentFocusedRowIndex < 0 && focusedRowIndex >= 0) {
            this.getKeyboardController().setFocusedRowIndex(focusedRowIndex);
          }
        });
      }
    } else if (currentFocusedRowIndex >= 0) {
      this._focusRowByIndex(currentFocusedRowIndex);
    }
  }
  isRowFocused(key) {
    const focusedRowKey = this.option("focusedRowKey");
    if (isDefined(focusedRowKey)) {
      return equalByValue(key, this.option("focusedRowKey"));
    }
    return;
  }
  updateFocusedRow(e) {
    const that = this;
    const focusedRowIndex = that.getDataController().getRowIndexByKey(e.focusedRowKey);
    const rowsView18 = that.getView("rowsView");
    let $tableElement;
    let $mainRow;
    each(rowsView18.getTableElements(), (index2, element) => {
      const isMainTable = 0 === index2;
      $tableElement = renderer_default(element);
      that._clearPreviousFocusedRow($tableElement, focusedRowIndex);
      const $row = that._prepareFocusedRow({
        changedItem: that.getDataController().getVisibleRows()[focusedRowIndex],
        $tableElement,
        focusedRowIndex
      });
      if (isMainTable) {
        $mainRow = $row;
      }
    });
    if (!e.preventScroll && $mainRow) {
      rowsView18.scrollToElementVertically($mainRow);
    }
  }
  _clearPreviousFocusedRow($tableElement, focusedRowIndex) {
    const $prevRowFocusedElement = $tableElement.find(FOCUSED_ROW_SELECTOR).filter((_, focusedRow) => {
      const $focusedRowTable = renderer_default(focusedRow).closest(`.${this.addWidgetPrefix("table")}`);
      return $tableElement.is($focusedRowTable);
    });
    $prevRowFocusedElement.removeClass("dx-row-focused").removeClass("dx-cell-focus-disabled").removeAttr("tabindex");
    $prevRowFocusedElement.children("td").removeAttr("tabindex");
    if (0 !== focusedRowIndex) {
      const $firstRow = renderer_default(this.getView("rowsView").getRowElement(0));
      $firstRow.removeClass("dx-cell-focus-disabled").removeAttr("tabIndex");
    }
  }
  _prepareFocusedRow(options2) {
    let $row;
    const {
      changedItem
    } = options2;
    if (changedItem && ("data" === changedItem.rowType || "group" === changedItem.rowType)) {
      const {
        focusedRowIndex
      } = options2;
      const {
        $tableElement
      } = options2;
      const tabIndex = this.option("tabindex") || 0;
      const rowsView18 = this.getView("rowsView");
      $row = renderer_default(rowsView18._getRowElements($tableElement).eq(focusedRowIndex));
      $row.addClass("dx-row-focused").attr("tabindex", tabIndex);
    }
    return $row;
  }
};
var keyboardNavigation3 = (Base) => class extends Base {
  init() {
    const rowIndex = this.option("focusedRowIndex");
    const columnIndex = this.option("focusedColumnIndex");
    this.createAction("onFocusedRowChanging", {
      excludeValidators: ["disabled", "readOnly"]
    });
    this.createAction("onFocusedRowChanged", {
      excludeValidators: ["disabled", "readOnly"]
    });
    this.createAction("onFocusedCellChanging", {
      excludeValidators: ["disabled", "readOnly"]
    });
    this.createAction("onFocusedCellChanged", {
      excludeValidators: ["disabled", "readOnly"]
    });
    super.init();
    this.setRowFocusType();
    this._focusedCellPosition = {};
    if (isDefined(rowIndex) && rowIndex >= 0) {
      this._focusedCellPosition.rowIndex = rowIndex;
    }
    if (isDefined(columnIndex) && columnIndex >= 0) {
      this._focusedCellPosition.columnIndex = columnIndex;
    }
  }
  setFocusedRowIndex(rowIndex) {
    super.setFocusedRowIndex(rowIndex);
    this.option("focusedRowIndex", rowIndex);
  }
  setFocusedColumnIndex(columnIndex) {
    super.setFocusedColumnIndex(columnIndex);
    this.option("focusedColumnIndex", columnIndex);
  }
  _escapeKeyHandler(eventArgs, isEditing) {
    if (isEditing || !this.option("focusedRowEnabled")) {
      return super._escapeKeyHandler(eventArgs, isEditing);
    }
    if (this.isCellFocusType()) {
      this.setRowFocusType();
      this._focus(this._getCellElementFromTarget(eventArgs.originalEvent.target), true);
      return true;
    }
    return false;
  }
  _updateFocusedCellPosition($cell, direction) {
    const position3 = super._updateFocusedCellPosition($cell, direction);
    if (position3 && position3.columnIndex >= 0) {
      this._fireFocusedCellChanged($cell);
    }
    return position3;
  }
};
var editorFactory5 = (Base) => class extends Base {
  renderFocusOverlay($element, isHideBorder) {
    var _this$_keyboardNaviga;
    const focusedRowEnabled = this.option("focusedRowEnabled");
    if (!focusedRowEnabled || !(null !== (_this$_keyboardNaviga = this._keyboardNavigationController) && void 0 !== _this$_keyboardNaviga && _this$_keyboardNaviga.isRowFocusType()) || this._editingController.isEditing() || this._columnHeadersView.isFilterRowCell($element)) {
      super.renderFocusOverlay($element, isHideBorder);
    } else if (focusedRowEnabled) {
      const isRowElement = "row" === this._keyboardNavigationController._getElementType($element);
      if (isRowElement && !$element.hasClass("dx-row-focused")) {
        const $cell = this._keyboardNavigationController.getFirstValidCellInRow($element);
        this._keyboardNavigationController.focus($cell);
      }
    }
  }
};
var columns6 = (Base) => class extends Base {
  getSortDataSourceParameters(_, sortByKey) {
    let result2 = super.getSortDataSourceParameters.apply(this, arguments);
    const dataSource = this._dataController._dataSource;
    const store = this._dataController.store();
    let key = store && store.key();
    const remoteOperations = dataSource && dataSource.remoteOperations() || {};
    const isLocalOperations = Object.keys(remoteOperations).every((operationName) => !remoteOperations[operationName]);
    if (key && (this.option("focusedRowEnabled") && false !== this._focusController.isAutoNavigateToFocusedRow() || sortByKey)) {
      key = Array.isArray(key) ? key : [key];
      const notSortedKeys = key.filter((key2) => !this.columnOption(key2, "sortOrder"));
      if (notSortedKeys.length) {
        result2 = result2 || [];
        if (isLocalOperations) {
          result2.push({
            selector: dataSource.getDataIndexGetter(),
            desc: false
          });
        } else {
          notSortedKeys.forEach((notSortedKey) => result2.push({
            selector: notSortedKey,
            desc: false
          }));
        }
      }
    }
    return result2;
  }
};
var data15 = (Base) => class extends Base {
  constructor() {
    super(...arguments);
    this._needToUpdateFocusedRowByIndex = false;
  }
  _applyChange(change) {
    if (change && "updateFocusedRow" === change.changeType) {
      return;
    }
    return super._applyChange.apply(this, arguments);
  }
  _fireChanged(e) {
    super._fireChanged(e);
    if (this.option("focusedRowEnabled") && this._dataSource) {
      const isPartialUpdate = "update" === e.changeType && e.repaintChangesOnly;
      const isPartialUpdateWithDeleting = isPartialUpdate && e.changeTypes && e.changeTypes.indexOf("remove") >= 0;
      if (this._needToUpdateFocusedRowByIndex) {
        this._needToUpdateFocusedRowByIndex = false;
        this._focusController._focusRowByIndex();
      } else if ("refresh" === e.changeType && e.items.length || isPartialUpdateWithDeleting) {
        this._updatePageIndexes();
        this._updateFocusedRow(e);
      } else if ("append" === e.changeType || "prepend" === e.changeType) {
        this._updatePageIndexes();
      } else if ("update" === e.changeType && e.repaintChangesOnly) {
        this._updateFocusedRow(e);
      }
    }
  }
  _handleDataPushed(changes) {
    super._handleDataPushed(changes);
    const focusedRowKey = this.option("focusedRowKey");
    this._needToUpdateFocusedRowByIndex = null === changes || void 0 === changes ? void 0 : changes.some((change) => "remove" === change.type && equalByValue(change.key, focusedRowKey));
  }
  _updatePageIndexes() {
    const prevRenderingPageIndex = this._lastRenderingPageIndex || 0;
    const renderingPageIndex = this._rowsScrollController ? this._rowsScrollController.pageIndex() : 0;
    this._lastRenderingPageIndex = renderingPageIndex;
    this._isPagingByRendering = renderingPageIndex !== prevRenderingPageIndex;
  }
  isPagingByRendering() {
    return this._isPagingByRendering;
  }
  _updateFocusedRow(e) {
    const operationTypes = e.operationTypes || {};
    const {
      reload,
      fullReload,
      pageIndex,
      paging
    } = operationTypes;
    const isVirtualScrolling = this._keyboardNavigationController._isVirtualScrolling();
    const pagingWithoutVirtualScrolling = paging && !isVirtualScrolling;
    const focusedRowKey = this.option("focusedRowKey");
    const isAutoNavigate = this._focusController.isAutoNavigateToFocusedRow();
    const isReload = reload && false === pageIndex;
    if (isReload && !fullReload && isDefined(focusedRowKey)) {
      this._focusController._navigateToRow(focusedRowKey, true).done((focusedRowIndex) => {
        if (focusedRowIndex < 0) {
          this._focusController._focusRowByIndex(void 0, operationTypes);
        }
      });
    } else if (pagingWithoutVirtualScrolling && isAutoNavigate) {
      const rowIndexByKey = this.getRowIndexByKey(focusedRowKey);
      const focusedRowIndex = this.option("focusedRowIndex");
      const isValidRowIndexByKey = rowIndexByKey >= 0;
      const isValidFocusedRowIndex = focusedRowIndex >= 0;
      const isSameRowIndex = focusedRowIndex === rowIndexByKey;
      if (isValidFocusedRowIndex && (isSameRowIndex || !isValidRowIndexByKey)) {
        this._focusController._focusRowByIndex(focusedRowIndex, operationTypes);
      }
    } else if (pagingWithoutVirtualScrolling && !isAutoNavigate && this.getRowIndexByKey(focusedRowKey) < 0) {
      this.option("focusedRowIndex", -1);
    } else if (operationTypes.fullReload) {
      this._focusController._focusRowByKeyOrIndex();
    }
  }
  getPageIndexByKey(key) {
    const that = this;
    const d = new Deferred();
    that.getGlobalRowIndexByKey(key).done((globalIndex) => {
      d.resolve(globalIndex >= 0 ? Math.floor(globalIndex / that.pageSize()) : -1);
    }).fail(d.reject);
    return d.promise();
  }
  getGlobalRowIndexByKey(key) {
    if (this._dataSource.group()) {
      return this._calculateGlobalRowIndexByGroupedData(key);
    }
    return this._calculateGlobalRowIndexByFlatData(key);
  }
  _calculateGlobalRowIndexByFlatData(key, groupFilter, useGroup) {
    const that = this;
    const deferred = new Deferred();
    const dataSource = that._dataSource;
    if (Array.isArray(key) || isNewRowTempKey(key)) {
      return deferred.resolve(-1).promise();
    }
    let filter = that._generateFilterByKey(key);
    dataSource.load({
      filter: that._concatWithCombinedFilter(filter),
      skip: 0,
      take: 1
    }).done((data17) => {
      if (data17.length > 0) {
        filter = that._generateOperationFilterByKey(key, data17[0], useGroup);
        dataSource.load({
          filter: that._concatWithCombinedFilter(filter, groupFilter),
          skip: 0,
          take: 1,
          requireTotalCount: true
        }).done((_, extra) => {
          deferred.resolve(extra.totalCount);
        });
      } else {
        deferred.resolve(-1);
      }
    });
    return deferred.promise();
  }
  _concatWithCombinedFilter(filter, groupFilter) {
    const combinedFilter = this.getCombinedFilter();
    return m_utils_default.combineFilters([filter, combinedFilter, groupFilter]);
  }
  _generateBooleanFilter(selector, value2, sortInfo) {
    const {
      desc
    } = sortInfo;
    switch (true) {
      case (false === value2 && desc):
        return [selector, "=", true];
      case (false === value2 && !desc):
        return [selector, "=", null];
      case (true === value2 && !desc):
      case (!isBoolean(value2) && desc):
        return [selector, "<>", value2];
      default:
        return;
    }
  }
  _generateOperationFilterByKey(key, rowData, useGroup) {
    const that = this;
    const dateSerializationFormat = that.option("dateSerializationFormat");
    const isRemoteFiltering = that._dataSource.remoteOperations().filtering;
    const isRemoteSorting = that._dataSource.remoteOperations().sorting;
    let filter = that._generateFilterByKey(key, "<");
    let sort = that._columnsController.getSortDataSourceParameters(!isRemoteFiltering, true);
    if (useGroup) {
      const group = that._columnsController.getGroupDataSourceParameters(!isRemoteFiltering);
      if (group) {
        sort = sort ? group.concat(sort) : group;
      }
    }
    if (sort) {
      sort.slice().reverse().forEach((sortInfo) => {
        const {
          selector,
          desc,
          compare: compare3
        } = sortInfo;
        const {
          getter,
          rawValue,
          safeValue
        } = UiGridCoreFocusUtils.getSortFilterValue(sortInfo, rowData, {
          isRemoteFiltering,
          dateSerializationFormat,
          getSelector: (selector2) => that._columnsController.columnOption(selector2, "selector")
        });
        filter = [
          [selector, "=", safeValue],
          "and",
          filter
        ];
        if (null === rawValue || isBoolean(rawValue)) {
          const booleanFilter = that._generateBooleanFilter(selector, safeValue, desc);
          if (booleanFilter) {
            filter = [booleanFilter, "or", filter];
          }
        } else {
          const filterOperation = desc ? ">" : "<";
          let sortFilter;
          if (compare3 && !isRemoteSorting) {
            sortFilter = (data17) => {
              if ("<" === filterOperation) {
                return compare3(rawValue, getter(data17)) >= 1;
              }
              return compare3(rawValue, getter(data17)) <= -1;
            };
          } else {
            sortFilter = [selector, filterOperation, safeValue];
            if (!desc) {
              sortFilter = [sortFilter, "or", [selector, "=", null]];
            }
          }
          filter = [sortFilter, "or", filter];
        }
      });
    }
    return filter;
  }
  _generateFilterByKey(key, operation) {
    const dataSourceKey = this._dataSource.key();
    let filter = [];
    if (!operation) {
      operation = "=";
    }
    if (Array.isArray(dataSourceKey)) {
      for (let i = 0; i < dataSourceKey.length; ++i) {
        const keyPart = key[dataSourceKey[i]];
        if (keyPart) {
          if (filter.length > 0) {
            filter.push("and");
          }
          filter.push([dataSourceKey[i], operation, keyPart]);
        }
      }
    } else {
      filter = [dataSourceKey, operation, key];
    }
    return filter;
  }
  _getLastItemIndex() {
    return this.items(true).length - 1;
  }
};
var editing6 = (Base) => class extends Base {
  _deleteRowCore(rowIndex) {
    const deferred = super._deleteRowCore.apply(this, arguments);
    const rowKey = this._dataController.getKeyByRowIndex(rowIndex);
    deferred.done(() => {
      const rowIndex2 = this._dataController.getRowIndexByKey(rowKey);
      const visibleRows = this._dataController.getVisibleRows();
      if (-1 === rowIndex2 && !visibleRows.length) {
        this._focusController._resetFocusedRow();
      }
    });
  }
};
var rowsView16 = (Base) => class extends Base {
  _createRow(row) {
    const $row = super._createRow.apply(this, arguments);
    if (this.option("focusedRowEnabled") && row) {
      if (this._focusController.isRowFocused(row.key)) {
        $row.addClass("dx-row-focused");
      }
    }
    return $row;
  }
  _checkRowKeys(options2) {
    super._checkRowKeys.apply(this, arguments);
    if (this.option("focusedRowEnabled") && this.option("dataSource")) {
      const store = this._dataController.store();
      if (store && !store.key()) {
        this._dataController.fireError("E1042", "Row focusing");
      }
    }
  }
  _update(change) {
    if ("updateFocusedRow" === change.changeType) {
      if (this.option("focusedRowEnabled")) {
        this._focusController.updateFocusedRow(change);
      }
    } else {
      super._update(change);
    }
  }
  updateFocusElementTabIndex($cellElements, preventScroll) {
    if (this.option("focusedRowEnabled")) {
      this._setFocusedRowElementTabIndex(preventScroll);
    } else {
      super.updateFocusElementTabIndex($cellElements);
    }
  }
  _setFocusedRowElementTabIndex(preventScroll) {
    const focusedRowKey = this.option("focusedRowKey");
    const tabIndex = this.option("tabIndex") ?? 0;
    const columnsController = this._columnsController;
    let rowIndex = this._dataController.getRowIndexByKey(focusedRowKey);
    let columnIndex = this.option("focusedColumnIndex");
    const $row = this._findRowElementForTabIndex();
    const dataSource = this._dataController.dataSource();
    const operationTypes = null === dataSource || void 0 === dataSource ? void 0 : dataSource.operationTypes();
    const isPaging = !operationTypes || operationTypes.paging;
    if (!isDefined(this._scrollToFocusOnResize)) {
      this._scrollToFocusOnResize = () => {
        this.scrollToElementVertically(this._findRowElementForTabIndex());
        this.resizeCompleted.remove(this._scrollToFocusOnResize);
      };
    }
    $row.attr("tabIndex", tabIndex);
    const rowIndexFromOption = this.option("focusedRowIndex") - this._dataController.getRowIndexOffset(true);
    if (!isPaging && rowIndex < 0 && rowIndexFromOption >= 0) {
      this._focusController.updateFocusedRow({
        focusedRowKey,
        preventScroll
      });
    }
    if (rowIndex >= 0 && !preventScroll) {
      if (columnIndex < 0) {
        columnIndex = 0;
      }
      rowIndex += this._dataController.getRowIndexOffset();
      columnIndex += columnsController.getColumnIndexOffset();
      this._keyboardNavigationController.setFocusedCellPosition(rowIndex, columnIndex);
      if (this._focusController.isAutoNavigateToFocusedRow()) {
        if (!isPaging && !this._dataController.isPagingByRendering()) {
          this.resizeCompleted.remove(this._scrollToFocusOnResize);
          this.resizeCompleted.add(this._scrollToFocusOnResize);
        }
      }
    }
  }
  _findRowElementForTabIndex() {
    const focusedRowKey = this.option("focusedRowKey");
    const rowIndex = this._dataController.getRowIndexByKey(focusedRowKey);
    return renderer_default(this.getRowElement(rowIndex >= 0 ? rowIndex : 0));
  }
  scrollToRowElement(key) {
    const rowIndex = this._dataController.getRowIndexByKey(key);
    const $row = renderer_default(this.getRow(rowIndex));
    return this.scrollToElementVertically($row);
  }
  scrollToElementVertically($row) {
    const scrollable = this.getScrollable();
    if (scrollable && $row.length) {
      const position3 = scrollable.getScrollElementPosition($row, "vertical");
      return this.scrollTopPosition(position3);
    }
    return new Deferred().resolve();
  }
  scrollTopPosition(scrollTop) {
    const d = new Deferred();
    const scrollable = this.getScrollable();
    if (scrollable) {
      const currentScrollTop = scrollable.scrollTop();
      const scrollHandler = () => {
        scrollable.off("scroll", scrollHandler);
        d.resolve();
      };
      if (scrollTop !== currentScrollTop) {
        scrollable.on("scroll", scrollHandler);
        this._dataController.resetFilterApplying();
        scrollable.scrollTo({
          top: scrollTop
        });
        return d.promise();
      }
    }
    return d.resolve();
  }
};
var focusModule = {
  defaultOptions: () => ({
    focusedRowEnabled: false,
    autoNavigateToFocusedRow: true,
    focusedRowKey: null,
    focusedRowIndex: -1,
    focusedColumnIndex: -1
  }),
  controllers: {
    focus: FocusController
  },
  extenders: {
    controllers: {
      keyboardNavigation: keyboardNavigation3,
      editorFactory: editorFactory5,
      columns: columns6,
      data: data15,
      editing: editing6
    },
    views: {
      rowsView: rowsView16
    }
  }
};

// node_modules/devextreme/esm/__internal/grids/data_grid/focus/m_focus.js
var MAX_SAFE_INTEGER2 = Number.MAX_SAFE_INTEGER || 9007199254740991;
var data16 = (Base) => class extends focusModule.extenders.controllers.data(Base) {
  changeRowExpand(path, isRowClick) {
    if (this.option("focusedRowEnabled") && Array.isArray(path) && this.isRowExpanded(path)) {
      if ((!isRowClick || !this._keyboardNavigationController.isKeyboardEnabled()) && this._isFocusedRowInsideGroup(path)) {
        this.option("focusedRowKey", path);
      }
    }
    return super.changeRowExpand(path, isRowClick);
  }
  _isFocusedRowInsideGroup(path) {
    const focusedRowKey = this.option("focusedRowKey");
    const rowIndex = this.getRowIndexByKey(focusedRowKey);
    const focusedRow = rowIndex >= 0 && this.getVisibleRows()[rowIndex];
    const groups = this._columnsController.getGroupDataSourceParameters(true);
    if (focusedRow) {
      for (let i = 0; i < path.length; ++i) {
        const getter = compileGetter(groups[i] && groups[i].selector);
        if (getter(focusedRow.data) !== path[i]) {
          return false;
        }
      }
    }
    return true;
  }
  _getGroupPath(groupItem, groupCount) {
    const groupPath = [];
    let items = [groupItem];
    while (items && items[0] && groupCount) {
      const item = items[0];
      if (void 0 !== item.key) {
        groupPath.push(item.key);
      }
      items = item.items;
      groupCount--;
    }
    return groupPath;
  }
  _expandGroupByPath(that, groupPath, level) {
    const d = new Deferred();
    level++;
    that.expandRow(groupPath.slice(0, level)).done(() => {
      if (level === groupPath.length) {
        d.resolve();
      } else {
        that._expandGroupByPath(that, groupPath, level).done(d.resolve).fail(d.reject);
      }
    }).fail(d.reject);
    return d.promise();
  }
  _calculateGlobalRowIndexByGroupedData(key) {
    const that = this;
    const dataSource = that._dataSource;
    const filter = that._generateFilterByKey(key);
    const deferred = new Deferred();
    const isGroupKey = Array.isArray(key);
    const group = dataSource.group();
    if (isGroupKey) {
      return deferred.resolve(-1).promise();
    }
    if (!dataSource._grouping._updatePagingOptions) {
      that._calculateGlobalRowIndexByFlatData(key, null, true).done(deferred.resolve).fail(deferred.reject);
      return deferred;
    }
    dataSource.load({
      filter: that._concatWithCombinedFilter(filter),
      group
    }).done((data17) => {
      if (!data17 || 0 === data17.length || !isDefined(data17[0].key) || -1 === data17[0].key) {
        return deferred.resolve(-1).promise();
      }
      const groupPath = that._getGroupPath(data17[0], group.length);
      that._expandGroupByPath(that, groupPath, 0).done(() => {
        that._calculateExpandedRowGlobalIndex(deferred, key, groupPath, group);
      }).fail(deferred.reject);
    }).fail(deferred.reject);
    return deferred.promise();
  }
  _calculateExpandedRowGlobalIndex(deferred, key, groupPath, group) {
    const groupFilter = createGroupFilter(groupPath, {
      group
    });
    const dataSource = this._dataSource;
    const scrollingMode = this.option("scrolling.mode");
    const isVirtualScrolling = "virtual" === scrollingMode || "infinite" === scrollingMode;
    const pageSize = dataSource.pageSize();
    let groupOffset;
    dataSource._grouping._updatePagingOptions({
      skip: 0,
      take: MAX_SAFE_INTEGER2
    }, (groupInfo, totalOffset) => {
      if (equalByValue(groupInfo.path, groupPath)) {
        groupOffset = totalOffset;
      }
    });
    this._calculateGlobalRowIndexByFlatData(key, groupFilter).done((dataOffset) => {
      let count;
      let groupContinuationCount;
      if (dataOffset < 0) {
        deferred.resolve(-1);
        return;
      }
      const currentPageOffset = groupOffset % pageSize || pageSize;
      count = currentPageOffset + dataOffset - groupPath.length;
      if (isVirtualScrolling) {
        groupContinuationCount = 0;
      } else {
        groupContinuationCount = Math.floor(count / (pageSize - groupPath.length)) * groupPath.length;
      }
      count = groupOffset + dataOffset + groupContinuationCount;
      deferred.resolve(count);
    }).fail(deferred.reject);
  }
};
m_core_default.registerModule("focus", _extends({}, focusModule, {
  extenders: _extends({}, focusModule.extenders, {
    controllers: _extends({}, focusModule.extenders.controllers, {
      data: data16
    })
  })
}));

// node_modules/devextreme/esm/__internal/m_draggable.js
var window29 = getWindow();
var DRAGGABLE = "dxDraggable";
var DRAGSTART_EVENT_NAME2 = addNamespace2(DRAG_START_EVENT, DRAGGABLE);
var DRAG_EVENT_NAME = addNamespace2(DRAG_EVENT, DRAGGABLE);
var DRAGEND_EVENT_NAME = addNamespace2(DRAG_END_EVENT, DRAGGABLE);
var DRAG_ENTER_EVENT_NAME = addNamespace2(DRAG_ENTER_EVENT, DRAGGABLE);
var DRAGEND_LEAVE_EVENT_NAME = addNamespace2(DRAG_LEAVE_EVENT, DRAGGABLE);
var POINTERDOWN_EVENT_NAME = addNamespace2(m_pointer_default.down, DRAGGABLE);
var KEYDOWN_EVENT_NAME = addNamespace2("keydown", DRAGGABLE);
var targetDraggable;
var sourceDraggable;
var getMousePosition = (event) => ({
  x: event.pageX - renderer_default(window29).scrollLeft(),
  y: event.pageY - renderer_default(window29).scrollTop()
});
var ScrollHelper = class {
  constructor(orientation, component) {
    this._$scrollableAtPointer = null;
    this._preventScroll = true;
    this._component = component;
    if ("vertical" === orientation) {
      this._scrollValue = "scrollTop";
      this._overFlowAttr = "overflowY";
      this._sizeAttr = "height";
      this._scrollSizeProp = "scrollHeight";
      this._clientSizeProp = "clientHeight";
      this._limitProps = {
        start: "top",
        end: "bottom"
      };
    } else {
      this._scrollValue = "scrollLeft";
      this._overFlowAttr = "overflowX";
      this._sizeAttr = "width";
      this._scrollSizeProp = "scrollWidth";
      this._clientSizeProp = "clientWidth";
      this._limitProps = {
        start: "left",
        end: "right"
      };
    }
  }
  updateScrollable(elements, mousePosition) {
    let isScrollableFound = false;
    elements.some((element) => {
      const $element = renderer_default(element);
      const isTargetOverOverlayWrapper = $element.hasClass("dx-overlay-wrapper");
      const isTargetOverOverlayContent = $element.hasClass("dx-overlay-content");
      if (isTargetOverOverlayWrapper || isTargetOverOverlayContent) {
        return true;
      }
      isScrollableFound = this._trySetScrollable(element, mousePosition);
      return isScrollableFound;
    });
    if (!isScrollableFound) {
      this._$scrollableAtPointer = null;
      this._scrollSpeed = 0;
    }
  }
  isScrolling() {
    return !!this._scrollSpeed;
  }
  isScrollable($element) {
    return ("auto" === $element.css(this._overFlowAttr) || $element.hasClass("dx-scrollable-container")) && $element.prop(this._scrollSizeProp) > Math.ceil("width" === this._sizeAttr ? getWidth($element) : getHeight($element));
  }
  _trySetScrollable(element, mousePosition) {
    const that = this;
    const $element = renderer_default(element);
    let distanceToBorders;
    const sensitivity = that._component.option("scrollSensitivity");
    let isScrollable = that.isScrollable($element);
    if (isScrollable) {
      distanceToBorders = that._calculateDistanceToBorders($element, mousePosition);
      if (sensitivity > distanceToBorders[that._limitProps.start]) {
        if (!that._preventScroll) {
          that._scrollSpeed = -that._calculateScrollSpeed(distanceToBorders[that._limitProps.start]);
          that._$scrollableAtPointer = $element;
        }
      } else if (sensitivity > distanceToBorders[that._limitProps.end]) {
        if (!that._preventScroll) {
          that._scrollSpeed = that._calculateScrollSpeed(distanceToBorders[that._limitProps.end]);
          that._$scrollableAtPointer = $element;
        }
      } else {
        isScrollable = false;
        that._preventScroll = false;
      }
    }
    return isScrollable;
  }
  _calculateDistanceToBorders($area, mousePosition) {
    const area = $area.get(0);
    let areaBoundingRect;
    if (area) {
      areaBoundingRect = getBoundingRect(area);
      return {
        left: mousePosition.x - areaBoundingRect.left,
        top: mousePosition.y - areaBoundingRect.top,
        right: areaBoundingRect.right - mousePosition.x,
        bottom: areaBoundingRect.bottom - mousePosition.y
      };
    }
    return {};
  }
  _calculateScrollSpeed(distance) {
    const component = this._component;
    const sensitivity = component.option("scrollSensitivity");
    const maxSpeed = component.option("scrollSpeed");
    return Math.ceil(((sensitivity - distance) / sensitivity) ** 2 * maxSpeed);
  }
  scrollByStep() {
    const that = this;
    if (that._$scrollableAtPointer && that._scrollSpeed) {
      if (that._$scrollableAtPointer.hasClass("dx-scrollable-container")) {
        const $scrollable = that._$scrollableAtPointer.closest(".dx-scrollable");
        const scrollableInstance = $scrollable.data("dxScrollable") || $scrollable.data("dxScrollView");
        if (scrollableInstance) {
          const nextScrollPosition = scrollableInstance.scrollOffset()[that._limitProps.start] + that._scrollSpeed;
          scrollableInstance.scrollTo({
            [that._limitProps.start]: nextScrollPosition
          });
        }
      } else {
        const nextScrollPosition = that._$scrollableAtPointer[that._scrollValue]() + that._scrollSpeed;
        that._$scrollableAtPointer[that._scrollValue](nextScrollPosition);
      }
      const dragMoveArgs = that._component._dragMoveArgs;
      if (dragMoveArgs) {
        that._component._dragMoveHandler(dragMoveArgs);
      }
    }
  }
  reset() {
    this._$scrollableAtPointer = null;
    this._scrollSpeed = 0;
    this._preventScroll = true;
  }
  isOutsideScrollable($scrollable, event) {
    if (!$scrollable) {
      return false;
    }
    const scrollableSize = getBoundingRect($scrollable.get(0));
    const start = scrollableSize[this._limitProps.start];
    const size = scrollableSize[this._sizeAttr];
    const mousePosition = getMousePosition(event);
    const location = "width" === this._sizeAttr ? mousePosition.x : mousePosition.y;
    return location < start || location > start + size;
  }
};
var ScrollAnimator = class extends m_animator_default {
  ctor(strategy3) {
    super.ctor();
    this._strategy = strategy3;
  }
  _step() {
    const horizontalScrollHelper = this._strategy._horizontalScrollHelper;
    const verticalScrollHelper = this._strategy._verticalScrollHelper;
    null === horizontalScrollHelper || void 0 === horizontalScrollHelper || horizontalScrollHelper.scrollByStep();
    null === verticalScrollHelper || void 0 === verticalScrollHelper || verticalScrollHelper.scrollByStep();
  }
};
var Draggable = class extends dom_component_default {
  reset() {
  }
  dragMove(e) {
  }
  dragEnter() {
  }
  dragLeave() {
  }
  dragEnd(sourceEvent) {
    const sourceDraggable2 = this._getSourceDraggable();
    sourceDraggable2._fireRemoveEvent(sourceEvent);
    return Deferred().resolve();
  }
  _fireRemoveEvent(sourceEvent) {
  }
  _getDefaultOptions() {
    return _extends({}, super._getDefaultOptions(), {
      onDragStart: null,
      onDragMove: null,
      onDragEnd: null,
      onDragEnter: null,
      onDragLeave: null,
      onDragCancel: null,
      onCancelByEsc: false,
      onDrop: null,
      immediate: true,
      dragDirection: "both",
      boundOffset: 0,
      allowMoveByClick: false,
      itemData: null,
      contentTemplate: "content",
      handle: "",
      filter: "",
      clone: false,
      autoScroll: true,
      scrollSpeed: 30,
      scrollSensitivity: 60
    });
  }
  _setOptionsByReference() {
    super._setOptionsByReference.apply(this, arguments);
    extend(this._optionsByReference, {
      component: true,
      group: true,
      itemData: true,
      data: true
    });
  }
  _init() {
    super._init();
    this._attachEventHandlers();
    this._scrollAnimator = new ScrollAnimator(this);
    this._horizontalScrollHelper = new ScrollHelper("horizontal", this);
    this._verticalScrollHelper = new ScrollHelper("vertical", this);
    this._initScrollTop = 0;
    this._initScrollLeft = 0;
  }
  _normalizeCursorOffset(offset2) {
    if (isObject(offset2)) {
      offset2 = {
        h: offset2.x,
        v: offset2.y
      };
    }
    offset2 = splitPair(offset2).map((value2) => parseFloat(value2));
    return {
      left: offset2[0],
      top: 1 === offset2.length ? offset2[0] : offset2[1]
    };
  }
  _getNormalizedCursorOffset(offset2, options2) {
    if (isFunction(offset2)) {
      offset2 = offset2.call(this, options2);
    }
    return this._normalizeCursorOffset(offset2);
  }
  _calculateElementOffset(options2) {
    let elementOffset;
    let dragElementOffset;
    const {
      event
    } = options2;
    const $element = renderer_default(options2.itemElement);
    const $dragElement = renderer_default(options2.dragElement);
    const isCloned = this._dragElementIsCloned();
    const cursorOffset = this.option("cursorOffset");
    let normalizedCursorOffset = {
      left: 0,
      top: 0
    };
    const currentLocate = this._initialLocate = locate($dragElement);
    if (isCloned || options2.initialOffset || cursorOffset) {
      elementOffset = options2.initialOffset || $element.offset();
      if (cursorOffset) {
        normalizedCursorOffset = this._getNormalizedCursorOffset(cursorOffset, options2);
        if (isFinite(normalizedCursorOffset.left)) {
          elementOffset.left = event.pageX;
        }
        if (isFinite(normalizedCursorOffset.top)) {
          elementOffset.top = event.pageY;
        }
      }
      dragElementOffset = $dragElement.offset();
      elementOffset.top -= dragElementOffset.top + (normalizedCursorOffset.top || 0) - currentLocate.top;
      elementOffset.left -= dragElementOffset.left + (normalizedCursorOffset.left || 0) - currentLocate.left;
    }
    return elementOffset;
  }
  _initPosition(options2) {
    const $dragElement = renderer_default(options2.dragElement);
    const elementOffset = this._calculateElementOffset(options2);
    if (elementOffset) {
      this._move(elementOffset, $dragElement);
    }
    this._startPosition = locate($dragElement);
  }
  _startAnimator() {
    if (!this._scrollAnimator.inProgress()) {
      this._scrollAnimator.start();
    }
  }
  _stopAnimator() {
    this._scrollAnimator.stop();
  }
  _addWidgetPrefix(className) {
    const componentName = this.NAME;
    return dasherize(componentName) + (className ? `-${className}` : "");
  }
  _getItemsSelector() {
    return this.option("filter") || "";
  }
  _$content() {
    const $element = this.$element();
    const $wrapper = $element.children(".dx-template-wrapper");
    return $wrapper.length ? $wrapper : $element;
  }
  _attachEventHandlers() {
    if (this.option("disabled")) {
      return;
    }
    let $element = this._$content();
    let itemsSelector = this._getItemsSelector();
    const allowMoveByClick = this.option("allowMoveByClick");
    const data17 = {
      direction: this.option("dragDirection"),
      immediate: this.option("immediate"),
      checkDropTarget: ($target, event) => {
        const targetGroup = this.option("group");
        const sourceGroup = this._getSourceDraggable().option("group");
        const $scrollable = this._getScrollable($target);
        if (this._verticalScrollHelper.isOutsideScrollable($scrollable, event) || this._horizontalScrollHelper.isOutsideScrollable($scrollable, event)) {
          return false;
        }
        return sourceGroup && sourceGroup === targetGroup;
      }
    };
    if (allowMoveByClick) {
      $element = this._getArea();
      m_events_engine_default.on($element, POINTERDOWN_EVENT_NAME, data17, this._pointerDownHandler.bind(this));
    }
    if (">" === itemsSelector[0]) {
      itemsSelector = itemsSelector.slice(1);
    }
    m_events_engine_default.on($element, DRAGSTART_EVENT_NAME2, itemsSelector, data17, this._dragStartHandler.bind(this));
    m_events_engine_default.on($element, DRAG_EVENT_NAME, data17, this._dragMoveHandler.bind(this));
    m_events_engine_default.on($element, DRAGEND_EVENT_NAME, data17, this._dragEndHandler.bind(this));
    m_events_engine_default.on($element, DRAG_ENTER_EVENT_NAME, data17, this._dragEnterHandler.bind(this));
    m_events_engine_default.on($element, DRAGEND_LEAVE_EVENT_NAME, data17, this._dragLeaveHandler.bind(this));
    if (this.option("onCancelByEsc")) {
      m_events_engine_default.on($element, KEYDOWN_EVENT_NAME, this._keydownHandler.bind(this));
    }
  }
  _dragElementIsCloned() {
    var _this$_$dragElement;
    return null === (_this$_$dragElement = this._$dragElement) || void 0 === _this$_$dragElement ? void 0 : _this$_$dragElement.hasClass(this._addWidgetPrefix("clone"));
  }
  _getDragTemplateArgs($element, $container) {
    return {
      container: getPublicElement($container),
      model: {
        itemData: this.option("itemData"),
        itemElement: getPublicElement($element)
      }
    };
  }
  _createDragElement($element) {
    let result2 = $element;
    const clone2 = this.option("clone");
    const $container = this._getContainer();
    let template = this.option("dragTemplate");
    if (template) {
      template = this._getTemplate(template);
      result2 = renderer_default("<div>").appendTo($container);
      template.render(this._getDragTemplateArgs($element, result2));
    } else if (clone2) {
      result2 = renderer_default("<div>").appendTo($container);
      $element.clone().css({
        width: $element.css("width"),
        height: $element.css("height")
      }).appendTo(result2);
    }
    return result2.toggleClass(this._addWidgetPrefix("clone"), result2.get(0) !== $element.get(0)).toggleClass("dx-rtl", this.option("rtlEnabled"));
  }
  _resetDragElement() {
    if (this._dragElementIsCloned()) {
      var _this$_$dragElement2;
      null === (_this$_$dragElement2 = this._$dragElement) || void 0 === _this$_$dragElement2 || _this$_$dragElement2.remove();
    } else {
      this._toggleDraggingClass(false);
    }
    this._$dragElement = null;
  }
  _resetSourceElement() {
    this._toggleDragSourceClass(false);
    this._$sourceElement = null;
  }
  _detachEventHandlers() {
    m_events_engine_default.off(this._$content(), `.${DRAGGABLE}`);
    m_events_engine_default.off(this._getArea(), `.${DRAGGABLE}`);
  }
  _move(position3, $element) {
    move($element || this._$dragElement, position3);
  }
  _getDraggableElement(e) {
    const $sourceElement = this._getSourceElement();
    if ($sourceElement) {
      return $sourceElement;
    }
    const allowMoveByClick = this.option("allowMoveByClick");
    if (allowMoveByClick) {
      return this.$element();
    }
    let $target = renderer_default(null === e || void 0 === e ? void 0 : e.target);
    const itemsSelector = this._getItemsSelector();
    if (">" === itemsSelector[0]) {
      const $items = this._$content().find(itemsSelector);
      if (!$items.is($target)) {
        $target = $target.closest($items);
      }
    }
    return $target;
  }
  _getSourceElement() {
    const draggable = this._getSourceDraggable();
    return draggable._$sourceElement;
  }
  _pointerDownHandler(e) {
    if (needSkipEvent(e)) {
      return;
    }
    const position3 = {};
    const $element = this.$element();
    const {
      dragDirection
    } = this.option();
    if ("horizontal" === dragDirection || "both" === dragDirection) {
      position3.left = e.pageX - $element.offset().left + locate($element).left - getWidth($element) / 2;
    }
    if ("vertical" === dragDirection || "both" === dragDirection) {
      position3.top = e.pageY - $element.offset().top + locate($element).top - getHeight($element) / 2;
    }
    this._move(position3, $element);
    this._getAction("onDragMove")(this._getEventArgs(e));
  }
  _isValidElement(event, $element) {
    var _event$originalEvent;
    const {
      handle
    } = this.option();
    const $target = renderer_default(null === (_event$originalEvent = event.originalEvent) || void 0 === _event$originalEvent ? void 0 : _event$originalEvent.target);
    if (handle && !$target.closest(handle).length) {
      return false;
    }
    if (!$element.length) {
      return false;
    }
    return !$element.is(".dx-state-disabled, .dx-state-disabled *");
  }
  _dragStartHandler(e) {
    const $element = this._getDraggableElement(e);
    this.dragInProgress = true;
    if (!this._isValidElement(e, $element)) {
      e.cancel = true;
      return;
    }
    if (this._$sourceElement) {
      return;
    }
    const dragStartArgs = this._getDragStartArgs(e, $element);
    this._getAction("onDragStart")(dragStartArgs);
    if (dragStartArgs.cancel) {
      e.cancel = true;
      return;
    }
    this.option("itemData", dragStartArgs.itemData);
    this._setSourceDraggable();
    this._$sourceElement = $element;
    let initialOffset = $element.offset();
    if (!this._hasClonedDraggable() && this.option("autoScroll")) {
      this._initScrollTop = this._getScrollableScrollTop();
      this._initScrollLeft = this._getScrollableScrollLeft();
      initialOffset = this._getDraggableElementOffset(initialOffset.left, initialOffset.top);
    }
    const $dragElement = this._$dragElement = this._createDragElement($element);
    this._toggleDraggingClass(true);
    this._toggleDragSourceClass(true);
    this._setGestureCoverCursor($dragElement.children());
    const isFixedPosition = "fixed" === $dragElement.css("position");
    this._initPosition(extend({}, dragStartArgs, {
      dragElement: $dragElement.get(0),
      initialOffset: isFixedPosition && initialOffset
    }));
    this._getAction("onDraggableElementShown")(_extends({}, dragStartArgs, {
      dragElement: $dragElement
    }));
    const $area = this._getArea();
    const areaOffset = this._getAreaOffset($area);
    const boundOffset = this._getBoundOffset();
    const areaWidth = getOuterWidth($area);
    const areaHeight = getOuterHeight($area);
    const elementWidth = getWidth($dragElement);
    const elementHeight = getHeight($dragElement);
    const startOffset_left = $dragElement.offset().left - areaOffset.left, startOffset_top = $dragElement.offset().top - areaOffset.top;
    if ($area.length) {
      e.maxLeftOffset = startOffset_left - boundOffset.left;
      e.maxRightOffset = areaWidth - startOffset_left - elementWidth - boundOffset.right;
      e.maxTopOffset = startOffset_top - boundOffset.top;
      e.maxBottomOffset = areaHeight - startOffset_top - elementHeight - boundOffset.bottom;
    }
    if (this.option("autoScroll")) {
      this._startAnimator();
    }
  }
  _getAreaOffset($area) {
    const offset2 = $area && position_default.offset($area);
    return offset2 || {
      left: 0,
      top: 0
    };
  }
  _toggleDraggingClass(value2) {
    var _this$_$dragElement3;
    null === (_this$_$dragElement3 = this._$dragElement) || void 0 === _this$_$dragElement3 || _this$_$dragElement3.toggleClass(this._addWidgetPrefix("dragging"), value2);
  }
  _toggleDragSourceClass(value2, $element) {
    const $sourceElement = $element || this._$sourceElement;
    null === $sourceElement || void 0 === $sourceElement || $sourceElement.toggleClass(this._addWidgetPrefix("source"), value2);
  }
  _setGestureCoverCursor($element) {
    renderer_default(".dx-gesture-cover").css("cursor", $element.css("cursor"));
  }
  _getBoundOffset() {
    let boundOffset = this.option("boundOffset");
    if (isFunction(boundOffset)) {
      boundOffset = boundOffset.call(this);
    }
    return quadToObject(boundOffset);
  }
  _getArea() {
    let area = this.option("boundary");
    if (isFunction(area)) {
      area = area.call(this);
    }
    return renderer_default(area);
  }
  _getContainer() {
    let {
      container
    } = this.option();
    if (void 0 === container) {
      container = value();
    }
    return renderer_default(container);
  }
  _getDraggableElementOffset(initialOffsetX, initialOffsetY) {
    var _this$_startPosition, _this$_startPosition2;
    const initScrollTop = this._initScrollTop;
    const initScrollLeft = this._initScrollLeft;
    const scrollTop = this._getScrollableScrollTop();
    const scrollLeft = this._getScrollableScrollLeft();
    const elementPosition = renderer_default(this.element()).css("position");
    const isFixedPosition = "fixed" === elementPosition;
    const result2 = {
      left: ((null === (_this$_startPosition = this._startPosition) || void 0 === _this$_startPosition ? void 0 : _this$_startPosition.left) ?? 0) + initialOffsetX,
      top: ((null === (_this$_startPosition2 = this._startPosition) || void 0 === _this$_startPosition2 ? void 0 : _this$_startPosition2.top) ?? 0) + initialOffsetY
    };
    if (isFixedPosition || this._hasClonedDraggable()) {
      return result2;
    }
    return {
      left: isNumeric(scrollLeft) ? result2.left + scrollLeft - initScrollLeft : result2.left,
      top: isNumeric(scrollTop) ? result2.top + scrollTop - initScrollTop : result2.top
    };
  }
  _hasClonedDraggable() {
    return this.option("clone") || this.option("dragTemplate");
  }
  _dragMoveHandler(e) {
    this._dragMoveArgs = e;
    if (!this._$dragElement) {
      e.cancel = true;
      return;
    }
    const offset2 = this._getDraggableElementOffset(e.offset.x, e.offset.y);
    this._move(offset2);
    this._updateScrollable(e);
    const eventArgs = this._getEventArgs(e);
    this._getAction("onDragMove")(eventArgs);
    if (true === eventArgs.cancel) {
      return;
    }
    const targetDraggable2 = this._getTargetDraggable();
    targetDraggable2.dragMove(e, scrollBy);
  }
  _updateScrollable(e) {
    const that = this;
    if (that.option("autoScroll")) {
      const mousePosition = getMousePosition(e);
      const allObjects = dom_adapter_default.elementsFromPoint(mousePosition.x, mousePosition.y, this.$element().get(0));
      that._verticalScrollHelper.updateScrollable(allObjects, mousePosition);
      that._horizontalScrollHelper.updateScrollable(allObjects, mousePosition);
    }
  }
  _getScrollable($element) {
    let $scrollable;
    $element.parents().toArray().some((parent) => {
      const $parent = renderer_default(parent);
      if (this._horizontalScrollHelper.isScrollable($parent) || this._verticalScrollHelper.isScrollable($parent)) {
        $scrollable = $parent;
        return true;
      }
      return false;
    });
    return $scrollable;
  }
  _getScrollableScrollTop() {
    var _this$_getScrollable;
    return (null === (_this$_getScrollable = this._getScrollable(renderer_default(this.element()))) || void 0 === _this$_getScrollable ? void 0 : _this$_getScrollable.scrollTop()) ?? 0;
  }
  _getScrollableScrollLeft() {
    var _this$_getScrollable2;
    return (null === (_this$_getScrollable2 = this._getScrollable(renderer_default(this.element()))) || void 0 === _this$_getScrollable2 ? void 0 : _this$_getScrollable2.scrollLeft()) ?? 0;
  }
  _defaultActionArgs() {
    const args = super._defaultActionArgs.apply(this, arguments);
    const component = this.option("component");
    if (component) {
      args.component = component;
      args.element = component.element();
    }
    return args;
  }
  _getEventArgs(e) {
    const sourceDraggable2 = this._getSourceDraggable();
    const targetDraggable2 = this._getTargetDraggable();
    return {
      event: e,
      itemData: sourceDraggable2.option("itemData"),
      itemElement: getPublicElement(sourceDraggable2._$sourceElement),
      fromComponent: sourceDraggable2.option("component") || sourceDraggable2,
      toComponent: targetDraggable2.option("component") || targetDraggable2,
      fromData: sourceDraggable2.option("data"),
      toData: targetDraggable2.option("data")
    };
  }
  _getDragStartArgs(e, $itemElement) {
    const args = this._getEventArgs(e);
    return {
      event: args.event,
      itemData: args.itemData,
      itemElement: $itemElement,
      fromData: args.fromData
    };
  }
  _revertItemToInitialPosition() {
    !this._dragElementIsCloned() && this._move(this._initialLocate, this._$sourceElement);
  }
  _dragEndHandler(e) {
    const d = Deferred();
    const dragEndEventArgs = this._getEventArgs(e);
    const dropEventArgs = this._getEventArgs(e);
    const targetDraggable2 = this._getTargetDraggable();
    let needRevertPosition = true;
    this.dragInProgress = false;
    try {
      this._getAction("onDragEnd")(dragEndEventArgs);
    } finally {
      when(fromPromise(dragEndEventArgs.cancel)).done((cancel2) => {
        if (!cancel2) {
          if (targetDraggable2 !== this) {
            targetDraggable2._getAction("onDrop")(dropEventArgs);
          }
          if (!dropEventArgs.cancel) {
            needRevertPosition = false;
            when(fromPromise(targetDraggable2.dragEnd(dragEndEventArgs))).always(d.resolve);
            return;
          }
        }
        d.resolve();
      }).fail(d.resolve);
      d.done(() => {
        if (needRevertPosition) {
          this._revertItemToInitialPosition();
        }
        this._resetDragOptions(targetDraggable2);
      });
    }
  }
  _isTargetOverAnotherDraggable(e) {
    const sourceDraggable2 = this._getSourceDraggable();
    if (this === sourceDraggable2) {
      return false;
    }
    const $dragElement = sourceDraggable2._$dragElement;
    const $sourceDraggableElement = sourceDraggable2.$element();
    const $targetDraggableElement = this.$element();
    const mousePosition = getMousePosition(e);
    const elements = dom_adapter_default.elementsFromPoint(mousePosition.x, mousePosition.y, this.element());
    const firstWidgetElement = elements.filter((element) => {
      const $element = renderer_default(element);
      if ($element.hasClass(this._addWidgetPrefix())) {
        return !$element.closest($dragElement).length;
      }
      return false;
    })[0];
    const $sourceElement = this._getSourceElement();
    const isTargetOverItself = firstWidgetElement === $sourceDraggableElement.get(0);
    const isTargetOverNestedDraggable = renderer_default(firstWidgetElement).closest($sourceElement).length;
    return !firstWidgetElement || firstWidgetElement === $targetDraggableElement.get(0) && !isTargetOverItself && !isTargetOverNestedDraggable;
  }
  _dragEnterHandler(e) {
    this._fireDragEnterEvent(e);
    if (this._isTargetOverAnotherDraggable(e)) {
      this._setTargetDraggable();
    }
    const sourceDraggable2 = this._getSourceDraggable();
    sourceDraggable2.dragEnter(e);
  }
  _dragLeaveHandler(e) {
    this._fireDragLeaveEvent(e);
    this._resetTargetDraggable();
    if (this !== this._getSourceDraggable()) {
      this.reset();
    }
    const sourceDraggable2 = this._getSourceDraggable();
    sourceDraggable2.dragLeave(e);
  }
  _keydownHandler(e) {
    if (this.dragInProgress && "Escape" === e.key) {
      this._keydownEscapeHandler(e);
    }
  }
  _keydownEscapeHandler(e) {
    var _sourceDraggable;
    const $sourceElement = this._getSourceElement();
    if (!$sourceElement) {
      return;
    }
    const dragCancelEventArgs = this._getEventArgs(e);
    this._getAction("onDragCancel")(dragCancelEventArgs);
    if (dragCancelEventArgs.cancel) {
      return;
    }
    this.dragInProgress = false;
    null === (_sourceDraggable = sourceDraggable) || void 0 === _sourceDraggable || _sourceDraggable._toggleDraggingClass(false);
    this._detachEventHandlers();
    this._revertItemToInitialPosition();
    const targetDraggable2 = this._getTargetDraggable();
    this._resetDragOptions(targetDraggable2);
    this._attachEventHandlers();
  }
  _getAction(name2) {
    return this[`_${name2}Action`] || this._createActionByOption(name2);
  }
  _getAnonymousTemplateName() {
    return "content";
  }
  _initTemplates() {
    if (!this.option("contentTemplate")) {
      return;
    }
    this._templateManager.addDefaultTemplates({
      content: new EmptyTemplate()
    });
    super._initTemplates.apply(this, arguments);
  }
  _render() {
    super._render();
    this.$element().addClass(this._addWidgetPrefix());
    const transclude = this._templateManager.anonymousTemplateName === this.option("contentTemplate");
    const template = this._getTemplateByOption("contentTemplate");
    if (template) {
      renderer_default(template.render({
        container: this.element(),
        transclude
      }));
    }
  }
  _optionChanged(args) {
    const {
      name: name2
    } = args;
    switch (name2) {
      case "onDragStart":
      case "onDragMove":
      case "onDragEnd":
      case "onDrop":
      case "onDragEnter":
      case "onDragLeave":
      case "onDragCancel":
      case "onDraggableElementShown":
        this[`_${name2}Action`] = this._createActionByOption(name2);
        break;
      case "dragTemplate":
      case "contentTemplate":
      case "container":
      case "clone":
      case "scrollSensitivity":
      case "scrollSpeed":
      case "boundOffset":
      case "handle":
      case "group":
      case "data":
      case "itemData":
        break;
      case "allowMoveByClick":
      case "dragDirection":
      case "disabled":
      case "boundary":
      case "filter":
      case "immediate":
        this._resetDragElement();
        this._detachEventHandlers();
        this._attachEventHandlers();
        break;
      case "onCancelByEsc":
        this._keydownHandler();
        break;
      case "autoScroll":
        this._verticalScrollHelper.reset();
        this._horizontalScrollHelper.reset();
        break;
      default:
        super._optionChanged(args);
    }
  }
  _getTargetDraggable() {
    return targetDraggable || this;
  }
  _getSourceDraggable() {
    return sourceDraggable || this;
  }
  _setTargetDraggable() {
    const currentGroup = this.option("group");
    const sourceDraggable2 = this._getSourceDraggable();
    if (currentGroup && currentGroup === sourceDraggable2.option("group")) {
      targetDraggable = this;
    }
  }
  _setSourceDraggable() {
    sourceDraggable = this;
  }
  _resetSourceDraggable() {
    sourceDraggable = null;
  }
  _resetTargetDraggable() {
    targetDraggable = null;
  }
  _resetDragOptions(targetDraggable2) {
    this.reset();
    targetDraggable2.reset();
    this._stopAnimator();
    this._horizontalScrollHelper.reset();
    this._verticalScrollHelper.reset();
    this._resetDragElement();
    this._resetSourceElement();
    this._resetTargetDraggable();
    this._resetSourceDraggable();
  }
  _dispose() {
    super._dispose();
    this._detachEventHandlers();
    this._resetDragElement();
    this._resetTargetDraggable();
    this._resetSourceDraggable();
    this._$sourceElement = null;
    this._stopAnimator();
  }
  _fireDragEnterEvent(sourceEvent) {
    const args = this._getEventArgs(sourceEvent);
    this._getAction("onDragEnter")(args);
  }
  _fireDragLeaveEvent(sourceEvent) {
    const args = this._getEventArgs(sourceEvent);
    this._getAction("onDragLeave")(args);
  }
};
component_registrator_default(DRAGGABLE, Draggable);
var m_draggable_default = Draggable;

// node_modules/devextreme/esm/__internal/m_sortable.js
var window30 = getWindow();
var SORTABLE = "dxSortable";
var isElementVisible = (itemElement) => renderer_default(itemElement).is(":visible");
var animate2 = (element, config3) => {
  var _config$to, _config$to2;
  if (!element) {
    return;
  }
  const left = (null === (_config$to = config3.to) || void 0 === _config$to ? void 0 : _config$to.left) || 0;
  const top = (null === (_config$to2 = config3.to) || void 0 === _config$to2 ? void 0 : _config$to2.top) || 0;
  element.style.transform = `translate(${left}px,${top}px)`;
  element.style.transition = fx_default.off ? "" : `transform ${config3.duration}ms ${config3.easing}`;
};
var stopAnimation = (element) => {
  if (!element) {
    return;
  }
  element.style.transform = "";
  element.style.transition = "";
};
function getScrollableBoundary($scrollable) {
  const offset2 = $scrollable.offset();
  const {
    style
  } = $scrollable[0];
  const paddingLeft = parseFloat(style.paddingLeft) || 0;
  const paddingRight = parseFloat(style.paddingRight) || 0;
  const paddingTop = parseFloat(style.paddingTop) || 0;
  const width = $scrollable[0].clientWidth - (paddingLeft + paddingRight);
  const height = getHeight($scrollable);
  const left = offset2.left + paddingLeft;
  const top = offset2.top + paddingTop;
  return {
    left,
    right: left + width,
    top,
    bottom: top + height
  };
}
var Sortable = class extends m_draggable_default {
  _init() {
    super._init();
    this._sourceScrollHandler = this._handleSourceScroll.bind(this);
    this._sourceScrollableInfo = null;
  }
  _getDefaultOptions() {
    return _extends({}, super._getDefaultOptions(), {
      clone: true,
      filter: "> *",
      itemOrientation: "vertical",
      dropFeedbackMode: "push",
      allowDropInsideItem: false,
      allowReordering: true,
      moveItemOnDrop: false,
      onDragChange: null,
      onAdd: null,
      onRemove: null,
      onReorder: null,
      onPlaceholderPrepared: null,
      placeholderClassName: "",
      animation: {
        type: "slide",
        duration: 300,
        easing: "ease"
      },
      fromIndex: null,
      toIndex: null,
      dropInsideItem: false,
      itemPoints: null,
      fromIndexOffset: 0,
      offset: 0,
      autoUpdate: false,
      draggableElementSize: 0
    });
  }
  reset() {
    this.option({
      dropInsideItem: false,
      toIndex: null,
      fromIndex: null,
      itemPoints: null,
      fromIndexOffset: 0,
      draggableElementSize: 0
    });
    if (this._$placeholderElement) {
      this._$placeholderElement.remove();
    }
    this._$placeholderElement = null;
    if (!this._isIndicateMode() && this._$modifiedItem) {
      this._$modifiedItem.css("marginBottom", this._modifiedItemMargin);
      this._$modifiedItem = null;
    }
  }
  _getPrevVisibleItem(items, index2) {
    return items.slice(0, index2).reverse().filter(isElementVisible)[0];
  }
  _dragStartHandler(e) {
    super._dragStartHandler.apply(this, arguments);
    if (true === e.cancel) {
      return;
    }
    const $sourceElement = this._getSourceElement();
    this._updateItemPoints();
    this._subscribeToSourceScroll(e);
    this.option("fromIndex", this._getElementIndex($sourceElement));
    this.option("fromIndexOffset", this.option("offset"));
  }
  _subscribeToSourceScroll(e) {
    const $scrollable = this._getScrollable(renderer_default(e.target));
    if ($scrollable) {
      this._sourceScrollableInfo = {
        element: $scrollable,
        scrollLeft: $scrollable.scrollLeft(),
        scrollTop: $scrollable.scrollTop()
      };
      m_events_engine_default.off($scrollable, "scroll", this._sourceScrollHandler);
      m_events_engine_default.on($scrollable, "scroll", this._sourceScrollHandler);
    }
  }
  _unsubscribeFromSourceScroll() {
    if (this._sourceScrollableInfo) {
      m_events_engine_default.off(this._sourceScrollableInfo.element, "scroll", this._sourceScrollHandler);
      this._sourceScrollableInfo = null;
    }
  }
  _handleSourceScroll(e) {
    const sourceScrollableInfo = this._sourceScrollableInfo;
    if (sourceScrollableInfo) {
      ["scrollLeft", "scrollTop"].forEach((scrollProp) => {
        if (e.target[scrollProp] !== sourceScrollableInfo[scrollProp]) {
          const scrollBy2 = e.target[scrollProp] - sourceScrollableInfo[scrollProp];
          this._correctItemPoints(scrollBy2);
          this._movePlaceholder();
          sourceScrollableInfo[scrollProp] = e.target[scrollProp];
        }
      });
    }
  }
  _dragEnterHandler(e) {
    super._dragEnterHandler.apply(this, arguments);
    if (this === this._getSourceDraggable()) {
      return;
    }
    this._subscribeToSourceScroll(e);
    this._updateItemPoints();
    this.option("fromIndex", -1);
    if (!this._isIndicateMode()) {
      const itemPoints = this.option("itemPoints");
      const lastItemPoint = itemPoints[itemPoints.length - 1];
      if (lastItemPoint) {
        const $element = this.$element();
        const $sourceElement = this._getSourceElement();
        const isVertical = this._isVerticalOrientation();
        const sourceElementSize = isVertical ? getOuterHeight($sourceElement, true) : getOuterWidth($sourceElement, true);
        const scrollSize = $element.get(0)[isVertical ? "scrollHeight" : "scrollWidth"];
        const scrollPosition = $element.get(0)[isVertical ? "scrollTop" : "scrollLeft"];
        const positionProp = isVertical ? "top" : "left";
        const lastPointPosition = lastItemPoint[positionProp];
        const elementPosition = $element.offset()[positionProp];
        const freeSize = elementPosition + scrollSize - scrollPosition - lastPointPosition;
        if (freeSize < sourceElementSize) {
          if (isVertical) {
            const items = this._getItems();
            const $lastItem = renderer_default(this._getPrevVisibleItem(items));
            this._$modifiedItem = $lastItem;
            this._modifiedItemMargin = $lastItem.get(0).style.marginBottom;
            $lastItem.css("marginBottom", sourceElementSize - freeSize);
            const $sortable = $lastItem.closest(".dx-sortable");
            const sortable = $sortable.data("dxScrollable") || $sortable.data("dxScrollView");
            null === sortable || void 0 === sortable || sortable.update();
          }
        }
      }
    }
  }
  _dragLeaveHandler() {
    super._dragLeaveHandler.apply(this, arguments);
    if (this !== this._getSourceDraggable()) {
      this._unsubscribeFromSourceScroll();
    }
  }
  dragEnter() {
    if (this !== this._getTargetDraggable()) {
      this.option("toIndex", -1);
    }
  }
  dragLeave() {
    if (this !== this._getTargetDraggable()) {
      this.option("toIndex", this.option("fromIndex"));
    }
  }
  _allowDrop(event) {
    const targetDraggable2 = this._getTargetDraggable();
    const $targetDraggable = targetDraggable2.$element();
    const $scrollable = this._getScrollable($targetDraggable);
    if ($scrollable) {
      const {
        left,
        right,
        top,
        bottom
      } = getScrollableBoundary($scrollable);
      const toIndex = this.option("toIndex");
      const itemPoints = this.option("itemPoints");
      const itemPoint = null === itemPoints || void 0 === itemPoints ? void 0 : itemPoints.filter((item) => item.index === toIndex)[0];
      if (itemPoint && void 0 !== itemPoint.top) {
        const isVertical = this._isVerticalOrientation();
        if (isVertical) {
          return top <= Math.ceil(itemPoint.top) && Math.floor(itemPoint.top) <= bottom;
        }
        return left <= Math.ceil(itemPoint.left) && Math.floor(itemPoint.left) <= right;
      }
    }
    return true;
  }
  dragEnd(sourceEvent) {
    this._unsubscribeFromSourceScroll();
    const $sourceElement = this._getSourceElement();
    const sourceDraggable2 = this._getSourceDraggable();
    const isSourceDraggable = sourceDraggable2.NAME !== this.NAME;
    const toIndex = this.option("toIndex");
    const {
      event
    } = sourceEvent;
    const allowDrop = this._allowDrop(event);
    if (null !== toIndex && toIndex >= 0 && allowDrop) {
      let cancelAdd;
      let cancelRemove;
      if (sourceDraggable2 !== this) {
        cancelAdd = this._fireAddEvent(event);
        if (!cancelAdd) {
          cancelRemove = this._fireRemoveEvent(event);
        }
      }
      if (isSourceDraggable) {
        resetPosition($sourceElement);
      }
      if (this.option("moveItemOnDrop")) {
        !cancelAdd && this._moveItem($sourceElement, toIndex, cancelRemove);
      }
      if (sourceDraggable2 === this) {
        return this._fireReorderEvent(event);
      }
    }
    return Deferred().resolve();
  }
  dragMove(e) {
    const itemPoints = this.option("itemPoints");
    if (!itemPoints) {
      return;
    }
    const isVertical = this._isVerticalOrientation();
    const axisName = isVertical ? "top" : "left";
    const cursorPosition = isVertical ? e.pageY : e.pageX;
    const rtlEnabled = this.option("rtlEnabled");
    let itemPoint;
    for (let i = itemPoints.length - 1; i >= 0; i--) {
      const centerPosition = itemPoints[i + 1] && (itemPoints[i][axisName] + itemPoints[i + 1][axisName]) / 2;
      if ((!isVertical && rtlEnabled ? cursorPosition > centerPosition : centerPosition > cursorPosition) || void 0 === centerPosition) {
        itemPoint = itemPoints[i];
      } else {
        break;
      }
    }
    if (itemPoint) {
      this._updatePlaceholderPosition(e, itemPoint);
      if (this._verticalScrollHelper.isScrolling() && this._isIndicateMode()) {
        this._movePlaceholder();
      }
    }
  }
  _isIndicateMode() {
    return "indicate" === this.option("dropFeedbackMode") || this.option("allowDropInsideItem");
  }
  _createPlaceholder() {
    if (!this._isIndicateMode()) {
      return;
    }
    const customCssClass = this.option("placeholderClassName");
    this._$placeholderElement = renderer_default("<div>").addClass(this._addWidgetPrefix("placeholder")).addClass(customCssClass ?? "").insertBefore(this._getSourceDraggable()._$dragElement);
    return this._$placeholderElement;
  }
  _getItems() {
    const itemsSelector = this._getItemsSelector();
    return this._$content().find(itemsSelector).not(`.${this._addWidgetPrefix("placeholder")}`).not(`.${this._addWidgetPrefix("clone")}`).toArray();
  }
  _allowReordering() {
    const sourceDraggable2 = this._getSourceDraggable();
    const targetDraggable2 = this._getTargetDraggable();
    return sourceDraggable2 !== targetDraggable2 || this.option("allowReordering");
  }
  _isValidPoint(visibleIndex, draggableVisibleIndex, dropInsideItem) {
    const allowDropInsideItem = this.option("allowDropInsideItem");
    const allowReordering2 = dropInsideItem || this._allowReordering();
    if (!allowReordering2 && (0 !== visibleIndex || !allowDropInsideItem)) {
      return false;
    }
    if (!this._isIndicateMode()) {
      return true;
    }
    return -1 === draggableVisibleIndex || visibleIndex !== draggableVisibleIndex && (dropInsideItem || visibleIndex !== draggableVisibleIndex + 1);
  }
  _getItemPoints() {
    const that = this;
    let result2 = [];
    let $item;
    let offset2;
    let itemWidth;
    const {
      rtlEnabled
    } = that.option();
    const isVertical = that._isVerticalOrientation();
    const itemElements = that._getItems();
    const visibleItemElements = itemElements.filter(isElementVisible);
    const visibleItemCount = visibleItemElements.length;
    const $draggableItem = this._getDraggableElement();
    const draggableVisibleIndex = visibleItemElements.indexOf($draggableItem.get(0));
    if (visibleItemCount) {
      for (let i = 0; i <= visibleItemCount; i++) {
        const needCorrectLeftPosition = !isVertical && rtlEnabled ^ i === visibleItemCount;
        const needCorrectTopPosition = isVertical && i === visibleItemCount;
        if (i < visibleItemCount) {
          $item = renderer_default(visibleItemElements[i]);
          offset2 = $item.offset();
          itemWidth = getOuterWidth($item);
        }
        result2.push({
          dropInsideItem: false,
          left: offset2.left + (needCorrectLeftPosition ? itemWidth : 0),
          top: offset2.top + (needCorrectTopPosition ? result2[i - 1].height : 0),
          index: i === visibleItemCount ? itemElements.length : itemElements.indexOf($item.get(0)),
          $item,
          width: getOuterWidth($item),
          height: getOuterHeight($item),
          isValid: that._isValidPoint(i, draggableVisibleIndex)
        });
      }
      if (this.option("allowDropInsideItem")) {
        const points = result2;
        result2 = [];
        for (let i = 0; i < points.length; i++) {
          result2.push(points[i]);
          if (points[i + 1]) {
            result2.push(extend({}, points[i], {
              dropInsideItem: true,
              top: Math.floor((points[i].top + points[i + 1].top) / 2),
              left: Math.floor((points[i].left + points[i + 1].left) / 2),
              isValid: this._isValidPoint(i, draggableVisibleIndex, true)
            }));
          }
        }
      }
    } else {
      result2.push({
        dropInsideItem: false,
        index: 0,
        isValid: true
      });
    }
    return result2;
  }
  _updateItemPoints(forceUpdate) {
    if (forceUpdate || this.option("autoUpdate") || !this.option("itemPoints")) {
      this.option("itemPoints", this._getItemPoints());
    }
  }
  _correctItemPoints(scrollBy2) {
    const itemPoints = this.option("itemPoints");
    if (scrollBy2 && itemPoints && !this.option("autoUpdate")) {
      const isVertical = this._isVerticalOrientation();
      const positionPropName = isVertical ? "top" : "left";
      itemPoints.forEach((itemPoint) => {
        itemPoint[positionPropName] -= scrollBy2;
      });
    }
  }
  _getElementIndex($itemElement) {
    return this._getItems().indexOf($itemElement.get(0));
  }
  _getDragTemplateArgs($element) {
    const args = super._getDragTemplateArgs.apply(this, arguments);
    args.model.fromIndex = this._getElementIndex($element);
    return args;
  }
  _togglePlaceholder(value2) {
    var _this$_$placeholderEl;
    null === (_this$_$placeholderEl = this._$placeholderElement) || void 0 === _this$_$placeholderEl || _this$_$placeholderEl.toggle(value2);
  }
  _isVerticalOrientation() {
    const {
      itemOrientation
    } = this.option();
    return "vertical" === itemOrientation;
  }
  _normalizeToIndex(toIndex, skipOffsetting) {
    const isAnotherDraggable = this._getSourceDraggable() !== this._getTargetDraggable();
    const fromIndex = this._getActualFromIndex();
    if (null === toIndex) {
      return fromIndex;
    }
    return Math.max(isAnotherDraggable || fromIndex >= toIndex || skipOffsetting ? toIndex : toIndex - 1, 0);
  }
  _updatePlaceholderPosition(e, itemPoint) {
    const sourceDraggable2 = this._getSourceDraggable();
    const toIndex = this._normalizeToIndex(itemPoint.index, itemPoint.dropInsideItem);
    const eventArgs = extend(this._getEventArgs(e), {
      toIndex,
      dropInsideItem: itemPoint.dropInsideItem
    });
    itemPoint.isValid && this._getAction("onDragChange")(eventArgs);
    if (eventArgs.cancel || !itemPoint.isValid) {
      if (!itemPoint.isValid) {
        this.option({
          dropInsideItem: false,
          toIndex: null
        });
      }
      return;
    }
    this.option({
      dropInsideItem: itemPoint.dropInsideItem,
      toIndex: itemPoint.index
    });
    this._getAction("onPlaceholderPrepared")(extend(this._getEventArgs(e), {
      placeholderElement: getPublicElement(this._$placeholderElement),
      dragElement: getPublicElement(sourceDraggable2._$dragElement)
    }));
    this._updateItemPoints();
  }
  _makeWidthCorrection($item, width) {
    this._$scrollable = this._getScrollable($item);
    if (this._$scrollable) {
      const scrollableWidth = getWidth(this._$scrollable);
      const overflowLeft = this._$scrollable.offset().left - $item.offset().left;
      const overflowRight = getOuterWidth($item) - overflowLeft - scrollableWidth;
      if (overflowLeft > 0) {
        width -= overflowLeft;
      }
      if (overflowRight > 0) {
        width -= overflowRight;
      }
    }
    return width;
  }
  _updatePlaceholderSizes($placeholderElement, $itemElement) {
    const dropInsideItem = this.option("dropInsideItem");
    const isVertical = this._isVerticalOrientation();
    let width = "";
    let height = "";
    $placeholderElement.toggleClass(this._addWidgetPrefix("placeholder-inside"), dropInsideItem);
    if (isVertical || dropInsideItem) {
      width = getOuterWidth($itemElement);
    }
    if (!isVertical || dropInsideItem) {
      height = getOuterHeight($itemElement);
    }
    width = this._makeWidthCorrection($itemElement, width);
    $placeholderElement.css({
      width,
      height
    });
  }
  _moveItem($itemElement, index2, cancelRemove) {
    let $prevTargetItemElement;
    const $itemElements = this._getItems();
    const $targetItemElement = $itemElements[index2];
    const sourceDraggable2 = this._getSourceDraggable();
    if (cancelRemove) {
      $itemElement = $itemElement.clone();
      sourceDraggable2._toggleDragSourceClass(false, $itemElement);
    }
    if (!$targetItemElement) {
      $prevTargetItemElement = $itemElements[index2 - 1];
    }
    this._moveItemCore($itemElement, $targetItemElement, $prevTargetItemElement);
  }
  _moveItemCore($targetItem, item, prevItem) {
    if (!item && !prevItem) {
      $targetItem.appendTo(this.$element());
    } else if (prevItem) {
      $targetItem.insertAfter(renderer_default(prevItem));
    } else {
      $targetItem.insertBefore(renderer_default(item));
    }
  }
  _getDragStartArgs(e, $itemElement) {
    return extend(super._getDragStartArgs.apply(this, arguments), {
      fromIndex: this._getElementIndex($itemElement)
    });
  }
  _getEventArgs(e) {
    const sourceDraggable2 = this._getSourceDraggable();
    const targetDraggable2 = this._getTargetDraggable();
    const dropInsideItem = targetDraggable2.option("dropInsideItem");
    return extend(super._getEventArgs.apply(this, arguments), {
      fromIndex: sourceDraggable2.option("fromIndex"),
      toIndex: this._normalizeToIndex(targetDraggable2.option("toIndex"), dropInsideItem),
      dropInsideItem
    });
  }
  _optionChanged(args) {
    const {
      name: name2
    } = args;
    switch (name2) {
      case "onDragChange":
      case "onPlaceholderPrepared":
      case "onAdd":
      case "onRemove":
      case "onReorder":
        this[`_${name2}Action`] = this._createActionByOption(name2);
        break;
      case "fromIndex":
        [false, true].forEach((isDragSource) => {
          const fromIndex = isDragSource ? args.value : args.previousValue;
          if (null !== fromIndex) {
            const $fromElement = renderer_default(this._getItems()[fromIndex]);
            this._toggleDragSourceClass(isDragSource, $fromElement);
          }
        });
        break;
      case "dropInsideItem":
        this._optionChangedDropInsideItem(args);
        break;
      case "toIndex":
        this._optionChangedToIndex(args);
        break;
      case "itemOrientation":
      case "allowDropInsideItem":
      case "moveItemOnDrop":
      case "dropFeedbackMode":
      case "itemPoints":
      case "animation":
      case "allowReordering":
      case "fromIndexOffset":
      case "offset":
      case "draggableElementSize":
      case "autoUpdate":
      case "placeholderClassName":
        break;
      default:
        super._optionChanged(args);
    }
  }
  _optionChangedDropInsideItem() {
    if (this._isIndicateMode() && this._$placeholderElement) {
      this._movePlaceholder();
    }
  }
  _isPositionVisible(position3) {
    const $element = this.$element();
    let scrollContainer;
    if ("hidden" !== $element.css("overflow")) {
      scrollContainer = $element.get(0);
    } else {
      $element.parents().each(function() {
        if ("visible" !== renderer_default(this).css("overflow")) {
          scrollContainer = this;
          return false;
        }
        return;
      });
    }
    if (scrollContainer) {
      const clientRect = getBoundingRect(scrollContainer);
      const isVerticalOrientation = this._isVerticalOrientation();
      const start = isVerticalOrientation ? "top" : "left";
      const end = isVerticalOrientation ? "bottom" : "right";
      const pageOffset = isVerticalOrientation ? window30.pageYOffset : window30.pageXOffset;
      if (position3[start] < clientRect[start] + pageOffset || position3[start] > clientRect[end] + pageOffset) {
        return false;
      }
    }
    return true;
  }
  _optionChangedToIndex(args) {
    const toIndex = args.value;
    if (this._isIndicateMode()) {
      const showPlaceholder = null !== toIndex && toIndex >= 0;
      this._togglePlaceholder(showPlaceholder);
      if (showPlaceholder) {
        this._movePlaceholder();
      }
    } else {
      this._moveItems(args.previousValue, args.value, args.fullUpdate);
    }
  }
  update() {
    if (null === this.option("fromIndex") && null === this.option("toIndex")) {
      return;
    }
    this._updateItemPoints(true);
    this._updateDragSourceClass();
    const toIndex = this.option("toIndex");
    this._optionChangedToIndex({
      value: toIndex,
      fullUpdate: true
    });
  }
  _updateDragSourceClass() {
    const fromIndex = this._getActualFromIndex();
    const $fromElement = renderer_default(this._getItems()[fromIndex]);
    if ($fromElement.length) {
      this._$sourceElement = $fromElement;
      this._toggleDragSourceClass(true, $fromElement);
    }
  }
  _makeLeftCorrection(left) {
    const $scrollable = this._$scrollable;
    if ($scrollable && this._isVerticalOrientation()) {
      const overflowLeft = $scrollable.offset().left - left;
      if (overflowLeft > 0) {
        left += overflowLeft;
      }
    }
    return left;
  }
  _movePlaceholder() {
    const that = this;
    const $placeholderElement = that._$placeholderElement || that._createPlaceholder();
    if (!$placeholderElement) {
      return;
    }
    const items = that._getItems();
    const toIndex = that.option("toIndex");
    const isVerticalOrientation = that._isVerticalOrientation();
    const rtlEnabled = this.option("rtlEnabled");
    const dropInsideItem = that.option("dropInsideItem");
    let position3 = null;
    let itemElement = items[toIndex];
    if (itemElement) {
      const $itemElement = renderer_default(itemElement);
      position3 = $itemElement.offset();
      if (!isVerticalOrientation && rtlEnabled && !dropInsideItem) {
        position3.left += getOuterWidth($itemElement, true);
      }
    } else {
      const prevVisibleItemElement = itemElement = this._getPrevVisibleItem(items, toIndex);
      if (prevVisibleItemElement) {
        position3 = renderer_default(prevVisibleItemElement).offset();
        if (isVerticalOrientation) {
          position3.top += getOuterHeight(prevVisibleItemElement, true);
        } else if (!rtlEnabled) {
          position3.left += getOuterWidth(prevVisibleItemElement, true);
        }
      }
    }
    that._updatePlaceholderSizes($placeholderElement, renderer_default(itemElement));
    if (position3 && !that._isPositionVisible(position3)) {
      position3 = null;
    }
    if (position3) {
      const isLastVerticalPosition = isVerticalOrientation && toIndex === items.length;
      const outerPlaceholderHeight = getOuterHeight($placeholderElement);
      position3.left = that._makeLeftCorrection(position3.left);
      position3.top = isLastVerticalPosition && position3.top >= outerPlaceholderHeight ? position3.top - outerPlaceholderHeight : position3.top;
      that._move(position3, $placeholderElement);
    }
    $placeholderElement.toggle(!!position3);
  }
  _getPositions(items, elementSize2, fromIndex, toIndex) {
    const positions = [];
    for (let i = 0; i < items.length; i++) {
      let position3 = 0;
      if (null === toIndex || null === fromIndex) {
        positions.push(position3);
        continue;
      }
      if (-1 === fromIndex) {
        if (i >= toIndex) {
          position3 = elementSize2;
        }
      } else if (-1 === toIndex) {
        if (i > fromIndex) {
          position3 = -elementSize2;
        }
      } else if (fromIndex < toIndex) {
        if (i > fromIndex && i < toIndex) {
          position3 = -elementSize2;
        }
      } else if (fromIndex > toIndex) {
        if (i >= toIndex && i < fromIndex) {
          position3 = elementSize2;
        }
      }
      positions.push(position3);
    }
    return positions;
  }
  _getDraggableElementSize(isVerticalOrientation) {
    const $draggableItem = this._getDraggableElement();
    let size = this.option("draggableElementSize");
    if (!size) {
      size = isVerticalOrientation ? (getOuterHeight($draggableItem) + getOuterHeight($draggableItem, true)) / 2 : (getOuterWidth($draggableItem) + getOuterWidth($draggableItem, true)) / 2;
      if (!this.option("autoUpdate")) {
        this.option("draggableElementSize", size);
      }
    }
    return size;
  }
  _getActualFromIndex() {
    const {
      fromIndex,
      fromIndexOffset,
      offset: offset2
    } = this.option();
    return null == fromIndex ? null : fromIndex + fromIndexOffset - offset2;
  }
  _moveItems(prevToIndex, toIndex, fullUpdate) {
    const fromIndex = this._getActualFromIndex();
    const isVerticalOrientation = this._isVerticalOrientation();
    const positionPropName = isVerticalOrientation ? "top" : "left";
    const elementSize2 = this._getDraggableElementSize(isVerticalOrientation);
    const items = this._getItems();
    const prevPositions = this._getPositions(items, elementSize2, fromIndex, prevToIndex);
    const positions = this._getPositions(items, elementSize2, fromIndex, toIndex);
    const animationConfig = this.option("animation");
    const rtlEnabled = this.option("rtlEnabled");
    for (let i = 0; i < items.length; i++) {
      const itemElement = items[i];
      const prevPosition = prevPositions[i];
      const position3 = positions[i];
      if (null === toIndex || null === fromIndex) {
        stopAnimation(itemElement);
      } else if (prevPosition !== position3 || fullUpdate && isDefined(position3)) {
        animate2(itemElement, extend({}, animationConfig, {
          to: {
            [positionPropName]: !isVerticalOrientation && rtlEnabled ? -position3 : position3
          }
        }));
      }
    }
  }
  _toggleDragSourceClass(value2, $element) {
    const $sourceElement = $element || this._$sourceElement;
    super._toggleDragSourceClass.apply(this, arguments);
    if (!this._isIndicateMode()) {
      null === $sourceElement || void 0 === $sourceElement || $sourceElement.toggleClass(this._addWidgetPrefix("source-hidden"), value2);
    }
  }
  _dispose() {
    this.reset();
    super._dispose();
  }
  _fireAddEvent(sourceEvent) {
    const args = this._getEventArgs(sourceEvent);
    this._getAction("onAdd")(args);
    return args.cancel;
  }
  _fireRemoveEvent(sourceEvent) {
    const sourceDraggable2 = this._getSourceDraggable();
    const args = this._getEventArgs(sourceEvent);
    sourceDraggable2._getAction("onRemove")(args);
    return args.cancel;
  }
  _fireReorderEvent(sourceEvent) {
    const args = this._getEventArgs(sourceEvent);
    this._getAction("onReorder")(args);
    return args.promise || Deferred().resolve();
  }
};
component_registrator_default(SORTABLE, Sortable);
var m_sortable_default = Sortable;

// node_modules/devextreme/esm/ui/sortable.js
var sortable_default = m_sortable_default;

// node_modules/devextreme/esm/__internal/grids/grid_core/row_dragging/const.js
var ATTRIBUTES2 = {
  dragCell: "dx-drag-cell"
};
var CLASSES7 = {
  cellFocusDisabled: "dx-cell-focus-disabled",
  handleIcon: "drag-icon",
  commandDrag: "dx-command-drag",
  sortableWithoutHandle: "dx-sortable-without-handle",
  rowsView: "rowsview",
  dragView: "dragview"
};

// node_modules/devextreme/esm/__internal/grids/grid_core/row_dragging/dom.js
var createHandleTemplateFunc = (addWidgetPrefix) => (container, options2) => {
  const $container = renderer_default(container);
  if ("data" === options2.rowType) {
    $container.addClass(CLASSES7.cellFocusDisabled);
    return renderer_default("<span>").addClass(addWidgetPrefix(CLASSES7.handleIcon));
  }
  m_utils_default.setEmptyText($container);
  return;
};
var GridCoreRowDraggingDom = {
  createHandleTemplateFunc
};

// node_modules/devextreme/esm/__internal/grids/grid_core/row_dragging/m_row_dragging.js
var rowsView17 = (Base) => class extends Base {
  init() {
    super.init.apply(this, arguments);
    this._updateHandleColumn();
  }
  optionChanged(args) {
    if ("rowDragging" === args.name) {
      this._updateHandleColumn();
      this._invalidate(true, true);
      args.handled = true;
    }
    super.optionChanged.apply(this, arguments);
  }
  _allowReordering() {
    const rowDragging = this.option("rowDragging");
    return !!(rowDragging && (rowDragging.allowReordering || rowDragging.allowDropInsideItem || rowDragging.group));
  }
  _updateHandleColumn() {
    const rowDragging = this.option("rowDragging");
    const allowReordering2 = this._allowReordering();
    const columnsController = this._columnsController;
    const isHandleColumnVisible = allowReordering2 && rowDragging.showDragIcons;
    null === columnsController || void 0 === columnsController || columnsController.addCommandColumn({
      type: "drag",
      command: "drag",
      visibleIndex: -2,
      alignment: "center",
      elementAttr: [{
        name: ATTRIBUTES2.dragCell,
        value: ""
      }],
      cssClass: CLASSES7.commandDrag,
      width: "auto",
      cellTemplate: this._getHandleTemplate(),
      visible: isHandleColumnVisible
    });
    null === columnsController || void 0 === columnsController || columnsController.columnOption("type:drag", "visible", isHandleColumnVisible);
  }
  _renderContent() {
    const rowDragging = this.option("rowDragging");
    const allowReordering2 = this._allowReordering();
    const $content = super._renderContent.apply(this, arguments);
    const isFixedTableRendering = this._isFixedTableRendering;
    const currentSortableName = isFixedTableRendering ? "_sortableFixed" : "_sortable";
    const anotherSortableName = isFixedTableRendering ? "_sortable" : "_sortableFixed";
    const togglePointerEventsStyle = (toggle) => {
      var _this$sortableFixedNa;
      null === (_this$sortableFixedNa = this._sortableFixed) || void 0 === _this$sortableFixedNa || _this$sortableFixedNa.$element().css("pointerEvents", toggle ? "auto" : "");
    };
    const rowSelector = ".dx-row:not(.dx-freespace-row):not(.dx-virtual-row):not(.dx-header-row):not(.dx-footer-row)";
    const filter = this.option("dataRowTemplate") ? `> table > tbody${rowSelector}` : `> table > tbody > ${rowSelector}`;
    if ((allowReordering2 || this[currentSortableName]) && $content.length) {
      this[currentSortableName] = this._createComponent($content, sortable_default, extend({
        component: this.component,
        contentTemplate: null,
        filter,
        cursorOffset: (options2) => {
          const {
            event
          } = options2;
          const rowsViewOffset = renderer_default(this.element()).offset();
          return {
            x: event.pageX - rowsViewOffset.left
          };
        },
        onDraggableElementShown: (e) => {
          if (rowDragging.dragTemplate) {
            return;
          }
          const $dragElement = renderer_default(e.dragElement);
          const gridInstance = $dragElement.children(".dx-widget").data(this.component.NAME);
          this._synchronizeScrollLeftPosition(gridInstance);
        },
        dragTemplate: this._getDraggableRowTemplate(),
        handle: rowDragging.showDragIcons && `.${CLASSES7.commandDrag}`,
        dropFeedbackMode: "indicate"
      }, rowDragging, {
        onDragStart: (e) => {
          var _this$getController, _rowDragging$onDragSt;
          null === (_this$getController = this.getController("keyboardNavigation")) || void 0 === _this$getController || _this$getController._resetFocusedCell();
          const row = e.component.getVisibleRows()[e.fromIndex];
          e.itemData = null === row || void 0 === row ? void 0 : row.data;
          const isDataRow2 = row && "data" === row.rowType;
          e.cancel = !allowReordering2 || !isDataRow2;
          null === (_rowDragging$onDragSt = rowDragging.onDragStart) || void 0 === _rowDragging$onDragSt || _rowDragging$onDragSt.call(rowDragging, e);
        },
        onDragEnter: (e) => {
          if (e.fromComponent !== e.toComponent) {
            togglePointerEventsStyle(true);
          }
        },
        onDragLeave: () => {
          togglePointerEventsStyle(false);
        },
        onDragEnd: (e) => {
          var _rowDragging$onDragEn;
          togglePointerEventsStyle(false);
          null === (_rowDragging$onDragEn = rowDragging.onDragEnd) || void 0 === _rowDragging$onDragEn || _rowDragging$onDragEn.call(rowDragging, e);
        },
        onAdd: (e) => {
          var _rowDragging$onAdd;
          togglePointerEventsStyle(false);
          null === (_rowDragging$onAdd = rowDragging.onAdd) || void 0 === _rowDragging$onAdd || _rowDragging$onAdd.call(rowDragging, e);
        },
        dropFeedbackMode: rowDragging.dropFeedbackMode,
        onOptionChanged: (e) => {
          const hasFixedSortable = this._sortableFixed;
          if (hasFixedSortable) {
            if ("fromIndex" === e.name || "toIndex" === e.name) {
              this[anotherSortableName].option(e.name, e.value);
            }
          }
        }
      }));
      $content.toggleClass("dx-scrollable-container", isFixedTableRendering);
      $content.toggleClass(CLASSES7.sortableWithoutHandle, allowReordering2 && !rowDragging.showDragIcons);
    }
    return $content;
  }
  _renderCore(e) {
    super._renderCore.apply(this, arguments);
    if (e && "update" === e.changeType && e.repaintChangesOnly && m_utils_default.isVirtualRowRendering(this)) {
      deferUpdate(() => {
        this._updateSortable();
      });
    }
  }
  _updateSortable() {
    const offset2 = this._dataController.getRowIndexOffset();
    const offsetDiff = offset2 - this._previousOffset;
    [this._sortable, this._sortableFixed].forEach((sortable) => {
      const toIndex = null === sortable || void 0 === sortable ? void 0 : sortable.option("toIndex");
      if (isDefined(toIndex) && isDefined(this._previousOffset)) {
        null === sortable || void 0 === sortable || sortable.option("toIndex", toIndex - offsetDiff);
      }
      null === sortable || void 0 === sortable || sortable.option("offset", offset2);
      null === sortable || void 0 === sortable || sortable.update();
    });
    this._previousOffset = offset2;
  }
  _resizeCore() {
    super._resizeCore.apply(this, arguments);
    this._updateSortable();
  }
  _getDraggableGridOptions(options2) {
    const gridOptions = this.option();
    const columns7 = this.getColumns();
    const $rowElement = renderer_default(this.getRowElement(options2.rowIndex));
    return {
      dataSource: [{
        id: 1,
        parentId: 0
      }],
      showBorders: true,
      showColumnHeaders: false,
      scrolling: {
        useNative: false,
        showScrollbar: "never"
      },
      pager: {
        visible: false
      },
      loadingTimeout: null,
      columnFixing: gridOptions.columnFixing,
      columnAutoWidth: gridOptions.columnAutoWidth,
      showColumnLines: gridOptions.showColumnLines,
      columns: columns7.map((column) => ({
        width: column.width || column.visibleWidth,
        fixed: column.fixed,
        fixedPosition: column.fixedPosition
      })),
      isDragging: true,
      onRowPrepared: (e) => {
        const rowsView18 = e.component.getView("rowsView");
        renderer_default(e.rowElement).replaceWith($rowElement.eq(rowsView18._isFixedTableRendering ? 1 : 0).clone());
      }
    };
  }
  _synchronizeScrollLeftPosition(gridInstance) {
    const scrollable = null === gridInstance || void 0 === gridInstance ? void 0 : gridInstance.getScrollable();
    null === scrollable || void 0 === scrollable || scrollable.scrollTo({
      x: this._scrollLeft
    });
  }
  _getDraggableRowTemplate() {
    return (options2) => {
      const $rootElement = this.component.$element();
      const $dataGridContainer = renderer_default("<div>");
      setWidth($dataGridContainer, getWidth($rootElement));
      const items = this._dataController.items();
      const row = items && items[options2.fromIndex];
      const gridOptions = this._getDraggableGridOptions(row);
      this._createComponent($dataGridContainer, this.component.NAME, gridOptions);
      $dataGridContainer.find(".dx-gridbase-container").children(`:not(.${this.addWidgetPrefix(CLASSES7.rowsView)})`).hide();
      $dataGridContainer.addClass(this.addWidgetPrefix(CLASSES7.dragView));
      return $dataGridContainer;
    };
  }
  _getHandleTemplate() {
    return GridCoreRowDraggingDom.createHandleTemplateFunc((string) => this.addWidgetPrefix(string));
  }
};
var rowDraggingModule = {
  defaultOptions: () => ({
    rowDragging: {
      showDragIcons: true,
      dropFeedbackMode: "indicate",
      allowReordering: false,
      allowDropInsideItem: false
    }
  }),
  extenders: {
    views: {
      rowsView: rowsView17
    }
  }
};

// node_modules/devextreme/esm/__internal/grids/data_grid/module_not_extended/row_dragging.js
m_core_default.registerModule("rowDragging", rowDraggingModule);

// node_modules/devextreme/esm/__internal/grids/data_grid/m_widget.js
var m_widget_default = m_widget_base_default;

// node_modules/devextreme/esm/ui/data_grid.js
var data_grid_default = m_widget_default;

// node_modules/devextreme-vue/esm/data-grid.js
var componentConfig = {
  props: {
    accessKey: String,
    activeStateEnabled: Boolean,
    allowColumnReordering: Boolean,
    allowColumnResizing: Boolean,
    autoNavigateToFocusedRow: Boolean,
    cacheEnabled: Boolean,
    cellHintEnabled: Boolean,
    columnAutoWidth: Boolean,
    columnChooser: Object,
    columnFixing: Object,
    columnHidingEnabled: Boolean,
    columnMinWidth: Number,
    columnResizingMode: String,
    columns: Array,
    columnWidth: [String, Number],
    customizeColumns: Function,
    dataRowTemplate: {},
    dataSource: [Array, Object, String],
    dateSerializationFormat: String,
    disabled: Boolean,
    editing: Object,
    elementAttr: Object,
    errorRowEnabled: Boolean,
    export: Object,
    filterBuilder: Object,
    filterBuilderPopup: Object,
    filterPanel: Object,
    filterRow: Object,
    filterSyncEnabled: [Boolean, String],
    filterValue: [Array, Function, String],
    focusedColumnIndex: Number,
    focusedRowEnabled: Boolean,
    focusedRowIndex: Number,
    focusedRowKey: {},
    grouping: Object,
    groupPanel: Object,
    headerFilter: Object,
    height: [Number, String],
    highlightChanges: Boolean,
    hint: String,
    hoverStateEnabled: Boolean,
    keyboardNavigation: Object,
    keyExpr: [Array, String],
    loadPanel: Object,
    masterDetail: Object,
    noDataText: String,
    onAdaptiveDetailRowPreparing: Function,
    onCellClick: Function,
    onCellDblClick: Function,
    onCellHoverChanged: Function,
    onCellPrepared: Function,
    onContentReady: Function,
    onContextMenuPreparing: Function,
    onDataErrorOccurred: Function,
    onDisposing: Function,
    onEditCanceled: Function,
    onEditCanceling: Function,
    onEditingStart: Function,
    onEditorPrepared: Function,
    onEditorPreparing: Function,
    onExporting: Function,
    onFocusedCellChanged: Function,
    onFocusedCellChanging: Function,
    onFocusedRowChanged: Function,
    onFocusedRowChanging: Function,
    onInitialized: Function,
    onInitNewRow: Function,
    onKeyDown: Function,
    onOptionChanged: Function,
    onRowClick: Function,
    onRowCollapsed: Function,
    onRowCollapsing: Function,
    onRowDblClick: Function,
    onRowExpanded: Function,
    onRowExpanding: Function,
    onRowInserted: Function,
    onRowInserting: Function,
    onRowPrepared: Function,
    onRowRemoved: Function,
    onRowRemoving: Function,
    onRowUpdated: Function,
    onRowUpdating: Function,
    onRowValidating: Function,
    onSaved: Function,
    onSaving: Function,
    onSelectionChanged: Function,
    onToolbarPreparing: Function,
    pager: Object,
    paging: Object,
    remoteOperations: [Boolean, String, Object],
    renderAsync: Boolean,
    repaintChangesOnly: Boolean,
    rowAlternationEnabled: Boolean,
    rowDragging: Object,
    rowTemplate: {},
    rtlEnabled: Boolean,
    scrolling: Object,
    searchPanel: Object,
    selectedRowKeys: Array,
    selection: Object,
    selectionFilter: [Array, Function, String],
    showBorders: Boolean,
    showColumnHeaders: Boolean,
    showColumnLines: Boolean,
    showRowLines: Boolean,
    sortByGroupSummaryInfo: Array,
    sorting: Object,
    stateStoring: Object,
    summary: Object,
    syncLookupFilterValues: Boolean,
    tabIndex: Number,
    toolbar: Object,
    twoWayBindingEnabled: Boolean,
    visible: Boolean,
    width: [Number, String],
    wordWrapEnabled: Boolean
  },
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:accessKey": null,
    "update:activeStateEnabled": null,
    "update:allowColumnReordering": null,
    "update:allowColumnResizing": null,
    "update:autoNavigateToFocusedRow": null,
    "update:cacheEnabled": null,
    "update:cellHintEnabled": null,
    "update:columnAutoWidth": null,
    "update:columnChooser": null,
    "update:columnFixing": null,
    "update:columnHidingEnabled": null,
    "update:columnMinWidth": null,
    "update:columnResizingMode": null,
    "update:columns": null,
    "update:columnWidth": null,
    "update:customizeColumns": null,
    "update:dataRowTemplate": null,
    "update:dataSource": null,
    "update:dateSerializationFormat": null,
    "update:disabled": null,
    "update:editing": null,
    "update:elementAttr": null,
    "update:errorRowEnabled": null,
    "update:export": null,
    "update:filterBuilder": null,
    "update:filterBuilderPopup": null,
    "update:filterPanel": null,
    "update:filterRow": null,
    "update:filterSyncEnabled": null,
    "update:filterValue": null,
    "update:focusedColumnIndex": null,
    "update:focusedRowEnabled": null,
    "update:focusedRowIndex": null,
    "update:focusedRowKey": null,
    "update:grouping": null,
    "update:groupPanel": null,
    "update:headerFilter": null,
    "update:height": null,
    "update:highlightChanges": null,
    "update:hint": null,
    "update:hoverStateEnabled": null,
    "update:keyboardNavigation": null,
    "update:keyExpr": null,
    "update:loadPanel": null,
    "update:masterDetail": null,
    "update:noDataText": null,
    "update:onAdaptiveDetailRowPreparing": null,
    "update:onCellClick": null,
    "update:onCellDblClick": null,
    "update:onCellHoverChanged": null,
    "update:onCellPrepared": null,
    "update:onContentReady": null,
    "update:onContextMenuPreparing": null,
    "update:onDataErrorOccurred": null,
    "update:onDisposing": null,
    "update:onEditCanceled": null,
    "update:onEditCanceling": null,
    "update:onEditingStart": null,
    "update:onEditorPrepared": null,
    "update:onEditorPreparing": null,
    "update:onExporting": null,
    "update:onFocusedCellChanged": null,
    "update:onFocusedCellChanging": null,
    "update:onFocusedRowChanged": null,
    "update:onFocusedRowChanging": null,
    "update:onInitialized": null,
    "update:onInitNewRow": null,
    "update:onKeyDown": null,
    "update:onOptionChanged": null,
    "update:onRowClick": null,
    "update:onRowCollapsed": null,
    "update:onRowCollapsing": null,
    "update:onRowDblClick": null,
    "update:onRowExpanded": null,
    "update:onRowExpanding": null,
    "update:onRowInserted": null,
    "update:onRowInserting": null,
    "update:onRowPrepared": null,
    "update:onRowRemoved": null,
    "update:onRowRemoving": null,
    "update:onRowUpdated": null,
    "update:onRowUpdating": null,
    "update:onRowValidating": null,
    "update:onSaved": null,
    "update:onSaving": null,
    "update:onSelectionChanged": null,
    "update:onToolbarPreparing": null,
    "update:pager": null,
    "update:paging": null,
    "update:remoteOperations": null,
    "update:renderAsync": null,
    "update:repaintChangesOnly": null,
    "update:rowAlternationEnabled": null,
    "update:rowDragging": null,
    "update:rowTemplate": null,
    "update:rtlEnabled": null,
    "update:scrolling": null,
    "update:searchPanel": null,
    "update:selectedRowKeys": null,
    "update:selection": null,
    "update:selectionFilter": null,
    "update:showBorders": null,
    "update:showColumnHeaders": null,
    "update:showColumnLines": null,
    "update:showRowLines": null,
    "update:sortByGroupSummaryInfo": null,
    "update:sorting": null,
    "update:stateStoring": null,
    "update:summary": null,
    "update:syncLookupFilterValues": null,
    "update:tabIndex": null,
    "update:toolbar": null,
    "update:twoWayBindingEnabled": null,
    "update:visible": null,
    "update:width": null,
    "update:wordWrapEnabled": null
  },
  computed: {
    instance() {
      return this.$_instance;
    }
  },
  beforeCreate() {
    this.$_WidgetClass = data_grid_default;
    this.$_hasAsyncTemplate = false;
    this.$_expectedChildren = {
      column: { isCollectionItem: true, optionName: "columns" },
      columnChooser: { isCollectionItem: false, optionName: "columnChooser" },
      columnFixing: { isCollectionItem: false, optionName: "columnFixing" },
      dataGridHeaderFilter: { isCollectionItem: false, optionName: "headerFilter" },
      dataGridSelection: { isCollectionItem: false, optionName: "selection" },
      editing: { isCollectionItem: false, optionName: "editing" },
      export: { isCollectionItem: false, optionName: "export" },
      filterBuilder: { isCollectionItem: false, optionName: "filterBuilder" },
      filterBuilderPopup: { isCollectionItem: false, optionName: "filterBuilderPopup" },
      filterPanel: { isCollectionItem: false, optionName: "filterPanel" },
      filterRow: { isCollectionItem: false, optionName: "filterRow" },
      grouping: { isCollectionItem: false, optionName: "grouping" },
      groupPanel: { isCollectionItem: false, optionName: "groupPanel" },
      headerFilter: { isCollectionItem: false, optionName: "headerFilter" },
      keyboardNavigation: { isCollectionItem: false, optionName: "keyboardNavigation" },
      loadPanel: { isCollectionItem: false, optionName: "loadPanel" },
      masterDetail: { isCollectionItem: false, optionName: "masterDetail" },
      pager: { isCollectionItem: false, optionName: "pager" },
      paging: { isCollectionItem: false, optionName: "paging" },
      remoteOperations: { isCollectionItem: false, optionName: "remoteOperations" },
      rowDragging: { isCollectionItem: false, optionName: "rowDragging" },
      scrolling: { isCollectionItem: false, optionName: "scrolling" },
      searchPanel: { isCollectionItem: false, optionName: "searchPanel" },
      selection: { isCollectionItem: false, optionName: "selection" },
      sortByGroupSummaryInfo: { isCollectionItem: true, optionName: "sortByGroupSummaryInfo" },
      sorting: { isCollectionItem: false, optionName: "sorting" },
      stateStoring: { isCollectionItem: false, optionName: "stateStoring" },
      summary: { isCollectionItem: false, optionName: "summary" },
      toolbar: { isCollectionItem: false, optionName: "toolbar" }
    };
  }
};
prepareComponentConfig(componentConfig);
var DxDataGrid = defineComponent4(componentConfig);
var DxAnimationConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:hide": null,
    "update:show": null
  },
  props: {
    hide: [Object, Number, String],
    show: [Object, Number, String]
  }
};
prepareConfigurationComponentConfig(DxAnimationConfig);
var DxAnimation = defineComponent4(DxAnimationConfig);
DxAnimation.$_optionName = "animation";
DxAnimation.$_expectedChildren = {
  hide: { isCollectionItem: false, optionName: "hide" },
  show: { isCollectionItem: false, optionName: "show" }
};
var DxAsyncRuleConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:ignoreEmptyValue": null,
    "update:message": null,
    "update:reevaluate": null,
    "update:type": null,
    "update:validationCallback": null
  },
  props: {
    ignoreEmptyValue: Boolean,
    message: String,
    reevaluate: Boolean,
    type: String,
    validationCallback: Function
  }
};
prepareConfigurationComponentConfig(DxAsyncRuleConfig);
var DxAsyncRule = defineComponent4(DxAsyncRuleConfig);
DxAsyncRule.$_optionName = "validationRules";
DxAsyncRule.$_isCollectionItem = true;
DxAsyncRule.$_predefinedProps = {
  type: "async"
};
var DxAtConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:x": null,
    "update:y": null
  },
  props: {
    x: String,
    y: String
  }
};
prepareConfigurationComponentConfig(DxAtConfig);
var DxAt = defineComponent4(DxAtConfig);
DxAt.$_optionName = "at";
var DxBoundaryOffsetConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:x": null,
    "update:y": null
  },
  props: {
    x: Number,
    y: Number
  }
};
prepareConfigurationComponentConfig(DxBoundaryOffsetConfig);
var DxBoundaryOffset = defineComponent4(DxBoundaryOffsetConfig);
DxBoundaryOffset.$_optionName = "boundaryOffset";
var DxButtonConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:cssClass": null,
    "update:disabled": null,
    "update:hint": null,
    "update:icon": null,
    "update:name": null,
    "update:onClick": null,
    "update:template": null,
    "update:text": null,
    "update:visible": null
  },
  props: {
    cssClass: String,
    disabled: [Boolean, Function],
    hint: String,
    icon: String,
    name: String,
    onClick: Function,
    template: {},
    text: String,
    visible: [Boolean, Function]
  }
};
prepareConfigurationComponentConfig(DxButtonConfig);
var DxButton = defineComponent4(DxButtonConfig);
DxButton.$_optionName = "buttons";
DxButton.$_isCollectionItem = true;
var DxChangeConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:data": null,
    "update:insertAfterKey": null,
    "update:insertBeforeKey": null,
    "update:type": null
  },
  props: {
    data: {},
    insertAfterKey: {},
    insertBeforeKey: {},
    type: String
  }
};
prepareConfigurationComponentConfig(DxChangeConfig);
var DxChange = defineComponent4(DxChangeConfig);
DxChange.$_optionName = "changes";
DxChange.$_isCollectionItem = true;
var DxColCountByScreenConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:lg": null,
    "update:md": null,
    "update:sm": null,
    "update:xs": null
  },
  props: {
    lg: Number,
    md: Number,
    sm: Number,
    xs: Number
  }
};
prepareConfigurationComponentConfig(DxColCountByScreenConfig);
var DxColCountByScreen = defineComponent4(DxColCountByScreenConfig);
DxColCountByScreen.$_optionName = "colCountByScreen";
var DxCollisionConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:x": null,
    "update:y": null
  },
  props: {
    x: String,
    y: String
  }
};
prepareConfigurationComponentConfig(DxCollisionConfig);
var DxCollision = defineComponent4(DxCollisionConfig);
DxCollision.$_optionName = "collision";
var DxColumnConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:alignment": null,
    "update:allowEditing": null,
    "update:allowExporting": null,
    "update:allowFiltering": null,
    "update:allowFixing": null,
    "update:allowGrouping": null,
    "update:allowHeaderFiltering": null,
    "update:allowHiding": null,
    "update:allowReordering": null,
    "update:allowResizing": null,
    "update:allowSearch": null,
    "update:allowSorting": null,
    "update:autoExpandGroup": null,
    "update:buttons": null,
    "update:calculateCellValue": null,
    "update:calculateDisplayValue": null,
    "update:calculateFilterExpression": null,
    "update:calculateGroupValue": null,
    "update:calculateSortValue": null,
    "update:caption": null,
    "update:cellTemplate": null,
    "update:columns": null,
    "update:cssClass": null,
    "update:customizeText": null,
    "update:dataField": null,
    "update:dataType": null,
    "update:editCellTemplate": null,
    "update:editorOptions": null,
    "update:encodeHtml": null,
    "update:falseText": null,
    "update:filterOperations": null,
    "update:filterType": null,
    "update:filterValue": null,
    "update:filterValues": null,
    "update:fixed": null,
    "update:fixedPosition": null,
    "update:format": null,
    "update:formItem": null,
    "update:groupCellTemplate": null,
    "update:groupIndex": null,
    "update:headerCellTemplate": null,
    "update:headerFilter": null,
    "update:hidingPriority": null,
    "update:isBand": null,
    "update:lookup": null,
    "update:minWidth": null,
    "update:name": null,
    "update:ownerBand": null,
    "update:renderAsync": null,
    "update:selectedFilterOperation": null,
    "update:setCellValue": null,
    "update:showEditorAlways": null,
    "update:showInColumnChooser": null,
    "update:showWhenGrouped": null,
    "update:sortIndex": null,
    "update:sortingMethod": null,
    "update:sortOrder": null,
    "update:trueText": null,
    "update:type": null,
    "update:validationRules": null,
    "update:visible": null,
    "update:visibleIndex": null,
    "update:width": null
  },
  props: {
    alignment: String,
    allowEditing: Boolean,
    allowExporting: Boolean,
    allowFiltering: Boolean,
    allowFixing: Boolean,
    allowGrouping: Boolean,
    allowHeaderFiltering: Boolean,
    allowHiding: Boolean,
    allowReordering: Boolean,
    allowResizing: Boolean,
    allowSearch: Boolean,
    allowSorting: Boolean,
    autoExpandGroup: Boolean,
    buttons: Array,
    calculateCellValue: Function,
    calculateDisplayValue: [Function, String],
    calculateFilterExpression: Function,
    calculateGroupValue: [Function, String],
    calculateSortValue: [Function, String],
    caption: String,
    cellTemplate: {},
    columns: Array,
    cssClass: String,
    customizeText: Function,
    dataField: String,
    dataType: String,
    editCellTemplate: {},
    editorOptions: {},
    encodeHtml: Boolean,
    falseText: String,
    filterOperations: Array,
    filterType: String,
    filterValue: {},
    filterValues: Array,
    fixed: Boolean,
    fixedPosition: String,
    format: [Object, String, Function],
    formItem: Object,
    groupCellTemplate: {},
    groupIndex: Number,
    headerCellTemplate: {},
    headerFilter: Object,
    hidingPriority: Number,
    isBand: Boolean,
    lookup: Object,
    minWidth: Number,
    name: String,
    ownerBand: Number,
    renderAsync: Boolean,
    selectedFilterOperation: String,
    setCellValue: Function,
    showEditorAlways: Boolean,
    showInColumnChooser: Boolean,
    showWhenGrouped: Boolean,
    sortIndex: Number,
    sortingMethod: Function,
    sortOrder: String,
    trueText: String,
    type: String,
    validationRules: Array,
    visible: Boolean,
    visibleIndex: Number,
    width: [Number, String]
  }
};
prepareConfigurationComponentConfig(DxColumnConfig);
var DxColumn = defineComponent4(DxColumnConfig);
DxColumn.$_optionName = "columns";
DxColumn.$_isCollectionItem = true;
DxColumn.$_expectedChildren = {
  AsyncRule: { isCollectionItem: true, optionName: "validationRules" },
  button: { isCollectionItem: true, optionName: "buttons" },
  columnHeaderFilter: { isCollectionItem: false, optionName: "headerFilter" },
  columnLookup: { isCollectionItem: false, optionName: "lookup" },
  CompareRule: { isCollectionItem: true, optionName: "validationRules" },
  CustomRule: { isCollectionItem: true, optionName: "validationRules" },
  EmailRule: { isCollectionItem: true, optionName: "validationRules" },
  format: { isCollectionItem: false, optionName: "format" },
  formItem: { isCollectionItem: false, optionName: "formItem" },
  headerFilter: { isCollectionItem: false, optionName: "headerFilter" },
  lookup: { isCollectionItem: false, optionName: "lookup" },
  NumericRule: { isCollectionItem: true, optionName: "validationRules" },
  PatternRule: { isCollectionItem: true, optionName: "validationRules" },
  RangeRule: { isCollectionItem: true, optionName: "validationRules" },
  RequiredRule: { isCollectionItem: true, optionName: "validationRules" },
  StringLengthRule: { isCollectionItem: true, optionName: "validationRules" },
  validationRule: { isCollectionItem: true, optionName: "validationRules" }
};
var DxColumnChooserConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:allowSearch": null,
    "update:container": null,
    "update:emptyPanelText": null,
    "update:enabled": null,
    "update:height": null,
    "update:mode": null,
    "update:position": null,
    "update:search": null,
    "update:searchTimeout": null,
    "update:selection": null,
    "update:sortOrder": null,
    "update:title": null,
    "update:width": null
  },
  props: {
    allowSearch: Boolean,
    container: {},
    emptyPanelText: String,
    enabled: Boolean,
    height: [Number, String],
    mode: String,
    position: Object,
    search: Object,
    searchTimeout: Number,
    selection: Object,
    sortOrder: String,
    title: String,
    width: [Number, String]
  }
};
prepareConfigurationComponentConfig(DxColumnChooserConfig);
var DxColumnChooser = defineComponent4(DxColumnChooserConfig);
DxColumnChooser.$_optionName = "columnChooser";
DxColumnChooser.$_expectedChildren = {
  columnChooserSearch: { isCollectionItem: false, optionName: "search" },
  columnChooserSelection: { isCollectionItem: false, optionName: "selection" },
  position: { isCollectionItem: false, optionName: "position" },
  search: { isCollectionItem: false, optionName: "search" },
  selection: { isCollectionItem: false, optionName: "selection" }
};
var DxColumnChooserSearchConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:editorOptions": null,
    "update:enabled": null,
    "update:timeout": null
  },
  props: {
    editorOptions: {},
    enabled: Boolean,
    timeout: Number
  }
};
prepareConfigurationComponentConfig(DxColumnChooserSearchConfig);
var DxColumnChooserSearch = defineComponent4(DxColumnChooserSearchConfig);
DxColumnChooserSearch.$_optionName = "search";
var DxColumnChooserSelectionConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:allowSelectAll": null,
    "update:recursive": null,
    "update:selectByClick": null
  },
  props: {
    allowSelectAll: Boolean,
    recursive: Boolean,
    selectByClick: Boolean
  }
};
prepareConfigurationComponentConfig(DxColumnChooserSelectionConfig);
var DxColumnChooserSelection = defineComponent4(DxColumnChooserSelectionConfig);
DxColumnChooserSelection.$_optionName = "selection";
var DxColumnFixingConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:enabled": null,
    "update:icons": null,
    "update:texts": null
  },
  props: {
    enabled: Boolean,
    icons: Object,
    texts: Object
  }
};
prepareConfigurationComponentConfig(DxColumnFixingConfig);
var DxColumnFixing = defineComponent4(DxColumnFixingConfig);
DxColumnFixing.$_optionName = "columnFixing";
DxColumnFixing.$_expectedChildren = {
  columnFixingTexts: { isCollectionItem: false, optionName: "texts" },
  icons: { isCollectionItem: false, optionName: "icons" },
  texts: { isCollectionItem: false, optionName: "texts" }
};
var DxColumnFixingTextsConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:fix": null,
    "update:leftPosition": null,
    "update:rightPosition": null,
    "update:stickyPosition": null,
    "update:unfix": null
  },
  props: {
    fix: String,
    leftPosition: String,
    rightPosition: String,
    stickyPosition: String,
    unfix: String
  }
};
prepareConfigurationComponentConfig(DxColumnFixingTextsConfig);
var DxColumnFixingTexts = defineComponent4(DxColumnFixingTextsConfig);
DxColumnFixingTexts.$_optionName = "texts";
var DxColumnHeaderFilterConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:allowSearch": null,
    "update:allowSelectAll": null,
    "update:dataSource": null,
    "update:groupInterval": null,
    "update:height": null,
    "update:search": null,
    "update:searchMode": null,
    "update:width": null
  },
  props: {
    allowSearch: Boolean,
    allowSelectAll: Boolean,
    dataSource: [Array, Object, Function],
    groupInterval: [String, Number],
    height: [Number, String],
    search: Object,
    searchMode: String,
    width: [Number, String]
  }
};
prepareConfigurationComponentConfig(DxColumnHeaderFilterConfig);
var DxColumnHeaderFilter = defineComponent4(DxColumnHeaderFilterConfig);
DxColumnHeaderFilter.$_optionName = "headerFilter";
DxColumnHeaderFilter.$_expectedChildren = {
  columnHeaderFilterSearch: { isCollectionItem: false, optionName: "search" },
  search: { isCollectionItem: false, optionName: "search" }
};
var DxColumnHeaderFilterSearchConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:editorOptions": null,
    "update:enabled": null,
    "update:mode": null,
    "update:searchExpr": null,
    "update:timeout": null
  },
  props: {
    editorOptions: {},
    enabled: Boolean,
    mode: String,
    searchExpr: [Array, Function, String],
    timeout: Number
  }
};
prepareConfigurationComponentConfig(DxColumnHeaderFilterSearchConfig);
var DxColumnHeaderFilterSearch = defineComponent4(DxColumnHeaderFilterSearchConfig);
DxColumnHeaderFilterSearch.$_optionName = "search";
var DxColumnLookupConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:allowClearing": null,
    "update:calculateCellValue": null,
    "update:dataSource": null,
    "update:displayExpr": null,
    "update:valueExpr": null
  },
  props: {
    allowClearing: Boolean,
    calculateCellValue: Function,
    dataSource: [Array, Object, Function],
    displayExpr: [Function, String],
    valueExpr: String
  }
};
prepareConfigurationComponentConfig(DxColumnLookupConfig);
var DxColumnLookup = defineComponent4(DxColumnLookupConfig);
DxColumnLookup.$_optionName = "lookup";
var DxCompareRuleConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:comparisonTarget": null,
    "update:comparisonType": null,
    "update:ignoreEmptyValue": null,
    "update:message": null,
    "update:type": null
  },
  props: {
    comparisonTarget: Function,
    comparisonType: String,
    ignoreEmptyValue: Boolean,
    message: String,
    type: String
  }
};
prepareConfigurationComponentConfig(DxCompareRuleConfig);
var DxCompareRule = defineComponent4(DxCompareRuleConfig);
DxCompareRule.$_optionName = "validationRules";
DxCompareRule.$_isCollectionItem = true;
DxCompareRule.$_predefinedProps = {
  type: "compare"
};
var DxCursorOffsetConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:x": null,
    "update:y": null
  },
  props: {
    x: Number,
    y: Number
  }
};
prepareConfigurationComponentConfig(DxCursorOffsetConfig);
var DxCursorOffset = defineComponent4(DxCursorOffsetConfig);
DxCursorOffset.$_optionName = "cursorOffset";
var DxCustomOperationConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:calculateFilterExpression": null,
    "update:caption": null,
    "update:customizeText": null,
    "update:dataTypes": null,
    "update:editorTemplate": null,
    "update:hasValue": null,
    "update:icon": null,
    "update:name": null
  },
  props: {
    calculateFilterExpression: Function,
    caption: String,
    customizeText: Function,
    dataTypes: Array,
    editorTemplate: {},
    hasValue: Boolean,
    icon: String,
    name: String
  }
};
prepareConfigurationComponentConfig(DxCustomOperationConfig);
var DxCustomOperation = defineComponent4(DxCustomOperationConfig);
DxCustomOperation.$_optionName = "customOperations";
DxCustomOperation.$_isCollectionItem = true;
var DxCustomRuleConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:ignoreEmptyValue": null,
    "update:message": null,
    "update:reevaluate": null,
    "update:type": null,
    "update:validationCallback": null
  },
  props: {
    ignoreEmptyValue: Boolean,
    message: String,
    reevaluate: Boolean,
    type: String,
    validationCallback: Function
  }
};
prepareConfigurationComponentConfig(DxCustomRuleConfig);
var DxCustomRule = defineComponent4(DxCustomRuleConfig);
DxCustomRule.$_optionName = "validationRules";
DxCustomRule.$_isCollectionItem = true;
DxCustomRule.$_predefinedProps = {
  type: "custom"
};
var DxDataGridHeaderFilterConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:allowSearch": null,
    "update:allowSelectAll": null,
    "update:height": null,
    "update:search": null,
    "update:searchTimeout": null,
    "update:texts": null,
    "update:visible": null,
    "update:width": null
  },
  props: {
    allowSearch: Boolean,
    allowSelectAll: Boolean,
    height: [Number, String],
    search: Object,
    searchTimeout: Number,
    texts: Object,
    visible: Boolean,
    width: [Number, String]
  }
};
prepareConfigurationComponentConfig(DxDataGridHeaderFilterConfig);
var DxDataGridHeaderFilter = defineComponent4(DxDataGridHeaderFilterConfig);
DxDataGridHeaderFilter.$_optionName = "headerFilter";
DxDataGridHeaderFilter.$_expectedChildren = {
  dataGridHeaderFilterSearch: { isCollectionItem: false, optionName: "search" },
  dataGridHeaderFilterTexts: { isCollectionItem: false, optionName: "texts" },
  search: { isCollectionItem: false, optionName: "search" },
  texts: { isCollectionItem: false, optionName: "texts" }
};
var DxDataGridHeaderFilterSearchConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:editorOptions": null,
    "update:enabled": null,
    "update:mode": null,
    "update:timeout": null
  },
  props: {
    editorOptions: {},
    enabled: Boolean,
    mode: String,
    timeout: Number
  }
};
prepareConfigurationComponentConfig(DxDataGridHeaderFilterSearchConfig);
var DxDataGridHeaderFilterSearch = defineComponent4(DxDataGridHeaderFilterSearchConfig);
DxDataGridHeaderFilterSearch.$_optionName = "search";
var DxDataGridHeaderFilterTextsConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:cancel": null,
    "update:emptyValue": null,
    "update:ok": null
  },
  props: {
    cancel: String,
    emptyValue: String,
    ok: String
  }
};
prepareConfigurationComponentConfig(DxDataGridHeaderFilterTextsConfig);
var DxDataGridHeaderFilterTexts = defineComponent4(DxDataGridHeaderFilterTextsConfig);
DxDataGridHeaderFilterTexts.$_optionName = "texts";
var DxDataGridSelectionConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:allowSelectAll": null,
    "update:deferred": null,
    "update:mode": null,
    "update:selectAllMode": null,
    "update:sensitivity": null,
    "update:showCheckBoxesMode": null
  },
  props: {
    allowSelectAll: Boolean,
    deferred: Boolean,
    mode: String,
    selectAllMode: String,
    sensitivity: String,
    showCheckBoxesMode: String
  }
};
prepareConfigurationComponentConfig(DxDataGridSelectionConfig);
var DxDataGridSelection = defineComponent4(DxDataGridSelectionConfig);
DxDataGridSelection.$_optionName = "selection";
var DxEditingConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:allowAdding": null,
    "update:allowDeleting": null,
    "update:allowUpdating": null,
    "update:changes": null,
    "update:confirmDelete": null,
    "update:editColumnName": null,
    "update:editRowKey": null,
    "update:form": null,
    "update:mode": null,
    "update:newRowPosition": null,
    "update:popup": null,
    "update:refreshMode": null,
    "update:selectTextOnEditStart": null,
    "update:startEditAction": null,
    "update:texts": null,
    "update:useIcons": null
  },
  props: {
    allowAdding: Boolean,
    allowDeleting: [Boolean, Function],
    allowUpdating: [Boolean, Function],
    changes: Array,
    confirmDelete: Boolean,
    editColumnName: String,
    editRowKey: {},
    form: Object,
    mode: String,
    newRowPosition: String,
    popup: Object,
    refreshMode: String,
    selectTextOnEditStart: Boolean,
    startEditAction: String,
    texts: {},
    useIcons: Boolean
  }
};
prepareConfigurationComponentConfig(DxEditingConfig);
var DxEditing = defineComponent4(DxEditingConfig);
DxEditing.$_optionName = "editing";
DxEditing.$_expectedChildren = {
  change: { isCollectionItem: true, optionName: "changes" },
  editingTexts: { isCollectionItem: false, optionName: "texts" },
  form: { isCollectionItem: false, optionName: "form" },
  popup: { isCollectionItem: false, optionName: "popup" },
  texts: { isCollectionItem: false, optionName: "texts" }
};
var DxEditingTextsConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:addRow": null,
    "update:cancelAllChanges": null,
    "update:cancelRowChanges": null,
    "update:confirmDeleteMessage": null,
    "update:confirmDeleteTitle": null,
    "update:deleteRow": null,
    "update:editRow": null,
    "update:saveAllChanges": null,
    "update:saveRowChanges": null,
    "update:undeleteRow": null,
    "update:validationCancelChanges": null
  },
  props: {
    addRow: String,
    cancelAllChanges: String,
    cancelRowChanges: String,
    confirmDeleteMessage: String,
    confirmDeleteTitle: String,
    deleteRow: String,
    editRow: String,
    saveAllChanges: String,
    saveRowChanges: String,
    undeleteRow: String,
    validationCancelChanges: String
  }
};
prepareConfigurationComponentConfig(DxEditingTextsConfig);
var DxEditingTexts = defineComponent4(DxEditingTextsConfig);
DxEditingTexts.$_optionName = "texts";
var DxEmailRuleConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:ignoreEmptyValue": null,
    "update:message": null,
    "update:type": null
  },
  props: {
    ignoreEmptyValue: Boolean,
    message: String,
    type: String
  }
};
prepareConfigurationComponentConfig(DxEmailRuleConfig);
var DxEmailRule = defineComponent4(DxEmailRuleConfig);
DxEmailRule.$_optionName = "validationRules";
DxEmailRule.$_isCollectionItem = true;
DxEmailRule.$_predefinedProps = {
  type: "email"
};
var DxExportConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:allowExportSelectedData": null,
    "update:enabled": null,
    "update:formats": null,
    "update:texts": null
  },
  props: {
    allowExportSelectedData: Boolean,
    enabled: Boolean,
    formats: Array,
    texts: Object
  }
};
prepareConfigurationComponentConfig(DxExportConfig);
var DxExport = defineComponent4(DxExportConfig);
DxExport.$_optionName = "export";
DxExport.$_expectedChildren = {
  exportTexts: { isCollectionItem: false, optionName: "texts" },
  texts: { isCollectionItem: false, optionName: "texts" }
};
var DxExportTextsConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:exportAll": null,
    "update:exportSelectedRows": null,
    "update:exportTo": null
  },
  props: {
    exportAll: String,
    exportSelectedRows: String,
    exportTo: String
  }
};
prepareConfigurationComponentConfig(DxExportTextsConfig);
var DxExportTexts = defineComponent4(DxExportTextsConfig);
DxExportTexts.$_optionName = "texts";
var DxFieldConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:calculateFilterExpression": null,
    "update:caption": null,
    "update:customizeText": null,
    "update:dataField": null,
    "update:dataType": null,
    "update:editorOptions": null,
    "update:editorTemplate": null,
    "update:falseText": null,
    "update:filterOperations": null,
    "update:format": null,
    "update:lookup": null,
    "update:name": null,
    "update:trueText": null
  },
  props: {
    calculateFilterExpression: Function,
    caption: String,
    customizeText: Function,
    dataField: String,
    dataType: String,
    editorOptions: {},
    editorTemplate: {},
    falseText: String,
    filterOperations: Array,
    format: [Object, String, Function],
    lookup: Object,
    name: String,
    trueText: String
  }
};
prepareConfigurationComponentConfig(DxFieldConfig);
var DxField = defineComponent4(DxFieldConfig);
DxField.$_optionName = "fields";
DxField.$_isCollectionItem = true;
DxField.$_expectedChildren = {
  fieldLookup: { isCollectionItem: false, optionName: "lookup" },
  format: { isCollectionItem: false, optionName: "format" },
  lookup: { isCollectionItem: false, optionName: "lookup" }
};
var DxFieldLookupConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:allowClearing": null,
    "update:dataSource": null,
    "update:displayExpr": null,
    "update:valueExpr": null
  },
  props: {
    allowClearing: Boolean,
    dataSource: [Array, Object],
    displayExpr: [Function, String],
    valueExpr: [Function, String]
  }
};
prepareConfigurationComponentConfig(DxFieldLookupConfig);
var DxFieldLookup = defineComponent4(DxFieldLookupConfig);
DxFieldLookup.$_optionName = "lookup";
var DxFilterBuilderConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:accessKey": null,
    "update:activeStateEnabled": null,
    "update:allowHierarchicalFields": null,
    "update:bindingOptions": null,
    "update:customOperations": null,
    "update:disabled": null,
    "update:elementAttr": null,
    "update:fields": null,
    "update:filterOperationDescriptions": null,
    "update:focusStateEnabled": null,
    "update:groupOperationDescriptions": null,
    "update:groupOperations": null,
    "update:height": null,
    "update:hint": null,
    "update:hoverStateEnabled": null,
    "update:maxGroupLevel": null,
    "update:onContentReady": null,
    "update:onDisposing": null,
    "update:onEditorPrepared": null,
    "update:onEditorPreparing": null,
    "update:onInitialized": null,
    "update:onOptionChanged": null,
    "update:onValueChanged": null,
    "update:rtlEnabled": null,
    "update:tabIndex": null,
    "update:value": null,
    "update:visible": null,
    "update:width": null
  },
  props: {
    accessKey: String,
    activeStateEnabled: Boolean,
    allowHierarchicalFields: Boolean,
    bindingOptions: Object,
    customOperations: Array,
    disabled: Boolean,
    elementAttr: Object,
    fields: Array,
    filterOperationDescriptions: Object,
    focusStateEnabled: Boolean,
    groupOperationDescriptions: Object,
    groupOperations: Array,
    height: [Number, String],
    hint: String,
    hoverStateEnabled: Boolean,
    maxGroupLevel: Number,
    onContentReady: Function,
    onDisposing: Function,
    onEditorPrepared: Function,
    onEditorPreparing: Function,
    onInitialized: Function,
    onOptionChanged: Function,
    onValueChanged: Function,
    rtlEnabled: Boolean,
    tabIndex: Number,
    value: [Array, Function, String],
    visible: Boolean,
    width: [Number, String]
  }
};
prepareConfigurationComponentConfig(DxFilterBuilderConfig);
var DxFilterBuilder = defineComponent4(DxFilterBuilderConfig);
DxFilterBuilder.$_optionName = "filterBuilder";
DxFilterBuilder.$_expectedChildren = {
  customOperation: { isCollectionItem: true, optionName: "customOperations" },
  field: { isCollectionItem: true, optionName: "fields" },
  filterOperationDescriptions: { isCollectionItem: false, optionName: "filterOperationDescriptions" },
  groupOperationDescriptions: { isCollectionItem: false, optionName: "groupOperationDescriptions" }
};
var DxFilterBuilderPopupConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:accessKey": null,
    "update:animation": null,
    "update:bindingOptions": null,
    "update:container": null,
    "update:contentTemplate": null,
    "update:deferRendering": null,
    "update:disabled": null,
    "update:dragAndResizeArea": null,
    "update:dragEnabled": null,
    "update:dragOutsideBoundary": null,
    "update:enableBodyScroll": null,
    "update:focusStateEnabled": null,
    "update:fullScreen": null,
    "update:height": null,
    "update:hideOnOutsideClick": null,
    "update:hideOnParentScroll": null,
    "update:hint": null,
    "update:hoverStateEnabled": null,
    "update:maxHeight": null,
    "update:maxWidth": null,
    "update:minHeight": null,
    "update:minWidth": null,
    "update:onContentReady": null,
    "update:onDisposing": null,
    "update:onHidden": null,
    "update:onHiding": null,
    "update:onInitialized": null,
    "update:onOptionChanged": null,
    "update:onResize": null,
    "update:onResizeEnd": null,
    "update:onResizeStart": null,
    "update:onShowing": null,
    "update:onShown": null,
    "update:onTitleRendered": null,
    "update:position": null,
    "update:resizeEnabled": null,
    "update:restorePosition": null,
    "update:rtlEnabled": null,
    "update:shading": null,
    "update:shadingColor": null,
    "update:showCloseButton": null,
    "update:showTitle": null,
    "update:tabIndex": null,
    "update:title": null,
    "update:titleTemplate": null,
    "update:toolbarItems": null,
    "update:visible": null,
    "update:width": null,
    "update:wrapperAttr": null
  },
  props: {
    accessKey: String,
    animation: Object,
    bindingOptions: Object,
    container: {},
    contentTemplate: {},
    deferRendering: Boolean,
    disabled: Boolean,
    dragAndResizeArea: {},
    dragEnabled: Boolean,
    dragOutsideBoundary: Boolean,
    enableBodyScroll: Boolean,
    focusStateEnabled: Boolean,
    fullScreen: Boolean,
    height: [Number, String],
    hideOnOutsideClick: [Boolean, Function],
    hideOnParentScroll: Boolean,
    hint: String,
    hoverStateEnabled: Boolean,
    maxHeight: [Number, String],
    maxWidth: [Number, String],
    minHeight: [Number, String],
    minWidth: [Number, String],
    onContentReady: Function,
    onDisposing: Function,
    onHidden: Function,
    onHiding: Function,
    onInitialized: Function,
    onOptionChanged: Function,
    onResize: Function,
    onResizeEnd: Function,
    onResizeStart: Function,
    onShowing: Function,
    onShown: Function,
    onTitleRendered: Function,
    position: [Function, String, Object],
    resizeEnabled: Boolean,
    restorePosition: Boolean,
    rtlEnabled: Boolean,
    shading: Boolean,
    shadingColor: String,
    showCloseButton: Boolean,
    showTitle: Boolean,
    tabIndex: Number,
    title: String,
    titleTemplate: {},
    toolbarItems: Array,
    visible: Boolean,
    width: [Number, String],
    wrapperAttr: {}
  }
};
prepareConfigurationComponentConfig(DxFilterBuilderPopupConfig);
var DxFilterBuilderPopup = defineComponent4(DxFilterBuilderPopupConfig);
DxFilterBuilderPopup.$_optionName = "filterBuilderPopup";
DxFilterBuilderPopup.$_expectedChildren = {
  animation: { isCollectionItem: false, optionName: "animation" },
  position: { isCollectionItem: false, optionName: "position" },
  toolbarItem: { isCollectionItem: true, optionName: "toolbarItems" }
};
var DxFilterOperationDescriptionsConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:between": null,
    "update:contains": null,
    "update:endsWith": null,
    "update:equal": null,
    "update:greaterThan": null,
    "update:greaterThanOrEqual": null,
    "update:isBlank": null,
    "update:isNotBlank": null,
    "update:lessThan": null,
    "update:lessThanOrEqual": null,
    "update:notContains": null,
    "update:notEqual": null,
    "update:startsWith": null
  },
  props: {
    between: String,
    contains: String,
    endsWith: String,
    equal: String,
    greaterThan: String,
    greaterThanOrEqual: String,
    isBlank: String,
    isNotBlank: String,
    lessThan: String,
    lessThanOrEqual: String,
    notContains: String,
    notEqual: String,
    startsWith: String
  }
};
prepareConfigurationComponentConfig(DxFilterOperationDescriptionsConfig);
var DxFilterOperationDescriptions = defineComponent4(DxFilterOperationDescriptionsConfig);
DxFilterOperationDescriptions.$_optionName = "filterOperationDescriptions";
var DxFilterPanelConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:customizeText": null,
    "update:filterEnabled": null,
    "update:texts": null,
    "update:visible": null
  },
  props: {
    customizeText: Function,
    filterEnabled: Boolean,
    texts: Object,
    visible: Boolean
  }
};
prepareConfigurationComponentConfig(DxFilterPanelConfig);
var DxFilterPanel = defineComponent4(DxFilterPanelConfig);
DxFilterPanel.$_optionName = "filterPanel";
DxFilterPanel.$_expectedChildren = {
  filterPanelTexts: { isCollectionItem: false, optionName: "texts" },
  texts: { isCollectionItem: false, optionName: "texts" }
};
var DxFilterPanelTextsConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:clearFilter": null,
    "update:createFilter": null,
    "update:filterEnabledHint": null
  },
  props: {
    clearFilter: String,
    createFilter: String,
    filterEnabledHint: String
  }
};
prepareConfigurationComponentConfig(DxFilterPanelTextsConfig);
var DxFilterPanelTexts = defineComponent4(DxFilterPanelTextsConfig);
DxFilterPanelTexts.$_optionName = "texts";
var DxFilterRowConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:applyFilter": null,
    "update:applyFilterText": null,
    "update:betweenEndText": null,
    "update:betweenStartText": null,
    "update:operationDescriptions": null,
    "update:resetOperationText": null,
    "update:showAllText": null,
    "update:showOperationChooser": null,
    "update:visible": null
  },
  props: {
    applyFilter: String,
    applyFilterText: String,
    betweenEndText: String,
    betweenStartText: String,
    operationDescriptions: Object,
    resetOperationText: String,
    showAllText: String,
    showOperationChooser: Boolean,
    visible: Boolean
  }
};
prepareConfigurationComponentConfig(DxFilterRowConfig);
var DxFilterRow = defineComponent4(DxFilterRowConfig);
DxFilterRow.$_optionName = "filterRow";
DxFilterRow.$_expectedChildren = {
  operationDescriptions: { isCollectionItem: false, optionName: "operationDescriptions" }
};
var DxFormConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:accessKey": null,
    "update:activeStateEnabled": null,
    "update:alignItemLabels": null,
    "update:alignItemLabelsInAllGroups": null,
    "update:bindingOptions": null,
    "update:colCount": null,
    "update:colCountByScreen": null,
    "update:customizeItem": null,
    "update:disabled": null,
    "update:elementAttr": null,
    "update:focusStateEnabled": null,
    "update:formData": null,
    "update:height": null,
    "update:hint": null,
    "update:hoverStateEnabled": null,
    "update:isDirty": null,
    "update:items": null,
    "update:labelLocation": null,
    "update:labelMode": null,
    "update:minColWidth": null,
    "update:onContentReady": null,
    "update:onDisposing": null,
    "update:onEditorEnterKey": null,
    "update:onFieldDataChanged": null,
    "update:onInitialized": null,
    "update:onOptionChanged": null,
    "update:optionalMark": null,
    "update:readOnly": null,
    "update:requiredMark": null,
    "update:requiredMessage": null,
    "update:rtlEnabled": null,
    "update:screenByWidth": null,
    "update:scrollingEnabled": null,
    "update:showColonAfterLabel": null,
    "update:showOptionalMark": null,
    "update:showRequiredMark": null,
    "update:showValidationSummary": null,
    "update:tabIndex": null,
    "update:validationGroup": null,
    "update:visible": null,
    "update:width": null
  },
  props: {
    accessKey: String,
    activeStateEnabled: Boolean,
    alignItemLabels: Boolean,
    alignItemLabelsInAllGroups: Boolean,
    bindingOptions: Object,
    colCount: [String, Number],
    colCountByScreen: Object,
    customizeItem: Function,
    disabled: Boolean,
    elementAttr: Object,
    focusStateEnabled: Boolean,
    formData: {},
    height: [Number, String],
    hint: String,
    hoverStateEnabled: Boolean,
    isDirty: Boolean,
    items: Array,
    labelLocation: String,
    labelMode: String,
    minColWidth: Number,
    onContentReady: Function,
    onDisposing: Function,
    onEditorEnterKey: Function,
    onFieldDataChanged: Function,
    onInitialized: Function,
    onOptionChanged: Function,
    optionalMark: String,
    readOnly: Boolean,
    requiredMark: String,
    requiredMessage: String,
    rtlEnabled: Boolean,
    screenByWidth: Function,
    scrollingEnabled: Boolean,
    showColonAfterLabel: Boolean,
    showOptionalMark: Boolean,
    showRequiredMark: Boolean,
    showValidationSummary: Boolean,
    tabIndex: Number,
    validationGroup: String,
    visible: Boolean,
    width: [Number, String]
  }
};
prepareConfigurationComponentConfig(DxFormConfig);
var DxForm = defineComponent4(DxFormConfig);
DxForm.$_optionName = "form";
DxForm.$_expectedChildren = {
  colCountByScreen: { isCollectionItem: false, optionName: "colCountByScreen" }
};
var DxFormatConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:currency": null,
    "update:formatter": null,
    "update:parser": null,
    "update:precision": null,
    "update:type": null,
    "update:useCurrencyAccountingStyle": null
  },
  props: {
    currency: String,
    formatter: Function,
    parser: Function,
    precision: Number,
    type: String,
    useCurrencyAccountingStyle: Boolean
  }
};
prepareConfigurationComponentConfig(DxFormatConfig);
var DxFormat = defineComponent4(DxFormatConfig);
DxFormat.$_optionName = "format";
var DxFormItemConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:colSpan": null,
    "update:cssClass": null,
    "update:dataField": null,
    "update:editorOptions": null,
    "update:editorType": null,
    "update:helpText": null,
    "update:isRequired": null,
    "update:itemType": null,
    "update:label": null,
    "update:name": null,
    "update:template": null,
    "update:validationRules": null,
    "update:visible": null,
    "update:visibleIndex": null
  },
  props: {
    colSpan: Number,
    cssClass: String,
    dataField: String,
    editorOptions: {},
    editorType: String,
    helpText: String,
    isRequired: Boolean,
    itemType: String,
    label: Object,
    name: String,
    template: {},
    validationRules: Array,
    visible: Boolean,
    visibleIndex: Number
  }
};
prepareConfigurationComponentConfig(DxFormItemConfig);
var DxFormItem = defineComponent4(DxFormItemConfig);
DxFormItem.$_optionName = "formItem";
DxFormItem.$_expectedChildren = {
  AsyncRule: { isCollectionItem: true, optionName: "validationRules" },
  CompareRule: { isCollectionItem: true, optionName: "validationRules" },
  CustomRule: { isCollectionItem: true, optionName: "validationRules" },
  EmailRule: { isCollectionItem: true, optionName: "validationRules" },
  label: { isCollectionItem: false, optionName: "label" },
  NumericRule: { isCollectionItem: true, optionName: "validationRules" },
  PatternRule: { isCollectionItem: true, optionName: "validationRules" },
  RangeRule: { isCollectionItem: true, optionName: "validationRules" },
  RequiredRule: { isCollectionItem: true, optionName: "validationRules" },
  StringLengthRule: { isCollectionItem: true, optionName: "validationRules" },
  validationRule: { isCollectionItem: true, optionName: "validationRules" }
};
var DxFromConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:left": null,
    "update:opacity": null,
    "update:position": null,
    "update:scale": null,
    "update:top": null
  },
  props: {
    left: Number,
    opacity: Number,
    position: Object,
    scale: Number,
    top: Number
  }
};
prepareConfigurationComponentConfig(DxFromConfig);
var DxFrom = defineComponent4(DxFromConfig);
DxFrom.$_optionName = "from";
DxFrom.$_expectedChildren = {
  position: { isCollectionItem: false, optionName: "position" }
};
var DxGroupingConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:allowCollapsing": null,
    "update:autoExpandAll": null,
    "update:contextMenuEnabled": null,
    "update:expandMode": null,
    "update:texts": null
  },
  props: {
    allowCollapsing: Boolean,
    autoExpandAll: Boolean,
    contextMenuEnabled: Boolean,
    expandMode: String,
    texts: Object
  }
};
prepareConfigurationComponentConfig(DxGroupingConfig);
var DxGrouping = defineComponent4(DxGroupingConfig);
DxGrouping.$_optionName = "grouping";
DxGrouping.$_expectedChildren = {
  groupingTexts: { isCollectionItem: false, optionName: "texts" },
  texts: { isCollectionItem: false, optionName: "texts" }
};
var DxGroupingTextsConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:groupByThisColumn": null,
    "update:groupContinuedMessage": null,
    "update:groupContinuesMessage": null,
    "update:ungroup": null,
    "update:ungroupAll": null
  },
  props: {
    groupByThisColumn: String,
    groupContinuedMessage: String,
    groupContinuesMessage: String,
    ungroup: String,
    ungroupAll: String
  }
};
prepareConfigurationComponentConfig(DxGroupingTextsConfig);
var DxGroupingTexts = defineComponent4(DxGroupingTextsConfig);
DxGroupingTexts.$_optionName = "texts";
var DxGroupItemConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:alignByColumn": null,
    "update:column": null,
    "update:customizeText": null,
    "update:displayFormat": null,
    "update:name": null,
    "update:showInColumn": null,
    "update:showInGroupFooter": null,
    "update:skipEmptyValues": null,
    "update:summaryType": null,
    "update:valueFormat": null
  },
  props: {
    alignByColumn: Boolean,
    column: String,
    customizeText: Function,
    displayFormat: String,
    name: String,
    showInColumn: String,
    showInGroupFooter: Boolean,
    skipEmptyValues: Boolean,
    summaryType: String,
    valueFormat: [Object, String, Function]
  }
};
prepareConfigurationComponentConfig(DxGroupItemConfig);
var DxGroupItem = defineComponent4(DxGroupItemConfig);
DxGroupItem.$_optionName = "groupItems";
DxGroupItem.$_isCollectionItem = true;
DxGroupItem.$_expectedChildren = {
  valueFormat: { isCollectionItem: false, optionName: "valueFormat" }
};
var DxGroupOperationDescriptionsConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:and": null,
    "update:notAnd": null,
    "update:notOr": null,
    "update:or": null
  },
  props: {
    and: String,
    notAnd: String,
    notOr: String,
    or: String
  }
};
prepareConfigurationComponentConfig(DxGroupOperationDescriptionsConfig);
var DxGroupOperationDescriptions = defineComponent4(DxGroupOperationDescriptionsConfig);
DxGroupOperationDescriptions.$_optionName = "groupOperationDescriptions";
var DxGroupPanelConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:allowColumnDragging": null,
    "update:emptyPanelText": null,
    "update:visible": null
  },
  props: {
    allowColumnDragging: Boolean,
    emptyPanelText: String,
    visible: [Boolean, String]
  }
};
prepareConfigurationComponentConfig(DxGroupPanelConfig);
var DxGroupPanel = defineComponent4(DxGroupPanelConfig);
DxGroupPanel.$_optionName = "groupPanel";
var DxHeaderFilterConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:allowSearch": null,
    "update:allowSelectAll": null,
    "update:dataSource": null,
    "update:groupInterval": null,
    "update:height": null,
    "update:search": null,
    "update:searchMode": null,
    "update:searchTimeout": null,
    "update:texts": null,
    "update:visible": null,
    "update:width": null
  },
  props: {
    allowSearch: Boolean,
    allowSelectAll: Boolean,
    dataSource: [Array, Object, Function],
    groupInterval: [String, Number],
    height: [Number, String],
    search: Object,
    searchMode: String,
    searchTimeout: Number,
    texts: Object,
    visible: Boolean,
    width: [Number, String]
  }
};
prepareConfigurationComponentConfig(DxHeaderFilterConfig);
var DxHeaderFilter = defineComponent4(DxHeaderFilterConfig);
DxHeaderFilter.$_optionName = "headerFilter";
DxHeaderFilter.$_expectedChildren = {
  columnHeaderFilterSearch: { isCollectionItem: false, optionName: "search" },
  dataGridHeaderFilterSearch: { isCollectionItem: false, optionName: "search" },
  dataGridHeaderFilterTexts: { isCollectionItem: false, optionName: "texts" }
};
var DxHideConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:complete": null,
    "update:delay": null,
    "update:direction": null,
    "update:duration": null,
    "update:easing": null,
    "update:from": null,
    "update:staggerDelay": null,
    "update:start": null,
    "update:to": null,
    "update:type": null
  },
  props: {
    complete: Function,
    delay: Number,
    direction: String,
    duration: Number,
    easing: String,
    from: Object,
    staggerDelay: Number,
    start: Function,
    to: Object,
    type: String
  }
};
prepareConfigurationComponentConfig(DxHideConfig);
var DxHide = defineComponent4(DxHideConfig);
DxHide.$_optionName = "hide";
DxHide.$_expectedChildren = {
  from: { isCollectionItem: false, optionName: "from" },
  to: { isCollectionItem: false, optionName: "to" }
};
var DxIconsConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:fix": null,
    "update:leftPosition": null,
    "update:rightPosition": null,
    "update:stickyPosition": null,
    "update:unfix": null
  },
  props: {
    fix: String,
    leftPosition: String,
    rightPosition: String,
    stickyPosition: String,
    unfix: String
  }
};
prepareConfigurationComponentConfig(DxIconsConfig);
var DxIcons = defineComponent4(DxIconsConfig);
DxIcons.$_optionName = "icons";
var DxItemConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:cssClass": null,
    "update:disabled": null,
    "update:html": null,
    "update:locateInMenu": null,
    "update:location": null,
    "update:menuItemTemplate": null,
    "update:name": null,
    "update:options": null,
    "update:showText": null,
    "update:template": null,
    "update:text": null,
    "update:visible": null,
    "update:widget": null
  },
  props: {
    cssClass: String,
    disabled: Boolean,
    html: String,
    locateInMenu: String,
    location: String,
    menuItemTemplate: {},
    name: String,
    options: {},
    showText: String,
    template: {},
    text: String,
    visible: Boolean,
    widget: String
  }
};
prepareConfigurationComponentConfig(DxItemConfig);
var DxItem = defineComponent4(DxItemConfig);
DxItem.$_optionName = "items";
DxItem.$_isCollectionItem = true;
var DxKeyboardNavigationConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:editOnKeyPress": null,
    "update:enabled": null,
    "update:enterKeyAction": null,
    "update:enterKeyDirection": null
  },
  props: {
    editOnKeyPress: Boolean,
    enabled: Boolean,
    enterKeyAction: String,
    enterKeyDirection: String
  }
};
prepareConfigurationComponentConfig(DxKeyboardNavigationConfig);
var DxKeyboardNavigation = defineComponent4(DxKeyboardNavigationConfig);
DxKeyboardNavigation.$_optionName = "keyboardNavigation";
var DxLabelConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:alignment": null,
    "update:location": null,
    "update:showColon": null,
    "update:template": null,
    "update:text": null,
    "update:visible": null
  },
  props: {
    alignment: String,
    location: String,
    showColon: Boolean,
    template: {},
    text: String,
    visible: Boolean
  }
};
prepareConfigurationComponentConfig(DxLabelConfig);
var DxLabel = defineComponent4(DxLabelConfig);
DxLabel.$_optionName = "label";
var DxLoadPanelConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:enabled": null,
    "update:height": null,
    "update:indicatorSrc": null,
    "update:shading": null,
    "update:shadingColor": null,
    "update:showIndicator": null,
    "update:showPane": null,
    "update:text": null,
    "update:width": null
  },
  props: {
    enabled: [Boolean, String],
    height: [Number, String],
    indicatorSrc: String,
    shading: Boolean,
    shadingColor: String,
    showIndicator: Boolean,
    showPane: Boolean,
    text: String,
    width: [Number, String]
  }
};
prepareConfigurationComponentConfig(DxLoadPanelConfig);
var DxLoadPanel = defineComponent4(DxLoadPanelConfig);
DxLoadPanel.$_optionName = "loadPanel";
var DxLookupConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:allowClearing": null,
    "update:calculateCellValue": null,
    "update:dataSource": null,
    "update:displayExpr": null,
    "update:valueExpr": null
  },
  props: {
    allowClearing: Boolean,
    calculateCellValue: Function,
    dataSource: [Array, Object, Function],
    displayExpr: [Function, String],
    valueExpr: [String, Function]
  }
};
prepareConfigurationComponentConfig(DxLookupConfig);
var DxLookup = defineComponent4(DxLookupConfig);
DxLookup.$_optionName = "lookup";
var DxMasterDetailConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:autoExpandAll": null,
    "update:enabled": null,
    "update:template": null
  },
  props: {
    autoExpandAll: Boolean,
    enabled: Boolean,
    template: {}
  }
};
prepareConfigurationComponentConfig(DxMasterDetailConfig);
var DxMasterDetail = defineComponent4(DxMasterDetailConfig);
DxMasterDetail.$_optionName = "masterDetail";
var DxMyConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:x": null,
    "update:y": null
  },
  props: {
    x: String,
    y: String
  }
};
prepareConfigurationComponentConfig(DxMyConfig);
var DxMy = defineComponent4(DxMyConfig);
DxMy.$_optionName = "my";
var DxNumericRuleConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:ignoreEmptyValue": null,
    "update:message": null,
    "update:type": null
  },
  props: {
    ignoreEmptyValue: Boolean,
    message: String,
    type: String
  }
};
prepareConfigurationComponentConfig(DxNumericRuleConfig);
var DxNumericRule = defineComponent4(DxNumericRuleConfig);
DxNumericRule.$_optionName = "validationRules";
DxNumericRule.$_isCollectionItem = true;
DxNumericRule.$_predefinedProps = {
  type: "numeric"
};
var DxOffsetConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:x": null,
    "update:y": null
  },
  props: {
    x: Number,
    y: Number
  }
};
prepareConfigurationComponentConfig(DxOffsetConfig);
var DxOffset = defineComponent4(DxOffsetConfig);
DxOffset.$_optionName = "offset";
var DxOperationDescriptionsConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:between": null,
    "update:contains": null,
    "update:endsWith": null,
    "update:equal": null,
    "update:greaterThan": null,
    "update:greaterThanOrEqual": null,
    "update:lessThan": null,
    "update:lessThanOrEqual": null,
    "update:notContains": null,
    "update:notEqual": null,
    "update:startsWith": null
  },
  props: {
    between: String,
    contains: String,
    endsWith: String,
    equal: String,
    greaterThan: String,
    greaterThanOrEqual: String,
    lessThan: String,
    lessThanOrEqual: String,
    notContains: String,
    notEqual: String,
    startsWith: String
  }
};
prepareConfigurationComponentConfig(DxOperationDescriptionsConfig);
var DxOperationDescriptions = defineComponent4(DxOperationDescriptionsConfig);
DxOperationDescriptions.$_optionName = "operationDescriptions";
var DxPagerConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:allowedPageSizes": null,
    "update:displayMode": null,
    "update:infoText": null,
    "update:label": null,
    "update:showInfo": null,
    "update:showNavigationButtons": null,
    "update:showPageSizeSelector": null,
    "update:visible": null
  },
  props: {
    allowedPageSizes: [Array, String],
    displayMode: String,
    infoText: String,
    label: String,
    showInfo: Boolean,
    showNavigationButtons: Boolean,
    showPageSizeSelector: Boolean,
    visible: [Boolean, String]
  }
};
prepareConfigurationComponentConfig(DxPagerConfig);
var DxPager = defineComponent4(DxPagerConfig);
DxPager.$_optionName = "pager";
var DxPagingConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:enabled": null,
    "update:pageIndex": null,
    "update:pageSize": null
  },
  props: {
    enabled: Boolean,
    pageIndex: Number,
    pageSize: Number
  }
};
prepareConfigurationComponentConfig(DxPagingConfig);
var DxPaging = defineComponent4(DxPagingConfig);
DxPaging.$_optionName = "paging";
var DxPatternRuleConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:ignoreEmptyValue": null,
    "update:message": null,
    "update:pattern": null,
    "update:type": null
  },
  props: {
    ignoreEmptyValue: Boolean,
    message: String,
    pattern: [RegExp, String],
    type: String
  }
};
prepareConfigurationComponentConfig(DxPatternRuleConfig);
var DxPatternRule = defineComponent4(DxPatternRuleConfig);
DxPatternRule.$_optionName = "validationRules";
DxPatternRule.$_isCollectionItem = true;
DxPatternRule.$_predefinedProps = {
  type: "pattern"
};
var DxPopupConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:accessKey": null,
    "update:animation": null,
    "update:bindingOptions": null,
    "update:container": null,
    "update:contentTemplate": null,
    "update:deferRendering": null,
    "update:disabled": null,
    "update:dragAndResizeArea": null,
    "update:dragEnabled": null,
    "update:dragOutsideBoundary": null,
    "update:enableBodyScroll": null,
    "update:focusStateEnabled": null,
    "update:fullScreen": null,
    "update:height": null,
    "update:hideOnOutsideClick": null,
    "update:hideOnParentScroll": null,
    "update:hint": null,
    "update:hoverStateEnabled": null,
    "update:maxHeight": null,
    "update:maxWidth": null,
    "update:minHeight": null,
    "update:minWidth": null,
    "update:onContentReady": null,
    "update:onDisposing": null,
    "update:onHidden": null,
    "update:onHiding": null,
    "update:onInitialized": null,
    "update:onOptionChanged": null,
    "update:onResize": null,
    "update:onResizeEnd": null,
    "update:onResizeStart": null,
    "update:onShowing": null,
    "update:onShown": null,
    "update:onTitleRendered": null,
    "update:position": null,
    "update:resizeEnabled": null,
    "update:restorePosition": null,
    "update:rtlEnabled": null,
    "update:shading": null,
    "update:shadingColor": null,
    "update:showCloseButton": null,
    "update:showTitle": null,
    "update:tabIndex": null,
    "update:title": null,
    "update:titleTemplate": null,
    "update:toolbarItems": null,
    "update:visible": null,
    "update:width": null,
    "update:wrapperAttr": null
  },
  props: {
    accessKey: String,
    animation: Object,
    bindingOptions: Object,
    container: {},
    contentTemplate: {},
    deferRendering: Boolean,
    disabled: Boolean,
    dragAndResizeArea: {},
    dragEnabled: Boolean,
    dragOutsideBoundary: Boolean,
    enableBodyScroll: Boolean,
    focusStateEnabled: Boolean,
    fullScreen: Boolean,
    height: [Number, String],
    hideOnOutsideClick: [Boolean, Function],
    hideOnParentScroll: Boolean,
    hint: String,
    hoverStateEnabled: Boolean,
    maxHeight: [Number, String],
    maxWidth: [Number, String],
    minHeight: [Number, String],
    minWidth: [Number, String],
    onContentReady: Function,
    onDisposing: Function,
    onHidden: Function,
    onHiding: Function,
    onInitialized: Function,
    onOptionChanged: Function,
    onResize: Function,
    onResizeEnd: Function,
    onResizeStart: Function,
    onShowing: Function,
    onShown: Function,
    onTitleRendered: Function,
    position: [Function, String, Object],
    resizeEnabled: Boolean,
    restorePosition: Boolean,
    rtlEnabled: Boolean,
    shading: Boolean,
    shadingColor: String,
    showCloseButton: Boolean,
    showTitle: Boolean,
    tabIndex: Number,
    title: String,
    titleTemplate: {},
    toolbarItems: Array,
    visible: Boolean,
    width: [Number, String],
    wrapperAttr: {}
  }
};
prepareConfigurationComponentConfig(DxPopupConfig);
var DxPopup = defineComponent4(DxPopupConfig);
DxPopup.$_optionName = "popup";
DxPopup.$_expectedChildren = {
  animation: { isCollectionItem: false, optionName: "animation" },
  position: { isCollectionItem: false, optionName: "position" },
  toolbarItem: { isCollectionItem: true, optionName: "toolbarItems" }
};
var DxPositionConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:at": null,
    "update:boundary": null,
    "update:boundaryOffset": null,
    "update:collision": null,
    "update:my": null,
    "update:of": null,
    "update:offset": null
  },
  props: {
    at: [Object, String],
    boundary: {},
    boundaryOffset: [Object, String],
    collision: [String, Object],
    my: [Object, String],
    of: {},
    offset: [Object, String]
  }
};
prepareConfigurationComponentConfig(DxPositionConfig);
var DxPosition = defineComponent4(DxPositionConfig);
DxPosition.$_optionName = "position";
DxPosition.$_expectedChildren = {
  at: { isCollectionItem: false, optionName: "at" },
  boundaryOffset: { isCollectionItem: false, optionName: "boundaryOffset" },
  collision: { isCollectionItem: false, optionName: "collision" },
  my: { isCollectionItem: false, optionName: "my" },
  offset: { isCollectionItem: false, optionName: "offset" }
};
var DxRangeRuleConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:ignoreEmptyValue": null,
    "update:max": null,
    "update:message": null,
    "update:min": null,
    "update:reevaluate": null,
    "update:type": null
  },
  props: {
    ignoreEmptyValue: Boolean,
    max: [Date, Number, String],
    message: String,
    min: [Date, Number, String],
    reevaluate: Boolean,
    type: String
  }
};
prepareConfigurationComponentConfig(DxRangeRuleConfig);
var DxRangeRule = defineComponent4(DxRangeRuleConfig);
DxRangeRule.$_optionName = "validationRules";
DxRangeRule.$_isCollectionItem = true;
DxRangeRule.$_predefinedProps = {
  type: "range"
};
var DxRemoteOperationsConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:filtering": null,
    "update:grouping": null,
    "update:groupPaging": null,
    "update:paging": null,
    "update:sorting": null,
    "update:summary": null
  },
  props: {
    filtering: Boolean,
    grouping: Boolean,
    groupPaging: Boolean,
    paging: Boolean,
    sorting: Boolean,
    summary: Boolean
  }
};
prepareConfigurationComponentConfig(DxRemoteOperationsConfig);
var DxRemoteOperations = defineComponent4(DxRemoteOperationsConfig);
DxRemoteOperations.$_optionName = "remoteOperations";
var DxRequiredRuleConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:message": null,
    "update:trim": null,
    "update:type": null
  },
  props: {
    message: String,
    trim: Boolean,
    type: String
  }
};
prepareConfigurationComponentConfig(DxRequiredRuleConfig);
var DxRequiredRule = defineComponent4(DxRequiredRuleConfig);
DxRequiredRule.$_optionName = "validationRules";
DxRequiredRule.$_isCollectionItem = true;
DxRequiredRule.$_predefinedProps = {
  type: "required"
};
var DxRowDraggingConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:allowDropInsideItem": null,
    "update:allowReordering": null,
    "update:autoScroll": null,
    "update:boundary": null,
    "update:container": null,
    "update:cursorOffset": null,
    "update:data": null,
    "update:dragDirection": null,
    "update:dragTemplate": null,
    "update:dropFeedbackMode": null,
    "update:filter": null,
    "update:group": null,
    "update:handle": null,
    "update:onAdd": null,
    "update:onDragChange": null,
    "update:onDragEnd": null,
    "update:onDragMove": null,
    "update:onDragStart": null,
    "update:onRemove": null,
    "update:onReorder": null,
    "update:scrollSensitivity": null,
    "update:scrollSpeed": null,
    "update:showDragIcons": null
  },
  props: {
    allowDropInsideItem: Boolean,
    allowReordering: Boolean,
    autoScroll: Boolean,
    boundary: {},
    container: {},
    cursorOffset: [Object, String],
    data: {},
    dragDirection: String,
    dragTemplate: {},
    dropFeedbackMode: String,
    filter: String,
    group: String,
    handle: String,
    onAdd: Function,
    onDragChange: Function,
    onDragEnd: Function,
    onDragMove: Function,
    onDragStart: Function,
    onRemove: Function,
    onReorder: Function,
    scrollSensitivity: Number,
    scrollSpeed: Number,
    showDragIcons: Boolean
  }
};
prepareConfigurationComponentConfig(DxRowDraggingConfig);
var DxRowDragging = defineComponent4(DxRowDraggingConfig);
DxRowDragging.$_optionName = "rowDragging";
DxRowDragging.$_expectedChildren = {
  cursorOffset: { isCollectionItem: false, optionName: "cursorOffset" }
};
var DxScrollingConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:columnRenderingMode": null,
    "update:mode": null,
    "update:preloadEnabled": null,
    "update:renderAsync": null,
    "update:rowRenderingMode": null,
    "update:scrollByContent": null,
    "update:scrollByThumb": null,
    "update:showScrollbar": null,
    "update:useNative": null
  },
  props: {
    columnRenderingMode: String,
    mode: String,
    preloadEnabled: Boolean,
    renderAsync: Boolean,
    rowRenderingMode: String,
    scrollByContent: Boolean,
    scrollByThumb: Boolean,
    showScrollbar: String,
    useNative: [Boolean, String]
  }
};
prepareConfigurationComponentConfig(DxScrollingConfig);
var DxScrolling = defineComponent4(DxScrollingConfig);
DxScrolling.$_optionName = "scrolling";
var DxSearchConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:editorOptions": null,
    "update:enabled": null,
    "update:mode": null,
    "update:searchExpr": null,
    "update:timeout": null
  },
  props: {
    editorOptions: {},
    enabled: Boolean,
    mode: String,
    searchExpr: [Array, Function, String],
    timeout: Number
  }
};
prepareConfigurationComponentConfig(DxSearchConfig);
var DxSearch = defineComponent4(DxSearchConfig);
DxSearch.$_optionName = "search";
var DxSearchPanelConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:highlightCaseSensitive": null,
    "update:highlightSearchText": null,
    "update:placeholder": null,
    "update:searchVisibleColumnsOnly": null,
    "update:text": null,
    "update:visible": null,
    "update:width": null
  },
  props: {
    highlightCaseSensitive: Boolean,
    highlightSearchText: Boolean,
    placeholder: String,
    searchVisibleColumnsOnly: Boolean,
    text: String,
    visible: Boolean,
    width: [Number, String]
  }
};
prepareConfigurationComponentConfig(DxSearchPanelConfig);
var DxSearchPanel = defineComponent4(DxSearchPanelConfig);
DxSearchPanel.$_optionName = "searchPanel";
var DxSelectionConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:allowSelectAll": null,
    "update:deferred": null,
    "update:mode": null,
    "update:recursive": null,
    "update:selectAllMode": null,
    "update:selectByClick": null,
    "update:sensitivity": null,
    "update:showCheckBoxesMode": null
  },
  props: {
    allowSelectAll: Boolean,
    deferred: Boolean,
    mode: String,
    recursive: Boolean,
    selectAllMode: String,
    selectByClick: Boolean,
    sensitivity: String,
    showCheckBoxesMode: String
  }
};
prepareConfigurationComponentConfig(DxSelectionConfig);
var DxSelection = defineComponent4(DxSelectionConfig);
DxSelection.$_optionName = "selection";
var DxShowConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:complete": null,
    "update:delay": null,
    "update:direction": null,
    "update:duration": null,
    "update:easing": null,
    "update:from": null,
    "update:staggerDelay": null,
    "update:start": null,
    "update:to": null,
    "update:type": null
  },
  props: {
    complete: Function,
    delay: Number,
    direction: String,
    duration: Number,
    easing: String,
    from: Object,
    staggerDelay: Number,
    start: Function,
    to: Object,
    type: String
  }
};
prepareConfigurationComponentConfig(DxShowConfig);
var DxShow = defineComponent4(DxShowConfig);
DxShow.$_optionName = "show";
DxShow.$_expectedChildren = {
  from: { isCollectionItem: false, optionName: "from" },
  to: { isCollectionItem: false, optionName: "to" }
};
var DxSortByGroupSummaryInfoConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:groupColumn": null,
    "update:sortOrder": null,
    "update:summaryItem": null
  },
  props: {
    groupColumn: String,
    sortOrder: String,
    summaryItem: [Number, String]
  }
};
prepareConfigurationComponentConfig(DxSortByGroupSummaryInfoConfig);
var DxSortByGroupSummaryInfo = defineComponent4(DxSortByGroupSummaryInfoConfig);
DxSortByGroupSummaryInfo.$_optionName = "sortByGroupSummaryInfo";
DxSortByGroupSummaryInfo.$_isCollectionItem = true;
var DxSortingConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:ascendingText": null,
    "update:clearText": null,
    "update:descendingText": null,
    "update:mode": null,
    "update:showSortIndexes": null
  },
  props: {
    ascendingText: String,
    clearText: String,
    descendingText: String,
    mode: String,
    showSortIndexes: Boolean
  }
};
prepareConfigurationComponentConfig(DxSortingConfig);
var DxSorting = defineComponent4(DxSortingConfig);
DxSorting.$_optionName = "sorting";
var DxStateStoringConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:customLoad": null,
    "update:customSave": null,
    "update:enabled": null,
    "update:savingTimeout": null,
    "update:storageKey": null,
    "update:type": null
  },
  props: {
    customLoad: Function,
    customSave: Function,
    enabled: Boolean,
    savingTimeout: Number,
    storageKey: String,
    type: String
  }
};
prepareConfigurationComponentConfig(DxStateStoringConfig);
var DxStateStoring = defineComponent4(DxStateStoringConfig);
DxStateStoring.$_optionName = "stateStoring";
var DxStringLengthRuleConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:ignoreEmptyValue": null,
    "update:max": null,
    "update:message": null,
    "update:min": null,
    "update:trim": null,
    "update:type": null
  },
  props: {
    ignoreEmptyValue: Boolean,
    max: Number,
    message: String,
    min: Number,
    trim: Boolean,
    type: String
  }
};
prepareConfigurationComponentConfig(DxStringLengthRuleConfig);
var DxStringLengthRule = defineComponent4(DxStringLengthRuleConfig);
DxStringLengthRule.$_optionName = "validationRules";
DxStringLengthRule.$_isCollectionItem = true;
DxStringLengthRule.$_predefinedProps = {
  type: "stringLength"
};
var DxSummaryConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:calculateCustomSummary": null,
    "update:groupItems": null,
    "update:recalculateWhileEditing": null,
    "update:skipEmptyValues": null,
    "update:texts": null,
    "update:totalItems": null
  },
  props: {
    calculateCustomSummary: Function,
    groupItems: Array,
    recalculateWhileEditing: Boolean,
    skipEmptyValues: Boolean,
    texts: Object,
    totalItems: Array
  }
};
prepareConfigurationComponentConfig(DxSummaryConfig);
var DxSummary = defineComponent4(DxSummaryConfig);
DxSummary.$_optionName = "summary";
DxSummary.$_expectedChildren = {
  groupItem: { isCollectionItem: true, optionName: "groupItems" },
  summaryTexts: { isCollectionItem: false, optionName: "texts" },
  texts: { isCollectionItem: false, optionName: "texts" },
  totalItem: { isCollectionItem: true, optionName: "totalItems" }
};
var DxSummaryTextsConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:avg": null,
    "update:avgOtherColumn": null,
    "update:count": null,
    "update:max": null,
    "update:maxOtherColumn": null,
    "update:min": null,
    "update:minOtherColumn": null,
    "update:sum": null,
    "update:sumOtherColumn": null
  },
  props: {
    avg: String,
    avgOtherColumn: String,
    count: String,
    max: String,
    maxOtherColumn: String,
    min: String,
    minOtherColumn: String,
    sum: String,
    sumOtherColumn: String
  }
};
prepareConfigurationComponentConfig(DxSummaryTextsConfig);
var DxSummaryTexts = defineComponent4(DxSummaryTextsConfig);
DxSummaryTexts.$_optionName = "texts";
var DxTextsConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:addRow": null,
    "update:avg": null,
    "update:avgOtherColumn": null,
    "update:cancel": null,
    "update:cancelAllChanges": null,
    "update:cancelRowChanges": null,
    "update:clearFilter": null,
    "update:confirmDeleteMessage": null,
    "update:confirmDeleteTitle": null,
    "update:count": null,
    "update:createFilter": null,
    "update:deleteRow": null,
    "update:editRow": null,
    "update:emptyValue": null,
    "update:exportAll": null,
    "update:exportSelectedRows": null,
    "update:exportTo": null,
    "update:filterEnabledHint": null,
    "update:fix": null,
    "update:groupByThisColumn": null,
    "update:groupContinuedMessage": null,
    "update:groupContinuesMessage": null,
    "update:leftPosition": null,
    "update:max": null,
    "update:maxOtherColumn": null,
    "update:min": null,
    "update:minOtherColumn": null,
    "update:ok": null,
    "update:rightPosition": null,
    "update:saveAllChanges": null,
    "update:saveRowChanges": null,
    "update:stickyPosition": null,
    "update:sum": null,
    "update:sumOtherColumn": null,
    "update:undeleteRow": null,
    "update:unfix": null,
    "update:ungroup": null,
    "update:ungroupAll": null,
    "update:validationCancelChanges": null
  },
  props: {
    addRow: String,
    avg: String,
    avgOtherColumn: String,
    cancel: String,
    cancelAllChanges: String,
    cancelRowChanges: String,
    clearFilter: String,
    confirmDeleteMessage: String,
    confirmDeleteTitle: String,
    count: String,
    createFilter: String,
    deleteRow: String,
    editRow: String,
    emptyValue: String,
    exportAll: String,
    exportSelectedRows: String,
    exportTo: String,
    filterEnabledHint: String,
    fix: String,
    groupByThisColumn: String,
    groupContinuedMessage: String,
    groupContinuesMessage: String,
    leftPosition: String,
    max: String,
    maxOtherColumn: String,
    min: String,
    minOtherColumn: String,
    ok: String,
    rightPosition: String,
    saveAllChanges: String,
    saveRowChanges: String,
    stickyPosition: String,
    sum: String,
    sumOtherColumn: String,
    undeleteRow: String,
    unfix: String,
    ungroup: String,
    ungroupAll: String,
    validationCancelChanges: String
  }
};
prepareConfigurationComponentConfig(DxTextsConfig);
var DxTexts = defineComponent4(DxTextsConfig);
DxTexts.$_optionName = "texts";
var DxToConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:left": null,
    "update:opacity": null,
    "update:position": null,
    "update:scale": null,
    "update:top": null
  },
  props: {
    left: Number,
    opacity: Number,
    position: Object,
    scale: Number,
    top: Number
  }
};
prepareConfigurationComponentConfig(DxToConfig);
var DxTo = defineComponent4(DxToConfig);
DxTo.$_optionName = "to";
DxTo.$_expectedChildren = {
  position: { isCollectionItem: false, optionName: "position" }
};
var DxToolbarConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:disabled": null,
    "update:items": null,
    "update:visible": null
  },
  props: {
    disabled: Boolean,
    items: Array,
    visible: Boolean
  }
};
prepareConfigurationComponentConfig(DxToolbarConfig);
var DxToolbar = defineComponent4(DxToolbarConfig);
DxToolbar.$_optionName = "toolbar";
DxToolbar.$_expectedChildren = {
  item: { isCollectionItem: true, optionName: "items" }
};
var DxToolbarItemConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:cssClass": null,
    "update:disabled": null,
    "update:html": null,
    "update:locateInMenu": null,
    "update:location": null,
    "update:menuItemTemplate": null,
    "update:options": null,
    "update:showText": null,
    "update:template": null,
    "update:text": null,
    "update:toolbar": null,
    "update:visible": null,
    "update:widget": null
  },
  props: {
    cssClass: String,
    disabled: Boolean,
    html: String,
    locateInMenu: String,
    location: String,
    menuItemTemplate: {},
    options: {},
    showText: String,
    template: {},
    text: String,
    toolbar: String,
    visible: Boolean,
    widget: String
  }
};
prepareConfigurationComponentConfig(DxToolbarItemConfig);
var DxToolbarItem = defineComponent4(DxToolbarItemConfig);
DxToolbarItem.$_optionName = "toolbarItems";
DxToolbarItem.$_isCollectionItem = true;
var DxTotalItemConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:alignment": null,
    "update:column": null,
    "update:cssClass": null,
    "update:customizeText": null,
    "update:displayFormat": null,
    "update:name": null,
    "update:showInColumn": null,
    "update:skipEmptyValues": null,
    "update:summaryType": null,
    "update:valueFormat": null
  },
  props: {
    alignment: String,
    column: String,
    cssClass: String,
    customizeText: Function,
    displayFormat: String,
    name: String,
    showInColumn: String,
    skipEmptyValues: Boolean,
    summaryType: String,
    valueFormat: [Object, String, Function]
  }
};
prepareConfigurationComponentConfig(DxTotalItemConfig);
var DxTotalItem = defineComponent4(DxTotalItemConfig);
DxTotalItem.$_optionName = "totalItems";
DxTotalItem.$_isCollectionItem = true;
DxTotalItem.$_expectedChildren = {
  valueFormat: { isCollectionItem: false, optionName: "valueFormat" }
};
var DxValidationRuleConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:comparisonTarget": null,
    "update:comparisonType": null,
    "update:ignoreEmptyValue": null,
    "update:max": null,
    "update:message": null,
    "update:min": null,
    "update:pattern": null,
    "update:reevaluate": null,
    "update:trim": null,
    "update:type": null,
    "update:validationCallback": null
  },
  props: {
    comparisonTarget: Function,
    comparisonType: String,
    ignoreEmptyValue: Boolean,
    max: [Date, Number, String],
    message: String,
    min: [Date, Number, String],
    pattern: [RegExp, String],
    reevaluate: Boolean,
    trim: Boolean,
    type: String,
    validationCallback: Function
  }
};
prepareConfigurationComponentConfig(DxValidationRuleConfig);
var DxValidationRule = defineComponent4(DxValidationRuleConfig);
DxValidationRule.$_optionName = "validationRules";
DxValidationRule.$_isCollectionItem = true;
DxValidationRule.$_predefinedProps = {
  type: "required"
};
var DxValueFormatConfig = {
  emits: {
    "update:isActive": null,
    "update:hoveredElement": null,
    "update:currency": null,
    "update:formatter": null,
    "update:parser": null,
    "update:precision": null,
    "update:type": null,
    "update:useCurrencyAccountingStyle": null
  },
  props: {
    currency: String,
    formatter: Function,
    parser: Function,
    precision: Number,
    type: String,
    useCurrencyAccountingStyle: Boolean
  }
};
prepareConfigurationComponentConfig(DxValueFormatConfig);
var DxValueFormat = defineComponent4(DxValueFormatConfig);
DxValueFormat.$_optionName = "valueFormat";
var data_grid_default2 = DxDataGrid;
export {
  DxAnimation,
  DxAsyncRule,
  DxAt,
  DxBoundaryOffset,
  DxButton,
  DxChange,
  DxColCountByScreen,
  DxCollision,
  DxColumn,
  DxColumnChooser,
  DxColumnChooserSearch,
  DxColumnChooserSelection,
  DxColumnFixing,
  DxColumnFixingTexts,
  DxColumnHeaderFilter,
  DxColumnHeaderFilterSearch,
  DxColumnLookup,
  DxCompareRule,
  DxCursorOffset,
  DxCustomOperation,
  DxCustomRule,
  DxDataGrid,
  DxDataGridHeaderFilter,
  DxDataGridHeaderFilterSearch,
  DxDataGridHeaderFilterTexts,
  DxDataGridSelection,
  DxEditing,
  DxEditingTexts,
  DxEmailRule,
  DxExport,
  DxExportTexts,
  DxField,
  DxFieldLookup,
  DxFilterBuilder,
  DxFilterBuilderPopup,
  DxFilterOperationDescriptions,
  DxFilterPanel,
  DxFilterPanelTexts,
  DxFilterRow,
  DxForm,
  DxFormItem,
  DxFormat,
  DxFrom,
  DxGroupItem,
  DxGroupOperationDescriptions,
  DxGroupPanel,
  DxGrouping,
  DxGroupingTexts,
  DxHeaderFilter,
  DxHide,
  DxIcons,
  DxItem,
  DxKeyboardNavigation,
  DxLabel,
  DxLoadPanel,
  DxLookup,
  DxMasterDetail,
  DxMy,
  DxNumericRule,
  DxOffset,
  DxOperationDescriptions,
  DxPager,
  DxPaging,
  DxPatternRule,
  DxPopup,
  DxPosition,
  DxRangeRule,
  DxRemoteOperations,
  DxRequiredRule,
  DxRowDragging,
  DxScrolling,
  DxSearch,
  DxSearchPanel,
  DxSelection,
  DxShow,
  DxSortByGroupSummaryInfo,
  DxSorting,
  DxStateStoring,
  DxStringLengthRule,
  DxSummary,
  DxSummaryTexts,
  DxTexts,
  DxTo,
  DxToolbar,
  DxToolbarItem,
  DxTotalItem,
  DxValidationRule,
  DxValueFormat,
  data_grid_default2 as default
};
/*! Bundled license information:

devextreme-vue/esm/core/helpers.js:
devextreme-vue/esm/core/children-processing.js:
devextreme-vue/esm/core/vue-helper.js:
devextreme-vue/esm/core/config.js:
devextreme-vue/esm/core/configuration.js:
devextreme-vue/esm/core/configuration-component.js:
devextreme-vue/esm/core/constants.js:
devextreme-vue/esm/core/templates-discovering.js:
devextreme-vue/esm/core/templates-manager.js:
devextreme-vue/esm/core/component.js:
devextreme-vue/esm/core/extension-component.js:
devextreme-vue/esm/core/index.js:
devextreme-vue/esm/data-grid.js:
  (*!
   * devextreme-vue
   * Version: 25.1.3
   * Build date: Wed Jun 25 2025
   *
   * Copyright (c) 2012 - 2025 Developer Express Inc. ALL RIGHTS RESERVED
   *
   * This software may be modified and distributed under the terms
   * of the MIT license. See the LICENSE file in the root of the project for details.
   *
   * https://github.com/DevExpress/devextreme-vue
   *)
*/
//# sourceMappingURL=devextreme-vue_data-grid.js.map
